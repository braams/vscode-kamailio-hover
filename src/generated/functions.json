{
 "sl_send_reply": "### sl_send_reply(code, reason)\n\n module: sl\n\nFor the current request, a reply is sent back having the given code and\ntext reason. The reply is sent stateless, totally independent of the\nTransaction module and with no retransmission for the INVITE's replies.\n\nIf the code is in the range 300-399 (redirect reply), the current\ndestination set is appended to the reply as Contact headers. The\ndestination set contains the request URI (R-URI), if it is modified\ncompared to the received one, plus the branches added to the request\n(e.g., after an append_branch() or lookup(\"location\")). If the R-URI was\nchanged but it is not desired to be part of the destination set, it can\nbe reverted using the function revert_uri().\n\nCustom headers to the reply can be added using append_to_reply()\nfunction from textops module.\n\nMeaning of the parameters is as follows:\n\n- *code* - Return code.\n\n- *reason* - Reason phrase.\n\n<!-- -->\n\n    ...\n    sl_send_reply(\"404\", \"Not found\");\n    ...\n            \n\n",
 "send_reply": "### send_reply(code, reason)\n\n module: sl\n\nFor the current request, a reply is sent back having the given code and\ntext reason. The reply is sent stateful or stateless, depending of the\nTM module: if a transaction exists for the current request, then the\nreply is sent statefully, otherwise stateless.\n\nMeaning of the parameters is as follows:\n\n- *code* - Return code.\n\n- *reason* - Reason phrase.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE. It can\nbe used on ONREPLY_ROUTE executed by tm module (upon a t_on_reply()\ncallback).\n\n    ...\n    send_reply(\"404\", \"Not found\");\n    ...\n    send_reply(\"403\", \"Invalid user - $fU\");\n    ...\n\n",
 "send_reply_mode": "### send_reply_mode(code, reason, mode)\n\n module: sl\n\nSimilar to send_reply() function, with additional third parameter mode,\nwhich can specify extra operations to be done along with sending the SIP\nresponse.\n\nThe parameter mode is a flag-based value and can be a combination of:\n\n- *1* - do not connect to send the response (similar to\n  set_reply_no_connect()).\n\n- *2* - close the connection after sending the response (similar to\n  set_reply_close()).\n\n<!-- -->\n\n    ...\n    send_reply_mode(\"404\", \"Not found\", \"3\");\n    ...\n    send_reply_mode(\"403\", \"Invalid user - $fU\", \"3\");\n    ...\n\n",
 "sl_reply_error": "### sl_reply_error()\n\n module: sl\n\nSends back an error reply describing the nature of the last internal\nerror. Usually this function should be used after a script function that\nreturned an error code.\n\n    ...\n    sl_reply_error();\n    ...\n            \n\n",
 "sl_forward_reply": "### sl_forward_reply([ code, [ reason ] ])\n\n module: sl\n\nForward statelessly the current received SIP reply, with the option to\nchange the status code and reason text. The new code has to be in the\nsame class. The received reply is forwarded as well by core when the\nconfig execution ended, unless it is dropped from config.\n\nMeaning of the parameters is as follows:\n\n- *code* - Status code.\n\n- *reason* - Reason phrase.\n\nThis function can be used from ONREPLY_ROUTE.\n\n    ...\n    if(status==\"408\")\n        sl_forward_reply(\"404\", \"Not found\");\n    ...\n\n",
 "bm_start_timer": "### bm_start_timer(name)\n\n module: benchmark\n\nStart timer \u201cname\u201d. A later call to \u201cbm_log_timer()\u201d logs this timer..\n\n    ...\n    bm_start_timer(\"test\");\n    ...\n\n",
 "bm_log_timer": "### bm_log_timer(name)\n\n module: benchmark\n\nThis function logs the timer with the given ID. The following data are\nlogged:\n\n- *Last msgs* is the number of calls in the last logging interval. This\n  equals the granularity variable.\n\n<!-- -->\n\n- *Last sum* is the accumulated duration in the current logging interval\n  (i.e. for the last \u201cgranularity\u201d calls).\n\n<!-- -->\n\n- *Last min* is the minimum duration between start/log_timer calls\n  during the last interval.\n\n<!-- -->\n\n- *Last max* - maximum duration.\n\n<!-- -->\n\n- *Last average* is the average duration between bm_start_timer() and\n  bm_log_timer() since the last logging.\n\n<!-- -->\n\n- *Global msgs* number of calls to log_timer.\n\n<!-- -->\n\n- *Global sum* total duration in microseconds.\n\n<!-- -->\n\n- *Global min*... You get the point. :)\n\n<!-- -->\n\n- *Global max* also obvious.\n\n<!-- -->\n\n- *Global avg* possibly the most interesting value.\n\n<!-- -->\n\n    ...\n    bm_log_timer(\"test\");\n    ...\n\n",
 "jwt_generate": "### jwt_generate(prvkey, alg, claims[, headers])\n\n module: jwt\n\nGenerate the JWT, its value can be retrieved in the variable \\$jwt(val).\n\nThe parameters are:\n\n- prvkey - path to private key\n\n- alg - the algorithm to build the signature, as supported by the libjwt\n  (e.g., RS256, HS256, ES256, ...)\n\n- claims - the list of claims to be added to JWT, in the format\n  \"name1=value1;name2=value2;...\" (same as the SIP parameters format).\n  The string values can be enclosed in single or double quotes. If a\n  value is not eclosed in between quotes, it is added as numeric value\n  if it is successfully converted to a long value, otherwise is added as\n  string value.\n\n- headers - the list of headers to be added to JWT, in the format\n  \"name1=value1;name2=value2;...\" (same as the SIP parameters format).\n  The string values can be enclosed in single or double quotes. If a\n  value is not eclosed in between quotes, it is added as numeric value\n  if it is successfully converted to a long value, otherwise is added as\n  string value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n      jwt_generate(\"/path/to/prvkey.pem\", \"RS256\",\n            \"caller='$fU';callee='$tU';callid='$ci';index=100\");\n    ...\n\n",
 "jwt_verify": "### jwt_verify(pubkeypath, alg, claims, jwtval)\n\n module: jwt\n\nVerify the JWT.\n\nThe parameters are:\n\n- pubkeypath - path to public key file\n\n- alg - the algorithm to build the signature, as supported by the libjwt\n  (e.g., RS256, HS256, ES256, ...)\n\n- claims - the list of claims to be checked they are in the JWT, in the\n  format \"name1=value1;name2=value2;...\" (same as the SIP parameters\n  format, see also the description of claims parameter for\n  jwt_generate()).\n\n- jwtval - the value of the JWT to verify\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n      if(!jwt_verify(\"/path/to/pubkey.pem\", \"RS256\",\n             \"caller='$fU';callee='$tU';callid='$ci';index=100\",\n            \"$var(jwt)\") {\n        xwarn(\"failed to verify jwt\\n\");\n      }\n    ...\n\n",
 "jwt_verify_key": "### jwt_verify_key(pubkeyval, alg, claims, jwtval)\n\n module: jwt\n\nVerify the JWT.\n\nThe parameters are:\n\n- pubkeyval - public key value\n\n- alg - the algorithm to build the signature, as supported by the libjwt\n  (e.g., RS256, HS256, ES256, ...)\n\n- claims - the list of claims to be checked they are in the JWT, in the\n  format \"name1=value1;name2=value2;...\" (same as the SIP parameters\n  format, see also the description of claims parameter for\n  jwt_generate()).\n\n- jwtval - the value of the JWT to verify\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n      if(!jwt_verify_key(\"...\", \"RS256\",\n             \"caller='$fU';callee='$tU';callid='$ci';index=100\",\n            \"$var(jwt)\") {\n        xwarn(\"failed to verify jwt\\n\");\n      }\n    ...\n\n",
 "update_stat": "### update_stat(variable,value)\n\n module: statistics\n\nUpdates the value of the statistic variable with the new value.\n\nMeaning of the parameters is as follows:\n\n- *variable* - variable to be updated (it can be a string or a\n  pseudovariable);\n\n- *value* - value to update with; it may be also negative (it can be a\n  string or pseudovariable).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    update_stat(\"register_counter\", \"+1\");\n    ...\n    $var(a_calls) = \"active_calls\";\n    update_stat(\"$var(a_calls)\", \"-1\");\n    ...\n\n",
 "reset_stat": "### reset_stat(variable)\n\n module: statistics\n\nResets to zero the value of the statistic variable.\n\nMeaning of the parameters is as follows:\n\n- *variable* - variable to be reset (it can be a string or a\n  pseudovariable).\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nFAILURE_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    reset_stat(\"register_counter\");\n    ...\n    $var(reg_counter) = \"register_counter\";\n    update_stat(\"$var(reg_counter)\");\n    ...\n",
 "pike_check_req": "### pike_check_req()\n\n module: pike\n\nProcess the source IP of the current request and return false if the IP\nwas exceeding the blocking limit.\n\nReturn codes:\n\n- *1 (true)* - IP is not to be blocked or internal error occurred.\n\n  <div class=\"warning\">\n\n  IMPORTANT: in case of internal error, the function returns true to\n  avoid reporting the current processed IP as blocked.\n\n  </div>\n\n- *-1 (false)* - IP is source of flooding, previously detected\n\n- *-2 (false)* - IP is detected as a new source of flooding - first time\n  detection\n\nThis function can be used from REQUEST_ROUTE\\|ONREPLY_ROUTE.\n\n    ...\n    if (!pike_check_req()) { exit; };\n    ...\n\n",
 "pike_check_ip": "### pike_check_ip(ipaddr)\n\n module: pike\n\nProcess the IP address parameter and return false if it was exceeding\nthe blocking limit. The return codes are the same from pike_check_req().\n\nThe parameter can contain variables.\n\nThis function can be used from REQUEST_ROUTE\\|ONREPLY_ROUTE.\n\n    ...\n    if (!pike_check_ip(\"1.2.3.4\")) { exit; };\n    ...\n    if (!pike_check_ip(\"$si\")) { exit; };\n    ...\n\n",
 "db_query": "### db_query(query | query_id[, handle])\n\n module: db2_ops\n\nExecutes query and in case of SELECT returns result via *handle*, seeks\nthe first record and returns TRUE if table is not empty. The result is\naccessible using `@db.fetch` select. See also `declare_handle`.\n*Query_id* references to query declared using `declare_query`, *handle*\nreferences to query declared using `declare_handle`.\n\n        ...\n        db_query(\"delete/silo///\");\n        if (db_query(\"select/silo/body/uid//inc_time/%$f.uid\", my_handle)) {\n        ...\n        }\n        ...\n        if (db_query(sel1, my_handle)) {\n\n        }\n                    \n\n",
 "db_close": "### db_close(handle)\n\n module: db2_ops\n\nClose table that has been opened using `db_query`. Note all close after\nscript processing automatically.\n\n        ...\n        db_close(my_handle);\n        ...\n                    \n\n",
 "db_first": "### db_first(handle)\n\n module: db2_ops\n\nReturns TRUE if table is not empty. Note that rewind might not be\nsupported by particular db driver.\n\n        ...\n        if (db_first(my_handle)) {\n        ...\n        }\n        ...\n                    \n\n",
 "db_next": "### db_next(handle)\n\n module: db2_ops\n\nMoves to the next record and returns TRUE if not EOF.\n\n        ...\n        if (db_next(my_handle)) {\n        ...\n        }\n        ...\n                    \n\n",
 "db_seek": "### db_seek(handle, row_no)\n\n module: db2_ops\n\nSeeks at the row no (origin is zero) and Returns TRUE in case of\nsuccess. Backward seek might not be supported by db driver.\n\n        ...\n        if (db_seek(my_handle, $row_no)) {\n        ...\n        }\n        ...\n                    \n\n",
 "db_foreach": "### db_foreach(handle, route)\n\n module: db2_ops\n\nCall specific route for each row, loop is interrupted if route returns\ncode \\<= 0. Return code of the last route call is returned as result of\n`db_foreach` (or -1 when no select is empty).\n\n        route[\"print_row\"] {\n        ....\n        }\n\n        ...\n        if (db_foreach(my_handle, print_row)) {\n        ...\n        }\n        ...\n                    \n\n",
 "db_proper": "### db_proper()\n\n module: db2_ops\n\nHack which enables using db_ops queries in failure route. Call it at the\nbeginning of FAILURE_ROUTE block.\n\n        failure_route[\"my_failure\"] {\n            db_proper();\n            db_query(my_query, my_handle);\n        ....\n        }\n                    \n\n",
 "rls_handle_subscribe": "### rls_handle_subscribe([watcher_uri])\n\n module: rls\n\nThis function detects if a Subscribe message should be handled by RLS.\nIf not it replies with the configured to_presence_code. If it is, it\nextracts the dialog info and sends aggregate Notify requests with\ninformation for the list.\n\nBy default this function uses the From: URI from the SUBSCRIBE request\nas the Watcher URI. The optional watcher_uri parameter can be used to\nspecify a different Watcher URI, possibly taken from a SIP header like\nP-Asserted-Identity:.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    For presence and rls on the same machine:\n        modparam(\"rls\", \"to_presence_code\", 10)\n\n        if(is_method(\"SUBSCRIBE\"))\n        {\n            $var(ret_code)= rls_handle_subscribe();\n\n            if($var(ret_code)== 10)\n                    handle_subscribe();\n\n            t_release();\n        }\n\n    For rls only:\n        if(is_method(\"SUBSCRIBE\"))\n        {\n            rls_handle_subscribe();\n            t_release();\n        }\n\n    ...\n\n",
 "rls_handle_notify": "### rls_handle_notify()\n\n module: rls\n\nHandle NOTIFY requests.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if(method==\"NOTIFY\")\n        rls_handle_notify();\n    ...\n\n",
 "rls_update_subs": "### rls_update_subs(uri, event)\n\n module: rls\n\nThis function can be used in configuration to trigger updates to\nresource list subscriptions (for example, after the contents of a\nresource list has changes).\n\nParameters:\n\n- uri - the uri of the user who made the change and whose resource list\n  subscriptions should be updated\n\n- event - the event package (e.g. presence).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    Within event_route[xhttp:request]:\n        case \"PUT\":\n            xcaps_put(\"$var(uri)\", \"$var(doc_uri)\", \"$rb\");\n            if($xcapuri(u=>auid)=~\"pres-rules\") {\n                pres_update_watchers(\"$var(uri)\", \"presence\");\n                pres_refresh_watchers(\"$var(uri)\", \"presence\", 1);\n            } else if ($xcapuri(u=>auid)=~\"resource-lists\"\n                   || $xcapuri(u=>auid)=~\"rls-services\") {\n                rls_update_subs(\"$var(uri)\", \"presence\");\n            }\n            exit;\n            break;\n    ...\n\n",
 "pv_isset": "### pv_isset(pvar)\n\n module: pv\n\nReturn true if a PV value is different than 'null'.\n\nMeaning of the parameters is as follows:\n\n- *pvar* - pvar identifier.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(pv_isset(\"$avp(s:x)\"))\n    {\n        ...\n    }\n    ...\n\n",
 "pv_unset": "### pv_unset(pvar)\n\n module: pv\n\nUnset the value of the PV (e.g., delete AVP, set to null).\n\nMeaning of the parameters is as follows:\n\n- *pvar* - pvar identifier.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pv_unset(\"$avp(s:x)\");\n    ...\n\n",
 "is_int": "### is_int(pvar)\n\n module: pv\n\nFunction checks if pvar argument contains integer value and returns 1 if\nit does and -1 otherwise.\n\nFunction can be used from all kinds of routes.\n\n    ...\n    if (is_int(\"$var(foo)\")) {\n        xlog(\"L_INFO\", \"variable foo contains integer value\\n\");\n    }\n    ...\n                    \n\n",
 "typeof": "### typeof(pvar, vtype)\n\n module: pv\n\nReturns true if the type of pseudo-variable matches the second\nparameter. The second parameter can be: 'int' - type is integer; 'str' -\ntype is string; 'null' - type is null.\n\nFunction can be used from ANYROUTE.\n\n    ...\n    if (typeof(\"$var(foo)\", \"str\")) {\n        xdbg(\"variable foo is a string\\n\");\n    }\n    ...\n                    \n\n",
 "not_empty": "### not_empty(pvar)\n\n module: pv\n\nReturns true if the pseudo-variables has the type string and is not\nempty value.\n\nFunction can be used from all kinds of routes.\n\n    ...\n    if (not_empty(\"$var(foo)\")) {\n        append_hf(\"X-Foo: $var(foo)\\r\\n\");\n    }\n    ...\n                    \n\n",
 "xavp_copy": "### xavp_copy(source_name, source_index, destination_name)\n\n module: pv\n\nCopy and append one XAVP.\n\nThe parameters can be variables or strings. First parameter is the\nsource XAVP name. Second parameter is the source XAVP stack index, use 0\nto copy the last assigned XAVP. Third parameter is the destination XAVP\nname, if found the XAVP will be appended else it will be created.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    # Using xavp_copy to reorder an existing xavp stack in a new one\n    $xavp(a=>x) = \"a-0-x\";\n    $xavp(a[0]=>y) = \"a-0-y\";\n    $xavp(a=>x) = \"a-1-x\";\n    $xavp(a[0]=>y) = \"a-1-y\";\n    $xavp(a=>x) = \"a-2-x\";\n    $xavp(a[0]=>y) = \"a-2-y\";\n\n    xinfo(\"BEFORE $xavp(a[0]=>x) == [a-2-x] == $xavp(a[0]=>y) == [a-2-y]\\n\");\n    xinfo(\"BEFORE $xavp(a[1]=>x) == [a-1-x] == $xavp(a[1]=>y) == [a-1-y]\\n\");\n    xinfo(\"BEFORE $xavp(a[2]=>x) == [a-0-x] == $xavp(a[2]=>y) == [a-0-y]\\n\");\n\n    # reorder\n    $var(source_index) = 1;\n    $var(destination_name) = \"b\";\n    xavp_copy(\"a\", \"2\", \"b\");\n    xavp_copy(\"a\", \"$var(source_index)\", \"$var(destination_name)\");\n    xavp_copy(\"a\", \"0\", \"$var(destination_name)\");\n\n    xinfo(\"AFTER $xavp(b[0]=>x) == [a-0-x] == $xavp(b[0]=>y) == [a-0-y]\\n\");\n    xinfo(\"AFTER $xavp(b[1]=>x) == [a-1-x] == $xavp(b[1]=>y) == [a-1-y]\\n\");\n    xinfo(\"AFTER $xavp(b[2]=>x) == [a-2-x] == $xavp(b[2]=>y) == [a-2-y]\\n\");\n    ...\n                    \n\n### xavp_copy(source_name, source_index, destination_name, destination_index)\n\n module: pv\n\nCopy and replace one XAVP.\n\nThe parameters can be variables or strings. First parameter is the\nsource XAVP name. Second parameter is the source XAVP stack index, use 0\nto copy the last assigned XAVP. Third parameter is the destination XAVP\nname, if not found xavp_copy will return -1. Fourth parameter is the\ndestination XAVP index, if not found xavp_copy will return -1.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    # Using xavp_copy to reorder an existing xavp stack inplace\n    $xavp(d=>x) = \"d-0-x\";\n    $xavp(d[0]=>y) = \"d-0-y\";\n    $xavp(d=>x) = \"d-1-x\";\n    $xavp(d[0]=>y) = \"d-1-y\";\n    $xavp(d=>x) = \"d-2-x\";\n    $xavp(d[0]=>y) = \"d-2-y\";\n\n    xinfo(\"NEW $xavp(d[0]=>x) == [d-2-x] and $xavp(d[0]=>y) == [d-2-y]\\n\");\n    xinfo(\"NEW $xavp(d[1]=>x) == [d-1-x] and $xavp(d[1]=>y) == [d-1-y]\\n\");\n    xinfo(\"NEW $xavp(d[2]=>x) == [d-0-x] and $xavp(d[2]=>y) == [d-0-y]\\n\");\n\n    xavp_copy(\"d\", \"0\", \"e\");\n    xavp_copy(\"d\", \"2\", \"d\", \"0\");\n    xavp_copy(\"e\", \"0\", \"d\", \"2\");\n\n    xinfo(\"AFTER $xavp(d[0]=>x) == [d-0-x] $xavp(d[0]=>y) == [d-0-y]\\n\");\n    xinfo(\"AFTER $xavp(d[1]=>x) == [d-1-x] $xavp(d[1]=>y) == [d-1-y]\\n\");\n    xinfo(\"AFTER $xavp(d[2]=>x) == [d-2-x] $xavp(d[2]=>y) == [d-2-y]\\n\");\n    ...\n                    \n\n",
 "xavp_params_explode": "### xavp_params_explode(sparams, xname)\n\n module: pv\n\nConvert a parameters string in xavp attributes.\n\nThe first parameter has to be a string in the format of SIP header\nparameters (name1=value1;...;nameN=valueN). The second parameter is the\nname of the root xavp to hold the pairs (nameX,valueX).\n\nThe values are stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavp_params_explode(\"a=b;c=d;e=d\", \"x\");\n    # results in:\n    #    $xavp(x=>a) = \"b\";\n    #    $xavp(x=>c) = \"d\";\n    #    $xavp(x=>e) = \"f\";\n    ...\n                    \n\n",
 "xavp_params_implode": "### xavp_params_implode(xname, pvname)\n\n module: pv\n\nSerialize the subfields in an XAVP to a parameters string format.\n\nNumber values are serialized as unsigned integer string format.\n\nThe first parameter has to be the name of XAVP (only the string name,\nnot the in \\$xavp(name)). The second parameter is the name of output\nvariable (in full name, like \\$var(output)).\n\nThe value is stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $xavp(x=>e) = \"f\";\n    $xavp(x[0]=>c) = \"d\";\n    $xavp(x[0]=>a) = \"b\";\n    xavp_params_implode(\"x\", \"$var(out)\");\n    # results in: $var(out) is \"a=b;c=d;e=f;\"\n    ...\n                    \n\n",
 "xavu_params_explode": "### xavu_params_explode(sparams, xname)\n\n module: pv\n\nConvert a parameters string in xavu attributes.\n\nThe first parameter has to be a string in the format of SIP header\nparameters (name1=value1;...;nameN=valueN). The second parameter is the\nname of the root xavu to hold the pairs (nameX,valueX).\n\nThe values are stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavu_params_explode(\"a=b;c=d;e=d\", \"x\");\n    # results in:\n    #    $xavu(x=>a) = \"b\";\n    #    $xavu(x=>c) = \"d\";\n    #    $xavu(x=>e) = \"f\";\n    ...\n                    \n\n",
 "xavu_params_implode": "### xavu_params_implode(xname, pvname)\n\n module: pv\n\nSerialize the subfields in an XAUP to a parameters string format.\n\nNumber values are serialized as unsigned integer string format.\n\nThe first parameter has to be the name of XAVU (only the string name,\nnot the in \\$xavu(name)). The second parameter is the name of output\nvariable (in full name, like \\$var(output)).\n\nThe value is stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $xavu(x=>e) = \"f\";\n    $xavu(x=>c) = \"d\";\n    $xavu(x=>a) = \"b\";\n    xavu_params_implode(\"x\", \"$var(out)\");\n    # results in: $var(out) is \"a=b;c=d;e=f;\"\n    ...\n                    \n\n",
 "xavp_slist_explode": "### xavp_slist_explode(slist, sep, mode, xname)\n\n module: pv\n\nBreaks a string list in tokens by separators and stores them in XAVPs.\nNote that is not storing empty values.\n\nThe first parameter has to be a string (static or with variables).\n\nThe second parameter has to contain separator characters (they can be\nmany).\n\nThe third parameter is mode, controlling the behaviour of extracting the\ntokens, the supported mode right now is 't', which trims the white\nspaces around the value.\n\nThe fourth parameter is the name of the root xavp to hold the tokens in\nfields named 'v' and indexed from 0.\n\nThe values are stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavp_slist_explode(\"a=b; c=d;\", \"=;\", \"t\", \"x\");\n    # results in:\n    #    $xavp(x[0]=>v[0]) = \"a\";\n    #    $xavp(x[0]=>v[1]) = \"b\";\n    #    $xavp(x[0]=>v[2]) = \"c\";\n    #    $xavp(x[0]=>v[3]) = \"d\";\n    ...\n                    \n\n",
 "xavp_child_seti": "### xavp_child_seti(rname, cname, ival)\n\n module: pv\n\nSet the value of \\$xavp(rname=\\>cname) to integer value ival.\n\nThe first parameter has to be the name of XAVP in the root list. The\nsecond parameter name of child XAVP. The third parameter can be an\ninteger number or a variable holding an integer.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $var(n) = 10;\n    xavp_child_seti(\"x\", \"y\", \"$var(n)\");\n    # results in: $xavp(x=>y) is 10\n    ...\n                    \n\n",
 "xavi_child_seti": "### xavi_child_seti(rname, cname, ival)\n\n module: pv\n\nSet the value of \\$xavi(rname=\\>cname) to integer value ival.\n\nThe first parameter has to be the name of XAVI in the root list. The\nsecond parameter name of child XAVI. The third parameter can be an\ninteger number or a variable holding an integer.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $var(n) = 10;\n    xavi_child_seti(\"WhatEver\", \"FoO\", \"$var(n)\");\n    # results in: $xavi(whatever=>foo) is 10\n    ...\n                    \n\n",
 "xavp_child_sets": "### xavp_child_sets(rname, cname, sval)\n\n module: pv\n\nSet the value of \\$xavp(rname=\\>cname) to string value sval.\n\nThe first parameter has to be the name of XAVP in the root list. The\nsecond parameter name of child XAVP. The third parameter can be a static\nor dynamic (with variables) string.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $var(n) = 10;\n    xavp_child_sets(\"x\", \"y\", \"Count: $var(n)\");\n    # results in: $xavp(x=>y) is \"Count: 10\"\n    ...\n                    \n\n",
 "xavi_child_sets": "### xavi_child_sets(rname, cname, sval)\n\n module: pv\n\nSet the value of \\$xavi(rname=\\>cname) to string value sval.\n\nThe first parameter has to be the name of XAVI in the root list. The\nsecond parameter name of child XAVI. The third parameter can be a static\nor dynamic (with variables) string.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $var(n) = 10;\n    xavi_child_sets(\"WhatEver\", \"FoO\", \"Count: $var(n)\");\n    # results in: $xavi(whatever=>foo) is \"Count: 10\"\n    ...\n                    \n\n",
 "xavp_rm": "### xavp_rm(rname)\n\n module: pv\n\nRemove the value of \\$xavp(rname).\n\nThe parameter has to be the name of XAVP in the root list. It can be\nstatic or dynamic string (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavp_rm(\"x\");\n    # same result as: $xavp(x) = $null;\n    ...\n                    \n\n",
 "xavi_rm": "### xavi_rm(rname)\n\n module: pv\n\nRemove the value of \\$xavi(rname).\n\nThe parameter has to be the name of XAVI in the root list. It can be\nstatic or dynamic string (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavi_rm(\"WhatEver\");\n    # same result as: $xavi(whatever) = $null;\n    ...\n                    \n\n",
 "xavp_child_rm": "### xavp_child_rm(rname, cname)\n\n module: pv\n\nRemove the value of \\$xavp(rname=\\>cname).\n\nThe first parameter has to be the name of XAVP in the root list. The\nsecond parameter name of child XAVP. Both parameters can be static or\ndynamic strings (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavp_child_rm(\"x\", \"y\");\n    # same result as: $xavp(x=>y) = $null;\n    ...\n                    \n\n",
 "xavi_child_rm": "### xavi_child_rm(rname, cname)\n\n module: pv\n\nRemove the value of \\$xavi(rname=\\>cname).\n\nThe first parameter has to be the name of XAVI in the root list. The\nsecond parameter name of child XAVI. Both parameters can be static or\ndynamic strings (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    xavi_child_rm(\"WhatEver\", \"FoO\");\n    # same result as: $xavi(whatever=>foo) = $null;\n    ...\n                    \n\n",
 "xavp_lshift": "### xavp_lshift(xname, idx)\n\n module: pv\n\nLeft shift with rotation of the xavps with name xname so that the one at\nthe index idx becomes the first and the ones before it are at the end of\nthe list.\n\nThe first parameter has to be the name of XAVP in the root list.\n\nThe second parameter is the index of the XAVP that becomes the first one\n(if it is greater than the number of XAVPs, modulo operation is done\nfirst; if it is negative, it counts from the end of the list).\n\nThe parameters can be with variables.\n\nFunction can be used from ANY ROUTE.\n\n    ...\n    $xavp(n) = 10;\n    $xavp(n) = 20;\n    $xavp(n) = 30;\n    xavp_lshift(\"n\", \"1\");\n    # results in: $xavp(n) having the list of values 20 30 10\n    ...\n                    \n\n",
 "xavp_push_dst": "### xavp_push_dst(xname)\n\n module: pv\n\nSet destination fields from XAVP attributes.\n\nThe first parameter has to be the name of XAVP in the root list.\n\nThe parameters can be with variables.\n\nThe attributes that can be stored in the XAVP fields:\n\n- uri: SIP URI address to set R-URI\n\n- dsturi: SIP URI address to set DST-URI\n\n- socket: listen address to set outgoing socket\n\nFunction can be used from REQUEST_ROUTE\\|BRANCH_ROUTE\\|FAILURE_ROUTE.\n\n    ...\n    $xavp(dst=>uri) = \"sip:alice@server.com\";\n    $xavp(dst[0]=>dsturi) = \"sip:proxy.com\";\n    $xavp(dst[0]=>socket) = \"udp:1.2.3.4:5060\";\n    xavp_push_dst(\"dst\");\n    ...\n                    \n\n",
 "sbranch_set_ruri": "### sbranch_set_ruri()\n\n module: pv\n\nUse the attributes from static branch (\\$sbranch(key) variable) to set\nrequest URI and the other fields of the branch associated with request\nURI (destination URI, path, ...).\n\nContent of the static branch is not reset after this function is\nexecuted. It has to be done explicitly with sbranch_reset().\n\nFunction can be used from REQUEST_ROUTE, BRANCH_ROUTE or FAILURE_ROUTE.\n\n    ...\n    sbranch_reset();\n    $sbranch(uri) = \"sip:127.0.0.1:5080\";\n    $sbranch(dst_uri) =  \"sip:127.0.0.1:5090\";\n    $sbranch(path) =  \"sip:127.0.0.1:5090, sip:127.0.0.1:5094\";\n    $sbranch(send_socket) =  \"udp:127.0.0.1:5060\";\n    sbranch_set_ruri();\n    ...\n                    \n\n",
 "sbranch_append": "### sbranch_append()\n\n module: pv\n\nUse the attributes from static branch (\\$sbranch(key) variable) to\nappend a new branch to destination set. It is an alternative to\nappend_branch() that allows setting each attribute specific to the\nbranch.\n\nContent of the static branch is not reset after this function is\nexecuted. It has to be done explicitly with sbranch_reset().\n\nFunction can be used from REQUEST_ROUTE, BRANCH_ROUTE or FAILURE_ROUTE.\n\n    ...\n    sbranch_reset();\n    $sbranch(uri) = \"sip:127.0.0.1:5080\";\n    $sbranch(dst_uri) =  \"sip:127.0.0.1:5090\";\n    $sbranch(send_socket) =  \"udp:127.0.0.1:5060\";\n    sbranch_append();\n    ...\n                    \n\n",
 "sbranch_reset": "### sbranch_reset()\n\n module: pv\n\nReset the content of static branch (\\$sbranch(key) variable.\n\nFunction can be used from REQUEST_ROUTE, BRANCH_ROUTE or FAILURE_ROUTE.\n\n    ...\n    sbranch_reset();\n    ...\n                    \n\n",
 "pv_xavp_print": "### pv_xavp_print()\n\n module: pv\n\nPrint all XAVPs to the syslog using INFO log level.\n\nFunction can be used from ANY_ROUTE.\n\n    ...\n    pv_xavp_print();\n    ...\n                    \n\n",
 "pv_xavu_print": "### pv_xavu_print()\n\n module: pv\n\nPrint all XAVUs to the syslog using INFO log level.\n\nFunction can be used from ANY_ROUTE.\n\n    ...\n    pv_xavu_print();\n    ...\n                    \n\n",
 "pv_xavi_print": "### pv_xavi_print()\n\n module: pv\n\nPrint all XAVIs to the syslog using INFO log level.\n\nFunction can be used from ANY_ROUTE.\n\n    ...\n    pv_xavi_print();\n    ...\n                    \n\n",
 "pv_var_to_xavp": "### pv_var_to_xavp(varname, xname)\n\n module: pv\n\nCopy the script variable value into an xavp.\n\nFirst parameter can be '\\*' in order to copy all script variables.\nSecond parameter is the name of the destination xavp. If xavp already\nexists it will be reset first.\n\nBoth parameters can contain variables that are evaluated at runtime.\n\nFunction can be used from ANY_ROUTE.\n\n    ...\n    $var(\"temp\") = 3;\n    $var(\"foo\") = \"foo indeed\";\n    pv_var_to_xavp(\"temp\", \"ok\");\n    ...\n    $xavp(\"ok[0]=>temp\") now is 3\n    ...\n    pv_var_to_xavp(\"*\", \"ok\");\n    ...\n    $xavp(\"ok[0]=>temp\") now is 3\n    $xavp(\"ok[0]=>foo\") now is \"foo indeed\"\n    ...\n                    \n\n",
 "pv_xavp_to_var": "### pv_xavp_to_var(xname)\n\n module: pv\n\nCopy xavp values into vars. Reverse of pv_var_to_xavp().\n\nBoth parameters can contain variables that are evaluated at runtime.\n\nFunction can be used from ANY_ROUTE.\n\n    ...\n    $xavp(\"bar=>temp\") = 3;\n    $xavp(\"bar[0]=>foo\") = \"foo indeed\";\n    pv_xavp_to_var(\"bar\");\n    ...\n    $var(\"temp\") now is 3\n    $var(\"foo\") now is \"foo indeed\"\n    ...\n                    \n\n",
 "pv_evalx": "### pv_evalx(dst, fmt)\n\n module: pv\n\nThe fmt string is evaluated twice for exiting variables, the result is\nstored in dst variable. The dst must be the name of a writable variable.\nThe fmt can contain variables that have a value containing other\nvariables.\n\nFunction can be used from ANY_ROUTE.\n\n    ...\n    $var(x) = \"test\";\n    $var(y) = \"$var(x)\"\n    pv_evalx(\"$var(z)\", \"$var(y) one\");\n\n    # - the value of $var(z) is \"test one\"\n    ...\n                    \n\n",
 "jansson_get": "### jansson_get(key/path, src, dst)\n\n module: jansson\n\nCopy the value at the location 'path' from the json object 'src' and\nstore it in pvar 'dst'. The 'src' can be a static string or a dynamic\nstring with variables.\n\nThe path string supports dot delimited notation (e.g. foo.bar.baz),\narray notation (e.g. \\[0\\]), or a combination of the two (e.g.\nfoo.bar\\[0\\]\\[1\\].baz).\n\nReturns FALSE if the data can not be parsed, TRUE otherwise.\n\nThe function can put a string, integer, null, or new json string into\ndestination. If the key/path can't be found in the JSON data structure,\nthe pvar is not changed. If it had a previous value, that value remains\nunchanged.\n\n*Note:* For JSON-Integer values exceeding the C-Integer boundaries, a\nString representing the number is returned.\n\n    ...\n    if(!jansson_get(\"inner.deep.list[3]\", \"$var(myjson)\", \"$var(n)\")) {\n        xlog(\"L_ERR\", \"Can't parse json data\");\n    }\n    xlog(\"L_INFO\", \"foo is $var(n)\");\n    ...\n    jansson_get(\"test\", \"{\\\"test\\\":\\\"abc\\\",\\\"idx\\\":20}\", \"$var(n)\")\n    ...\n            \n\n",
 "jansson_pv_get": "### jansson_pv_get(key/path, srcvar, dst)\n\n module: jansson\n\nSimilar to jansson_get(), but the 'srcvar' parameter can be only a\nvariable name.\n\n    ...\n    if(!jansson_pv_get(\"inner.deep.list[3]\", \"$var(myjson)\", \"$var(n)\")) {\n        xlog(\"L_ERR\", \"Can't parse json data\");\n    }\n    xlog(\"L_INFO\", \"foo is $var(n)\");\n    ...\n            \n\n",
 "jansson_set": "### jansson_set(type, key/path, value, result)\n\n module: jansson\n\nInsert 'value' as 'type' at location 'path' into 'result'.\n\nThe path string works the same as in jansson_get.\n\nValid 'type' parameters are 'integer', 'real', 'string', 'object',\n'array', 'true', 'false', and 'null' as well as abbreviated names such\nas 'int', 'str', and 'obj'. 'value' is ignored when type is 'true',\n'false', or 'null'.\n\n*Note:* If you want to insert a JSON-Integer value exceeding the\nC-Integer boundaries (e.g. C-type long), then the number can be provided\nas a string.\n\n    ...\n    # create a new json object and put a string in it at key \"mystr\"\n    jansson_set(\"string\", \"mystr\", \"my input string\", \"$var(myjson)\");\n    # $var(myjson) =='{\"mystr\":\"my input string\"}'\n\n    # add other values\n    jansson_set(\"integer\", \"count\", 9000, \"$var(myjson)\");\n    jansson_set(\"true\", \"mybool\", 0, \"$var(myjson)\");\n    jansson_set(\"real\", \"pi\", \"3.14159\", \"$var(myjson)\");\n    # $var(myjson) == '{\"mystr\":\"my input string\", \"count\":9000, \"mybool\":true, \"pi\":3.14159}'\n\n    # add a nested object\n    jansson_set(\"obj\", \"myobj\", '{\"foo\":\"bar\"}', \"$var(myjson)\");\n    # $var(myjson) =='{\"mystr\":\"my input string\", \"count\":9000, \"mybool\":true, \"pi\":3.14159, \"myobj\":{\"foo\":\"bar\"}}'\n\n    # change the nested object\n    jansson_set(\"str\", \"myobj.foo\", \"baz\", \"$var(myjson)\");\n    # $var(myjson) == '{\"mystr\":\"my input string\", \"count\":9000, \"mybool\":true, \"pi\":3.14159, \"myobj\":{\"foo\":\"baz\"}}'\n    ...\n            \n\n",
 "jansson_append": "### jansson_append(type, key/path, value, result)\n\n module: jansson\n\nLike jansson_set but can be used to append to arrays. It can also be\nused to combine two json objects.\n\nNote that when appending a json object to another json object, if there\nis a key that is shared between the two objects, that value will be\noverwritten by the new object.\n\n    ...\n    # create a new json array and append values to it\n    $var(myarray) = '[]';\n    jansson_append(\"int\", \"\", 0, \"$var(myarray)\");\n    jansson_append(\"int\", \"\", 1, \"$var(myarray)\");\n    jansson_append(\"int\", \"\", 2, \"$var(myarray)\");\n    jansson_append(\"int\", \"\", 3, \"$var(myarray)\");\n    jansson_append(\"int\", \"\", 4, \"$var(myarray)\");\n    # $var(myarray) == '[0,1,2,3,4]'\n\n    # add that array to an object\n    jansson_set(\"array\", \"list\", $var(myarray), \"$var(myjson)\");\n    # $var(myjson) == '{\"list\":[0,1,2,3,4]}'\n\n    # append another value to the list\n    jansson_append(\"int\", \"list\", 5, \"$var(myjson)\");\n    # $var(myjson) == '{\"list\":[0,1,2,3,4,5]}'\n\n    # combining two json objects\n    $var(newobj) = '{\"b\":2, \"c\":3}';\n    jansson_append('obj', \"\", '{\"a\":1, \"b\":100}', \"$var(newobj)\");\n    # $var(newobj) == '{\"a\":1,\"b\":100\",\"c\":3}';\n    ...\n            \n\n",
 "jansson_array_size": "### jansson_array_size(key/path, src, dst)\n\n module: jansson\n\nPuts the size of the array in 'src' at location 'path' into the pvar\n'dst'.\n\nThis is particularly useful for looping through an array. See example.\n\n    ...\n    $var(array) = \"{\\\"loopme\\\":[0,1,2,3,4,5]}\";\n    $var(count) = 0;\n    jansson_array_size(\"loopme\", $var(array), \"$var(size)\");\n    while($var(count) < $var(size)) {\n        jansson_get(\"loopme[$var(count)]\", $var(array), \"$var(v)\");\n        xlog(\"loopme[$var(count)] == $var(v)\\n\");\n        $var(count) = $var(count) + 1;\n    }\n    ...\n            \n\n    ...\n    $var(count) = 0;\n    $var(appendme) = '[0,1]';\n    $var(mylist) = '[2,3,4,5]';\n    jansson_array_size(\"\", $var(mylist), \"$var(appendme_size)\");\n    while($var(count) < $var(appendme_size)) {\n        jansson_get(\"[$var(count)]\", $var(mylist), \"$var(tmp)\");\n        jansson_append('int', \"\", $var(tmp), \"$var(appendme)\");\n        $var(count) = $var(count) + 1;\n    }\n    ...\n            \n\n",
 "jansson_xdecode": "### jansson_xdecode(json, xavp)\n\n module: jansson\n\nParse a JSON string in 'json' and store the elements in xapv 'xavp'.\nTop-level JSON must be an object or an array of objects. Nested arrays\nand objects are not decoded but stored as string.\n\n    ...\n    jansson_xdecode('{\"foo\":\"bar\"}', \"js\");\n    xlog(\"foo is $xavp(js=>foo)\");\n    ...\n            \n\n",
 "jansson_xencode": "### jansson_xencode(xavp, pv)\n\n module: jansson\n\nEncode the items in the xavp 'xavp' as JSON and store the result in a\npv. Nested xavps's are not supported.\n\n    ...\n    $xavp(a=>foo) = \"bar\";\n    jansson_xencode(\"a\", \"$var(js)\");\n    # $var(js) = '{\"foo\":\"bar\"}'\n    ...\n            \n\n",
 "jansson_get_field": "### jansson_get_field(src, field_name, dst)\n\n module: jansson\n\nCopy field 'field_name' from json object 'src' and store it in pvar\n'dst'.\n\n*This function is deprecated* but kept for backwards compatibility.\nRight now it is just a wrapper around `jansson_get`, and its\nfunctionality is the same.\n\n    ...\n    jansson_get_field(\"{'foo':'bar'}\", \"foo\", \"$var(foo)\");\n    xlog(\"foo is $var(foo)\");\n    ...\n            \n",
 "imc_manager": "### imc_manager()\n\n module: imc\n\nTHis function handles incoming MESSAGE requests. If detects if the body\nof the message is a conference command it executes it, otherwise it\nsends the message to all the members in the room.\n\nThis function can be used from REQUEST_ROUTE. See command description\nfor error codes returned by this function.\n\n    ...\n    # the rooms will be named chat-xyz to avoid overlapping\n    # with usernames\n    if(is_method(\"MESSAGE)\n        && (uri=~ \"sip:chat-[0-9]+@\" || (uri=~ \"sip:chat-manager@\"))\n    {\n        if(imc_manager())\n            sl_send_reply(\"200\", \"ok\");\n        else\n            sl_send_reply(\"500\", \"command error\");\n        exit;\n    }\n    ...\n\n",
 "phonenum_match": "### phonenum_match(num, pvc)\n\n module: phonenum\n\nMatch num against the libphonenumber and set the attributes inside the\npvc result container. The function has to be called before accessing a\nkey via: \\$phn(pvc=\\>key).\n\nThe parameters can be static strings or strings with variables.\n\nIt can be used from ANY_ROUTE.\n\n    ...\n    if(phonenum_match(\"1-484-555-8888\", \"src\")) {\n        if($phn(src=>valid)==1) {\n            xlog(\"number normalized to: $phn(src=>normalized)\\n\");\n        } else {\n            xlog(\"number normalization error: $phn(src=>error)\\n\");\n        }\n    }\n    ...\n\n",
 "phonenum_match_cn": "### phonenum_match_cn(num, cnc, pvc)\n\n module: phonenum\n\nMatch num against the libphonenumber and set the attributes inside the\npvc container, restricting the rules with a country name code (two\nletter, e.g: \"DE\", \"US\", \"ES\"). The function has to be called before\naccessing a key via: \\$phn(pvc=\\>key).\n\nNote from libphonenumber library docs: country name code is the region\nthat is expected the number to be from. It is only used if the number\nbeing parsed is not written in international format. The country code\nfor the number in this case would be stored as that of the region\nsupplied. If the number is guaranteed to start with a '+' followed by\nthe country calling code, then region 'ZZ'.\n\nThe parameters can be static strings or strings with variables.\n\nIt can be used from ANY_ROUTE.\n\n    ...\n    if(phonenum_match_cn(\"1-484-555-8888\", \"US\", \"src\")) {\n        if($phn(src=>valid)==1) {\n            xlog(\"number normalized to: $phn(src=>normalized)\\n\");\n        } else {\n            xlog(\"number normalization error: $phn(src=>error)\\n\");\n        }\n    }\n    ...\n\n",
 "cdp_check_peer": "### cdp_check_peer(fqdn)\n\n module: cdp\n\nThe method checks, if a specific peer is connected and ready.\n\nMeaning of the parameter is as follows:\n\n- *fqdn* - the Fully qualified domain name of the peer, that should be\n  checked. The parameter may contain pseudovariables.\n\n<!-- -->\n\n    ...\n    if(!cdp_check_peer(\"hss.mnc001.mcc001.3gppnetwork.org\")) {\n        send_reply(\"503\", \"HSS not ready\");\n        exit;\n    }\n    ...\n\n",
 "cdp_has_app": "### cdp_has_app([vendorid, ]application)\n\n module: cdp\n\nThe method checks, if any peer with this specific application has\nconnected.\n\nMeaning of the parameters are as follows:\n\n- *vendorid* - The Vendor ID of the App\n\n  *application* - The Application ID\n\n<!-- -->\n\n    ...\n    if(!cdp_has_app(\"10415\", \"4\")) {\n        send_reply(\"503\", \"Charging Server not ready\");\n        exit;\n    }\n    ...\n\n    ...\n    if(!cdp_has_app(\"16777216\")) {\n        send_reply(\"503\", \"Cx/Dx Interface not ready\");\n        exit;\n    }\n    ...\n\n",
 "sql_query": "### sql_query(connection, query[, result])\n\n module: sqlops\n\nMake an SQL query using 'connection' and store data in 'result'.\n\n- *connection* - the name of the connection to be used for the query\n  (defined via the \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\n- *result* - string name to identify the result. Will be used by\n  \\$dbr(...) pseudo-variable to access result attributes. If omitted,\n  any resultset will be discarded. The result parameter should normally\n  only be omitted when no result is expected (INSERT, UPDATE, DELETE).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    modparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n    ...\n    sql_query(\"ca\", \"select * from domain\", \"ra\");\n    xlog(\"number of rows in table domain: $dbr(ra=>rows)\\n\");\n    sql_result_free(\"ra\");\n    ...\n\n",
 "sql_xquery": "### sql_xquery(connection, query, result)\n\n module: sqlops\n\nMake an SQL query using 'connection' and store data in 'result' xavp.\n\n- *connection* - the name of the connection to be used for the query\n  (defined via the \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\n- *result* - string name to identify the result xavp. Each row will be\n  added to this xavp, each column can be accessed by its name.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    modparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n    ...\n    sql_xquery(\"ca\", \"select * from domain\", \"ra\");\n    xlog(\"first domain: $xavp(ra=>domain) with id: $xavp(ra=>domain_id)\\n\");\n    ...\n    if (sql_xquery(\"ca\", \"select * from domain\", \"ra\") == 1) {\n        xlog(\"domain: $xavp(ra=>domain) with id: $xavp(ra=>domain_id)\\n\");\n    }\n    ..\n\n",
 "sql_pvquery": "### sql_pvquery(connection, query, result)\n\n module: sqlops\n\nMake an SQL query using 'connection' and store data in arbitrary pseudo\nvariables specified by 'result' parameter.\n\n- *connection* - the name of the connection to be used for query\n  (defined via the \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\n- *result* - a list with PV names where to store the result. The format\n  is \u201c\\$pv;\\$pv;...\u201d. Every PV that is writable may be used (for example\n  \\$var, \\$avp, \\$xavp, \\$ru, \\$du, \\$sht, etc).\n\n  The PV are assigned values in the following order: last row to first\n  row, first field to last field. Assignment has the same behavior as\n  assigning in the script itself with one exception for avp's, a NULL\n  value will not delete an avp, but will be skipped over.\n\n  Beware that if multiple rows are returned, non-(x)avp variables will\n  only hold the last added value, which corresponds to the first\n  returned row.\n\n  The value type of the PV (string or integer) will be derived from the\n  type of the columns. Please note that only these two datatypes are\n  supported, other datatypes will/may be converted to string.\n\nThis function can be used from ANY_ROUTE. Returns -1 on Error, 1 on\nsuccessful query, 2 if query provided no result set, 3 if result is\nignored (no result parameter given)\n\n    ...\n    modparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n    ...\n    sql_pvquery(\"ca\", \"select 'col1', 2, NULL, 'sip:test@example.com'\",\n        \"$var(a), $avp(col2), $xavp(item[0]=>s), $ru\");\n    ...\n\n",
 "sql_result_free": "### sql_result_free(result)\n\n module: sqlops\n\nFree data in SQL 'result'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    modparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n    ...\n    sql_query(\"ca\", \"select * from domain\", \"ra\");\n    xlog(\"number of rows in table domain: $dbr(ra=>rows)\\n\");\n    ...\n    sql_result_free(\"ra\");\n    ...\n\n",
 "sql_query_async": "### sql_query_async(connection, query)\n\n module: sqlops\n\nMake an async SQL query using 'connection', if implemented by db driver\nmodule (e.g., db_mysql). The query is executed in another process and\nresult is not available back to config, thus it should be used only for\nsql statements that don't return values (e.g., insert, delete,\nupdate...). Note that async_workers core parameter must be set in order\nto enable the asynchronous framework needed by this function.\n\n- *connection* - the name of the connection to be used for the query\n  (defined via \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    modparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n    ...\n    sql_query_async(\"ca\", \"delete from domain\");\n    ...\n\n",
 "sdp_remove_codecs_by_id": "### sdp_remove_codecs_by_id(list [, mtype])\n\n module: sdpops\n\nRemove the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one item or a\ncomma separated list of numeric codec IDs. The parameter can be a static\nstring or a variable holding the list of numeric codec IDs.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # remove PCMU\n    sdp_remove_codecs_by_id(\"0\");\n    # remove PCMU, PCMA and GSM\n    sdp_remove_codecs_by_id(\"0,8,3\");\n    sdp_remove_codecs_by_id(\"17\", \"audio\");\n    sdp_remove_codecs_by_id(\"23\", \"video\");\n    ...\n\n",
 "sdp_remove_codecs_by_name": "### sdp_remove_codecs_by_name(list [, mtype])\n\n module: sdpops\n\nRemove the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one item or a\ncomma separated list of codec names. The parameter can be a static\nstring or a variable holding the list of codec names.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # remove PCMU\n    sdp_remove_codecs_by_name(\"PCMU\");\n    # remove PCMU, PCMA and GSM\n    sdp_remove_codecs_by_name(\"PCMU,PCMA,GSM\");\n    ...\n\n",
 "sdp_remove_line_by_prefix": "### sdp_remove_line_by_prefix(string [, mtype])\n\n module: sdpops\n\nRemove all SDP attribute lines beginning with 'string' in all media\nstreams.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if ($si == \"2001:DB8::8:800:200C:417A\"\n            and ( has_body(\"application/sdp\") or has_body(\"multipart/mixed\")))\n    {\n        xlog(\"L_INFO\", \"Cleaning ugly SDP from $si\\n\");\n        sdp_remove_codecs_by_name(\"X-NSE\");\n        sdp_remove_line_by_prefix(\"a=X-\");\n    }\n\n    ...\n\n",
 "sdp_keep_codecs_by_id": "### sdp_keep_codecs_by_id(list [, mtype])\n\n module: sdpops\n\nKeep only the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one item or a\ncomma separated list of numeric codec IDs. The parameter can be a static\nstring or a variable holding the list of numeric codec IDs.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # keep only PCMU\n    sdp_keep_codecs_by_id(\"0\");\n    # keep PCMU, PCMA and GSM in audio stream\n    sdp_keep_codecs_by_id(\"0,8,3\", \"audio\");\n    ...\n\n",
 "sdp_keep_codecs_by_name": "### sdp_keep_codecs_by_name(list [, mtype])\n\n module: sdpops\n\nKeep only the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one or a\ncomma separated list of codec names. The parameter can be a static\nstring or a variable holding the list of codec names.\n\nNote that you have to explicitly keep 'telephone-event' in the list of\nnames if you want to keep DTMF attributes.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # keep only PCMU\n    sdp_keep_codecs_by_name(\"PCMU\");\n    # keep PCMU, PCMA and GSM\n    sdp_keep_codecs_by_name(\"PCMU,PCMA,GSM\");\n    ...\n\n",
 "sdp_with_media": "### sdp_with_media(type)\n\n module: sdpops\n\nReturn true if the SDP has 'media=type ...' line. Useful to check the\ncontent of the RTP sessions, such as 'audio' or 'video'. The parameter\ncan be static string or variable holding the media type.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # check for video stream\n    if(sdp_with_media(\"video\"))\n    {\n        # the session has a video stream\n    }\n    ...\n\n",
 "sdp_with_active_media": "### sdp_with_active_media(type)\n\n module: sdpops\n\nReturn true if the SDP has 'media=type ...' line and the media is\nactive. Useful to check the content of the RTP sessions, such as 'audio'\nor 'video'. Active media means the port is non-zero and the direction is\nnot \"inactive\" The parameter can be static string or variable holding\nthe media type.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # check for active video stream\n    if(sdp_with_active_media(\"video\"))\n    {\n        # the session has an active video stream\n    }\n    ...\n\n",
 "sdp_remove_media": "### sdp_remove_media(type)\n\n module: sdpops\n\nRemove the streams that match on 'm=type ...' line. The parameter can be\nstatic string or variable holding the media type.\n\nNote: If this is executed on a request, the callee should reply without\nthe Media too. However, RFC 3264 mandates, that the reply should contain\nthe exact same number of \"m=\" lines as the request.\n\n> 6 Generating the Answer\n>\n> \\[...\\]\n>\n> For each \"m=\" line in the offer, there MUST be a corresponding \"m=\"\n> line in the answer. The answer MUST contain exactly the same number of\n> \"m=\" lines as the offer. This allows for streams to be matched up\n> based on their order. This implies that if the offer contained zero\n> \"m=\" lines, the answer MUST contain zero \"m=\" lines.\n>\n> \u2014 RFC 3264\n\nSo this may not work with all Endpoints, especially if they follow RFC\n3264 precisely (e.g. JSSIP).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # remove video stream\n    sdp_remove_media(\"video\");\n    ...\n\n",
 "sdp_with_transport": "### sdp_with_transport(type)\n\n module: sdpops\n\nReturn true if the SDP has 'media=media port type ...' line. Useful to\ncheck the transport of the RTP sessions, such as 'RTP/AVP', 'RTP/SAVP',\n'RTP/SAVPF' or 'UDP/TLS/RTP/SAVPF'. The parameter can be static string\nor variable holding the transport type. The function does an exact match\nof the strings.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # check for RTP/SAVP stream\n    if(sdp_with_transport(\"UDP/TLS/RTP/SAVPF\"))\n    {\n        # the session has a UDP/TLS/RTP/SAVPF stream\n    }\n    ...\n\n",
 "sdp_with_transport_like": "### sdp_with_transport_like(type)\n\n module: sdpops\n\nReturns true if the SDP has 'media=media port type ...' line, where type\ncontains the string in the parameter. The parameter can be static string\nor variable holding a string.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # check for SAVPF stream\n    if(sdp_with_transport_like(\"SAVPF\"))\n    {\n        # the session has a SAVPF stream, e.g., RTP/SAVPF or UDP/TLS/RTP/SAVPF\n    }\n    ...\n\n",
 "sdp_transport": "### sdp_transport(pv)\n\n module: sdpops\n\nAssigns common media transport (if any) of 'm' lines to pv argument.\nReturns 1 if common media transport was found, -2 if there was no common\nmedia transport, and -1 in case of error.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sdp_transport(\"$avp(caller_rtp_transport)\");\n    ...\n\n",
 "sdp_remove_transport": "### sdp_remove_transport(type)\n\n module: sdpops\n\nRemove the streams that match on 'm=media port type ...' line. The\nparameter can be static string or variable holding the transport type.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # remove stream with transport RTP/AVP\n    sdp_remove_transport(\"RTP/AVP\");\n    ...\n\n",
 "sdp_with_codecs_by_id": "### sdp_with_codecs_by_id(list)\n\n module: sdpops\n\nReturns true if any of the codecs provided in the parameter 'list' from\nall media streams is found in SDP payload. The parameter 'list' must be\none or a comma separated list of numeric codec IDs. The parameter can be\na static string or a variable holding the list of numeric codec IDs.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # test for PCMU\n    if(sdp_with_codecs_by_id(\"0\")) { ... }\n    # test for PCMU, PCMA or GSM\n    if(sdp_with_codecs_by_id(\"0,8,3\")) { ... }\n    ...\n\n",
 "sdp_with_codecs_by_name": "### sdp_with_codecs_by_name(list)\n\n module: sdpops\n\nReturns true if any of the codecs provided in the parameter 'list' from\nall media streams is found in SDP payload. The parameter 'list' must be\none item or a comma separated list of codec names. The parameter can be\na static string or a variable holding the list of codec names.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # test for PCMU\n    if(sdp_with_codecs_by_name(\"PCMU\")) { ... }\n    # test for PCMU, PCMA or GSM\n    if(sdp_with_codecs_by_name(\"PCMU,PCMA,GSM\")) { ... }\n    ...\n\n",
 "sdp_print": "### sdp_print(level)\n\n module: sdpops\n\nPrint the SDP internal structure to log 'level'. The parameter can be\nstatic integer or variable holding the integer value of the log level.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # print the SDP\n    sdp_print(\"1\");\n    ...\n\n",
 "sdp_get": "### sdp_get(avpvar)\n\n module: sdpops\n\nStore the SDP part of message body in an AVP. Return 1 if SDP is found,\n-1 on error and -2 if there is no SDP part in the message body.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sdp_get(\"$avp(sdp)\");\n    ...\n\n",
 "sdp_content": "### sdp_content([sloppy])\n\n module: sdpops\n\nReturn true if the SIP message has SDP body or a SDP part in body. If an\nargument is given, the function does not parse message body, but returns\ntrue if Content-Type is \"application/sdp\" or if that string exists in\n\"multipart/mixed\" body.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(sdp_content()) {\n        ...\n    }\n    ...\n\n",
 "sdp_with_ice": "### sdp_with_ice()\n\n module: sdpops\n\nReturn true if the SIP message has SDP body that contains ICE candidate\nattribute(s).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(sdp_with_ice()) {\n        ...\n    }\n    ...\n\n",
 "sdp_get_line_startswith": "### sdp_get_line_startswith(avpvar, string)\n\n module: sdpops\n\nStore the search part of SDP body message with line beginning with\n'string' in an AVP. Return 1 if 'string' is found in SDP, -1 on error\nand -2 if there is no SDP part in the message body. The second parameter\ncan contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(sdp_get_line_startswith(\"$avp(mline)\", \"m=\")) {\n        xlog(\"m-line: $avp(mline)\\n\");\n    }\n    ...\n\n",
 "sdp_get_address_family": "### sdp_get_address_family()\n\n module: sdpops\n\nIt helps to get IP address family at c line from sdp body. It returns -1\non error, 4 for IP4 and 6 for IP6\n\n    ...\n    if(is_method(\"INVITE\") && has_body(\"application/sdp\")){\n        $avp(af) = sdp_get_address_family();\n        xlog(\"L_INFO\",\"ADDRESS FAMILY OF SDP C line $avp(af) \");\n    }\n    ...\n\n            \n\n",
 "crypto_aes_encrypt": "### crypto_aes_encrypt(text, key, res)\n\n module: crypto\n\nEncrypts the text with the key using AES encryption algorithm. The\nresult is encoded in base64 format and stored in res. The parameter res\nmust be a read-write variables. The parameters text and key can be\nstatic strings or strings with variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    crypto_aes_encrypt(\"$rb\", \"my-secret-key\", \"$var(encrypted)\");\n    ...\n\n",
 "crypto_aes_decrypt": "### crypto_aes_decrypt(text, key, res)\n\n module: crypto\n\nDecrypts the text with the key using AES encryption algorithm. The text\nhas to be encoded in base64 format. The parameter res must be a\nread-write variables. The parameters text and key can be static strings\nor strings with variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    crypto_aes_decrypt(\"$var(encrypted)\", \"my-secret-key\", \"$var(text)\");\n    ...\n\n",
 "crypto_hmac_sha256": "### crypto_hmac_sha256(text, key, res)\n\n module: crypto\n\nCalculates HMAC (keyed-hash message authentication code) with SHA256 as\na cryptographic hash function. The result is encoded in base64 url\nencoded format and stored in res. The parameter res must be a read-write\nvariable. The parameters text and key can be static strings or strings\nwith variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    crypto_hmac_sha256(\"$var(text)\", \"my-secret-key\", \"$var(hmac)\");\n    ...\n\n",
 "crypto_netio_out": "### crypto_netio_out()\n\n module: crypto\n\nReturn 1 (true) if it is an outgoing net message, or -1 (false)\notherwise.\n\nThis function can be used from EVENT_ROUTE.\n\n    ...\n    event_route[crypto:netio] {\n      if(crypto_netio_out()) {\n        crypto_netio_encrypt();\n      }\n    ...\n\n",
 "crypto_netio_encrypt": "### crypto_netio_encrypt()\n\n module: crypto\n\nMark the network message for encryption.\n\nThis function can be used from EVENT_ROUTE.\n\n    ...\n    event_route[crypto:netio] {\n      if(crypto_netio_out()) {\n        crypto_netio_encrypt();\n      }\n    ...\n\n",
 "crypto_netio_decrypt": "### crypto_netio_decrypt()\n\n module: crypto\n\nMark the network message for decryption.\n\nThis function can be used from EVENT_ROUTE.\n\n    ...\n    event_route[crypto:netio] {\n      if(crypto_netio_in()) {\n        crypto_netio_decrypt();\n      }\n    ...\n\n",
 "mongodb_cmd": "### mongodb_cmd(srvname, dbname, cname, command, replyid)\n\n module: ndb_mongodb\n\nSend a valid command to MongoDB server identified by srvname. The reply\nwill be stored in a local container identified by replyid. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThe reply can be accessed via pseudo-variable \\$mongodb(key). The key\ncan be: type - type of the reply; value - the value in JSON format\nreturned by MongoDB server; info - in case of error from MongoDB, it\nwill contain an info message.\n\nThe result can contain many documents, see mongodb_next() function for\nmore details.\n\nMeaning of the parameters:\n\n- *srvname* - MongoDB server name as given via 'server' parameter.\n\n- *dbname* - MongoDB database name.\n\n- *cname* - MongodDB collection (table) name.\n\n- *command* - valid MongoDB command given as JSON string.\n\n- *replyid* - the name of the container to store the response.\n\nThe function can be used from ANY_ROUTE.\n\n    ...\n    if(mongodb_cmd(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"collStats\\\": \\\"acc\\\" }\", \"mgr1\")) {\n        xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    }\n    ...\n\n",
 "mongodb_cmd_simple": "### mongodb_cmd_simple(srvname, dbname, cname, command, replyid)\n\n module: ndb_mongodb\n\nSend a valid command to MongoDB server identified by srvname. The reply\nwill be stored in a local container identified by replyid. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThe reply can be accessed via pseudo-variable \\$mongodb(key). The key\ncan be: type - type of the reply; value - the value in JSON format\nreturned by MongoDB server; info - in case of error from MongoDB, it\nwill contain an info message.\n\nThis function should be used when the response has only one document.\n\nSee mongodb_cmd() for the meaning of the parameters.\n\nThe function can be used from ANY_ROUTE.\n\n    ...\n    if(mongodb_cmd_simple(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"collStats\\\": \\\"acc\\\" }\", \"mgr1\")) {\n        xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    }\n    ...\n\n",
 "mongodb_find": "### mongodb_find(srvname, dbname, cname, command, replyid)\n\n module: ndb_mongodb\n\nSend a find command to MongoDB server identified by srvname. The reply\nwill be stored in a local container identified by replyid. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThe reply can be accessed via pseudo-variable \\$mongodb(key). The key\ncan be: type - type of the reply; value - the value in JSON format\nreturned by MongoDB server; info - in case of error from MongoDB, it\nwill contain an info message.\n\nThis function is useful for querying collections and accessing the\nresults.\n\nSee mongodb_cmd() for the meaning of the parameters, with the remark\nthat command has to be a valid filter JSON document, like for find()\ncommand in mongoc command line client tool.\n\nThe function can be used from ANY_ROUTE.\n\n    ...\n    if(mongodb_find(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"src_user\\\" : \\\"111\\\" }\", \"mgr1\")) {\n        xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    }\n    ...\n\n",
 "mongodb_find_one": "### mongodb_find_one(srvname, dbname, cname, command, replyid)\n\n module: ndb_mongodb\n\nSimilar to mongodb_find(...), but it stops searching after first match,\nreturning the result with one object - faster when expecting to have a\nsingle match. Parameters and behaviour are the same as for\nmongodb_find(...).\n\nThe function can be used from ANY_ROUTE.\n\n    ...\n    if(mongodb_find_one(\"mgs1\", \"kamailio\", \"subscriber\", \"{ \\\"username\\\" : \\\"111\\\" }\", \"mgr1\")) {\n        xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    }\n    ...\n\n",
 "mongodb_next": "### mongodb_next(replyid)\n\n module: ndb_mongodb\n\nMoves to next document in a MongoDB reply. This function can be used\nafter a successful mongodb_cmd() or mongodb_find(). It returns true if\nthere is a shift to document. The current document becomes available via\n\\$mongodb(key) variable.\n\n    ...\n    if(mongodb_find(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"src_user\\\" : \\\"111\\\" }\", \"mgr1\")) {\n        xlog(\"first response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n        while(mongodb_next(\"mgr1\") ){\n            xlog(\"next response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n        }\n    }\n    mongodb_free(\"mgr1\");\n    ...\n            \n\n",
 "mongodb_free": "### mongodb_free(replyid)\n\n module: ndb_mongodb\n\nFrees data in a previous reply from memory. After this function call,\naccessing to a freed replyid returns null value.\n\nIt is not really necessary to free a reply to use it again in a new\nmongodb_cmd function, being automatically freed on next command\nexecution, but for freeing used resources (e.g., memory), it is\nrecommended to do it.\n\n    ...\n    if(mongodb_cmd_simple(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"collStats\\\": \\\"acc\\\" }\", \"mgr1\")) {\n        xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    }\n    mongodb_free(\"mgr1\");\n    ...\n            \n",
 "set_deny_filter": "### set_deny_filter(filter, flags)\n\n module: uac_redirect\n\nSets additional deny filters. Maximum 6 may be combined. This additional\nfilter will apply only to the current message - it will not have a\nglobal effect.\n\nDefault or previous added deny filter may be reset depending of the\n*flag* parameter value:\n\n- *reset_all* - reset both default and previous added deny filters;\n\n- *reset_default* - reset only the default deny filter;\n\n- *reset_added* - reset only the previous added deny filters;\n\n- *empty* - no reset, just add the filter.\n\nThis function can be used from FAILURE_ROUTE.\n\n    ...\n    set_deny_filter(\".*@domain2.net\",\"reset_all\");\n    set_deny_filter(\".*@domain1.net\",\"\");\n    ...\n                    \n\n",
 "set_accept_filter": "### set_accept_filter(filter, flags)\n\n module: uac_redirect\n\nSets additional accept filters. Maximum 6 may be combined. This\nadditional filter will apply only to the current message - it will not\nhave a global effect.\n\nDefault or previous added deny filter may be reset depending of the\n*flag* parameter value:\n\n- *reset_all* - reset both default and previous added accept filters;\n\n- *reset_default* - reset only the default accept filter;\n\n- *reset_added* - reset only the previous added accept filters;\n\n- *empty* - no reset, just add the filter.\n\nThis function can be used from FAILURE_ROUTE.\n\n    ...\n    set_accept_filter(\".*@domain2.net\",\"reset_added\");\n    set_accept_filter(\".*@domain1.net\",\"\");\n    ...\n                    \n\n",
 "get_redirects": "### get_redirects(max)\n\n module: uac_redirect\n\nThe function may be called only from failure routes. It will extract the\ncontacts from all 3xx branches and append them as new branches. Note\nthat the function will not forward the new branches, this must be done\nexplicitly from script.\n\nHow many contacts (in total and per branch) are selected depends of the\n*max* parameter values. Its syntax is:\n\n- max = max_total \\[\":\" max_branch\\]\n\n- max_total = number of total contacts to be selected\n\n- max_branch = number of contacts per branch to be selected\n\nBoth \u201cmax_total\u201d and \u201cmax_branch\u201d are positive integer. To specify\nunlimited values, use 0 value or \"\\*\" character.\n\nNOTE that during the selection process, each set of contacts from a\nspecific branch are ordered based on \u201cq\u201d value.\n\nThis function will produce no accounting records.\n\nThis function can be used from FAILURE_ROUTE.\n\n    ...\n    # max 2 contacts per branch, but no overall limit\n    get_redirects(\"*:2\");\n    ...\n    # no limits per branch, but not more than 6 overall contacts\n    get_redirects(\"6:*\");\n    ...\n    # no restrictions\n    get_redirects(\"*\");\n    ...\n                    \n\n### get_redirects(max, reason)\n\n module: uac_redirect\n\nThe function has same functionality as `get_redirects(max)` function,\nbut it will produce accounting records.\n\nThe accounting records will be mark by the *reason* phrase.\n\nIf this function appears in the script, at startup, the module will\nimport the accounting function. Otherwise not.\n\nThis function can be used from FAILURE_ROUTE.\n\n    ...\n    get_redirects(\"4:1\",\"Redirected\");\n    ...\n                    \n\n",
 "call_control": "### call_control()\n\n module: call_control\n\nTrigger the use of callcontrol for the dialog started by the INVITE for\nwhich this function is called (the function should only be called for\nthe first INVITE of a call). Further in-dialog requests will be\nprocessed automatically using internal bindings into the dialog state\nmachine, allowing callcontrol to update its internal state as the dialog\nprogresses, without any other intervention from the script.\n\nThis function should be called right before the message is sent out\nusing t_relay(), when all the request uri modifications are over and a\nfinal destination has been determined.\n\nThis function has the following return codes:\n\n- +2 - call has no limit\n\n- +1 - call has limit and is traced by callcontrol\n\n- -1 - not enough credit to make the call\n\n- -2 - call is locked by another call in progress\n\n- -5 - internal error (message parsing, communication, ...)\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_avp_set(\"$avp(i:805)\")) {\n        # the diverter AVP is set, use it as billing party\n        $avp(s:billing_party_domain) = $(avp(i:805){uri.domain});\n    } else {\n        $avp(s:billing_party_domain) = $fd;\n    }\n\n    if (method==INVITE && !has_totag() &&\n        is_domain_local(\"$avp(s:billing_party_domain)\")) {\n        call_control();\n        switch ($retcode) {\n        case 2:\n            # Call with no limit\n        case 1:\n            # Call has limit and is under callcontrol management\n            break;\n        case -1:\n            # Not enough credit (prepaid call)\n            sl_send_reply(\"402\", \"Not enough credit\");\n            exit;\n            break;\n        case -2:\n            # Locked by another call in progress (prepaid call)\n            sl_send_reply(\"403\", \"Call locked by another call in progress\");\n            exit;\n            break;\n        default:\n            # Internal error (message parsing, communication, ...)\n            if (PREPAID_ACCOUNT) {\n                xlog(\"Call control: internal server error\\n\");\n                sl_send_reply(\"500\", \"Internal server error\");\n                exit;\n            } else {\n                xlog(\"L_WARN\", \"Cannot set time limit for postpaid call\\n\");\n            }\n        }\n    }\n    t_relay();\n    ...\n            \n",
 "log_udp": "### log_udp(text)\n\n module: log_custom\n\nSend the text to the address specified in core parameter\nlog_engine_data. It is provided as sample function mainly for testing,\nbecause all logs messages printed by kamailio should be diverted as\ndescribed in the section 'Core Logging', so you can use xlog functions\nin config file.\n\nThe parameter can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n       log_udp(\"R-URI is $ru\\n\");\n    ...\n",
 "set_gflag": "### set_gflag(flag)\n\n module: cfgutils\n\nSet the bit at the position \u201cflag\u201d in global flags.\n\n\u201cflag\u201d can have a value in the range of 0..31.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n    ...\n    set_gflag(\"4\");\n    ...\n\n",
 "reset_ugflag": "### reset_ugflag(flag_num)\n\n module: uid_gflags\n\nSet the flag identified by flag_num to 0. The range of flag_num is 0 to\n31.\n\n    ...\n    reset_ugflag(\"2\");\n    ...\n            \n\n",
 "is_ugflag": "### is_ugflag(flag_num)\n\n module: uid_gflags\n\nReturns 1 when flag identified by flag_num is set, 0 otherwise. The\nrange of flag_num parameter is 0 to 31.\n\n",
 "ws_handle_handshake": "### ws_handle_handshake()\n\n module: websocket\n\nThis function checks an HTTP GET request for the required headers and\nvalues, and (if successful) upgrades the connection from HTTP to\nWebSocket.\n\nThis function can be used from ANY_ROUTE (but will only work in\n*event_route\\[xhttp:request\\]*).\n\n<div class=\"note\">\n\nThis function returns 0, stopping all further processing of the request,\nwhen there is a problem. Otherwise, it returns 1 (or positive number) in\ncase of success.\n\n</div>\n\n    ...\n    ws_handle_handshake();\n    ...\n\n",
 "ws_close": "### ws_close([status, reason[, connection_id]])\n\n module: websocket\n\nThis function closes a WebSocket connection.\n\nThe function returns -1 if there is an error and 1 if it succeeds.\n\nThe meaning of the parameters is as follows:\n\n- *status* - an integer indicating the reason for closure.\n\n- *reason* - a string describing the reason for closure.\n\n- *connection_id* - the connection to close. If not specified the\n  connection the current message arrived on will be closed.\n\n<div class=\"note\">\n\n*status* and *reason* values SHOULD correspond to the definitions in\nsection 7.4 of RFC 6455. If these parameters are not used the defaults\nof \"1000\" and \"Normal closure\" will be used.\n\n</div>\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    ws_close(4000, \"Because I say so\");\n    ...\n\n",
 "http_connect": "### http_connect(connection, url, [content_type, data,] result)\n\n module: http_client\n\nSends HTTP GET or POST request to a given connection. For a POST\nrequest, content-type can be specified.\n\n- *connection* - the name of an existing HTTP connection, defined by a\n  httpcon modparam.\n\n  *url* - the part of the URL to add to the predefined URL in the\n  connection definition.\n\n  *content_type* - Used only when posting data with HTTP POST. An\n  Internet Media type, like \"application/json\" or \"text/plain\". Will be\n  added to the HTTP request as a header.\n\n  *data* - Data or a pseudo variable holding data to be posted. (may\n  contain pseudo variable)\n\n  *result* - The name of a pseudo variable that will have the data of\n  the response from the HTTP server.\n\nThe return value is the HTTP return code (if \\>=100) or the CURL error\ncode if below 100. See the \\$curlerror pseudovariable below for more\ninformation about CURL error codes.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n    ...\n    modparam(\"http_client\", \"httpcon\", \"apiserver=>https://kamailio.org/api/\");\n    ...\n    # POST Request\n    $var(res) = http_connect(\"apiserver\", \"/mailbox\", \"application/json\", \"{ ok, {200, ok}}\", \"$avp(gurka)\");\n    xlog(\"L_INFO\", \"API-server HTTP connection: $avp(gurka) Result code $var(res)\\n\");\n\n    $var(res) = http_connect(\"apiserver\", \"/callroute\", \"application/json\", \"$var(jsondata)\", \"$avp(route)\");\n    xlog(\"L_INFO\", \"API-server HTTP connection: $avp(route) Result code $var(res)\\n\");\n    ...\n                    \n\n",
 "http_connect_raw": "### http_connect_raw(connection, url, content_type, data, result)\n\n module: http_client\n\nSends HTTP POST request to a given connection. Similar to http_connect.\nThe only difference is that the data parameter will not be parsed for\npseudo variables, therefore it can safely be used for content that may\ncontain \"\\$\" character like JSON.\n\n- *connection* - the name of an existing HTTP connection, defined by a\n  httpcon modparam.\n\n  *url* - the part of the URL to add to the predefined URL in the\n  connection definition.\n\n  *content_type* - Used only when posting data with HTTP POST. An\n  Internet Media type, like \"application/json\" or \"text/plain\". Will be\n  added to the HTTP request as a header.\n\n  *data* - Data or a pseudo variable holding data to be posted. (will\n  not be parsed for pseudo variable)\n\n  *result* - The name of a pseudo variable that will have the data of\n  the response from the HTTP server.\n\nThe return value is the HTTP return code (if \\>=100) or the CURL error\ncode if below 100. See the \\$curlerror pseudovariable below for more\ninformation about CURL error codes.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n    ...\n    modparam(\"http_client\", \"httpcon\", \"apiserver=>https://kamailio.org/api/\");\n    ...\n    # POST Request\n    $var(res) = http_connect_raw(\"apiserver\", \"/mailbox\", \"application/json\", \"{ ok, {200, ok}}\", \"$avp(gurka)\");\n    xlog(\"L_INFO\", \"API-server HTTP connection: $avp(gurka) Result code $var(res)\\n\");\n\n    $var(res) = http_connect_war(\"apiserver\", \"/callroute\", \"application/json\", \"$var(jsondata)\", \"$avp(route)\");\n    xlog(\"L_INFO\", \"API-server HTTP connection: $avp(route) Result code $var(res)\\n\");\n    ...\n                    \n\n",
 "http_get_redirect": "### http_get_redirect(connection, result)\n\n module: http_client\n\nWhen a http connection gets a redirect and the connection is configured\nto follow redirects (301,302) then the target URL, the result of the\nredirects can be retrieved with this function after a successful\nconnection.\n\n- *connection* - the name of an existing HTTP connection, defined by a\n  httpcon modparam.\n\n  *result* - The name of a pseudo variable that will contain the last\n  used URL.\n\n<!-- -->\n\n    ...\n    modparam(\"http_client\", \"httpredirect\", 1);\n    ...\n    http_get_redirect(\"apiserver\", \"$var(targeturl)\");\n    ...\n                    \n\n",
 "http_client_query": "### http_client_query(url, [post-data], [hdrs], result)\n\n module: http_client\n\nSends HTTP GET or POST request according to URL given in \u201curl\u201d\nparameter, which is a string that may contain pseudo variables.\n\nIf you want to make a POST-Request, you have to define the \u201cpost\u201d-data,\nthat should be submitted in that request as the second parameter.\n\nCustom headers may be specified via \u201chdrs\u201d parameter (e.g.,\nContent-Type).\n\nEither of \u201cpost-data\u201d or \u201chdrs\u201d can be also set to empty string in order\nto be ignored.\n\nIf HTTP server returns a class 2xx, 3xx or 4xx reply, the first line or\nthe entire reply body (if any) is stored in \u201cresult\u201d parameter, which\nmust be a writable pseudo variable. See the query_result parameter for\ncontrolling what value to be stored in the result variable.\n\nFunction returns reply code of HTTP reply or -1 if something went wrong.\n\nThis function can be used from ANY_ROUTE.\n\nNote that this function is based on the http_query function in the utils\nmodule. It is changed to use the same base library and settings as the\nrest of the functions in this module.\n\n    ...\n    # GET-Request\n    http_client_query(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n           \"$var(result)\");\n    switch ($rc) {\n        ...\n    }\n    ...\n    # POST-Request\n    http_client_query(\"http://api.com/index.php\",\n        \"r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n        \"$var(result)\");\n    }\n    ...\n    # POST-Request\n    http_client_query(\"http://api.com/index.php\", \"src=$si\",\n        \"Content-Type: text/plain\", \"$var(result)\");\n    ...\n                    \n\n",
 "http_client_get": "### http_client_get(url, body, hdrs, respv)\n\n module: http_client\n\nPerform a HTTP GET request to \"url\", storing the response body in the\n\"respv\" variable. The \"body\" and \"hdrs\" can be empty strings to skip\nsetting them. The first three parameters can contain variables that are\nevaluated at runtime. The \"respv\" has to be the name of a writable\nvariable.\n\nNote: usually HTTP GET requests should have no body, according to specs\nthe body in HTTP GET does not affect the response, but is not\nexplicitely forbidden.\n\n    ...\n    http_client_get(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n           \"\", \"X-Token: abc\", \"$var(result)\");\n    switch ($rc) {\n        ...\n    }\n    ...\n                    \n\n",
 "set_rtp_proxy_set": "### set_rtp_proxy_set(setid)\n\n module: rtpproxy\n\nSets the Id of the rtpproxy set to be used for the next\nunforce_rtp_proxy(), rtpproxy_offer(), rtpproxy_answer() or\nrtpproxy_manage() command. The parameter can be an integer or a config\nvariable holding an integer.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    set_rtp_proxy_set(\"2\");\n    rtpproxy_offer();\n    ...\n\n",
 "rtpproxy_offer": "### rtpproxy_offer([flags [, ip_address]])\n\n module: rtpproxy\n\nRewrites SDP body to ensure that media is passed through an RTP proxy.\nTo be invoked on INVITE for the cases the SDPs are in INVITE and 200 OK\nand on 200 OK when SDPs are in 200 OK and ACK.\n\nMeaning of the parameters is as follows:\n\n- *flags* - flags to turn on some features.\n\n  - *1* - append first Via branch to Call-ID when sending command to\n    rtpproxy. This can be used to create one media session per branch on\n    the rtpproxy. When sending a subsequent \u201cdelete\u201d command to the\n    rtpproxy, you can then stop just the session for a specific branch\n    when passing the flag '1' or '2' in the \u201cunforce_rtpproxy\u201d, or stop\n    all sessions for a call when not passing one of those two flags\n    there. This is especially useful if you have serially forked call\n    scenarios where rtpproxy gets an \u201cupdate\u201d command for a new branch,\n    and then a \u201cdelete\u201d command for the previous branch, which would\n    otherwise delete the full call, breaking the subsequent \u201clookup\u201d for\n    the new branch. *This flag is only supported by the\n    ngcp-mediaproxy-ng rtpproxy (now named rtpengine) at the moment!*\n\n  - *2* - append second Via branch to Call-ID when sending command to\n    rtpproxy. See flag '1' for its meaning.\n\n  - *3* - behave like flag 1 is set for a request and like flag 2 is set\n    for a reply.\n\n  - *a* - flags that UA from which message is received doesn't support\n    symmetric RTP. (automatically sets the 'r' flag)\n\n  - *b* - append branch specific variable to Call-ID when sending\n    command to rtpproxy. This creates one rtpproxy session per unique\n    variable. Works similar to the 1, 2 and 3 parameter, but is useful\n    when forking to multiple destinations on different address families\n    or network segments, requiring different rtpproxy parameters. The\n    variable value is taken from the \u201cextra_id_pv\u201d. When used, it must\n    be used in every call to rtpproxy_manage(), rtpproxy_offer(),\n    rtpproxy_answer() and rtpproxy_destroy() with the same contents of\n    the PV. The b parameter may not be used in conjunction with the 1, 2\n    or 3 parameter to use the Via branch in the Call-ID.\n\n  - *l* - force \u201clookup\u201d, that is, only rewrite SDP when corresponding\n    session already exists in the RTP proxy. By default is on when the\n    session is to be completed.\n\n  - *i, e* - these flags specify the direction of the SIP message. These\n    flags only make sense when rtpproxy is running in bridge mode. 'i'\n    means internal network (LAN), 'e' means external network (WAN). 'i'\n    corresponds to rtpproxy's first interface, 'e' corresponds to\n    rtpproxy's second interface. You always have to specify two flags to\n    define the incoming network and the outgoing network. For example,\n    'ie' should be used for SIP message received from the local\n    interface and sent out on the external interface, and 'ei' vice\n    versa. Other options are 'ii' and 'ee'. So, for example if a SIP\n    requests is processed with 'ie' flags, the corresponding response\n    must be processed with 'ie' flags.\n\n    Note: As rtpproxy in bridge mode is asymmetric per default, you have\n    to specify the 'w' flag for clients behind NAT! See also above\n    notes!\n\n  - *x* - this flag a shortcut for using the \"ie\" or \"ei\"-flags of\n    RTP-Proxy, in order to do automatic bridging between IPv4 on the\n    \"internal network\" and IPv6 on the \"external network\". The\n    distinction is done by the given IP in the SDP, e.g. an IPv4 Address\n    will always call \"ie\" to the RTPProxy (IPv4(i) to IPv6(e)) and an\n    IPv6Address will always call \"ei\" to the RTPProxy (IPv6(e) to\n    IPv4(i)).\n\n    Note: Please note, that this will only work properly with\n    non-dual-stack user-agents or with dual-stack clients according to\n    RFC6157 (which suggest ICE for Dual-Stack implementations). This\n    short-cut will not work properly with RFC4091 (ANAT) compatible\n    clients, which suggests having different m-lines with different\n    IP-protocols grouped together.\n\n  - *f* - instructs rtpproxy to ignore marks inserted by another\n    rtpproxy in transit to indicate that the session is already goes\n    through another proxy. Allows creating a chain of proxies.\n\n  - *r* - flags that IP address in SDP should be trusted. Without this\n    flag, rtpproxy ignores address in the SDP and uses source address of\n    the SIP message as media address which is passed to the RTP proxy.\n\n  - *o* - flags that IP from the origin description (o=) should be also\n    changed.\n\n  - *c* - flags to change the session-level SDP connection (c=) IP if\n    media-description also includes connection information.\n\n  - *w* - flags that for the UA from which message is received, support\n    symmetric RTP must be forced.\n\n  - *zNN* - requests the RTPproxy to perform re-packetization of RTP\n    traffic coming from the UA which has sent the current message to\n    increase or decrease payload size per each RTP packet forwarded if\n    possible. The NN is the target payload size in ms, for the most\n    codecs its value should be in 10ms increments, however for some\n    codecs the increment could differ (e.g. 30ms for GSM or 20ms for\n    G.723). The RTPproxy would select the closest value supported by the\n    codec. This feature could be used for significantly reducing\n    bandwidth overhead for low bitrate codecs, for example with G.729\n    going from 10ms to 100ms saves two thirds of the network bandwidth.\n\n- *ip_address* - new SDP IP address.\n\nThis function can be used from ANY_ROUTE.\n\n    route {\n    ...\n        if (is_method(\"INVITE\")) {\n            if (has_body(\"application/sdp\")) {\n                if (rtpproxy_offer())\n                    t_on_reply(\"1\");\n            } else {\n                t_on_reply(\"2\");\n            }\n        }\n        if (is_method(\"ACK\") && has_body(\"application/sdp\"))\n            rtpproxy_answer();\n    ...\n    }\n\n    onreply_route[1]\n    {\n    ...\n        if (has_body(\"application/sdp\"))\n            rtpproxy_answer();\n    ...\n    }\n\n    onreply_route[2]\n    {\n    ...\n        if (has_body(\"application/sdp\"))\n            rtpproxy_offer();\n    ...\n    }\n\n",
 "rtpproxy_answer": "### rtpproxy_answer([flags [, ip_address]])\n\n module: rtpproxy\n\nRewrites SDP body to ensure that media is passed through an RTP proxy.\nTo be invoked on 200 OK for the cases the SDPs are in INVITE and 200 OK\nand on ACK when SDPs are in 200 OK and ACK.\n\nSee rtpproxy_answer() function description above for the meaning of the\nparameters.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\nSee rtpproxy_offer() function example above for example.\n\n",
 "rtpproxy_destroy": "### rtpproxy_destroy([flags])\n\n module: rtpproxy\n\nTears down the RTPProxy session for the current call.\n\nThis function can be used from ANY_ROUTE.\n\nMeaning of the parameters is as follows:\n\n- *flags* - flags to turn on some features.\n\n  - *1* - append first Via branch to Call-ID when sending command to\n    rtpproxy. This can be used to create one media session per branch on\n    the rtpproxy. When sending a subsequent \u201cdelete\u201d command to the\n    rtpproxy, you can then stop just the session for a specific branch\n    when passing the flag '1' or '2' in the \u201cunforce_rtpproxy\u201d, or stop\n    all sessions for a call when not passing one of those two flags\n    there. This is especially useful if you have serially forked call\n    scenarios where rtpproxy gets an \u201cupdate\u201d command for a new branch,\n    and then a \u201cdelete\u201d command for the previous branch, which would\n    otherwise delete the full call, breaking the subsequent \u201clookup\u201d for\n    the new branch. *This flag is only supported by the\n    ngcp-mediaproxy-ng rtpproxy (now named rtpengine) at the moment!*\n\n  - *2* - append second Via branch to Call-ID when sending command to\n    rtpproxy. See flag '1' for its meaning.\n\n  - *b* - append branch specific variable to Call-ID when sending\n    command to rtpproxy. See rtpproxy_offer() for details.\n\n  - *t* - do not include To tag to \u201cdelete\u201d command to rtpproxy thus\n    causing full call to be deleted. Useful for deleting unused rtpproxy\n    call when 200 OK is received on a branch, where rtpproxy is not\n    needed.\n\n<!-- -->\n\n    ...\n    rtpproxy_destroy();\n    ...\n\n",
 "unforce_rtp_proxy": "### unforce_rtp_proxy()\n\n module: rtpproxy\n\nSame as rtpproxy_destroy().\n\n",
 "rtpproxy_manage": "### rtpproxy_manage([flags [, ip_address]])\n\n module: rtpproxy\n\nManage the RTPProxy session - it combines the functionality of\nrtpproxy_offer(), rtpproxy_answer() and unforce_rtpproxy(), detecting\ninternally based on message type and method which one to execute.\n\nIt can take the same parameters as `rtpproxy_offer()`. The flags\nparameter to rtpproxy_manage() can be a configuration variable\ncontaining the flags as a string.\n\nFunctionality:\n\n- If INVITE with SDP, then do `rtpproxy_offer()`\n\n- If INVITE with SDP, when the tm module is loaded, mark transaction\n  with internal flag FL_SDP_BODY to know that the 1xx and 2xx are for\n  `rtpproxy_answer()`\n\n- If ACK with SDP, then do `rtpproxy_answer()`\n\n- If BYE or CANCEL, or called within a FAILURE_ROUTE\\[\\], then call\n  `unforce_rtpproxy()`. Be careful with calling this function after\n  resuming a suspended transaction (e.g., after t_continue()), because\n  the context of executed route is FAILURE ROUTE (in other words,\n  rtpproxy_manage() in the route block of t_continue() does the same as\n  in failure_route; use a branch route to engage rtpengine for a\n  forwarded branch after resuming the transaction).\n\n- It does nothing if used inside event_route\\[tm:branch-failure:...\\]\n\n- If reply to INVITE with code \\>= 300 do `unforce_rtpproxy()`\n\n- If reply with SDP to INVITE having code 1xx and 2xx, then do\n  `rtpproxy_answer()` if the request had SDP or tm is not loaded,\n  otherwise do `rtpproxy_offer()`\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    rtpproxy_manage();\n    ...\n\n",
 "rtpproxy_stream2uac": "### rtpproxy_stream2uac(prompt_name, count),\n\n module: rtpproxy\n\nInstruct the RTPproxy to stream prompt/announcement pre-encoded with the\nmakeann command from the RTPproxy distribution. The uac/uas suffix\nselects who will hear the announcement relatively to the current\ntransaction - UAC or UAS. For example invoking the `rtpproxy_stream2uac`\nin the request processing block on ACK transaction will play the prompt\nto the UA that has generated original INVITE and ACK while\n`rtpproxy_stop_stream2uas` on 183 in reply processing block will play\nthe prompt to the UA that has generated 183.\n\nApart from generating announcements, another possible application of\nthis function is implementing music on hold (MOH) functionality. When\ncount is -1, the streaming will be in loop indefinitely until the\nappropriate `rtpproxy_stop_stream2xxx` is issued.\n\nIn order to work correctly, these functions require that a session in\nthe RTPproxy already exists. Also those functions don't alter the SDP,\nso that they are not a substitute for calling `rtpproxy_offer` or\n`rtpproxy_answer`.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\nMeaning of the parameters is as follows:\n\n- *prompt_name* - name of the prompt to stream. Should be either\n  absolute pathname or pathname relative to the directory where RTPproxy\n  runs.\n\n- *count* - number of times the prompt should be repeated. A value of -1\n  means that it will be streaming in a loop indefinitely, until the\n  appropriate `rtpproxy_stop_stream2xxx` is issued.\n\n<!-- -->\n\n    ...\n        if (is_method(\"INVITE\")) {\n            rtpproxy_offer();\n            if (is_audio_on_hold()) {\n                rtpproxy_stream2uas(\"/var/rtpproxy/prompts/music_on_hold\", \"-1\");\n            } else {\n                rtpproxy_stop_stream2uas();\n            };\n        };\n    ...\n            \n\n",
 "rtpproxy_stream2uas": "### rtpproxy_stream2uas(prompt_name, count)\n\n module: rtpproxy\n\nSee function `rtpproxy_stream2uac(prompt_name, count)`.\n\n",
 "rtpproxy_stop_stream2uac": "### rtpproxy_stop_stream2uac(),\n\n module: rtpproxy\n\nStop streaming of announcement/prompt/MOH started previously by the\nrespective `rtpproxy_stream2xxx`. The uac/uas suffix selects whose\nannouncement relatively to tha current transaction should be stopped -\nUAC or UAS.\n\nThese functions can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n",
 "rtpproxy_stop_stream2uas": "### rtpproxy_stop_stream2uas()\n\n module: rtpproxy\n\nSee function `rtpproxy_stop_stream2uac()`.\n\n    ...\n        if (is_method(\"INVITE\")) {\n            rtpproxy_offer();\n            if (is_audio_on_hold()) {\n                rtpproxy_stream2uas(\"/var/rtpproxy/prompts/music_on_hold\", \"-1\");\n            } else {\n                rtpproxy_stop_stream2uas();\n            };\n        };\n    ...\n            \n\n",
 "start_recording": "### start_recording([flags])\n\n module: rtpengine\n\nThis function will send a signal to the RTP relay to record the RTP\nstream flowing through it. See also the option \u201crecord-call=on\u201d for\nrtpengine_manage()/rtpengine_offer(), which offers an alternative for\ncall recording, saving also call metadata from SDP.\n\nIt can take the same parameters as `rtpengine_manage()`. The flags\nparameter to start_recording can be a configuration variable containing\nthe flags as a string. The call-id flag can be used to start recording\nfor a different call.\n\nThis function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    start_recording();\n    ...\n            \n\n",
 "sr_msg_push": "### sr_msg_push(msgid)\n\n module: siprepo\n\nPush the message content to hash table and associate it with \\`msgid\\`.\nThe Call-Id and msgid are needed to pull the message.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        $var(msgid) = $sruid;\n        if(sr_msg_push(\"$var(msgid)\")) {\n        }\n        ...\n    }\n    ...\n\n",
 "sr_msg_pull": "### sr_msg_pull(callid, msgid, rname)\n\n module: siprepo\n\nPull the message content and execute the route block 'rname'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(sr_msg_pull(\"$var(callid)\", \"$var(msgid)\", \"REPOPULL\")) {\n        }\n        ...\n    }\n    ...\n\n",
 "sr_msg_async_pull": "### sr_msg_async_pull(callid, msgid, gname, rname)\n\n module: siprepo\n\nPull the message content and execute the route block 'rname' via async\ngroup 'gname'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(sr_msg_async_pull(\"$var(callid)\", \"$var(msgid)\", \"WG01\", \"REPOPULL\")) {\n        }\n        ...\n    }\n    ...\n\n",
 "sr_msg_rm": "### sr_msg_rm(callid, msgid)\n\n module: siprepo\n\nRemove the message content.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(sr_msg_rm(\"$var(callid)\", \"$var(msgid)\")) {\n        }\n        ...\n    }\n    ...\n\n",
 "sr_msg_check": "### sr_msg_check()\n\n module: siprepo\n\nCheck if the message is stored.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(sr_msg_check()) {\n        }\n        ...\n    }\n    ...\n",
 "www_authenticate": "### www_authenticate(realm, table [, method])\n\n module: auth_db\n\nName alias: www_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nNegative codes may be interpreted as follows:\n\n- *-1 (generic error)* - Bad credentials , couldn't parse credentials ,\n  no memory left , couldn't fetch from table , couldn't get realm or\n  some generic error occurred and no reply was sent out;\n\n- *-2 (invalid password)* - wrong password;\n\n- *-3 (invalid user)* - authentication user does not exist.\n\n- *-4 (nonce expired)* - the nonce has expired\n\n- *-5 (no credentials)* - request does not contain an Authorization\n  header with the correct realm.\n\n- *-6 (nonce reused)* - the nonce has already been used to authenticate\n  a previous request\n\n- *-8 (authuser mismatch)* - depending on the method, the From/To/RURI\n  user does not match the authentication user (see auth_check()\n  function).\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests To header\n  field domain (e.g., variable \\$td) can be used (because this header\n  field represents the user being registered), for all other messages\n  From header field domain can be used (e.g., variable \\$fd).\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\n- *method* - the method to be used for authentication. This parameter is\n  optional and if not set is the first \"word\" on the request-line.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!www_authorize(\"kamailio.org\", \"subscriber\")) {\n        www_challenge(\"kamailio.org\", \"1\");\n    };\n    ...\n\n",
 "www_authorize": "### www_authorize(realm, table)\n\n module: uid_auth_db\n\nThe function verifies credentials according to RFC2617. If the\ncredentials are verified successfully then the function will succeed and\nmark the credentials as authorized (marked credentials can be later used\nby some other functions). If the function was unable to verify the\ncredentials for some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nMeaning of the parameters is as follows:\n\n- <div class=\"formalpara-title\">\n\n  **realm**\n\n  </div>\n\n  Realm is a opaque string that the user agent should present to the\n  user so he can decide what username and password to use. Usually this\n  is domain of the host the server is running on. If an empty string \"\"\n  is used then the server will generate it from the request. In case of\n  REGISTER requests To header field domain will be used (because this\n  header field represents a user being registered), for all other\n  messages From header field domain will be used.\n\n- <div class=\"formalpara-title\">\n\n  **table**\n\n  </div>\n\n  Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\n<!-- -->\n\n    ...\n    if (www_authorize(\"iptel.org\", \"subscriber\")) {\n        www_challenge(\"iptel.org\", \"1\");\n    };\n    ...\n            \n\n",
 "proxy_authenticate": "### proxy_authenticate(realm, table)\n\n module: auth_db\n\nName alias: proxy_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable \\$fd).\n\n  If an empty string \u201c\u201d is used then the server will generate it from\n  the request. From header field domain will be used as realm.\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!proxy_authorize(\"$fd\", \"subscriber)) {\n        proxy_challenge(\"$fd\", \"1\");  # Realm will be autogenerated\n    };\n    ...\n\n",
 "proxy_authorize": "### proxy_authorize(realm, table)\n\n module: uid_auth_db\n\nThe function verifies credentials according to RFC2617. If the\ncredentials are verified successfully then the function will succeed and\nmark the credentials as authorized (marked credentials can be later used\nby some other functions). If the function was unable to verify the\ncredentials for some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is a opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  If an empty string \"\" is used then the server will generate it from\n  the request. From header field domain will be used as realm.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\n<!-- -->\n\n    ...\n    if (!proxy_authorize(\"\", \"subscriber)) {\n        proxy_challenge(\"\", \"1\");  # Realm will be autogenerated\n    };\n    ...\n            \n",
 "auth_check": "### auth_check(realm, table, flags)\n\n module: auth_db\n\nThe function combines the functionalities of `www_authenticate` and\n`proxy_authenticate`, first being executed if the SIP request is a\nREGISTER, the second for the rest.\n\nIn addition, a matter of *flags* parameter value, the function checks if\nauthentication username matches From/To header username, and Request-URI\nin case of PUBLISH.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable \\$fd).\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\n  The string may contain pseudo variables.\n\n- *flags* - set of flags to control the behaviour of the function. If it\n  is 1, then the function will check to see if the authentication\n  username matches either To or From header username. REGISTER requests:\n  From and To must match the authentication user. PUBLISH requests:\n  From, To and Request-URI must match the authentication user. All other\n  requests: From header must match the authentication user. If bit 2 is\n  set as well (flags==3), the ID check is skipped for INVITE, BYE,\n  PRACK, UPDATE, MESSAGE - these requests can come with anonymous caller\n  id. If set to 0, then all user checks are skipped.\n\n  Additionally all domains in the checked URIs and the realm in the\n  authentication header will be checked to match the provided realm\n  parameter.\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!auth_check(\"$fd\", \"subscriber\", \"1\")) {\n        auth_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "is_subscriber": "### is_subscriber(uri, dbtable, flags)\n\n module: auth_db\n\nThe function checks if there is a subscriber corresponding to the AoR in\nuri parameter. It uses same database connection as for authentication\nfunctions.\n\nIn addition, if the subscriber record is found, then the\nload_credentials attributes are loaded. A use case can be loading the\ncredential attributes for callee.\n\nMeaning of the parameters is as follows:\n\n- *uri* - a valid SIP URI value to identify the subscriber. The string\n  may contain pseudo variables.\n\n- *dbtable* - Table to be used to lookup username and domain from URI\n  (usually subscriber table). The string may contain pseudo variables.\n\n- *flags* - set of flags to control the behaviour of the function. If\n  1st bit is set, then the function will use the domain part of the URI\n  to perform the database table search. If 2nd bit is set, then the\n  credentials are not loaded in variables (a simple check if subscriber\n  exists).\n\n  The parameter may be a pseudo variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (!is_subscriber(\"$ru\", \"subscriber\", \"3\")) {\n        # callee is not a local subscriber\n        ...\n    }\n    ...\n",
 "check_to": "### check_to()\n\n module: uri_db\n\nCheck \u201cTo\u201d username against URI table (if use_uri_table is set) or\ndigest credentials (no DB backend required).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (check_to()) {\n        ...\n    };\n    ...\n\n",
 "check_from": "### check_from()\n\n module: uri_db\n\nCheck \u201cFrom\u201d username against URI table (if use_uri_table is set) or\ndigest credentials (no DB backend required).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (check_from()) {\n        ...\n    };\n    ...\n\n",
 "does_uri_exist": "### does_uri_exist()\n\n module: uri_db\n\nCheck if username in the request URI belongs to an existing user.\n\nThe checking is done against the URI table (if use_uri_table is set) or\nthe subscriber table.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (does_uri_exist()) {\n        ...\n    };\n    ...\n",
 "sip_capture": "### sip_capture([table], [cmode])\n\n module: sipcapture\n\nStore the current processed HEP/IPIP SIP message in a database. It is\nstored in the form prior applying changes made to it.\n\nMeaning of the parameters is as follows:\n\n- *table* - The table where HEP SIP message will be stored. Homer 5 use\n  now tables with datestamp. To generate an automatic table's name\n  please use strftime parameters. I.e. \\$var(table) =\n  \"sip_capture_call\\_%Y%m%d\" and set the variable as an argument of the\n  sip_capture function.\n\n- *cmode* - The reference to the capture_mode parameter.\n\nThis function can be used from ANY_ROUTE.\n\nDefault value is \"NULL\".\n\n    ...\n    sip_capture();\n    ...\n    sip_capture(\"sip_capture_call_20160124\");\n    ...\n    sip_capture(\"\", \"cmode\");\n    ...\n\n",
 "report_capture": "### report_capture([table], [cid], [data])\n\n module: sipcapture\n\nStore the current processed HEP REPORT message in a database.\n\nMeaning of the parameters is as follows:\n\n- *table* - The table where REPORT message will be stored.\n\n- *cid* - The correlation id.\n\n- *data* - The custom report data in JSON format.\n\nThis function can be used from ANY_ROUTE.\n\nDefault value is \"NULL\".\n\n    ...\n    report_capture();\n    ...\n    report_capture(\"report_data\", \"$ci\");\n    ...\n    report_capture(\"report_data\", \"$ci\", \"{\\\"MOS\\\":4.1,\\\"PACKET_LOST\\\":100\"});\n    ...\n\n",
 "float2int": "### float2int(fval, ival)\n\n module: sipcapture\n\nReturn the value of atof(fval) \\* atoi(ival). On case the result is 0,\nthen -1 is returned.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(res) = float2int(\"10.5\", \"1\");\n    ...\n\n",
 "sip_capture_forward": "### sip_capture_forward(uri)\n\n module: sipcapture\n\nForward the HEP packet to an address specified by the parameter uri (it\nhas to be a sip uri format). The function should be used inside\nevent_route\\[sipcapture:request\\]. After using this function, add a\nreturn 0 in order to stop processing further the packet in the local\nKamailio instance.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        event_route[sipcapture:request] {\n            ...\n            if(src_ip==1.2.3.4) {\n                sip_capture_forward(\"sip:2.3.4.5:5090\");\n                return 0;\n            }\n            ...\n        }\n    ...\n\n",
 "ruby_run": "### ruby_run(function, params)\n\n module: app_ruby\n\nExecute the Ruby function 'func' giving params as parameters. There can\nbe up to 3 string parameters. The function must exist in the script\nloaded at startup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n    ...\n    if(!ruby_run(\"rb_append_fu_to_reply\"))\n    {\n        xdbg(\"SCRIPT: failed to execute ruby function!\\n\");\n    }\n    ...\n    ruby_run(\"rb_funcx\", \"$rU\", \"2\");\n    ...\n\n",
 "add_diversion": "### add_diversion(reason [, uri])\n\n module: diversion\n\nThe function adds a new diversion header field before any other existing\nDiversion header field in the message (the newly added Diversion header\nfield will become the topmost Diversion header field). If 'uri'\nparameter is missing, the inbound (without any modifications done by the\nproxy server) Request-URI will be used as the Diversion URI.\n\nMeaning of the parameters is as follows:\n\n- *reason* - The reason string to be added as the reason parameter\n\n- *uri* - The URI to be set in Diversion header\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    add_diversion(\"user-busy\");\n    add_diversion(\"user-busy\", \"$ru\");\n    ...\n\n",
 "blst_add": "### blst_add([timeout])\n\n module: blst\n\nAdds the source of the current message to the blocklist for `timeout`\nseconds. If timeout is missing or 0 it uses the default blocklist\ntimeout (`dst_blocklist_expire`).\n\n    ...\n    if (src_ip==10.0.0.0/9)\n        blst_add(30); # 30 s\n    else\n        blst_add();  # use default blocklist timeout\n    ...\n            \n\n",
 "blst_add_retry_after": "### blst_add_retry_after(min, max)\n\n module: blst\n\nAdds the source of the current message to the blocklist for the time\ninterval specified in the *Retry-After* header. If the *Retry-After*\nheader is missing, it will fail (returns false). If the *Retry-After*\nvalue is less than `min`, then `min` seconds will be used instead. If\nthe *Retry-After* value is greater than `max`, then `max` seconds will\nbe used instead.\n\n    ...\n    # on_reply route\n    if (msg_status==503){ # blocklist 503 source for Retry-After seconds\n        if (! blst_add_retry_after(30, 3600))\n            blst_add(60); # if no retry_after header add it for 60s\n    }\n    ...\n            \n\n",
 "blst_del": "### blst_del()\n\n module: blst\n\nRemoves the source of the current message from the blocklist. If the\naddress is not present in the blocklist at the time of the call it\nreturns false.\n\n    ...\n        blst_del();\n    ...\n            \n\n",
 "blst_is_blocklisted": "### blst_is_blocklisted()\n\n module: blst\n\nReturns true if the source of the current message is blocklisted.\n\n    ...\n        if (blst_is_blocklisted()){\n            log(\"message from a blocklisted source\");\n            drop;\n       }\n    ...\n            \n\n",
 "blst_set_ignore": "### blst_set_ignore([flags])\n\n module: blst\n\nSet errors that will not be taken into account when deciding whether to\nblocklist a destination for the current message or a local reply to the\ncurrent message.\n\n`blst_set_ignore(..)` works for forwarding the current message and\n`blst_rpl_set_ignore(...)` works for local replies to the current\nmessage.\n\nThe variants of these functions with no parameters will ignore\neverything (equivalent to passing 0xff).\n\nThe flags are stored internally as a bitmask, and are applied by bitwise\nANDing them together. The following flags are available:\n\n- 0x02\n  \\- generic send error (send denied/ failed).\n- 0x04\n  \\- connect failed (TCP, TLS or SCTP).\n- 0x08\n  \\- ICMP error (not currently used).\n- 0x10\n  \\- SIP transaction timeout.\n- 0x20\n  \\- 503 reply (stateful mode only). For more details see\n  tm\n  blst_503\n  .\n\n<div class=\"note\">\n\nTCP and TLS send and connect errors are handled per connection and not\nper message. The connection blocklist ignore flags are inherited from\nthe message that caused the connection establishment.\n\n</div>\n\n    ...\n        blst_set_ignore(6); # ignore send and connect errors\n    ...\n            \n\n",
 "blst_rpl_set_ignore": "### blst_rpl_set_ignore([flags])\n\n module: blst\n\nSee function `blst_set_ignore([flags])`.\n\n",
 "blst_clear_ignore": "### blst_clear_ignore([flags])\n\n module: blst\n\nClears blocklist ignore flags previously set by the corresponding\n`blst_set_ignore(...)` or `blst_rpl_set_ignore(...)` functions.\n\nSee also `blst_set_ignore`.\n\n    ...\n        blst_clear_ignore(4); # ignore connect errors\n    ...\n            \n\n",
 "blst_rpl_clear_ignore": "### blst_rpl_clear_ignore([flags])\n\n module: blst\n\nSee function `blst_clear_ignore([flags])`.\n",
 "checkospheader": "### checkospheader()\n\n module: osp\n\nThis function checks for the existence of the OSP-Auth-Token header\nfield.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (checkospheader()) {\n      log(1,\"OSP header field found.\\n\");\n    } else {\n      log(1,\"no OSP header field present\\n\");\n    };\n    ...\n            \n\n",
 "validateospheader": "### validateospheader()\n\n module: osp\n\nThis function validates an OSP-Token specified in the\nOSP-Auth-Tokenheader field of the SIP message. If a peering token is\npresent, it will be validated locally. If no OSP header is found or the\nheader token is invalid or expired, -1 is returned; on successful\nvalidation 1 is returned.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (validateospheader()) {\n      log(1,\"valid OSP header found\\n\");\n    } else {\n      log(1,\"OSP header not found, invalid or expired\\n\");\n    };\n    ...\n            \n\n",
 "requestosprouting": "### requestosprouting()\n\n module: osp\n\nThis function launches a query to the peering server requesting the IP\naddress of one or more destination peers serving the called party. If\ndestination peers are available, the peering server will return the IP\naddress and a peering authorization token for each destination peer. The\nOSP-Auth-Token Header field is inserted into the SIP message and the SIP\nuri is rewritten to the IP address of destination peer provided by the\npeering server.\n\nThe address of the called party must be a valid E164 number, otherwise\nthis function returns -1. If the transaction was accepted by the peering\nserver, the uri is being rewritten and 1 returned, on errors (peering\nservers are not available, authentication failed or there is no route to\ndestination or the route is blocked) -1 is returned.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (requestosprouting()) {\n      log(1,\"successfully queried OSP server, now relaying call\\n\");\n    } else {\n      log(1,\"Authorization request was rejected from OSP server\\n\");\n    };\n    ...\n            \n\n",
 "checkosproute": "### checkosproute()\n\n module: osp\n\nThis function is used to check if there is any route for the call.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (checkosproute()) {\n      log(1,\"There is at least one route for the call\\n\");\n    } else {\n      log(1,\"There is not any route for the call\\n\");\n    };\n    ...\n            \n\n",
 "prepareosproute": "### prepareosproute()\n\n module: osp\n\nThis function tries to prepare the INVITE to be forwarded using the\ndestination in the list returned by the peering server. If the calling\nnumber is translated, a RPID value for the RPID AVP will be set. If the\nroute could not be prepared, the function returns 'FALSE' back to the\nscript, which can then decide how to handle the failure. Note, if\ncheckosproute has been called and returns 'TRUE' before calling\nprepareosproute, prepareosproute should not return 'FALSE' because\ncheckosproute has confirmed that there is at least one route.\n\nThis function can be used from BRANCH_ROUTE.\n\n    ...\n    if (prepareosproute()) {\n      log(1,\"successfully prepared the route, now relaying call\\n\");\n    } else {\n      log(1,\"could not prepare the route, there is not route\\n\");\n    };\n    ...\n            \n\n",
 "checkcallingtranslation": "### checkcallingtranslation()\n\n module: osp\n\nThis function is used to check if the calling number is translated.\nBefore calling checkcallingtranslation, prepareosproute should be\ncalled. If the calling number does been translated, the original\nRemote-Party-ID, if it exists, should be removed from the INVITE\nmessage. And a new Remote-Party-ID header should be added (a RPID value\nfor the RPID AVP has been set by prepareosproute). If the calling number\nis not translated, nothing should be done.\n\nThis function can be used from BRANCH_ROUTE.\n\n    ...\n    if (checkcallingtranslation()) {\n      # Remove the Remote_Party-ID from the received message\n      # Otherwise it will be forwarded on to the next hop\n      remove_hf(\"Remote-Party-ID\");\n\n      # Append a new Remote_Party\n      append_rpid_hf();\n    }\n    ...\n            \n\n",
 "prepareallosproute": "### prepareallosproute()\n\n module: osp\n\nThis function tries to prepare all the routes in the list returned by\nthe peering server. The message is then either forked off or redirected\nto the destination. If unsuccessful in preparing the routes a SIP 500 is\nsent back and a trace message is logged.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (prepareallosproute()) {\n      log(1,\"Routes are prepared, now either forking or redirecting the call\\n\");\n    } else {\n      log(1,\"Could not prepare the routes. No destination available\\n\");\n    };\n    ...\n            \n\n",
 "reportospusage": "### reportospusage()\n\n module: osp\n\nThis function should be called after receiving a BYE message. If the\nmessage contains an OSP cookie, the function will forward originating\nand/or terminating duration usage information to a peering server. The\nfunction returns TRUE if the BYE includes an OSP cookie. The actual\nusage message will be sent on a different thread and will not delay BYE\nprocessing. The function should be called before relaying the message.\n\nMeaning of the parameter is as follows:\n\n- \"0\" - Source device releases the call.\n\n- \"1\" - Destination device releases the call.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_direction(\"downstream\")) {\n      log(1,\"This BYE message is from SOURCE\\n\");\n      if (!reportospusage(\"0\")) {\n        log(1,\"This BYE message does not include OSP usage information\\n\");\n      }\n    } else {\n      log(1,\"This BYE message is from DESTINATION\\n\");\n      if (!reportospusage(\"1\")) {\n        log(1,\"This BYE message does not include OSP usage information\\n\");\n      }\n    }\n    ...\n            \n\n",
 "acc_diam_request": "### acc_diam_request(comment)\n\n module: acc_diameter\n\nLike `acc_log_request`, `acc_diam_request` reports on a request. It\nreports to the configured Diameter server.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The string can contain any number\n  of pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    acc_diam_request(\"Some comment\");\n    acc_diam_request(\"$var(code) Error: $avp(reason)\");\n    ...\n",
 "janssonrpc_notification": "### janssonrpc_notification(conn, method, parameters)\n\n module: janssonrpcc\n\n- conn\n  \\- name for a collection of servers (required)\n- method\n  \\- jsonrpc method (required)\n- params\n  \\- jsonrpc request params (required) Use \\$null or empty string to not\n  send any parameters in the jsonrpc notification.\n\nUnlike janssonrpc_request (below), notifications do not receive a\nresponse. Script processing continues in the usual fashion as soon as\nthe notification has been sent.\n\nIf no servers can be reached, a message is sent to the logs.\n\nThe 'method' and 'params' can be a static string or dynamic string value\nwith config variables.\n\n    ...\n    janssonrpc_notification(\"user_db\", \"update_user\", '{\"id\": 1234, \"name\": \"Daniel\"}');\n    ...\n                    \n\n",
 "janssonrpc_request": "### janssonrpc_request(conn, method, params[, options]])\n\n module: janssonrpcc\n\nThe conn, method, params, and options can be a static string or a\ndynamic string value with config variables.\n\n- conn\n  \\- name for a collection of servers (required)\n\n- method\n  \\- jsonrpc method (required)\n\n- params\n  \\- jsonrpc request params (required) Use \\$null or empty string to not\n  send any parameters in the jsonrpc request.\n\n- *options*\n\n  Options for the janssonrpc_request function. Format can be\n  \"route=RESPONSE;retry=2;timeout=100\". All these parameters are\n  optional.\n\n  - retry\n    \\- number of times you retry a failed request. -1 means retry\n    forever. Default is 0. Request will be retried if they either\n    timeout or fail to send. Retries utilize exponential back off\n    between successive retries, up to 60 seconds. The equation for time\n    between retries is:\n    time = n^2 \\* timeout (for time \\< 60 seconds)\n\n    where n is the number of times a request has been tried.\n  - timeout\n    \\- request timeout in milliseconds. Default is 500.\n  - route\n    \\- resume script execution at this route.\n\nWhen a response is received, processing continues for the SIP request in\nthe route specified.\n\nIf no route is specified, then any errors are logged and successes are\nignored. The function will also not interrupt script execution.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution is lost. Only shared variables (\\$shv, \\$avp, etc) should\nbe used for any value that will be needed when the script is resumed.\n\nThe result is stored in the pseudo-variable specified in the module\nparameter 'result_pv'. This pseudo-variable is set *after* the response\nis received.\n\n    ...\n    janssonrpc_request(\"user_db\", \"get_user\", '{\"id\": 1234}', \"route=RESPONSE;retry=1\");\n        ...\n\n    route[RESPONSE] {\n        xlog(\"Result received: $var(result)\");\n        ...\n    }\n    ...\n                    \n\n",
 "load_gws": "### load_gws(lcr_id[, uri_user[, caller_uri]])\n\n module: lcr\n\nLoads attributes of matching gateways to gw_uri_avp (see Overview\nsection). Argument lcr_id specifies the used LCR instance. It can be a\npositive integer or a pseudo variable containing an integer value. If\nuri_user is given, it is used, instead of Request-URI user part, to look\nfor matching gateways. Caller's URI may be given by caller_uri argument.\nIf caller_uri argument is omitted, it defaults to empty string. Both\nuri_user and caller_uri argument may be a string or a pseudo variable\ncontaining a string value.\n\nReturns 1 if at least one matching gateway was found, 2 if no matching\ngateways was found, and -1 on error.\n\nExecution time of load_gws() function is O(N) \\* O(M), where N is number\nof different prefix lengths and M is number of collisions for matching\nprefix(es) in lcr rules hash table of the LCR instance.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!load_gws(1, $rU, $var(caller_uri))) {\n        sl_send_reply(\"500\", \"Server Internal Error - Cannot load gateways\");\n        exit;\n    };\n    ...\n\n",
 "next_gw": "### next_gw()\n\n module: lcr\n\nUpon first call, fetches attribute values stored in first gw_uri_avp,\ndestroys that AVP, and rewrites Request-URI and possibly also\ndestination URI as described in the Overview section. Saves user part of\nRequest-URI into ruri_user_avp for use in subsequent next_gw() calls.\n\nUpon subsequent calls, does the same as in above, but takes user part of\nRequest-URI from ruri_user_avp.\n\nAs a side effect, stores gateway's tag and flags to tag_avp and\nflags_avp, respectively, if the corresponding module parameter has been\ndefined. In the same way, rule_id_avp, if defined, contains the id of\nthe rule that selected the gateway.\n\nReturns 1 on success and -1 if there were no gateways left or if an\nerror occurred (see syslog).\n\nMust be preceded by successful load_gws() call.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (!next_gw()) {\n        sl_send_reply(\"503\", \"Service not available - No gateways\");\n        exit;\n    };\n    ...\n\n    ...\n    if (!next_gw()) {\n        t_reply(\"503\", \"Service not available - No more gateways\");\n        exit;\n    };\n    ...\n\n",
 "inactivate_gw": "### inactivate_gw()\n\n module: lcr\n\nInactivates the gateway denoted by lcr_id_avp and defunct_gw_avp (which\nwere set by previous next_gw() call). Use of this function requires that\n`ping_interval` module parameter has been set to a positive value\nallowing an inactivated gateway to be automatically activated by a\npositive response to OPTIONS ping request.\n\nReturns 1 on success and -1 in case of error (see syslog).\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    failure_route [GW_FAILURE] {\n    ...\n        if (t_check_status(\"408|503\")) {\n            inactivate_gw();\n        };\n    ...\n            \n\n",
 "defunct_gw": "### defunct_gw(period)\n\n module: lcr\n\nDefuncts gateway denoted by lcr_id_avp and defunct_gw_avp (which were\nset by previuos next_gw() call) for a period of seconds given as\nargument. Argument must be a positive integer constant or a pseudo\nvariable with positive integer value. Value of defunct column in\ndatabase is not updated.\n\nReturns 1 on success and -1 in case of error (see syslog).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    defunct_gw(60);\n    ...\n\n",
 "from_gw": "### from_gw(lcr_id[, ip_addr, proto[, src_port]])\n\n module: lcr\n\nChecks if request comes from IP address, transport protocol and source\nport specified for a gateway in LCR instance lcr_id. Fails if the LCR\ninstance includes one or more gateways without IP address. IP address,\ntransport protocol and source port to be checked are either taken from\nsource IP address and port of the request or (if present) from ip_addr,\nproto and src_port arguments.\n\nlcr_id can be an integer constant or a pseudo variable holding an\ninteger value. ip_addr can be a string or a pseudo variable holding a\nstring value. proto can be an integer constant (0 = ANY, 1 = UDP, 2 =\nTCP, 3 = TLS, 4 = SCTP) or a pseudo variable holding such an integer\nvalue. src_port can be an integer or a pseudo variable holding such an\ninteger value.\n\nIf request comes from a gateway, gateway's tag and flags are stored as a\nside effect to tag_avp and flags_avp, respectively, if the corresponding\nmodule parameter has been defined. In the same way, rule_id_avp, if\ndefined, contains the id of the rule that selected the gateway.\n\nReturns 1 on success and -1 on failure or on error.\n\nExecution time of from_gw() function is O(log N), where N is number of\ngateways in the LCR instance.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE.\n\n    ...\n    if (from_gw(1, $avp(real_source_addr), 2, 5060) {\n        ...\n    };\n    ...\n\n",
 "from_any_gw": "### from_any_gw([ip_addr, proto[, src_port]])\n\n module: lcr\n\nChecks if request comes from IP address, transport protocol and source\nport specified for any gateway. Only LCR instances, where all gateways\nhave IP address, are included in the test. IP address, transport\nprotocol and source port to be checked are either taken from source IP\naddress, transport protocol and source port of the request or (if\npresent) from ip_addr, proto and src_port arguments. See from_gw()\nfunction for more info about the arguments.\n\nIf any gateway has the IP address, transport protocol and source port,\nfunction returns LCR identifier of the gateway. Returns -1 on error or\nif the request does not come from a gateway.\n\nIf request comes from a gateway, gateway's tag and flags are stored as a\nside effect to tag_avp and flags_avp, respectively, if the corresponding\nmodule parameter has been defined. In the same way, rule_id_avp, if\ndefined, contains the id of the rule that selected the gateway.\n\nExecution time of from_gw() function is M \\* O(log N), where M is number\nof LCR instances and N is average number of gateways in LCR instances.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE.\n\n    ...\n    $var(lcr_id) = from_any_gw(\"192.168.1.1\", 3, 5061);\n    ...\n\n",
 "to_gw": "### to_gw(lcr_id[, ip_addr, proto])\n\n module: lcr\n\nChecks if in-dialog request goes to IP address and transport protocol\nspecified for a gateway in LCR instance lcr_id. Fails if LCR instance\nincludes one or more gateways without IP address. IP address and\ntransport protocol to be checked are either taken from Request-URI or\n(if present) from ip_addr and proto arguments. See from_gw() for more\ninfo regarding the arguments.\n\nReturns 1 on success and -1 on failure and error.\n\nExecution time of to_gw() function is O(log N), where N is number of\ngateways in the LCR instance.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (to_gw(\"1\")) {\n        ...\n        exit;\n    };\n    ...\n\n",
 "to_any_gw": "### to_any_gw([ip_addr, proto])\n\n module: lcr\n\nChecks if in-dialog request goes to IP address and transport protocol of\nany gateway. Only LCR instances, where all gateways have IP address, are\nincluded in the test. IP address and transport protocol to be checked\nare either taken from Request-URI or (if present) from ip_addr and proto\narguments. See from_gw() for more info regarding the arguments.\n\nExecution time of to_any_gw() function is M \\* O(log N), where M is\nnumber of LCR instances and N is average number of gateways in LCR\ninstances.\n\nIf any gateway has the IP address, returns LCR identifier of the\ngateway. Returns -1 if request does not go to a gateway and on error.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (to_any_gw(\"192.55.66.2\", 1)) {\n        ...\n        exit;\n    };\n    ...\n\n",
 "call_obj_get": "### call_obj_get(reply_number)\n\n module: call_obj\n\nGet next free number. reply_number parameter is a variable where\nfunction will store result in string format.\n\n    ...\n    if (call_obj_get(\"$dlg_var(x)\")) {\n        xlog(\"Object: $dlg_var(x)\\n\");\n    }\n    ...\n\n",
 "call_obj_free": "### call_obj_free(object_number)\n\n module: call_obj\n\nMark an object_number as free, so it can be assigned again. This number\nwill not be readily assigned until a loop in the ring has completed.\nobject_number shall be provided in string format.\n\n    ...\n    $dlg_var(y) = \"27\";\n    if (call_obj_free(\"$dlg_var(y)\")) {\n        xlog(\"object $dlg_var(y) freed OK\\n\");\n    }\n    ...\n            \n\n",
 "ims_www_authorize": "### ims_www_authorize(realm, table)\n\n module: ims_auth\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nNegative codes may be interpreted as follows:\n\n- *-1 (generic error)* - some generic error occurred and no reply was\n  sent out;\n\n- *-2 (invalid password)* - valid user, but wrong password;\n\n- *-3 (invalid user)* - authentication user does not exist.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is a opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests To header\n  field domain (e.g., variable \\$td) can be used (because this header\n  field represents the user being registered), for all other messages\n  From header field domain can be used (e.g., variable \\$fd).\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!www_authorize(\"kamailio.org\", \"subscriber\")) {\n        www_challenge(\"\"REG_MAR_REPLY\"\", \"kamailio.org\", \"1\");\n    };\n    ...\n\n",
 "ims_www_authenticate": "### ims_www_authenticate(realm)\n\n module: ims_auth\n\nIt is the same function as www_authenticate(realm, table). This name is\nkept for backward compatibility, since it was named this way first time\nby it actually does user authentication.\n\n",
 "ims_www_challenge": "### ims_www_challenge(route_block, realm)\n\n module: ims_auth\n\nName alias: proxy_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- Route block to resume after async MAR Diameter reply.\n\n- *realm* - Realm is a opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable \\$fd).\n\n  If an empty string \u201c\u201d is used then the server will generate it from\n  the request. From header field domain will be used as realm.\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!proxy_authorize(\"$fd\", \"subscriber)) {\n        proxy_challenge(\"\"REG_MAR_REPLY\",\"$fd\");  # Realm will be autogenerated\n    };\n    ...\n                ...\n    route[REG_MAR_REPLY]\n    {\n         #this is async so to know status we have to check the reply avp\n         xlog(\"L_DBG\",\"maa_return code is $avp(s:maa_return_code)\\n\");\n\n         switch ($avp(s:maa_return_code)){\n                 case 1: #success\n                         xlog(\"L_DBG\", \"MAR success - 401/407 response sent from module\\n\");\n                         break;\n                 case -1: #failure\n                         xlog(\"L_ERR\", \"MAR failure - error response sent from module\\n\");\n                         break;\n                 case -2: #error\n                         xlog(\"L_ERR\", \"MAR error - sending error response now\\n\");\n                         t_reply(\"500\", \"MAR failed\");\n                         break;\n                 default:\n                         xlog(\"L_ERR\", \"Unknown return code from MAR, value is [$avp(s:uaa_return_code)]\\n\");\n                         t_reply(\"500\", \"Unknown response code from MAR\");\n                         break;\n         }\n         exit;\n    }\n\n### ims_www_challenge(route_block, realm, algorithm)\n\n module: ims_auth\n\nSame as 4.3 except here there is the additional option to specify the\nauthorisation algorithm\n\n- *algorithm* - The algorithm to be used when challenging the client.\n  Can be AKAv1-MD5, AKAv2-MD5, MD5, or HSS-Selected. If left as an empty\n  string, the default algorithm will be chosen according to the\n  parameter registration_default_algorithm (see section 3.7)\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n     if (!ims_www_authenticate(NETWORKNAME)) {\n                    #user has not been authenticated. Lets send a challenge via 401 Unauthorized\n                    if ($? == -2) {\n                            t_reply(\"403\", \"Authentication Failed\");\n                            exit;\n                    } else if ($? == -3) {\n                            t_reply(\"400\", \"Bad Request\");\n                            exit;\n                    } else if ($? == -9) {\n                            xlog(\"L_DBG\", \"Authentication re-sync requested\\n\");\n                            ims_www_resync_auth(\"REG_RESYNC_REPLY\", \"$td\");\n                            exit;\n                    } else {\n                            xlog(\"L_DBG\",\"About to challenge! auth_ims\\n\");\n                            ims_www_challenge(\"REG_MAR_REPLY\", \"$td\", \"MD5\");\n                            exit;\n                    }\n            }\n\n",
 "ims_proxy_challenge": "### ims_proxy_challenge(route_block, realm, table)\n\n module: ims_auth\n\nName alias: proxy_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- Route block to resume after async MAR Diameter reply.\n\n- *realm* - Realm is a opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable \\$fd).\n\n  If an empty string \u201c\u201d is used then the server will generate it from\n  the request. From header field domain will be used as realm.\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!proxy_authorize(\"$fd\", \"subscriber)) {\n        proxy_challenge(\"REG_MAR_REPLY\",\"$fd\", \"1\");  # Realm will be autogenerated\n    };\n    ...\n    route[REG_MAR_REPLY]\n    {\n         #this is async so to know status we have to check the reply avp\n         xlog(\"L_DBG\",\"maa_return code is $avp(s:maa_return_code)\\n\");\n\n         switch ($avp(s:maa_return_code)){\n                 case 1: #success\n                         xlog(\"L_DBG\", \"MAR success - 401/407 response sent from module\\n\");\n                         break;\n                 case -1: #failure\n                         xlog(\"L_ERR\", \"MAR failure - error response sent from module\\n\");\n                         break;\n                 case -2: #error\n                         xlog(\"L_ERR\", \"MAR error - sending error response now\\n\");\n                         t_reply(\"500\", \"MAR failed\");\n                         break;\n                 default:\n                         xlog(\"L_ERR\", \"Unknown return code from MAR, value is [$avp(s:uaa_return_code)]\\n\");\n                         t_reply(\"500\", \"Unknown response code from MAR\");\n                         break;\n         }\n         exit;\n    }\n    ...\n\n",
 "ims_proxy_authenticate": "### ims_proxy_authenticate(realm, table)\n\n module: ims_auth\n\nIt is same function as proxy_authenticate(realm, table). This name is\nkept for backward compatibility, since it was named this way first time\nbut it actually does user authentication.\n\n",
 "cass_insert": "### cass_insert(keyspace, column_family, key, column, value)\n\n module: ndb_cassandra\n\nInserts the value for the given key, column, column_family and keyspace.\nThere must be an existing keyspace called 'keyspace' with a\ncolumn_family called 'column_family' in the targeted Cassandra node.\n\nReturn integer needs to be checked:\n\n- ret \\< 0, error\n\n- ret \\> 0, success\n\n",
 "cass_retrieve": "### cass_retrieve(keyspace, column_family, key, column, value)\n\n module: ndb_cassandra\n\nRetrieves the value for the given key, column, column_family and\nkeyspace. There must be an existing keyspace called 'keyspace' with a\ncolumn_family called 'column_family' in the targeted Cassandra node.\n\n`value` will be returned as well as an integer return code.\n\nReturn integer needs to be checked:\n\n- ret \\< 0, error\n\n- ret \\> 0, success\n\n<!-- -->\n\n              ...\n        loadmodule \"ndb_cassandra.so\"\n        # (...)\n        modparam(\"ndb_cassandra\", \"host\", \"10.22.22.190\")\n        modparam(\"ndb_cassandra\", \"port\", 9160)\n        # (...)\n        xlog(\"L_DBG\", \"Testing ndb_cassandra module.\");\n        # Inserting to cassandra\n        $var(keyspace) = \"indigital\";\n        $var(column_family) = \"employees\";\n        $var(column) = \"name\";\n        $var(val_write) = \"TestMyName\"; # To be written\n        if (cass_insert(\"$var(keyspace)\", \"$var(column_family)\", \"$ru\", \"$var(column)\", \"$var(val_write)\") > 0) {\n           xlog(\"L_DBG\", \"ndb_cassandra. Sucess while inserting to Cassandra. val_write: \\\"$var(val_write)\\\"\");\n        } else {\n           xlog(\"L_DBG\", \"ndb_cassandra. Error while inserting to Cassandra\");\n        }\n\n        # Retrieving from cassandra\n        $var(keyspace) = \"indigital\";\n        $var(column_family) = \"employees\";\n        $var(key) = \"sip:10.22.22.110\"; # Before we saved our $ru, which was 'sip:10.22.22.110'\n        $var(column) = \"name\";\n        $var(val_read) = \"\"; # To be read\n        if (cass_retrieve(\"$var(keyspace)\", \"$var(column_family)\", \"$var(key)\", \"$var(column)\", \"$var(val_read)\") > 0) {\n           xlog(\"L_DBG\", \"ndb_cassandra. Sucess while reading from Cassandra. val_read: \\\"$var(val_read)\\\"\");\n        } else {\n           xlog(\"L_DBG\", \"ndb_cassandra. Error while reading from Cassandra\");\n        }\n              ...\n            \n",
 "fix_nated_contact": "### fix_nated_contact()\n\n module: nathelper\n\nRewrites the \u201cContact\u201d header to contain the request's source\naddress:port.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    if (search(\"User-Agent: Cisco ATA.*\") {fix_nated_contact();};\n    ...\n\n",
 "fix_nated_sdp": "### fix_nated_sdp(flags [, ip_address])\n\n module: nathelper\n\nAlters the SDP information in order to facilitate NAT traversal. What\nchanges to be performed may be controlled via the \u201cflags\u201d parameter.\nReturn value is -1 if error occurred, 1 if ip's were replaced, 2 if no\nip's were replaced.\n\nMeaning of the parameters is as follows:\n\n- *flags* - the value may be a bitwise OR of the following flags:\n\n  - *0x01* - adds \u201ca=direction:active\u201d SDP line;\n\n  - *0x02* - rewrite media IP address (c=) with source address of the\n    message or the provided IP address. (a=rtcp) param will be rewritten\n    if exists. (the provided IP address take precedence over the source\n    address).\n\n  - *0x04* - adds \u201ca=nortpproxy:yes\u201d SDP line;\n\n  - *0x08* - rewrite IP from origin description (o=) with source address\n    of the message or the provided IP address. (a=rtcp) param will be\n    rewritten if exists. (the provided IP address take precedence over\n    the source address).\n\n- *ip_address* - IP to be used for rewriting SDP. If not specified, the\n  received signalling IP will be used. The parameter allows\n  pseudo-variables usage. NOTE: For the IP to be used, you need to use\n  0x02 or 0x08 flags, otherwise it will have no effect. Must be IPv4\n  address family.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if (search(\"User-Agent: Cisco ATA.*\") {fix_nated_sdp(\"3\");};\n    ...\n\n",
 "add_rcv_param": "### add_rcv_param([flag]),\n\n module: nathelper\n\nAdd a received parameter to the \u201cContact\u201d header fields (available for\nall transports) or to the Contact URI (available only for UDP traffic).\n\nThe parameter will contain the URI created from the source IP, port, and\nprotocol (if different than UDP) of the packet containing the SIP\nmessage. The parameter can be then processed by another registrar. This\nis useful, for example, when replicating register messages using\n`t_replicate` function to another registrar.\n\nMeaning of the parameters is as follows:\n\n- *flag* - flags to indicate if the parameter should be added to Contact\n  URI or Contact header. If the flag is non-zero, the parameter will be\n  added to the Contact URI. If not used or equal to zero, the parameter\n  will go to the Contact header.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    add_rcv_param(); # add the parameter to the Contact header\n    ....\n    add_rcv_param(\"1\"); # add the parameter to the Contact URI\n    ...\n\n",
 "fix_nated_register": "### fix_nated_register()\n\n module: nathelper\n\nThe function creates a URI consisting of the source IP, port, and\nprotocol and stores the URI in an Attribute-Value-Pair. The URI will be\nappended as \"received\" parameter to Contact in 200 OK and registrar will\nstore it in the received column in the location table.\n\nNote: You have to set the \u201creceived_avp\u201d parameter of the nathelper\nmodule and the registrar module (both module parameters must have the\nsame value) to use this function.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    fix_nated_register();\n    ...\n\n",
 "nat_uac_test": "### nat_uac_test(flags)\n\n module: nathelper\n\nTries to guess if client's request originated behind a nat. The\nparameter determines what heuristics is used.\n\nMeaning of the flags is as follows:\n\n- *1* - The \u201cContact\u201d header field is searched for occurrence of RFC1918\n  or RFC6598 addresses.\n\n- *2* - the \"received\" test is used: address in the \u201cVia\u201d header is\n  compared against source IP address of signaling. If the \u201cVia\u201d header\n  contains no port, it uses the default SIP port 5060\n\n- *4* - The Top Most \u201cVia\u201d is searched for occurrence of RFC1918 or\n  RFC6598 addresses\n\n- *8* - The SDP is searched for occurrence of RFC1918 or RFC6598\n  addresses\n\n- *16* - Test if the source port is different from the port in the \u201cVia\u201d\n  header. If the \u201cVia\u201d header contains no port, it uses the default SIP\n  port 5060\n\n- *32* - Test if the source IP address of signaling is a RFC1918 or\n  RFC6598 address\n\n- *64* - Test if the source connection of signaling is a WebSocket\n\n- *128* - Test if the \u201cContact\u201d header URI port differs from the source\n  port of the request (Warning: this is might be legal or even intended\n  combination in non NATted scenarios)\n\n- *256* - Test if the SDP connection address is different from source IP\n  address. It will work also with multiple connection address lines.\n\n- *512* - Test if the target addresses are different or over websocket.\n  For requests, it compares host and port in R-URI (\\$rU) and D-URI\n  (\\$du). For replies, it compares host and port in 2nd Via with\n  received and rport parameters.\n\nAll flags can be bitwise combined, the test returns true if any of the\ntests identified a NAT.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if(nat_uac_test(\"19\")) {\n        rtpproxy_manage(\"co\");\n    }\n    ...\n\n",
 "is_rfc1918": "### is_rfc1918(ip_address)\n\n module: nathelper\n\nDetermines if the address in the parameter is an rfc1918 or rfc6598\naddress. The parameter allows pseudo-variables usage.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(is_rfc1918(\"$rd\")) {\n        # domain in r-uri is private address\n    }\n    ...\n\n",
 "add_contact_alias": "### add_contact_alias([ip_addr, port, proto])\n\n module: nathelper\n\nAdds an \u201c;alias=ip~port~transport\u201d parameter to the contact URI\ncontaining either received ip, port, and transport protocol or those\ngiven as parameters. If called without parameters, \u201c;alias\u201d parameter is\nonly added if received ip, port, or transport protocol differs from that\nin contact URI.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n    ...\n        if (!is_present_hf(\"Record-Route\")) {\n            if (!add_contact_alias(\"$var(src_ip)\", \"$Rp\", \"tcp\")) {\n                xlog(\"L_ERR\", \"Error in aliasing contact $ct\\n\");\n                send_reply(\"400\", \"Bad request\");\n                exit;\n            };\n        };\n    ...\n            \n\n",
 "handle_ruri_alias": "### handle_ruri_alias([mode])\n\n module: nathelper\n\nChecks if the Request URI has an \u201calias\u201d parameter and if so, removes it\nand sets the \u201c\\$du\u201d based on its value. Note that this means that\nrouting of request is based on \u201c;alias\u201d parameter value of the Request\nURI rather than the Request URI itself. If you call\n`handle_ruri_alias()` on a request, make sure that you screen the alias\nparameter value of Request URI the same way as you would screen the\nRequest URI itself.\n\nThe optional parameter mode can be 0 to consume first alias parameter,\notherwise it consumes the last alias parameter. If the parameter mode is\nnot provided, it consumes the first parameter.\n\nReturns *1* if \u201c;alias\u201d parameter was found and \u201c\\$du\u201d was set and the\n\u201c\\$ru\u201d rewritten, *2* if the alias parameter was not found and nothing\nwas done, or *-1* in case of error.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, and\nLOCAL_ROUTE.\n\n    ...\n        if ($du == \"\") {\n            handle_ruri_alias();\n            switch ($rc) {\n            case -1:\n                xlog(\"L_ERR\", \"Failed to handle alias of R-URI $ru\\n\");\n                send_reply(\"400\", \"Bad request\");\n                exit;\n            case 1:\n                xlog(\"L_INFO\", \"Routing in-dialog $rm from $fu to $du\\n\");\n                break;\n            case 2:\n                xlog(\"L_INFO\", \"Routing in-dialog $rm from $fu to $ru\\n\");\n                break;\n             };\n        };\n    ...\n            \n\n",
 "set_contact_alias": "### set_contact_alias([trim])\n\n module: nathelper\n\nAdds an \u201c;alias=ip~port~transport\u201d parameter to the contact URI\ncontaining the received ip, port, and transport protocol. The update of\ncontact URI is signaled to a few other modules in the way the\n`fix_nated_contact()` does it by using the internal flags. The new value\nis not visible to pseudo-variables and it does not change the SIP\nmessage buffer.\n\nMeaning of parameters:\n\n- *trim* - by default, set_contact_alias() will not detect and trim an\n  already existing alias parameter. If this optional parameter is set to\n  \"1\", set_contact_alias() will trim the existing alias before adding a\n  new one.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE, and FAILURE_ROUTE.\n\n    ...\n        if (!is_present_hf(\"Record-Route\")) {\n            if (!set_contact_alias()) {\n                xlog(\"L_ERR\", \"Error in aliasing contact $ct\\n\");\n                send_reply(\"400\", \"Bad request\");\n                exit;\n            };\n        };\n    ...\n            \n\n",
 "set_alias_to_pv": "### set_alias_to_pv(target_avp)\n\n module: nathelper\n\nReads \u201c;alias=ip~port~transport\u201d from Contact header then writes to\ntarget pseudo-variable as a sip uri.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE, and FAILURE_ROUTE.\n\n    ...\n            set_alias_to_pv(\"$avp(aliasuri)\");\n    ...\n            \n\n",
 "smsdump": "### smsdump()\n\n module: smsops\n\nDumps the content of a 3GPP-SMS message to the Debug-Log.\n\nPlease make sure, to have debug-Log enabled. Otherwise, you won't see\nanything.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    smsdump();\n    ...\n",
 "dispatch_xhttp_rpc": "### dispatch_xhttp_rpc()\n\n module: xhttp_rpc\n\nHandle the HTTP request and generate a response.\n\n    ...\n    tcp_accept_no_cl=yes\n    ...\n    loadmodule \"sl.so\"\n    loadmodule \"xhttp.so\"\n    loadmodule \"xhttp_rpc.so\"\n    ...\n    modparam(\"xhttp_rpc\", \"xhttp_rpc_root\", \"http_rpc\")\n    ...\n    event_route[xhttp:request] {\n        $var(xhttp_rpc_root) = $(hu{s.substr,0,9});\n        if ($var(xhttp_rpc_root) == \"/http_rpc\")\n            dispatch_xhttp_rpc();\n        else\n            xhttp_reply(\"200\", \"OK\", \"text/html\",\n                    \"<html><body>Wrong URL $hu</body></html>\");\n    }\n    ...\n\n",
 "alias_db_lookup": "### alias_db_lookup(table_name[, flags])\n\n module: alias_db\n\nThe function takes the R-URI and search to see whether it is an alias or\nnot. If it is an alias for a local user, the R-URI is replaced with\nuser's SIP uri.\n\nThe function returns TRUE if R-URI is alias and it was replaced by\nuser's SIP uri.\n\nMeaning of the parameters is as follows:\n\n- *table_name* - the name of the table where to search for alias. It can\n  include pseudo-variables.\n\n- *flags* (optional) - set of flags (char based flags) to control the\n  alias lookup process:\n\n  - *d* - do not use domain URI part in the alias lookup query (use only\n    a username-based lookup). By default, both username and domain are\n    used.\n\n  - *r* - do reverse alias lookup - lookup for the alias mapped to the\n    current URI (URI 2 alias translation); normally, the function looks\n    up for the URI mapped to the alias (alias 2 URI translation).\n\n  - *u* - use domain URI part in the alias lookup query. Default depends\n    on the module parameter use_domain.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    alias_db_lookup(\"dbaliases\", \"rd\");\n    alias_db_lookup(\"dba_$(rU{s.substr,0,1})\");\n    ...\n\n",
 "alias_db_find": "### alias_db_find(table_name, input, output[, flags])\n\n module: alias_db\n\nThe function is very similar to `alias_db_lookup()`, but instead of\nusing fixed input (RURI) and output (RURI) is able to get the input SIP\nURI from a pseudo-variable and place the result back also in a\npseudo-variable.\n\nThe function is useful as the alias lookup does not affect the request\nitself (no RURI changes), can be used in a reply context (as it does not\nwork with RURI only) and can be used for others URI than the RURI (To\nURI, From URI, custom URI).\n\nThe function returns TRUE if any alias mapping was found and returned.\n\nMeaning of the parameters is as follows:\n\n- *table_name* - any PV (string or PV or mix) the name of the table\n  where to search for alias.\n\n- *input* - any PV (string or PV or mix) carrying the SIP URI that needs\n  to be looked up.\n\n- *output* - PV (AVP or script VAR) where to place the SIP URI resulting\n  from the alias lookup.\n\n- *flags* (optional) - set of flags (char based flags) to control the\n  alias lookup process:\n\n  - *d* - do not use domain URI part in the alias lookup query (use only\n    a username-based lookup). Default depends on the module parameter\n    use_domain.\n\n  - *r* - do reverse alias lookup - lookup for the alias mapped to the\n    current URI (URI 2 alias translation); normally, the function looks\n    up for the URI mapped to the alias (alias 2 URI translation).\n\n  - *u* - use domain URI part in the alias lookup query. Default depends\n    on the module parameter use_domain.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, LOCAL_ROUTE,\nSTARTUP_ROUTE, FAILURE_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    # do reverse alias lookup and find the alias for the FROM URI\n    alias_db_find(\"dbaliases\" , \"$fu\", \"$avp(from_alias)\", \"r\");\n    ...\n",
 "ruxc_http_get": "### ruxc_http_get(url, hdrs, respv)\n\n module: ruxc\n\nPerform a HTTP GET request to \"url\", storing the response body in the\n\"respv\" variable. The \"hdrs\" can be empty string to skip setting them.\nThe first two parameters can contain variables that are evaluated at\nruntime. The \"respv\" has to be the name of a writable variable.\n\nThe function returns response code of HTTP reply or negative value if\nsomething went wrong.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    ruxc_http_get(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n           \"\", \"X-Token: abc\", \"$var(result)\");\n    switch ($rc) {\n        ...\n    }\n    ...\n                    \n\n",
 "ruxc_http_post": "### ruxc_http_post(url, body, hdrs, respv)\n\n module: ruxc\n\nPerform a HTTP POST request to \"url\", storing the response body in the\n\"respv\" variable. The \"body\" and \"hdrs\" can be empty strings to skip\nsetting them. The first three parameters can contain variables that are\nevaluated at runtime. The \"respv\" has to be the name of a writable\nvariable.\n\nThe function returns response code of HTTP reply or negative value if\nsomething went wrong.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    ruxc_http_post(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n           \"\", \"X-Token: abc\", \"$var(result)\");\n    switch ($rc) {\n        ...\n    }\n    ...\n                    \n\n",
 "ruxc_http_delete": "### ruxc_http_delete(url, body, hdrs, respv)\n\n module: ruxc\n\nPerform a HTTP DELETE request to \"url\", storing the response body in the\n\"respv\" variable. The \"body\" and \"hdrs\" can be empty strings to skip\nsetting them. The first three parameters can contain variables that are\nevaluated at runtime. The \"respv\" has to be the name of a writable\nvariable.\n\nThe function returns response code of HTTP reply or negative value if\nsomething went wrong.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    ruxc_http_delete(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n           \"\", \"X-Token: abc\", \"$var(result)\");\n    switch ($rc) {\n        ...\n    }\n    ...\n                    \n\n",
 "http_async_query": "### http_async_query(url, route_name)\n\n module: http_async_client\n\nSends HTTP(S) request asynchronously to the URL given in \u201curl\u201d\nparameter, which is a string that may contain pseudo variables.\n\nParameter \u201croute_name\u201d defines the route to be executed upon reception\nof HTTP reply, on error or on timeout. If a transaction exists before\ncalling *http_async_query()*, it will be paused and resumed in this\nroute, while the routing script execution will be stopped. If executed\nin a transactionless context, or if *\\$http_req(suspend)* is used not to\nsuspend the transaction, the routing script execution will continue and\nthe query result will be available in \u201croute_name\u201d.\n\nReturn value: 0 (stop script execution) on success in transaction\ncontext, 1 (continue script execution) in transaction-less context (or\nif \\$http_req(suspend) is used), -1 on error.\n\nThis function can be used from ANY_ROUTE.\n\nThis method is executed asynchronously. The HTTP return code, body and\nerror are returned in the module-specific \\$http\\_\\* PVs (see below).\nSee example on how to retrieve return values.\n\n    ...\n    # create a transaction to be paused, and resumed in route[HTTP_REPLY]\n    t_newtran();\n    # GET\n    http_async_query(\"http://example.com/test.php?r_uri=$rU&f_uri=$fU\", \"HTTP_REPLY\");\n    ...\n    # POST\n    $http_req(body) = \"{'r_uri':'\" + $rU + \"', 'f_uri':'\" + $fU + \"'}\";\n    http_async_query(\"http://example.com/test.php\", \"HTTP_REPLY\");\n    ...\n    route[HTTP_REPLY] {\n        if ($http_ok) {\n            xlog(\"L_INFO\", \"route[HTTP_REPLY]: status $http_rs\\n\");\n            xlog(\"L_INFO\", \"route[HTTP_REPLY]: body   $http_rb\\n\");\n        } else {\n            xlog(\"L_INFO\", \"route[HTTP_REPLY]: error  $http_err)\\n\");\n        }\n    }\n    ...\n            \n\n",
 "jsonrpc_dispatch": "### jsonrpc_dispatch()\n\n module: jsonrpcs\n\nHandle the JSONRPC request and generate a response.\n\n    ...\n    #!KAMAILIO\n\n    memdbg=5\n    memlog=5\n\n    debug=3\n    log_stderror=yes\n\n    fork=yes\n    children=2\n\n    tcp_accept_no_cl=yes\n\n    loadmodule \"sl.so\"\n    loadmodule \"pv.so\"\n    loadmodule \"xhttp.so\"\n    loadmodule \"jsonrpcs.so\"\n\n    modparam(\"jsonrpcs\", \"transport\", 1)\n\n    request_route {\n        send_reply(\"404\", \"not found\");\n        exit;\n    }\n\n    event_route[xhttp:request] {\n        if(src_ip!=127.0.0.1) {\n            xhttp_reply(\"403\", \"Forbidden\", \"text/html\",\n                \"<html><body>Not allowed from $si</body></html>\");\n            exit;\n        }\n        if ($hu =~ \"^/RPC\") {\n            jsonrpc_dispatch();\n        } else {\n            xhttp_reply(\"200\", \"OK\", \"text/html\",\n                \"<html><body>Wrong URL $hu</body></html>\");\n        }\n        return;\n    }\n    ...\n\n",
 "jsonrpc_exec": "### jsonrpc_exec(cmd)\n\n module: jsonrpcs\n\nExecute a JSON-RPC command given as a parameter.\n\nThe parameter has to be a valid full JSON-RPC document. It can be a\ndynamic string with variables. The result of the command can be accessed\nvia \\$jsonrpl(key) pseudo variables.\n\n    ...\n    jsonrpc_exec('{\"jsonrpc\": \"2.0\", \"method\": \"dispatcher.reload\", \"id\": 1}');\n    xlog(\"jsonrpc response code: $jsonrpl(code) - the body is: $jsonrpl(body)\\n\");\n    ...\n\n",
 "lost_held_query": "### lost_held_query(con, [id,] pidf-lo, url, error)\n\n module: lost\n\nSends a HELD locationRequest to a given connection. The device identity\nis either specified, or the P-A-I header value, or the From header\nvalue.\n\n- *con* - the name of an existing HTTP connection, defined by a httpcon\n  modparam\n\n- *id* - the device id used in the HELD locationRequest\n\n- *pidf-lo* - the PIDF-LO returned in the HELD locationRequest response\n\n- *url* - the location reference returned in the HELD locationRequest\n  response - this reference may be added as Geolocation header value and\n  forwarded downstream. Note: to work properly, it is required to\n  include \"locationURI\" in the location_type parameter.\n\n- *error* - any error code returned in the HELD response\n\nThe return value is 200 on success, 400 if an internal error occured, or\n500 if an error code is returned in the HELD locationRequest response.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n    ...\n    modparam(\"http_client\", \"httpcon\", \"heldsrv=>http://service.org/api/held\");\n    ...\n    # HELD location request\n    $var(id) = \"sip:alice@atlanta\";\n    $var(res) = lost_held_query(\"heldsrv\", \"$var(id)\" , \"$var(pidf)\", \"$var(url)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"HELD locationRequest: Result code $var(res)\\nUrl: $var(url)\\n$var(pidf)\");\n    ...\n    $var(res) = lost_held_query(\"heldsrv\", \"$var(pidf)\", \"$var(url)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"HELD locationRequest: Result code $var(res)\\nUrl: $var(url)\\n$var(pidf)\\n\");\n    ...\n                    \n\n",
 "lost_held_dereference": "### lost_held_dereference(url, rtime, rtype, pidf-lo, error)\n\n module: lost\n\nSends a HELD POST locationRequest to a given URL. Attributes are\nresponseTime and resposeType. The *locationType* property \"exact\" is set\nto \"false\".\n\n- *url* - a URL received via Geolocation header to dereference location\n\n- *rtime* - the response time as defined in [\n  (int)](#lost.p.response_time)\n\n- *rtype* - the response type (location) as defined in [\n  (string)](#lost.p.location_type)\n\n- *pidf-lo* - the PIDF-LO returned in the HELD locationRequest response\n\n- *error* - any error code returned in the HELD response\n\nThe return value is 200..203 on success, 400 if an internal error\noccured, or 500 if an error code is returned in the HELD response.\nSuccess codes in detail are as follows:\n\n- *200* - received 200 OK, but neither location-info nor locationURI\n  element found\n\n- *201* - received 200 OK with locationURI (aka Location-by-Reference)\n\n- *202* - received 200 OK with location-info element (aka\n  Location-by-Value)\n\n- *203* - received 200 OK with location-info and locationURI element\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n    ...\n    # HELD location dereference\n    if ($hdr(Geolocation)=~\"^<http.*$\") {\n        $var(url) = $(hdr(Geolocation){s.select,0,;});\n        $var(res) = lost_held_dereference(\"$(var(url){s.unbracket})\", \"emergencyDispatch\", \"civic geodetic\", \"$var(pidf)\", \"$var(err)\");\n        xlog(\"L_INFO\", \"HELD location dereference: Result code $var(res)\\n$var(pidf)\");\n    ...\n    }\n                    \n\n",
 "lost_query": "### lost_query(con, [pidf-lo, urn,] uri, name, error)\n\n module: lost\n\nSends a LOST findService request to a given connection. PIDF-LO and URN\nare either specified, or, if omitted, parsed from the message body\n(PIDF-LO) and request line (URN). Either \"pidf-lo\" or \"urn\" can be set\nto an empty string in order to be ignored.\n\n- *con* - the name of an existing HTTP connection defined by a httpcon\n  modparam\n\n- *pidf-lo* - the PIDF-LO used to create the LOST findService request\n\n- *urn* - the URN used to create the LOST findService request\n\n- *uri* - the SIP uri returned in the LOST findServiceResponse\n\n- *name* - the display name returned in the LOST findServiceResponse\n\n- *error* - any error code returned in the LOST findServiceResponse\n\nThe return value is 200 on success, 400 if an internal error occured, or\n500 if an error code is returned in the LOST findServiceResponse.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n    ...\n    modparam(\"http_client\", \"httpcon\", \"heldsrv=>http://service.org/api/held\");\n    modparam(\"http_client\", \"httpcon\", \"lostsrv=>http://service.org/api/lost\");\n    ...\n    # HELD location request\n    $var(id) = \"sip:alice@atlanta\";\n    $var(res) = lost_held_query(\"heldsrv\", \"$var(id)\" , \"$var(pidf)\", \"$var(url)\", \"$var(err)\");\n    ...\n    # LOST findService request - pidf-lo and urn as parameter\n    $var(id) = \"urn:service:sos\";\n    $var(res) = lost_query(\"lostsrv\", \"$var(pidf)\", \"$var(urn)\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name)\\n\");\n    ...\n    # LOST findService request - pidf-lo as parameter, urn taken from request line\n    $var(res) = lost_query(\"lostsrv\", \"$var(pidf)\", \"\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name)\\n\");\n    ...\n    # LOST findService request - urn as parameter, pidf-lo taken from message body\n    $var(res) = lost_query(\"lostsrv\", \"\", \"$var(urn)\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name\\n\");\n    ...\n    # LOST findService request - pidf-lo and urn taken from message\n    $var(res) = lost_query(\"lostsrv\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name)\\n\");\n    ...\n                    \n\n",
 "sms_send_msg_to_net": "### sms_send_msg_to_net(network_name)\n\n module: sms\n\nPut the SIP msg in the specified network queue. The function return\nerror if the number encapsulated into SIP message is malformed, if the\ncontent_type is incorrect or because of some internal failures.\n\nMeaning of the parameters is as follows:\n\n- *network_name* - Name of network.\n\n<!-- -->\n\n    ...\n    if (sms_send_msg_to_net(\"D1\"))\n    {\n        if (!t_reply(\"202\", \"yes sir, SMS sent over\"))\n        {\n            # if replying failed, retry statelessly\n            sl_reply_error();\n        };\n    } else {\n        if (!t_reply(\"502\", \"Bad gateway - SMS error\"))\n        {\n            # if replying failed, retry statelessly\n            sl_reply_error();\n        };\n        break;\n    };\n    ...\n            \n\n",
 "sms_send_msg": "### sms_send_msg()\n\n module: sms\n\nThe same as the previous one, but use the default network queue.\n\n    ...\n    if (sms_send_msg_to_net())\n    {\n        if (!t_reply(\"202\", \"yes sir, SMS sent over\"))\n        {\n            # if replying failed, retry statelessly\n            sl_reply_error();\n        };\n    } else {\n        if (!t_reply(\"502\", \"Bad gateway - SMS error\"))\n        {\n            # if replying failed, retry statelessly\n            sl_reply_error();\n        };\n        break;\n    };\n    ...\n            \n",
 "dp_can_connect": "### dp_can_connect()\n\n module: domainpolicy\n\nChecks the interconnection policy of the caller. It uses the domain in\nthe request URI to perform the DP-DDDS algorithm according to\ndraft-lendl-domain-policy-ddds-02 to retrieve the domain's policy\nannouncements. As of this version, only records conforming to\ndraft-lendl-speermint-federations-02 and\ndraft-lendl-speermint-technical-policy-00 are supported.\n\nNon-terminal NAPTR records will cause recursion to the replacement\ndomain. dp_can_connect() will thus look for policy rules in the\nreferenced domain. Furthermore, an AVP for \"domainreplacement\"\n(containing the new domain) will be added to the call. This will\nredirect SRV/A record lookups to the new domain.\n\nIn order to simplify direct domain-based peerings all destination\ndomains are treated as if they contain a top priority \"D2P+SIP:dom\" rule\nwith the domain itself as the value of the rule. Thus any database row\nwith type = 'dom' and rule = 'example.com' will override any dynamic\nDNS-discovered rules.\n\nFor NAPTRs with service-type \"D2P+SIP:fed\", the federation IDs (as\nextracted from the regexp field) are used to retrieve policy records\nfrom a local local database (basically: \"SELECT dp_col_att, dp_col_val\nFROM dp_table WHERE dp_col_rule = '\\[federationID\\]' AND type = 'fed').\nIf records are found (and all other records with the same order value\nare fulfillable) then AVPs will be created from the dp_col_att and\ndp_col_val columns.\n\nFor NAPTRs with service-type \"D2P+SIP:std\", the same procedure is\nperformed. This time, the database lookup searched for type = 'std',\nthough.\n\n\"D2P+SIP:fed\" and \"D2P+SIP:std\" can be mixed freely. If two rules with\nthe same \"order\" match and try to set the same AVP, then the behaviour\nis undefined.\n\nThe dp_col_att column specifies the AVP's name. If the AVP start with\n\"s:\" or \"i:\", the corresponding AVP type (string named or integer named)\nwill be generated. If the exact specifier is omitted, the AVP type will\nbe guessed.\n\nThe dp_col_val column will always be interpreted as string. Thus, the\nAVP's value is always string based.\n\ndp_can_connect returns:\n\n- *-2*: on errors during the evaluation. (DNS, DB, ...)\n\n- *-1*: D2P+SIP records were found, but the policy is not fullfillable.\n\n- *1*: D2P+SIP records were found and a call is possible\n\n- *2*: No D2P+SIP records were found. The destination domain does not\n  announce a policy for incoming SIP calls.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    dp_can_connect();\n    switch(retcode) {\n        case -2:\n            xlog(\"L_INFO\",\"Errors during the DP evaluation\\n\");\n            sl_send_reply(\"404\", \"We can't connect you.\");\n            break;\n        case -1:\n            xlog(\"L_INFO\",\"We can't connect to that domain\\n\");\n            sl_send_reply(\"404\", \"We can't connect you.\");\n            break;\n        case 1:\n            xlog(\"L_INFO\",\"We found matching policy records\\n\");\n            avp_print();\n            dp_apply_policy();\n            t_relay();\n            break;\n        case 2:\n            xlog(\"L_INFO\",\"No DP records found\\n\");\n            t_relay();\n            break;\n    }\n    ...\n            \n\n",
 "dp_apply_policy": "### dp_apply_policy()\n\n module: domainpolicy\n\nThis function sets the destination URI according to the policy returned\nfrom the `dp_can_connect()` function. Parameter exchange between\n`dp_can_connect()` and `dp_apply_policy()` is done via AVPs. The AVPs\ncan be configured in the module's parameter section.\n\nNote: The name of the AVPs must correspond with the names in the *att*\ncolumn in the domainpolicy table.\n\nSetting the following AVPs in `dp_can_connect()` (or by any other means)\ncause the following actions in `dp_apply_policy()`:\n\n- *port_override_avp*: If this AVP is set, the port in the destination\n  URI is set to this port. Setting an override port disables NAPTR and\n  SRV lookups according to RFC 3263.\n\n- *transport_override_avp*: If this AVP is set, the transport parameter\n  in the destination URI is set to the specified transport (\"udp\",\n  \"tcp\", \"tls\"). Setting an override transport also disables NAPTR\n  lookups, but retains an SRV lookup according to RFC 3263.\n\n- *domain_replacement_avp*: If this AVP is set, the domain in the\n  destination URI will be replaced by this domain.\n\n  A non-terminal NAPTR and thus a referral to a new domain implicitly\n  sets *domain_replacement_avp* to the new domain.\n\n- *domain_prefix_avp*: If this AVP is set, the domain in the destination\n  URI will be prefixed with this \"subdomain\". E.g. if the domain in the\n  request URI is \"example.com\" and the domain_prefix_avp contains\n  \"inbound\", the domain in the destination URI is set to\n  \"inbound.example.com\".\n\n- *domain_suffix_avp*: If this AVP is set, the domain in the destination\n  URI will have the content of the AVP appended to it. E.g. if the\n  domain in the request URI is \"example.com\" and the domain_suffix_avp\n  contains \"myroot.com\", the domain in the destination URI is set to\n  \"example.com.myroot.com\".\n\n- *send_socket_avp*: If this AVP is set, the sending socket will be\n  forced to the socket in the AVP. The payload format of this AVP must\n  be \\[proto:\\]ip_address\\[:port\\].\n\nIf both prefix/suffix and domain replacements are used, then the\nreplacement is performed first and the prefix/suffix are applied to the\nnew domain.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (dp_apply_policy()) {\n        t_relay();\n    }\n    ...\n            \n\n",
 "consume_credentials": "### consume_credentials()\n\n module: auth\n\nThis function removes previously authorized credential headers from the\nmessage being processed by the server. That means that the downstream\nmessage will not contain credentials there were used by this server.\nThis ensures that the proxy will not reveal information about\ncredentials used to downstream elements and also the message will be a\nlittle bit shorter. The function must be called after `www_authorize`,\n`proxy_authorize`, `www_authenticate` or `proxy_authenticate`.\n\n    ...\n    if (www_authenticate(\"realm\", \"subscriber\")) {\n        consume_credentials();\n    }\n    ...\n            \n\n",
 "has_credentials": "### has_credentials(realm)\n\n module: auth\n\nThis function returns true if the request has Authorization or\nProxy-Authorization header with provided realm. The parameter can be\nstring with pseudo-variables.\n\n    ...\n    if (has_credentials(\"myrealm\")) {\n        ...\n    }\n    ...\n            \n\n",
 "www_challenge": "### www_challenge(realm, flags)\n\n module: auth\n\nThe function challenges a user agent. It will generate a WWW-Authorize\nheader field containing a digest challenge, it will put the header field\ninto a response generated from the request the server is processing and\nsend the 401 reply. Upon reception of such a reply the user agent should\ncompute credentials and retry the request. For more information\nregarding digest authentication see RFC2617. See module parameter\nforce_stateless_reply regarding sending of the reply.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests, the To\n  header field domain (e.g., variable \\$td) can be used (because this\n  header field represents the user being registered), for all other\n  messages From header field domain can be used (e.g., variable \\$fd).\n\n  The string may contain pseudo variables.\n\n- *flags* - Value of this parameter can be a bitmask of following:\n\n  - *1* - build challenge header with qop=auth\n\n  - *2* - build challenge header with qop=auth-int\n\n  - *4* - do not send '500 Internal Server Error' reply automatically in\n    failure cases (error code is returned to config)\n\n  - *16* - build challenge header with stale=true\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!www_authenticate(\"$td\", \"subscriber\")) {\n        www_challenge(\"$td\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "proxy_challenge": "### proxy_challenge(realm, flags)\n\n module: auth\n\nThe function challenges a user agent. It will generate a Proxy-Authorize\nheader field containing a digest challenge, it will put the header field\ninto a response generated from the request the server is processing and\nsend the 407 reply. Upon reception of such a reply the user agent should\ncompute credentials and retry the request. For more information\nregarding digest authentication see RFC2617. See module parameter\nforce_stateless_reply regarding sending of the reply.\n\nMeaning of the parameters is the same as for function\nwww_challenge(realm, flags)\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!proxy_authenticate(\"$fd\", \"subscriber\")) {\n        proxy_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "auth_challenge": "### auth_challenge(realm, flags)\n\n module: auth\n\nThe function challenges a user agent for authentication. It combines the\nfunctions www_challenge() and proxy_challenge(), by calling internally\nthe first one for REGISTER requests and the second one for the rest of\nother request types. In other words, it challenges for authentication by\nsending a 401 reply for REGISTER requests and 407 reply for the other\ntypes of SIP requests.\n\nMeaning of the parameters the same as for function www_challenge(realm,\nflags)\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!auth_check(\"$fd\", \"subscriber\", \"1\")) {\n        auth_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "pv_www_authenticate": "### pv_www_authenticate(realm, passwd, flags [, method])\n\n module: auth\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nNegative codes may be interpreted as follows:\n\n- *-1 (generic error)* - some generic error occurred and no reply was\n  sent out\n\n- *-2 (invalid password)* - wrong password\n\n- *-4 (nonce expired)* - the nonce has expired\n\n- *-5 (no credentials)* - request does not contain an Authorization\n  header with the correct realm\n\n- *-6 (nonce reused)* - the nonce has already been used to authenticate\n  a previous request\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests To header\n  field domain (e.g., variable \\$td) can be used (because this header\n  field represents a user being registered), for all other messages From\n  header field domain can be used (e.g., variable \\$fd).\n\n  The string may contain pseudo variables.\n\n- *passwd* - the password to be used for authentication. Can contain\n  config variables. The Username is taken from Auth header.\n\n- *flags* - the value of this parameter can be a bitmask of following:\n\n  - *1* - the value of password parameter is HA1 format\n\n  - *2* - build challenge header with no qop and add it to avp\n\n  - *4* - build challenge header with qop=auth and add it to avp\n\n  - *8* - build challenge header with qop=auth-int and add it to avp\n\n  - *16* - build challenge header with stale=true\n\n  - *32* - don't invalidate nc on authentication failure\n\n- *method* - the method to be used for authentication. This parameter is\n  optional and if not set is the first \"word\" on the request-line.\n\nWhen challenge header is built and stored in avp, append_to_reply() and\nthe sl reply functions can be used to send appropriate SIP reply to\nchallenge for authentication.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!pv_www_authenticate(\"$td\", \"123abc\", \"0\")) {\n        www_challenge(\"$td\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "pv_proxy_authenticate": "### pv_proxy_authenticate(realm, passwd, flags)\n\n module: auth\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again. For more about\nthe negative return codes, see the above function.\n\nMeaning of the parameters is the same as for pv_www_authenticate(realm,\npasswd, flags)\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    $avp(password)=\"xyz\";\n    if (!pv_proxy_authenticate(\"$fd\", \"$avp(password)\", \"0\")) {\n        proxy_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "pv_auth_check": "### pv_auth_check(realm, passwd, flags, checks)\n\n module: auth\n\nThe function combines the functionalities of `pv_www_authenticate` and\n`pv_proxy_authenticate`, first being executed if the SIP request is a\nREGISTER, the second for the rest.\n\nMeaning of the first three parameters is the same as for\npv_www_authenticate(realm, passwd, flags).\n\nParameter *checks* can be used to control the behaviour of the function.\nIf it is 1, then the function will check to see if the authentication\nusername matches either To or From header username, a matter of whether\nit is for a REGISTER request or not. The parameter may be a pseudo\nvariable.\n\nThe set of possible return codes is the same than\npv\\_{www,proxy}\\_authenticate, with one more possible value:\n\n*-8 (auth user mismatch)* - the auth user is different than the From/To\nuser\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    $avp(password)=\"xyz\";\n    if (!pv_auth_check(\"$fd\", \"$avp(password)\", \"0\", \"1\")) {\n        auth_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "auth_get_www_authenticate": "### auth_get_www_authenticate(realm, flags, pvdest)\n\n module: auth\n\nBuild WWW-Authentication header and set the resulting value in 'pvdest'\npseudo-variable parameter.\n\nMeaning of the realm and flags parameters is the same as for\npv_www_authenticate(realm, passwd, flags)\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (auth_get_www_authenticate(\"$fd\", \"0\", \"$var(wauth)\")) {\n        xlog(\"www authenticate header is [$var(wauth)]\\n\");\n    }\n    ...\n",
 "is_user_in": "### is_user_in(URI, group)\n\n module: group\n\nThis function is to be used for script group membership. The function\nreturns true if username in the given URI is a member of the given group\nand false if not.\n\nMeaning of the parameters is as follows:\n\n- *URI* - URI whose username and optionally domain to be used, this can\n  be one of:\n\n  - Request-URI - Use Request-URI username and (optionally) domain.\n\n  - To - Use To username and (optionally) domain.\n\n  - From - Use From username and (optionally) domain.\n\n  - Credentials - Use digest credentials username.\n\n  - \\$avp(name) - Use the URI from the AVP specified by this\n    pseudo-variable.\n\n- *group* - Name of the group to check.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (is_user_in(\"Request-URI\", \"ld\")) {\n        ...\n    };\n    ...\n\n",
 "get_user_group": "### get_user_group(URI, AVP)\n\n module: group\n\nThis function is to be used for regular expression based group\nmembership. The function returns true if username in the given URI\nbelongs to at least one group; the group ID(s) are returned as AVPs.\n\nMeaning of the parameters is as follows:\n\n- *URI* - URI to be matched against the regular expressions:\n\n  - Request-URI - Use Request-URI\n\n  - To - Use To URI.\n\n  - From - Use From URI\n\n  - Credentials - Use digest credentials username and realm.\n\n  - \\$avp(name) - Use the URI from the AVP specified by this\n    pseudo-variable.\n\n- *AVP* - \\$avp(name) - the matched group IDs are returned in this AVP.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (get_user_group(\"Request-URI\", \"$avp(i:10)\")) {\n        xgdb(\"User $ru belongs to $(avp(i:10)[*]) group(s)\\n\");\n        ....\n    };\n    ...\n",
 "engage_media_proxy": "### engage_media_proxy()\n\n module: mediaproxy\n\nTrigger the use of MediaProxy for all the dialog requests and replies\nthat have an SDP body. This needs to be called only once for the first\nINVITE in a dialog. After that it will use the dialog module to trace\nthe dialog and automatically call use_media_proxy() on every request and\nreply that belongs to the dialog and has an SDP body. When the dialog\nends it will also call automatically end_media_session(). All of these\nare called internally on dialog callbacks, so for this function to work,\nthe dialog module must be loaded and configured.\n\nThis function is an advanced mechanism to use a media relay without\nhaving to manually call a function on each message that belongs to the\ndialog. However this method is less flexible, because once things were\nset in motion by calling this function on the first INVITE, it cannot be\nstopped, not even by calling end_media_session(). It will only stop when\nthe dialog ends. Until then it will modify the SDP content of every\nin-dialog message to make it use a media relay. If one needs more\ncontrol over the process, like starting to use mediaproxy only later in\nthe failure route, or stopping to use mediaproxy in the failure route,\nthen the use_media_proxy and end_media_session functions should be used,\nand manually called as appropriate. Using this function should NOT be\nmixed with either of use_media_proxy() or end_media_session().\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (method==INVITE && !has_totag()) {\n        # We can also use a specific media relay if we need to\n        #$avp(media_relay) = \"1.2.3.4\";\n        engage_media_proxy();\n    }\n    ...\n            \n\n",
 "use_media_proxy": "### use_media_proxy()\n\n module: mediaproxy\n\nWill make a call to the dispatcher and replace the IPs and ports in the\nSDP body with the ones returned by the media relay for each supported\nmedia stream in the SDP body. This will force the media streams to be\nrouted through the media relay. If a mix of supported and unsupported\nstreams are present in the SDP, only the supported streams will be\nmodified, while the unsupported streams will be left alone.\n\nThis function should NOT be mixed with engage_media_proxy().\n\nThis function has the following return codes:\n\n- +1 - successfully modified message (true value)\n\n- -1 - error in processing message (false value)\n\n- -2 - missing SDP body, nothing to process (false value)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if (method==INVITE) {\n        # We can also use a specific media relay if we need to\n        #$avp(media_relay) = \"1.2.3.4\";\n        use_media_proxy();\n    }\n    ...\n            \n\n",
 "end_media_session": "### end_media_session()\n\n module: mediaproxy\n\nWill call on the dispatcher to inform the media relay to end the media\nsession. This is done when a call ends, to instruct the media relay to\nrelease the resources allocated to that call as well as to save logging\ninformation about the media session. Called on BYE, CANCEL or failures.\n\nThis function should NOT be mixed with engage_media_proxy().\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if (method==BYE) {\n        end_media_session();\n    }\n    ...\n            \n",
 "avp_db_load": "### avp_db_load(source, name)\n\n module: avpops\n\nLoads from DB into memory the AVPs corresponding to the given *source*.\nIf given, it sets the script flags for loaded AVPs. It returns true if\nit loaded some values in AVPs, false otherwise (db error, no avp loaded\n...).\n\nMeaning of the parameters is as follows:\n\n- *source* - what info is used for identifying the AVPs. Parameter\n  syntax:\n\n  - *source = (pvar\\|str_value)\n    \\['/'('username'\\|'domain'\\|'uri'\\|'uuid')\\])*\n\n  - *pvar = any pseudo variable defined in Kamailio. If the pvar is \\$ru\n    (request uri), \\$fu (from uri), \\$tu (to uri) or \\$ou (original\n    uri), then the implicit flag is 'uri'. Otherwise, the implicit flag\n    is 'uuid'.*\n\n- *name* - which AVPs will be loaded from DB into memory. Parameter\n  syntax is:\n\n  - *name = avp_spec\\['/'(table_name\\|'\\$'db_scheme)\\]*\n\n  - *avp_spec = matching_flags\\|\\$avp(avp_name)\\|\\$avp(avp_alias)*\n\n  - *matching_flags = 'a' \\| 'A' \\| 'i' \\| 'I' \\| 's' \\| 'S'\n    \\[script_flags\\]*\n\n    'a' or 'A' means matching any of AVP name types ('i' and 's') (NOTE:\n    matching_flags cannot be used with \\$db_scheme because the name of\n    AVP to save in cannot be specified), the rest have the meaning\n    described in 'AVP naming format' chapter.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_db_load(\"$fu\",\"$(i:678)\");\n    avp_db_load(\"$ru/domain\",\"i:/domain_preferences\");\n    avp_db_load(\"$uuid\",\"$avp(s:404fwd)/fwd_table\");\n    avp_db_load(\"$ru\",\"$avp(i1:123)/$some_scheme\");\n    ...\n                    \n\n",
 "avp_db_store": "### avp_db_store(source, name)\n\n module: avpops\n\nStores to DB the AVPs corresponding to the given *source*.\n\nThe meaning and usage of the parameters are identical as for\n*avp_db_load(source,name)* function. Please refer to its description.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_db_store(\"$tu\",\"$avp(i:678)\");\n    avp_db_store(\"$ru/username\",\"$avp(email)\");\n    ...\n                    \n\n",
 "avp_db_delete": "### avp_db_delete(source, name)\n\n module: avpops\n\nDeletes from DB the AVPs corresponding to the given *source*.\n\nThe meaning and usage of the parameters are identical as for\n*avp_db_load(source,name)* function. Please refer to its description.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_db_delete(\"$tu\",\"$avp(i:678)\");\n    avp_db_delete(\"$ru/username\",\"$avp(email)\");\n    avp_db_delete(\"$uuid\",\"$avp(s:404fwd)/fwd_table\");\n    ...\n                    \n\n",
 "avp_db_query": "### avp_db_query(query[, dest])\n\n module: avpops\n\nMake a database query and store the result in AVPs. This command is\ndeprecated, please use the more flexible and advanced *sqlops* module\ninstead.\n\nThe meaning and usage of the parameters:\n\n- *query* - must be a valid SQL query. The parameter can contain\n  pseudo-variables.\n\n  You must escape any pseudo-variables manually to prevent SQL injection\n  attacks. You can use the existing transformations *escape.common* and\n  *unescape.common* to escape and unescape the content of any\n  pseudo-variable. Failing to escape the variables used in the query\n  makes you vulnerable to SQL injection, e.g. make it possible for an\n  outside attacker to alter your database content.\n\n- *dest* - a list with AVP names where to store the result. The format\n  is \u201c\\$avp(name1);\\$avp(name2);...\u201d. If this parameter is ommited, the\n  result is stored in \u201c\\$avp(i:1);\\$avp(i:2);...\u201d. If the result gives\n  many rows, then multiple AVPs with corresponding name will be added.\n  The value type of the AVP (string or integer) will be derived from the\n  type of the columns. Please note that only this two datatypes are\n  supported, so it is not possible for example to return floating point\n  or big integer values this way.\n\nThe function delivers the following return-codes:\n\n- *-1* - An error occurred while querying the database (e.g. wrong SQL\n  or database error)\n\n- *1* - Query was successful\n\n- *-2* - Query was successful, but no rows where returned.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_db_query(\"select password, ha1 from subscriber where username='$tu'\",\n        \"$avp(i:678);$avp(i:679)\");\n    avp_db_query(\"delete from subscriber\");\n    ...\n                    \n\n",
 "avp_delete": "### avp_delete(name)\n\n module: avpops\n\nDeletes from memory the AVPs with *name* or, if empty, all AVPs.\n\nMeaning of the parameters is as follows:\n\n- *name* - which AVPs will be deleted from memory. Parameter syntax is:\n\n  - *name = (matching_flags\\|avp_name\\|avp_alias)\\['/'flag\\]*\n\n  - *matching_flags = please refer to avp_db_load() function*\n\n  - *flag = 'g'\\|'G' = deletes not only the last value but the complete\n    AVP.*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_delete(\"$avp(i:678)/g\");\n    avp_delete(\"$avp(email)\");\n    avp_delete(\"i\");\n    avp_delete(\"a3\");\n    ...\n                    \n\n",
 "avp_pushto": "### avp_pushto(destination, name)\n\n module: avpops\n\nPushes the value of AVP(s) into the SIP message.\n\nMeaning of the parameters is as follows:\n\n- *destination* - as what will be the AVP value pushed into SIP message.\n  Parameter syntax:\n\n  - *destination = '\\$ru' \\['/'('username'\\|'domain')\\] \\| '\\$du' \\|\n    '\\$br'*\n\n  - *\\$ru '\\['/'('username'\\|'domain')\\] - write the AVP in the request\n    URI or in username/domain part of it*\n\n  - *\\$du - write the AVP in 'dst_uri' field*\n\n  - *\\$br - write the AVP directly as a new branch (does not affect\n    RURI)*\n\n- *name* - which AVP(s)/pseudo-variable should be pushed into the SIP\n  message. Parameter syntax is:\n\n  - *name = ( avp_name \\| avp_alias \\| pvar_name )\\['/'flags\\]*\n\n  - *flags = 'g' - effective only with AVPs*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_pushto(\"$ru/domain\",\"$fd\");\n    avp_pushto(\"$ru\",\"$avp(i:678)\");\n    avp_pushto(\"$ru/domain\",\"$avp(s:backup_domains)/g\");\n    avp_pushto(\"$du\",\"$avp(i:679)\");\n    avp_pushto(\"$br\",\"$avp(i:680)\");\n    ...\n                    \n\n",
 "avp_check": "### avp_check(name, op_value)\n\n module: avpops\n\nChecks the value of the AVP(s) against an operator and value.\n\nMeaning of the parameters is as follows:\n\n- *name* - which AVP(s) should be checked. Parameter syntax is:\n\n  - *name = ( pseudo-variable )*\n\n- *op_value* - define the operator, the value and flags for checking.\n  Parameter syntax is:\n\n  - *op_value = operator '/' value \\['/'flags\\]*\n\n  - *operator = 'eq' \\| 'ne' \\| 'lt' \\| 'le' \\| 'gt' \\| 'ge' \\| 're' \\|\n    'fm' \\| 'and' \\| 'or' \\| 'xor'*\n\n  - *value = pseudo-variable \\| fix_value*\n\n  - *fix_value = 'i:'integer \\| 's:'string \\| string*\n\n  - *flags = 'g' \\| 'G' \\| 'i' \\| 'I'*\n\n  Operator meaning:\n\n  - *eq* - equal\n\n  - *ne* - not equal\n\n  - *lt* - less than\n\n  - *le* - less or equal\n\n  - *gt* - greater than\n\n  - *ge* - greater or equal\n\n  - *re* - regexp (regular expression match)\n\n  - *fm* - fast match (see: man fnmatch)\n\n  - *and* - bitwise 'and'\n\n  - *or* - bitwise 'or'\n\n  - *xor* - bitwise 'xor'\n\n  Integer values can be given in hexadecimal using notation:\n  'i:0xhex_number' (e.g.,: 'i:0xabcd');\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_check(\"$avp(i:678)\", \"lt/i:345/g\");\n    avp_check(\"$fd\",\"eq/$td/I\");\n    avp_check(\"$avp(s:foo)\",\"gt/$avp($var(bar))/g\");\n    avp_check(\"$avp(s:foo)\",\"re/sip:.*@bar.net/g\");\n    avp_check(\"$avp(s:foo)\",\"fm/$avp(fm_avp)/g\");\n    ...\n                    \n\nNOTE: you can use a xavp variable\n(\\$xavp(key1\\[indx1\\]=\\>key2\\[indx2\\])) as first or second parameter. If\nyou want to check all the values of the key2 you should use \\[\\*\\] at\nindx2. The \\[\\*\\] index is not allowed at indx1.\n\n    ...\n    avp_check(\"$xavp(op[0]=>lt[0])\", \"lt/i:345/g\");\n    avp_check(\"$xavp(op=>fd\",\"eq/$td/I\");\n    avp_check(\"$xavp(op[1]=>foo[*])\",\"gt/$avp($var(bar))/g\");\n    avp_check(\"$avp(s:foo)\",\"re/$xavp(op[0]=>re[*]/g\");\n    $var(id)=2;\n    avp_check(\"$xavp(op=>foo[*])\",\"fm/$xavp(op=>fm[$var(id)])/g\");\n    ...\n                    \n\n",
 "avp_copy": "### avp_copy(old_name, new_name)\n\n module: avpops\n\nCopy / move an avp under a new name.\n\nMeaning of the parameters is as follows:\n\n- *name1* - which AVP(s) should be copied/moved. Parameter syntax is:\n\n  - *name = ( avp_name \\| avp_alias )*\n\n- *name2* - the new name of the copied/moved AVP(s). Parameter syntax\n  is:\n\n  - *name = ( avp_name \\| avp_alias ) \\['/'flags\\]*\n\n  - *flags = 'g' \\| 'G' \\| 'd' \\| 'D' \\| 'n' \\| 'N' \\| 's' \\| 'S'*\n\nNOTE: if a list of AVPs is copied/moved (flag g\\|G), then the order of\nthe values is reversed. Copy/move twice in order to get the same order\nas in original list.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    avp_copy(\"$avp(i:678)\", \"$avp(s:345)/g\");\n    avp_copy(\"$avp(old)\",\"$avp(new)/gd\");\n    ...\n                    \n\n",
 "avp_printf": "### avp_printf(dest, format)\n\n module: avpops\n\nNOTE: since Kamailio 1.3.0 the function has been moved to core and it is\nan alias to pv_printf().\n\nPrints the formatted string 'format' in the AVP 'dest'. The 'format'\nparameter can include any pseudo-variable defined in Kamailio. The list\nwith all pseudo-variables in Kamailio can be found at:\n<https://www.kamailio.org/wikidocs/>\n\nMeaning of the parameters is as follows:\n\n- *dest* - in which AVP should be stored the result. Parameter syntax\n  is:\n\n  - *name = ( avp_name \\| avp_alias )*\n\n- *format* - the formatted string to be printed in 'dest' AVP.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_printf(\"$avp(i:20)\", \"This is a $rm request with call-id $hdr(call-id)\");\n    ...\n                    \n\n",
 "avp_subst": "### avp_subst(avps, subst)\n\n module: avpops\n\nPerl/sed-like subst applied to AVPs having string value.\n\nMeaning of the parameters is as follows:\n\n- *avps* - source AVP, destination AVP and flags. Parameter syntax is:\n\n  - *avps = src_avp \\[ '/' dst_avp \\[ '/' flags \\] \\]*\n\n  - *src_avp = ( avp_name \\| avp_alias )*\n\n  - *dst_avp = ( avp_name \\| avp_alias ) - if dst_avp is missing then\n    the value of src_avp will be replaced*\n\n  - *flags = ( d \\| D \\| g \\| G ) -- (d, D - delete source avp; g, G -\n    apply to all avps matching src_avp name)*\n\n- *subst* - perl/sed-like reqular expression. Parameter syntax is:\n\n  - *subst = \"/regexp/replacement/flags\"*\n\n  - *regexp - regular expression*\n\n  - *replacement - replacement string, can include pseudo-variables and\n    \\1, ..., \\9 for matching tokens, \\0 for whole matching text*\n\n  - *flags = 'g' \\| 'G' \\| 'i' \\| 'i' (g, G - replace all matching\n    tokens; i, I - match ignore case)*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    # if avp i:678 has a string value in e-mail format, replace the\n    # domain part with the value of domain part from R-URI\n    avp_subst(\"$avp(i:678)\", \"/(.*)@(.*)/\\1@$rd/\");\n\n    # if any avp i:678 has a string value in e-mail format, replace the\n    # domain part with the value of domain part from R-URI\n    # and place the result in avp i:679\n    avp_subst(\"$avp(i:678)/$avp(i:679)/g\", \"/(.*)@(.*)/\\1@$rd/\");\n    ...\n                    \n\nIMPORTANT NOTE: if the replacement string includes src_avp or dst_avp\nyou will get something that you may not expect. In case you have many\nsrc_avp and you make the substitution to be applied to all of them,\nafter the first src_avp is processed, it will be added in avp list and\nnext processing will use it.\n\n",
 "avp_subst_pv": "### avp_subst_pv(avps, subst)\n\n module: avpops\n\nSame functionality than avp_subst() but seccond parameter will be\nevaluated first.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    $(avp(src)[*]) = \"testME\";\n    $var(z) = \"j\";\n    $var(y) = \"e\";\n    $var(x) = \"/\" + $var(y) + \"/\" + $var(z) + \"/gi\";\n\n    ## all this calls will produce the same result \"tjstMj\"\n    avp_subst_pv(\"$avp(src)\", \"/e/j/gi\");\n    avp_subst_pv(\"$avp(src)\", \"/\" + $var(y) + \"/\" + $var(z) + \"/gi\");\n    avp_subst_pv(\"$avp(src)\", \"/$var(y)/$var(z)/gi\");\n    avp_subst_pv(\"$avp(src)\", \"$var(x)\");\n    ...\n                    \n\n",
 "avp_op": "### avp_op(name, op_value)\n\n module: avpops\n\nDifferent integer operations with avps.\n\nMeaning of the parameters is as follows:\n\n- *name* - 'source_avp/destination_avp' - which AVP(s) should be\n  processed and where to store the result. If 'destination_avp' is\n  missing, same name as 'source_avp' is used to store the result.\n\n  Parameter syntax is:\n\n  - *name = ( source_avp\\[/destination_avp\\] )*\n\n    *source_avp = ( avp_name \\| avp_alias )*\n\n    *destination_avp = ( avp_name \\| avp_alias )*\n\n- *op_value* - define the operation, the value and flags. Parameter\n  syntax is:\n\n  - *op_value = operator '/' value \\['/'flags\\]*\n\n  - *operator = 'add' \\| 'sub' \\| 'mul' \\| 'div' \\| 'mod' \\| 'and' \\|\n    'or' \\| 'xor' \\| 'not'*\n\n  - *value = pseudo-variable \\| fix_value*\n\n  - *fix_value = 'i:'integer*\n\n  - *flags = 'g' \\| 'G' \\| 'd' \\| 'D'*\n\n  Integer values can be given in hexadecimal using notation\n  'i:0xhex_number' (e.g.,: 'i:0xabcd');\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_op(\"$avp(i:678)\", \"add/i:345/g\");\n    avp_op(\"$avp(number)\",\"sub/$avp(number2)/d\");\n    ...\n                    \n\n",
 "is_avp_set": "### is_avp_set(name)\n\n module: avpops\n\nCheck if any AVP with *name* is set.\n\nMeaning of the parameters is as follows:\n\n- *name* - name of AVP to look for. Parameter syntax is:\n\n  - *name = avp_name\\|avp_alias \\[ '/' flags \\])*\n\n    *flags = ('e'\\|'s'\\|'n') - e = empty value; s = value string; n =\n    value number (int)*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    if(is_avp_set(\"$avp(i:678)\"))\n        log(\"AVP with integer id 678 exists\\n\");\n    ...\n                    \n\n",
 "avp_print": "### avp_print()\n\n module: avpops\n\nPrints the list with all the AVPs from memory. This is only a\nhelper/debug function.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    avp_print();\n    ...\n                    \n",
 "app_python3s_exec": "### app_python3s_exec(method [, param])\n\n module: app_python3s\n\nExecute the Python function with the name given by the parameter\n'method'. Optionally can be provided a second string with the parameter\nto be passed to the Python function.\n\nBoth parameters can contain pseudo-variables.\n\n    ...\n    app_python3s_exec(\"my_python_function\");\n    app_python3s_exec(\"my_python_function\", \"my_params\");\n    app_python3s_exec(\"my_python_function\", \"$rU\");\n    ...\n\n",
 "msrp_relay": "### msrp_relay()\n\n module: msrp\n\nRelay MSRP frame according to the To-Path. This function has to be\nexecuted for each MSRP request or reply that has to be forwarded. Note\nthat due to nature of the MSRP transport layer, which is reliable\n(TCP/TLS), there is no retransmission of MSRP frames.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        msrp_relay();\n    }\n    ...\n\n",
 "msrp_reply": "### msrp_reply(code, text [, hdrs])\n\n module: msrp\n\nSend a reply for the current MSRP request, adding optional headers.\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        msrp_reply(\"403\", \"Not allowed\");\n    }\n    ...\n\n",
 "msrp_is_request": "### msrp_is_request()\n\n module: msrp\n\nReturn true if the MSRP frame is a request.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        if(msrp_is_request())\n        {\n            msrp_relay();\n            exit;\n        }\n    }\n    ...\n\n",
 "msrp_is_reply": "### msrp_is_reply()\n\n module: msrp\n\nReturn true if the MSRP frame is a reply.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        if(msrp_is_reply())\n        {\n            msrp_relay();\n            exit;\n        }\n    }\n    ...\n\n",
 "msrp_set_dst": "### msrp_set_dst(addr, sock)\n\n module: msrp\n\nSet destination attributes: addr - target address as MSRP URI; sock -\nlocal socket to be used (format 'proto:ip:port').\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        ...\n        msrp_set_dst(\"msrp://127.0.0.1:8000\", \"tcp:127.0.0.1:5060\");\n        ...\n    }\n    ...\n\n",
 "msrp_relay_flags": "### msrp_relay_flags(flags)\n\n module: msrp\n\nSet transport layer sending flags for forwarding current MSRP frame;\nflags - a bitmask of flags - 1 (don't create a new connection), 2 (close\nconnection after send).\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        ...\n        msrp_relay_flags(\"1\");\n        ...\n    }\n    ...\n\n",
 "msrp_reply_flags": "### msrp_reply_flags(flags)\n\n module: msrp\n\nSet transport layer sending flags for replies to the current MSRP frame;\nflags - a bitmask of flags - 1 (don't create a new connection), 2 (close\nconnection after send).\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        ...\n        msrp_reply_flags(\"1\");\n        ...\n    }\n    ...\n\n",
 "msrp_cmap_save": "### msrp_cmap_save()\n\n module: msrp\n\nSave details of a MSRP connection upon AUTH request inside the internal\nmap table, indexed by session id.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        ...\n        if(method==\"AUTH\") { msrp_cmap_save(); exit; }\n        ...\n    }\n    ...\n\n",
 "msrp_cmap_lookup": "### msrp_cmap_lookup()\n\n module: msrp\n\nLookup MSRP connection details for current session id.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[msrp:frame-in] {\n        ...\n        if(method==\"SEND\" and $msrp(nexthops)==1) {\n            if(msrp_cmap_lookup()) {\n                msrp_relay();\n            } else {\n                msrp_reply(\"481\", \"Session not found\");\n            }\n        }\n        ...\n    }\n    ...\n\n",
 "sd_journal_print": "### sd_journal_print(level, text)\n\n module: log_systemd\n\nPrint the text in the systemd journal at the provided level parameter.\n\nBoth parameters can contain variables.\n\nFor more, see the manual page for function sd_journal_print() in C\nlibrary libsystemd.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n       sd_journal_print(\"LOG_INFO\", \"R-URI is $ru\\n\");\n    ...\n\n",
 "sd_journal_send_xavp": "### sd_journal_send_xavp(name)\n\n module: log_systemd\n\nCreates a structured log event in journald.\n\nThe sd_journal_send_xavp(name) function sends a log event in journald,\nbased on the fields provided in the xavp whose root name is specified as\nparameter. This function is a wrapper for journald's *sd_journal_send()*\nfunction, and allows to specify as many custom fields as desired (see\n*sd_journal_send(3)*).\n\nThe xavp given as parameter must contain child AVPs with names\nconforming to journald's field name policy (only uppercase letters,\nnumbers and underscore), otherwise they will be discarded by journald.\n\nSome field name have a default meaning for journald:\n\n- *MESSAGE*: the human-readable message string for this entry.\n\n- *PRIORTTY*: integer priority value between 0 (\"emerg\") and 7 (\"debug\")\n\n- (...) (see *systemd.journald-fields(7)*)\n\nThis function can be used from ANY_ROUTE.\n\n    request_route {\n        $xavp(event=>MESSAGE) = $rm + \" request logged with journald\";\n        $xavp(event[0]=>SIP_MESSAGE) = $mb;\n    # don't forget the '[0]', otherwise kamailio will create and\n    # stack new AVPs (see pseudovariable documentation) over the previous one\n        $xavp(event[0]=>SIP_CALL_ID) = $ci;\n        $xavp(event[0]=>SIP_SRC_PORT) = $sp;\n        $xavp(event[0]=>PRIORITY) = 6;\n        sd_journal_send_xavp(\"event\");\n    (...)\n    }\n",
 "pua_json_publish": "### pua_json_publish(json_payload)\n\n module: pua_json\n\nThe function build presentity state from json_payload and updates\npresentity table.\n\nUsage: presence related.\n\nThis function can be used from ANY ROUTE.\n\n    ...\n    event_route[xhttp:request] {\n        $var(call-id) = $(rb{json.parse,Call-ID});\n        if ($(rb{json.parse,Event-Package}) == \"dialog\") {\n            xlog(\"L_INFO\", \"$var(call-id)|log|received $(rb{json.parse,Event-Package}) update for $(rb{json.parse,From})\");\n            pua_json_publish($rb);\n        }\n    }\n    ...\n",
 "sipt_destination": "### sipt_destination(destination, hops, nai[, terminator=1])\n\n module: sipt\n\nupdates the IAM in the body if it exists, setting the called party\nnumber to \u201cdestination\u201d with the nature address specified in \u201cnai\u201d and\ndecrementing the hop counter value if present. If the hop counter header\nis missing it will be added with the value of \u201chops\u201d. If \u201cterminator\u201d is\nset to 1, then F will be appended to digit string to indicate the number\nis complete (default).\n\n    ...\n    # update the destination number to our current request uri,\n    # setting nature of address to international\n    $rU = \"19495551234\";\n    sipt_destination($rU, 31, 4);\n    ...\n\n",
 "sipt_set_bci_1": "### sipt_set_bci_1(charge_indicator, called_status, called_category, e2e_indicator)\n\n module: sipt\n\nupdates the first byte of the backward call indicator in the ACM or COT\nin the body if setting the Charge Indicator to \u201ccharge_indicator\u201d, the\nCalled party's status indicator in \u201ccalled_status\u201d, the Called party's\ncategory indicator in \u201ccalled_category\u201d and the End to End Method\nIndicator with the value of the value of \u201ce2e_indicator\u201d.\n\n    ...\n    # set bci for charging, subscriber free, ordinary, no e2e available\n    sipt_set_bci_1(\"2\", \"1\", \"1\", \"0\");\n    ...\n\n",
 "sipt_set_calling": "### sipt_set_calling(origin, nai, presentation, screening)\n\n module: sipt\n\nupdates the IAM in the body if it exists, setting (or adding) the\ncalling party number to \u201corigin\u201d with the nature address specified in\n\u201cnai\u201d and setting the presentation and screening values to\n\u201cpresentation\u201d and \u201cscreening\u201d.\n\n    ...\n    # update the calling party to the value in the from header\n    sipt_set_calling($fU, 4, 0, 3);\n    ...\n\n",
 "sipt_forwarding": "### sipt_forwarding(origin, nai)\n\n module: sipt\n\nupdates the IAM in the body if it exists, setting (or adding) the\nforwarding number to \u201corigin\u201d with the nature address specified in\n\u201cnai\u201d.\n\n    ...\n    # update the forwarding number to the value in the from header\n    sipt_forwarding($avp(s:forwarding_number), 3);\n    ...\n\n",
 "sipt_has_isup_body": "### sipt_has_isup_body()\n\n module: sipt\n\nThe function returns *true* if the SIP message has an ISUP body\nattached.\n\n    ...\n    if(sipt_has_isup_body())\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "evapi_relay": "### evapi_relay(evdata)\n\n module: evapi\n\nRelay the event data given as parameter to connected applications.\n\nThe format on the network is netstring with evdata payload if\nnetstring_format parameter is set to 1 or bare evdata if\nnetstring_format parameter is set to 0.\n\nThe function is passing the task to evapi dispatcher process, therefore\nthe SIP worker process is not blocked. Also, it doesn't wait for any\nresponse, therefore the processing of the configuration continues very\nfast when executing evapi_relay().\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    evapi_relay(\"{ \\\"event\\\": \\\"test\\\",\\n \\\"data\\\": { \\\"fU\\\": \\\"$fU\\\" }\\n}\");\n    ...\n\nThe above example will send the following message over tcp:\n\n    ...\n    47:{\n     \"event\": \"test\",\n     \"data\": { \"fU\": \"test\" }\n    },\n    ...\n\n",
 "evapi_async_relay": "### evapi_async_relay(evdata)\n\n module: evapi\n\nRelay the event data given as parameter to connected applications.\nBefore evaluating the parameter, the request processing is suspended\nusing tm module (using the t_suspend()/t_continue() framework). The\nrouting of the SIP request can be continued once\nevent_route\\[evapi:message-received\\] is triggered. After\nevapi_async_relay() returns true, no relaying should happen in\nrequest_route(), it should be followed by exit;.\n\nThe format on the network is netstring with evdata payload if\nnetstring_format parameter is set to 1 or bare evdata if\nnetstring_format parameter is set to 0.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    evapi_async_relay(\"{ \\\"event\\\": \\\"suspend\\\",\\n \\\"data\\\":\"\n            \" { \\\"index\\\": \\\"$T(id_index)\\\", \\\"label\\\": \\\"$T(id_label)\\\" }\\n}\");\n    ...\n\n",
 "evapi_multicast": "### evapi_multicast(evdata, etag)\n\n module: evapi\n\nRelay the event data given as parameter to connections that match the\ntag provided by etag value. The etag can be a variable. For more see\nevapi_relay() and evapi_set_tag().\n\n    ...\n    evapi_multicast(\"{ \\\"event\\\": \\\"test\\\",\\n \\\"data\\\": { \\\"fU\\\": \\\"$fU\\\" }\\n}\", \"tagx\");\n    ...\n\n",
 "evapi_async_multicast": "### evapi_async_multicast(evdata, etag)\n\n module: evapi\n\nAsync relay the event data given as parameter to connections that match\nthe tag provided by etag value. The etag can be a variable. For more see\nevapi_async_relay() and evapi_set_tag().\n\n    ...\n    evapi_async_multicast(\"{ \\\"event\\\": \\\"suspend\\\",\\n \\\"data\\\":\"\n        \" { \\\"index\\\": \\\"$T(id_index)\\\", \\\"label\\\": \\\"$T(id_label)\\\" }\\n}\", \"tagx\");\n    ...\n\n",
 "evapi_unicast": "### evapi_unicast(evdata, etag)\n\n module: evapi\n\nRelay the event data given as parameter to the first connection that\nmatch the tag provided by etag value. The etag can be a variable. For\nmore see evapi_relay() and evapi_set_tag().\n\n    ...\n    evapi_unicast(\"{ \\\"event\\\": \\\"test\\\",\\n \\\"data\\\": { \\\"fU\\\": \\\"$fU\\\" }\\n}\", \"tagx\");\n    ...\n\n",
 "evapi_async_unicast": "### evapi_async_unicast(evdata, etag)\n\n module: evapi\n\nAsync relay the event data given as parameter to the first connection\nthat match the tag provided by etag value. The etag can be a variable.\nFor more see evapi_async_relay() and evapi_set_tag().\n\n    ...\n    evapi_async_unicast(\"{ \\\"event\\\": \\\"suspend\\\",\\n \\\"data\\\":\"\n        \" { \\\"index\\\": \\\"$T(id_index)\\\", \\\"label\\\": \\\"$T(id_label)\\\" }\\n}\", \"tagx\");\n    ...\n\n",
 "evapi_close": "### evapi_close()\n\n module: evapi\n\nClose evapi current client connection.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    event_route[evapi:connection-new] {\n      if($evapi(srcaddr)!=\"127.0.0.1\") {\n        evapi_close();\n        exit;\n      }\n    }\n    ...\n\n",
 "evapi_set_tag": "### evapi_set_tag(tname)\n\n module: evapi\n\nSet tag name for current client connection. The parameters has to be a\nstring up to 64 characters. It can also be a variable holding such\nstring.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    event_route[evapi:connection-new] {\n      if($evapi(srcaddr)==\"127.0.0.1\") {\n        evapi_set_tag(\"local\");\n        exit;\n      }\n    }\n    ...\n\n",
 "radius_load_caller_avps": "### radius_load_caller_avps(caller)\n\n module: misc_radius\n\nThe functions loads caller's attributes from radius and stores them into\nAVPs. Parameter \u201ccaller\u201d is a string that may contain pseudo variables.\nIt indicates the user, whose attributes are loaded.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    radius_load_caller_avps(\"$fU@$fd\"); # take caller from From URI\n    ...\n    radius_load_caller_avps(\"$au@$ar\"); # take caller from Authorization\n    ...                 # or Proxy-Authorization header\n\n",
 "radius_load_callee_avps": "### radius_load_callee_avps(callee)\n\n module: misc_radius\n\nThe functions loads callee's attributes from radius and stores them into\nAVPs. Parameter \u201ccallee\u201d is a string that may contain pseudo variables.\nIt indicates the user, whose attributes are loaded.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    radius_load_callee_avps(\"$rU@$rd\"); # take callee from Request-URI\n    ...\n\n",
 "radius_is_user_in": "### radius_is_user_in(user, group)\n\n module: misc_radius\n\nThe functions checks from RADIUS, if user given in first argument\nbelongs to group given in second argument. Both arguments are strings,\nbut user string may also contain pseudo variables. In case of positive\nresult, loads AVPs from SIP-AVP reply items, if any.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n    ...\n    radius_is_user_in(\"$rU@$rd\", \"1\");  # take user from Request-URI\n    ...\n    radius_is_user_in(\"$au@$ar\", \"group_x\");# take user from credentials\n    ...\n\n",
 "radius_does_uri_exist": "### radius_does_uri_exist([uri])\n\n module: misc_radius\n\nChecks from RADIUS if userpart@hostpart of Request-URI or of an URI\nstored in optional pseudo variable argument belongs to a local user. In\ncase of positive result, loads AVPs from SIP-AVP reply items, if any.\n\nThis function can be used from REQUEST_ROUTE and LOCAL_ROUTE.\n\n    ...\n    if (radius_does_uri_exist()) ...    # check Request-URI\n    ...\n    if (radius_does_uri_exist(\"$avp(i:99)\")) ...    # check URI in $avp(i:99)\n    ...\n\n",
 "radius_does_uri_user_exist": "### radius_does_uri_user_exist([user])\n\n module: misc_radius\n\nSimilar to radius_does_uri_exist, but check is done based only on\nRequest-URI userpart or userpart stored in optional pseudo variable\nargument. Userpart should thus be unique among all user URIs, such as an\nE.164 number. In case of positive result, loads AVPs from SIP-AVP reply\nitems, if any.\n\nThis function can be used from REQUEST_ROUTE and LOCAL_ROUTE.\n\n    ...\n    if (radius_does_uri_user_exist()) ...   # check Request-URI userpart\n    ...\n    if (radius_does_uri_exist(\"$fU\")) ...   # check From URI userpart\n    ...\n",
 "dlgs_init": "### dlgs_init(src, dst, data)\n\n module: dlgs\n\nStart track the dialog corresponding to the current SIP message. It has\nto be used for INVITE messages.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nONREPLY_ROUTE, ONSEND_ROUTE.\n\n    ...\n    onsend_route {\n        ...\n        if(is_method(\"INVITE\")) {\n            dlgs_init(\"$fu\", \"$tu\", \"my data\");\n        }\n        ...\n    }\n    ...\n\n",
 "dlgs_update": "### dlgs_update()\n\n module: dlgs\n\nUpdate dialog state. It has to be used for SIP requests only, the SIP\nresponses are handled automatically.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nONSEND_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(is_method(\"ACK|BYE|CANCEL\")) {\n            dlgs_update();\n        }\n        ...\n    }\n    ...\n\n",
 "dlgs_count": "### dlgs_count(field, op, data)\n\n module: dlgs\n\nReturn the number of dialogs matching the filter specified by the\nparameters. It does not count the dialogs that are finished (not\nanswered or terminated with BYE).\n\nThe field parameter can be: 'src', 'dst', 'data' to specify what dialog\nattribute has to be used for matching. It can be also 'any' to get the\ncount of all ongoing dialogs.\n\nThe op parameter can be: 'eq' - equal; 'ne' - not equal; 're' - regex;\n'sw' - start with; 'fm' - fnmatch.\n\nIn case of error or no dialog matched, it returns -1 or other negative\n(false) value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        $var(count) = dlgs_count(\"src\", \"eq\", \"$fu\");\n        if($var(count) > 0) {\n            # caller has ongoing dialogs\n        }\n        ...\n        $var(allcalls) = dlgs_count(\"any\", \"eq\", \"*\");\n        if($var(allcalls) > 0) {\n            # there are ongoing dialogs\n        }\n        ...\n    }\n    ...\n\n",
 "dlgs_tags_add": "### dlgs_tags_add(vtag)\n\n module: dlgs\n\nAdd a tag to current dialog.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        dlgs_tags_add(\"$si\");\n        ...\n    }\n    ...\n\n",
 "dlgs_tags_rm": "### dlgs_tags_rm(vtag)\n\n module: dlgs\n\nRemove a tag from current dialog.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        dlgs_tags_rm(\"$si\");\n        ...\n    }\n    ...\n\n",
 "dlgs_tags_count": "### dlgs_tags_count(vtag)\n\n module: dlgs\n\nCount all tags for ongoing dialogs matching the parameter.\n\nIt returns -1 if no tag for ongoing dialogs is matched or there was an\nerror.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        $var(tcount) = dlgs_tags_count(\"$si\");\n        ...\n    }\n    ...\n\n",
 "sca_handle_subscribe": "### sca_handle_subscribe()\n\n module: sca\n\nThe function handling call-info and line-seize SUBSCRIBE requests. It\nstores or updates the subscriptions in shared memory, and sends NOTIFYs\nto the subscriber and other members of the group as needed.\n\nFor example, a line-seize SUBSCRIBE will cause the module to reserve an\nappearance index for the subscriber; send a line-seize NOTIFY to the\nsubscriber indicating which appearance index it must use; and send\ncall-info NOTIFYs to other subscribers to the address-of-record letting\nthem know the appearance is off hook.\n\nThis function can be used from the REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n    ...\n    if ( is_method( \"SUBSCRIBE\" )) {\n        if ( $hdr(Event) == \"call-info\" || $hdr(Event) == \"line-seize\" ) {\n        sca_handle_subscribe();\n        exit;\n        }\n    }\n    ...\n            \n\n",
 "sca_call_info_update": "### sca_call_info_update([mask, to, from])\n\n module: sca\n\n- *mask* - integer (optional)\n\n  controls what to check as shared line (BOTH, CALLER, CALLEE)\n\n  - 0 - SCA_CALL_INFO_SHARED_NONE (default) check both\n\n  - 1 - SCA_CALL_INFO_SHARED_CALLER\n\n  - 2 - SCA_CALL_INFO_SHARED_CALLEE\n\n- *to* - string (optional)\n\n  string to use as To and skip parsing To header from the message. The\n  parameter allows pseudo-variables usage\n\n- *from* - string (optional)\n\n  string to use as From and skip parsing From header from the message.\n  The parameter allows pseudo-variables usage\n\nThe sca_call_info_update function updates call state for SCA\nappearances. If a request or response packet contains a Call-Info\nheader, the function extracts call state from the header and sends\nNOTIFYs to subscribers if needed. If no Call-Info header is included in\nthe packet, the module looks up the To and From URIs to see if either\nare SCA addresses-of-record. If either the To or From URI are SCA AoRs,\nthe function looks up the appearance by dialog and updates call state as\nneeded, sending NOTIFYs to members of the group if the call state has\nchanged.\n\nThe sca_call_info_update function updates call state for INVITE, CANCEL,\nBYE, PRACK and REFER requests and responses.\n\nThis function can be used from the REQUEST_ROUTE, REPLY_ROUTE, and\nFAILURE_ROUTE.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n    ...\n    route\n    {\n    ...\n        sca_call_info_update(0, \"$var(to)\", \"$var(from)@$var(domain)\");\n    ...\n    }\n\n    onreply_route[REPLY_ROUTE]\n    {\n    ...\n        if ( status =~ \"[456][0-9][0-9]\" ) {\n        # don't update SCA state here, since there may be\n        # failure route processing (e.g., call forwarding).\n        # update state in failure route instead.\n        break;\n        }\n\n        sca_call_info_update();\n    ...\n    }\n\n    failure_route[FAILURE_ROUTE]\n    {\n    ...\n        sca_call_info_update();\n    ...\n    }\n    ...\n                    \n\n",
 "pres_check_basic": "### pres_check_basic(presentity_uri, status)\n\n module: presence_xml\n\nChecks the /presence/tuple/status/basic nodes in the presentity for\n*presentity_uri* against the value in status.\n\nThis function can be used from ANY_ROUTE.\n\n*Return code:*\n\n- *1 - if a match is found*.\n\n- *-1 - if a match is not found*.\n\n<!-- -->\n\n    ...\n        if (pres_check_basic(\"$ru\", \"open\")) {\n            ...\n        } else {\n            if (is_method(\"MESSAGE\"))\n                m_store();\n        else\n            send_reply(\"404\", \"Not Found\");\n        }\n    ...\n\n",
 "pres_check_activities": "### pres_check_activities(presentity_uri, activity)\n\n module: presence_xml\n\nChecks whether a /presence/person/activities/*activity* node exists in\nthe presentity for *presentity_uri*.\n\nThis function can be used from ANY_ROUTE.\n\n*Return code:*\n\n- *1 - if a match is found*.\n\n- *-1 - if a match is not found*.\n\n- *-2 - if /presence/person or /presence/person/activity do not exist*.\n\n<!-- -->\n\n    ...\n        if (pres_check_basic(\"$ru\", \"open\")) {\n        pres_check_activities(\"$ru\", \"unknown\");\n        if ($retcode || $retcode == -2 || !is_method(\"INVITE\"))\n                t_relay();\n        else\n                send_reply(\"486\", \"Busy Here\");\n        } else {\n            ...\n        }\n    ...\n\n",
 "pua_update_contact": "### pua_update_contact()\n\n module: pua\n\nThe remote target can be updated by the Contact of a subsequent in\ndialog request. In the PUA watcher case (sending a SUBSCRIBE messages),\nthis means that the remote target for the following Subscribe messages\ncan be updated at any time by the contact of a Notify message. If this\nfunction is called on request route on receiving a Notify message, it\nwill try to update the stored remote target.\n\nThis function can be used from REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - if success*.\n\n- *-1 - if error*.\n\n<!-- -->\n\n    ...\n    if(method==\"NOTIFY\")\n        pua_update_contact();\n    ...\n\n",
 "tcp_conid_alive": "### tcp_conid_alive(conid)\n\n module: tcpops\n\nCheck the state of a TCP or WS connection ID\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id (as in the\n  *\\$conid* pseudovariable).\n\nReturn values:\n\n1: Connection is OK\n\n-1: Connection has errors, does not exist or is about to be closed)\n\n    ...\n        $var(conid) = $conid;\n        if(!tcp_conid_alive(\"$var(conid)\")) {\n            xlog(\"L_ERR\", \"Connection $conid can no longer be used\\n\");\n        }\n    ...\n                \n\n",
 "tcp_conid_state": "### tcp_conid_state(conid)\n\n module: tcpops\n\nCheck the state of a TCP or WS connection ID\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id (as in the\n  *\\$conid* pseudovariable).\n\nReturn values:\n\n1: Connection is OK\n\n2: Socket is accepting incoming connections\n\n3: Socket is setting up outgoing connection\n\n-1: Connection does not exist (or was closed)\n\n-2: Socket has reached EOF\n\n-3: Socket error has occurred. Connection will likely close.\n\n-4: Socket is in unknown bad state. Connection will likely close.\n\n    ...\n        if(!tcp_conid_state(\"$var(conid)\")) {\n            xlog(\"L_ERR\", \"Connection $conid is closed or malfunctional\\n\");\n        }\n    ...\n                \n\n",
 "tcp_keepalive_enable": "### tcp_keepalive_enable([conid], idle, count, interval)\n\n module: tcpops\n\nEnables keepalive on a TCP connection.\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id on which TCP\n  keepalive will be enabled. If no parameter is given, the keepalive\n  mechanism will be enabled on the current message source connection.\n\n- *idle* (seconds): the time before the first keepalive packet is sent\n  out.\n\n- *count*: number of non-acked keepalive before resetting the\n  connection.\n\n- *interval* (seconds): time between two keepalive probes.\n\nReturns 1 on success, -1 on failure.\n\n    request_route {\n        if (is_method(\"INVITE\")) {\n            $avp(caller_conid) = $conid;\n            t_on_reply(\"foo\");\n        }\n        ...\n    }\n\n    onreply_route[foo] {\n        if (is_method(\"INVITE\") && status == 200) {\n            # enable on callee's connection\n            tcp_keepalive_enable(\"60\", \"5\", \"5\");\n            # enable on caller's connection\n            tcp_keepalive_enable(\"$avp(caller_conid)\", \"60\", \"5\", \"2\");\n        }\n        ...\n    }\n                \n\n",
 "tcp_keepalive_disable": "### tcp_keepalive_disable([conid])\n\n module: tcpops\n\nDisables keepalive on a TCP connection.\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id on which TCP\n  keepalive will be disabled. If no parameter is given, the keepalive\n  mechanism will be disabled on the current message source connection.\n\nReturns 1 on success, -1 on failure.\n\n    request_route {\n        ...\n        if (is_method(\"BYE\")) {\n            $avp(bye_conid) = $conid;\n            t_on_reply(\"foo\");\n        }\n        ...\n    }\n\n    onreply_route[foo] {\n        ...\n        if (is_method(\"BYE\") && status == 200) {\n            tcp_keepalive_disable();\n            tcp_keepalive_disable(\"$avp(bye_conid)\");\n        }\n        ...\n    }\n                \n\n",
 "tcp_set_connection_lifetime": "### tcp_set_connection_lifetime([conid], lifetime)\n\n module: tcpops\n\nSets the connection lifetime of a connection (TCP).\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id on which to\n  set the new lifetime. If no parameter is given, it will be set on the\n  current message source connection.\n\n- *lifetime* (seconds): the new connection lifetime.\n\nReturns 1 on success, -1 on failure.\n\n    ...\n    # use 10s as default lifetime\n    tcp_connection_lifetime=10\n    ...\n\n    request_route {\n            ...\n            if (is_method(\"REGISTER\") && pv_www_authenticate(\"$td\", \"xxx\", \"0\")) {\n                    # raise the TCP lifetime to a bigger value\n                    tcp_set_connection_lifetime(\"3605\");\n            }\n            ...\n    }\n                            \n\n",
 "tcp_enable_closed_event": "### tcp_enable_closed_event([conid])\n\n module: tcpops\n\nExplicitly enables the \"tcp:closed\" event route on a TCP connection.\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id. If no\n  parameter is given, it will be enabled on the current message source\n  connection.\n\nReturns 1 on success, -1 on failure.\n\n    ...\n    # \"tcp:closed\" event route is \"manual\" mode\n    modparam(\"tcpops\", \"closed_event\", 2)\n    ...\n\n    request_route {\n        ...\n        if (is_method(\"REGISTER\") && pv_www_authenticate(\"$td\", \"xxx\", \"0\")) {\n            # it will be called for this specific connection\n            tcp_enable_closed_event();\n        }\n        ...\n\n    }\n\n    event_route[tcp:closed] {\n        xlog(\"connection $conid was closed\");\n    }\n\n",
 "tcp_get_conid": "### tcp_get_conid(hostport, pvname)\n\n module: tcpops\n\nGet the connection id based on target host:port. The connection id is\nset in the variable named by pvname parameter.\n\nMeaning of the parameters is as follows:\n\n- *hostport* - target \"host:port\" address, the port can be omitted\n  (default to 5060) and the parameter can contain variables.\n\n- *pvname* - target variable name.\n\nReturn values:\n\n1: connection was found\n\n-1: connection was not found or an error occurred\n\n    ...\n        if(tcp_get_conid(\"127.0.0.1:5060\", \"$var(conid)\")) {\n            xlog(\"connection id is: $var(conid)\\n\");\n        }\n    ...\n                \n\n",
 "tcp_set_otcpid": "### tcp_set_otcpid(conid)\n\n module: tcpops\n\nSet the value for outbound tcp connection id.\n\nMeaning of the parameters is as follows:\n\n- *conid* - the value of tcp connection id. It can be an integer number\n  or a variable holding an interver value.\n\nReturn values:\n\n- 1: success\n\n- -1: failure\n\n<!-- -->\n\n    ...\n        $var(conid) = 10;\n        tcp_set_otcpid(\"$var(conid)\");\n    ...\n                \n\n",
 "tcp_set_otcpid_flag": "### tcp_set_otcpid_flag(mode)\n\n module: tcpops\n\nSet or reset the internal flag for using or not the outbound tcp\nconnection id for sending out. The outbound connection id can be set by\nmodule or by config using tcp_set_otcpid(...) function. An example of a\nmodule setting the otcpid is register via lookup location function,\nwhich sets the filed to the connection id used to receive the\nregistration request.\n\nMeaning of the parameters is as follows:\n\n- *mode* - if 0, then the flag is reset, otherwise it is set.\n\nReturn values:\n\n- 1: success\n\n- -1: failure\n\nNote: if you set the flag to use the outbound tcp connection id, then\ncustom config changes to the destination address, like updating the\nr-uri (\\$ru) or dst uri (\\$du) are not resetting it, so the same already\nset connection id is used and the SIP request might be sent to the\nunexpected destination. Reset the flag in such case, if you set it\npreviously.\n\n    ...\n        $var(cmode) = 1;\n        tcp_set_otcpid_flag(\"$var(cmode)\");\n    ...\n                \n\n",
 "tcp_close_connection": "### tcp_close_connection([conid])\n\n module: tcpops\n\nTrigger a close of the connection corresponding to current SIP message\nor to connection id 'conid'.\n\nMeaning of the parameters is as follows:\n\n- *conid* - the value of tcp connection id. It can be an integer number\n  or a variable holding an interver value.\n\nReturn values:\n\n- 1: success\n\n- -1 (or other negative values): failure\n\n<!-- -->\n\n    ...\n        $var(conid) = 10;\n        tcp_close_connection(\"$var(conid)\");\n    ...\n                \n\n",
 "add_path": "### add_path()\n\n module: path\n\nThis function is used to insert a Path header in the form \u201cPath:\n\\<sip:1.2.3.4;lr\\>\u201d, where \u201c1.2.3.4\u201d is the address of the outgoing\ninterface.\n\nIf the \u201coutbound\u201d module was loaded before this module, and outbound is\nrequired for this request, the header will be in the form \u201cPath:\n\\<sip:flowtoken@1.2.3.4;lr;ob\\>\u201d, where \u201cflowtoken\u201d is the RFC 5626\nflow-token that can be used to identify the source and local address and\ntransport the request was received on, and where \u201c1.2.3.4\u201d is the\naddress of the outgoing interface.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!add_path()) {\n        sl_send_reply(\"503\", \"Internal Path Error\");\n        ...\n    };\n    ...\n\n### add_path(user)\n\n module: path\n\nThis function adds a Path header in the form \u201cPath:\n\\<sip:user@1.2.3.4;lr\\>\u201d.\n\nMeaning of the parameters is as follows:\n\n- *user* - The username to be inserted as user part. SPVE is supported.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!add_path(\"loadbalancer\")) {\n        sl_send_reply(\"503\", \"Internal Path Error\");\n        ...\n    };\n    ...\n\n### add_path(user, parameters)\n\n module: path\n\nThis function adds a Path header in the form \u201cPath:\n\\<sip:user@1.2.3.4;lr\\>\u201d and appends the given *parameters* as\nadditional URI parameters.\n\nMeaning of the parameters is as follows:\n\n- *user* - The username to be inserted as user part. SPVE is supported.\n\n- *parameters* - Additional URI parameters to be appended to the URI.\n  The semicolon separator is added automatically. The script writer is\n  responsible for proper URI escaping. SPVE is supported.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!add_path(\"loadbalancer\", \"ob\")) {\n        sl_send_reply(\"503\", \"Internal Path Error\");\n        ...\n    };\n    ...\n\n",
 "add_path_received": "### add_path_received()\n\n module: path\n\nThis function adds a Path header in the form \u201cPath:\n\\<sip:1.2.3.4;received=sip:2.3.4.5:1234;lr\\>\u201d, setting its own outgoing\naddress as domain-part, and the address the request has been received\nfrom as received-parameter.\n\nIf the \u201coutbound\u201d module was loaded before this module, and outbound is\nrequired for this request, the header will be in the form \u201cPath:\n\\<sip:flowtoken@1.2.3.4;lr;received=sip:2.3.4.5:1234;ob\\>\u201d, where\n\u201cflowtoken\u201d is the RFC 5626 flow-token that can be used to identify the\nsource and local address and transport the request was received on, and\nwhere \u201c1.2.3.4\u201d is the address of the outgoing interface.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!add_path_received()) {\n        sl_send_reply(\"503\", \"Internal Path Error\");\n        ...\n    };\n    ...\n\n### add_path_received(user)\n\n module: path\n\nThis function adds a Path header in the form \u201cPath:\n\\<sip:user@1.2.3.4;received=sip:2.3.4.5:1234;lr\\>\u201d, setting 'user' as\nusername part of address, its own outgoing address as domain-part, and\nthe address the request has been received from as received-parameter.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!add_path_received(\"inbound\")) {\n        sl_send_reply(\"503\", \"Internal Path Error\");\n        ...\n    };\n    ...\n\n### add_path_received(user, parameters)\n\n module: path\n\nThis function adds a Path header in the form \u201cPath:\n\\<sip:user@1.2.3.4;received=sip:2.3.4.5:1234;lr\\>\u201d, setting 'user' as\nusername part of address, its own outgoing address as domain-part, and\nthe address the request has been received from as received-parameter.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!add_path_received(\"inbound\", \"ob\")) {\n        sl_send_reply(\"503\", \"Internal Path Error\");\n        ...\n    };\n    ...\n",
 "dmq_handle_message": "### dmq_handle_message([continue])\n\n module: dmq\n\nHandles a DMQ message by passing it to the appropriate local peer\n(module). The peer is identified by the user part of the To header.\n\nMeaning of parameters:\n\n- *continue* - by default, dmq_handle_message() will end execution of\n  routing script. If this optional parameter is set to \"1\",\n  dmq_handle_message() will continue executing the routing script after\n  it's been called.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        if(is_method(\"KDMQ\")) {\n            dmq_handle_message();\n        }\n    ...\n\n",
 "dmq_process_message": "### dmq_process_message([continue])\n\n module: dmq\n\nSimilar to dmq_handle_message, but the processing is happening\nimmediately, no longer cloning the request in shared memory to be passed\nto a DMQ worker process.\n\nMeaning of parameters:\n\n- *continue* - by default, dmq_process_message() will end execution of\n  routing script by returning 0. If this optional parameter is set to\n  \"1\", dmq_process_message() will continue executing the routing script\n  after it is been executed, returning 1.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        if(is_method(\"KDMQ\")) {\n            dmq_process_message();\n        }\n    ...\n\n",
 "dmq_send_message": "### dmq_send_message(channel, node, body, content_type)\n\n module: dmq\n\nSends a DMQ message directly from config file to a single node.\n\nMeaning of parameters:\n\n- *channel* - name of the channel that should handle the message.\n\n- *node* - the SIP address of the node to which the message should be\n  sent.\n\n- *body* - the message body.\n\n- *content_type* - the MIME type of the message body.\n\nThis function can be used from any route.\n\n    ...\n        dmq_send_message(\"channel1\", \"sip:10.0.0.21:5060\", \"Message body...\", \"text/plain\");\n    ...\n\n",
 "dmq_bcast_message": "### dmq_bcast_message(channel, body, content_type)\n\n module: dmq\n\nBroadcasts a DMQ message from config file to all active nodes (except\nself) on the specific channel.\n\nMeaning of parameters:\n\n- *channel* - name of the channel that should handle the message.\n\n- *body* - the message body.\n\n- *content_type* - the MIME type of the message body.\n\nThis function can be used from any route.\n\n    ...\n        dmq_bcast_message(\"channel1\", \"Message body...\", \"text/plain\");\n    ...\n\n",
 "dmq_t_replicate": "### dmq_t_replicate([skip_loop_test])\n\n module: dmq\n\nReplicates the current SIP message to all active nodes (except self).\nUseful for replicating REGISTER, PUBLISH etc. in a clustered\nenvironment.\n\nMeaning of parameters:\n\n- *skip_loop_test* - by default, DMQ checks the source IP of the message\n  prior to replication, to ensure it has not been sent by another DMQ\n  node (to avoid infinite loops). If this optional parameter is set to\n  \"1\", the loop test is not performed. This makes sense, from a\n  performance perspective, if you have already performed the necessary\n  checks in the config script (see dmq_is_from_node()).\n\nThis function can be used from REQUEST_ROUTE only.\n\n    ...\n        dmq_t_replicate();\n    ...\n            \n\n",
 "dmq_is_from_node": "### dmq_is_from_node()\n\n module: dmq\n\nChecks whether the current message has been sent by another active DMQ\nnode in the cluster.\n\nThis function can be used from REQUEST_ROUTE only.\n\n    ...\n        # basic example for REGISTER replication\n        if(is_method(\"REGISTER\")) {\n            if (dmq_is_from_node()) {\n                # coming from a DMQ node - already authenticated there\n                # now just save contact, etc...\n            } else {\n                # coming from end point - authenticate, save contact, etc...\n                dmq_t_replicate(\"1\"); # source address checked, skip the loop test\n            }\n        }\n    ...\n                    \n\n",
 "save": "### save(async_reply_route, domain, mode, flags)\n\n module: ims_registrar_scscf\n\nThe function processes a REGISTER message. It can add, remove or modify\nusrloc records depending on Contact and Expires HFs in the REGISTER\nmessage. On success and when called from the REQUEST_ROUTE, 200 OK will\nbe returned listing all contacts that are currently in usrloc. On an\nerror, error message will be sent with a short description in reason\nphrase. In case of internal errors the function will return FALSE,\notherwise a force to exit the cfg is file is actioned by returning 0\n(asynchronous processing)\n\nMeaning of the parameters is as follows:\n\n- *async_reply_route*- the route to execute after the save has\n  completed. This is required because the save function is executed\n  asynchronously (Diameter).\n\n- *domain*- Logical domain within registrar.\n\n- *mode*- Optional and unused legacy parameter.\n\n- *flags*- Optional parameter. Valid values: 0x01 - Realm is not used\n  when extracting Private Identity from the Authorization header.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE\n\n    ...\n    if (!impu_registered(\"location\")) {\n       save(\"PRE_REG_SAR_REPLY\",\"location\");\n    }\n    ...\n\n",
 "lookup": "### lookup(domain)\n\n module: ims_registrar_scscf\n\nThis function extract the IMPU from the Request-URI and tries to find\nall registered contacts in usrloc. If there are no such contacts, -1 is\nreturned. If there are, Request-URI will be rewritten with the contact\nthat has the highest q value. The rest of the contacts will be appended\nto the sip msg structure (if append_branches is set) and can be later\nused by TM module for forking for example...\n\nIf the method filtering option is enabled, the lookup function will only\nreturn contacts that support the method of the request being processed\n(see allows header)\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within registrar.\n\nReturn codes:\n\n- *-1* - Not found\n\n- -2 - Found, but method not allowed (check Allows header for INVITE,\n  MESSAGE, etc).\n\n- -3 - Error occurred internally during processing\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    lookup(\"location\");\n    switch ($retcode) {\n        case -1:\n        case -3:\n            sl_send_reply(\"404\", \"Not Found\");\n            exit;\n        case -2:\n            sl_send_reply(\"405\", \"Not Found\");\n            exit;\n    };\n    ...\n\n",
 "lookup_to_dset": "### lookup_to_dset(domain [, uri])\n\n module: registrar\n\nSimilar to lookup(...), but push the location contacts to destination\nset, without changing the R-URI (first branch not changed, it creates\nadditional branches). For the meaning of the parameters and the return\ncodes, see the documentation for lookup(...) function.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    lookup_to_dset(\"location\");\n    ...\n\n",
 "lookup_branches": "### lookup_branches(domain)\n\n module: registrar\n\nThe function performs lookup(domain) on r-uri and additional branches\n(only branches that have no other attributes set than uri).\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup.\n\nReturn codes are propagated from the `lookup(domain)` function.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    lookup_branches(\"location\");\n    ...\n\n",
 "lookup_xavp": "### lookup_xavp(ultable, uri, rxname, cxname)\n\n module: registrar\n\nSimilar to lookup(...), but store the location record attributes in\nXAVPs. Note that not all contact record fields are stored\n\nMeaning of the parameters:\n\n- *ultable* - name of the usrloc table that is used for the lookup.\n\n- *uri* - the URI to be searched in location table.\n\n- *rxname* - name of the XAVP to store record attributes. These are:\n\n  - *aor* - the address of record.\n\n- *cxname* - name of the XAVP to store content attributes, name mapping\n  is done from the perspective of using them to send out SIP requests.\n  These are:\n\n  - *uri* - the contact address.\n\n  - *socket* - the socket of the contact record.\n\n  - *dsturi* - the destination uri of the contact record (the received\n    field in location contact).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    lookup_xavp(\"location\", \"$fu\", \"rul\", \"cul\");\n    xinfo(\"aor: $xavp(rul=>aor)\\n\");\n    xinfo(\"number of contacts: $xavp(rul>count)\\n\");\n    xinfo(\"first contact record - uri: $xavp(cul>uri)\\n\");\n    xinfo(\"first contact record - socket: $xavp(cul>socket)\\n\");\n    ...\n\n",
 "registered": "### registered(domain [, uri [, match_option [, match_action]]])\n\n module: registrar\n\nThe function returns true if the AOR in the URI is registered, false\notherwise. The function does not modify the message being processed, it\nneither rewrites the Request-URI if a contact is found nor append\nbranches. If uri parameter is not provided, then it considered to be the\nRequest-URI for SIP requests and To-URI for SIP replies.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup.\n\n- *uri* (optional) - SIP URI to do be used instead of Request/To-URI. It\n  can be a dynamic string with pseudo-variables.\n\n- *match_option* (optional) - flag parameter to restrict contact search.\n  use xavp_cfg to set the values to compare to.\n\n  flag values is as follows:\n\n  - 1 - match_callid\n\n  - 2 - match_received\n\n  - 4 - match_contact\n\n- *match_action* (optional) - actions to perform when match is positive.\n\n  flag values is as follows:\n\n  - 1 - restore the xavps associated with the matched contact\n\n  - 2 - skip adding the matched location record attributes to xavp_rcd\n    (e.g., the ruid, contact, received, ...)\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (registered(\"location\")) {\n        sl_send_reply(\"100\", \"Trying\");\n        ...\n    };\n    ...\n    $xavp(regcfg=>match_received) = $su;\n    if (registered(\"location\",\"$rz:$Au\", 2)) {\n        sl_send_reply(\"100\", \"Trying\");\n        ...\n    };\n    ...\n\n",
 "add_sock_hdr": "### add_sock_hdr(hdr_name)\n\n module: registrar\n\nAdds a new header to the current REGISTER request with \u201chdr_name\u201d which\ncontains the description of the received socket (proto:ip:port)\n\nThis makes sense only in multiple replicated servers scenarios.\n\nMeaning of the parameters is as follows:\n\n- *hdr_name* - header name to be used, it can be a static string or\n  contain variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    add_sock_hdr(\"Sock-Info\");\n    ...\n\n",
 "unregister": "### unregister(domain)\n\n module: ims_registrar_scscf\n\nThis function will remove all bindings for the IMPU found in the\nRequest-URI.\n\nMeaning of the parameters is as follows:\n\n- *Domain*- Logical domain within registrar.\n\nThis function can be used in REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    unregister(\"location\");\n    ...\n\n",
 "reg_fetch_contacts": "### reg_fetch_contacts(domain, uri, profile)\n\n module: ims_registrar_scscf\n\nThe function fetches the contacts for 'uri' from table 'domain' to\npseudo-variable \\$imssulc(profile) \\[imssulc = ims scscf ulc\\].\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup of contact\n  addresses.\n\n- *uri* - The SIP URI address of the user which to fetch the contact\n  addresses for. It can contain pseudo-variables that are evaluated at\n  runtime.\n\n- *profile* - Name of \\$imssulc pseudo-variable profile that will store\n  the fetched contacts. It is a static string.\n\nThis function can be used in REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    reg_fetch_contacts(\"location\", \"$ru\", \"callee\");\n    reg_fetch_contacts(\"location\", \"sip:user@kamailio.org\", \"caller\");\n    ...\n\n",
 "reg_free_contacts": "### reg_free_contacts(profile)\n\n module: ims_registrar_scscf\n\nThe function frees the contacts from pseudo-variable \\$ulc(profile).\nShould be called to release the content of a profile. Anyhow, fetching a\nnew contact addresses set over a profile will release any existing data\nin that profile.\n\nMeaning of the parameters is as follows:\n\n- *profile* - Name of \\$imssulc pseudo-variable profile that stores the\n  contacts. It is a static string.\n\nThis function can be used in REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    reg_free_contacts(\"callee\");\n    ...\n\n",
 "reg_send_reply": "### reg_send_reply()\n\n module: registrar\n\nThe function sends the SIP reply that is normally sent by save(...), but\nthat was skipped due to flag 0x2. It must be used after save(...,\n\"0x2\"). Practically it allows saving registration to location table, do\nother operations and then send the reply.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    save(\"location\", \"0x2\");\n    ...\n    reg_send_reply();\n    ...\n\n",
 "reg_from_user": "### reg_from_user(ultable, uri, mode)\n\n module: registrar\n\nThe function returns true if the SIP message comes from the user\nidentified by 'uri' parameter by matching the associated location\nrecords. The matching is done with the field 'received' if it is set,\notherwise with the contact address.\n\nMeaning of the parameters is as follows:\n\n- *ultable* - user location table (e.g., 'location')\n\n- *uri* - SIP URI to identify the location records to match against.\n\n- *mode* - matching mode (int) - host part (IP address) is matched\n  always. If mode has bit 1 set (value 1), then the port is matched as\n  well. If mode has bit 2 set (value 2), then the protocol is matched as\n  well.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(reg_from_user(\"location\", \"sip:alice@server.com\", \"0\")) {\n        # message coming from where 'alice' sent before a REGISTER request\n    }\n    ...\n\n",
 "enum_query": "### enum_query([\"suffix\" [,\"service\"]])\n\n module: enum\n\nThe function performs an enum query and rewrites the Request-URI with\nthe result of the query. See [Overview](#sec-overview) for more\ninformation.\n\nMeaning of the parameters is as follows:\n\n- *suffix* - Suffix string to be appended to the domain name. String may\n  contain pseudo variables.\n\n- *service* - Service string to be used in the service field. String may\n  contain pseudo variables.\n\nParameters can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    # search for \"e2u+sip\" in freenum.org\n    enum_query(\"freenum.org.\");\n    ...\n    # search for \"e2u+sip\" in default tree (configured as parameter)\n    enum_query();\n    ...\n    # search for \"e2u+voice:sip\" in e164.arpa\n    enum_query(\"e164.arpa.\",\"voice\");\n    ...\n    # search for service type \"sip\" or \"voice:sip\" or \"video:sip\"\n    # note the '+' sign in front of the second parameter\n    enum_query(\"e164.arpa.\",\"+sip+voice:sip+video:sip\");\n    ...\n    # quering for service sip and voice:sip\n    enum_query(\"e164.arpa.\");\n    enum_query(\"e164.arpa.\",\"voice\");\n    # or use instead\n    enum_query(\"e164.arpa.\",\"+sip+voice:sip\");\n    ...\n\n",
 "enum_pv_query": "### enum_pv_query(\"pvar\" [,\"suffix\" [,\"service\"]])\n\n module: enum\n\nThe function performs an enum query on E.164 number stored in its first\nargument and rewrites the Request-URI with the result of the query. See\n[Overview](#sec-overview) for more information.\n\nMeaning of the parameters is as follows:\n\n- *pvar* - Pseudo variable that holds an E.164 number on which enum\n  query is performed.\n\n- *suffix* - Suffix to be appended to the domain name.\n\n- *service* - Service string to be used in the service field.\n\nParameters can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    # search for \"e2u+sip\" in freenum.org\n    enum_pv_query(\"$avp(i:100)\", \"freenum.org.\");\n    ...\n    # search for \"e2u+sip\" in default tree (configured as parameter)\n    enum_pv_query(\"$fU\");\n    ...\n    # search for \"e2u+voice:sip\" in e164.arpa\n    enum_pv_query(\"$avp(i:100)\",\"e164.arpa.\",\"voice\");\n    ...\n    # search for service type \"sip\" or \"voice:sip\" or \"video:sip\"\n    # note the '+' sign in front of the second parameter\n    enum_pv_query(\"$fU\",\"e164.arpa.\",\"+sip+voice:sip+video:sip\");\n    ...\n    # quering for service sip and voice:sip\n    enum_pv_query(\"$avp(i:100)\",\"e164.arpa.\");\n    enum_pv_query(\"$avp(i:100)\",\"e164.arpa.\",\"voice\");\n    # or use instead\n    enum_pv_query(\"$avp(i:100)\",\"e164.arpa.\",\"+sip+voice:sip\");\n    ...\n\n",
 "i_enum_query": "### i_enum_query([\"suffix\" [,\"service\"]])\n\n module: enum\n\nThe function performs an enum query and rewrites the Request-URI with\nthe result of the query. This is the Infrastructure-ENUM version of\nenum_query(). The only difference to enum_query() is in the calculation\nof the FQDN where NAPTR records are looked for.\n\nParameters can include pseudo-variables.\n\nSee\nftp://ftp.rfc-editor.org/in-notes/internet-drafts/draft-haberler-carrier-enum-01.txt\nfor the rationale behind this function.\n\n",
 "is_from_user_enum": "### is_from_user_enum()\n\n module: enum\n\nChecks if the user part of from URI is found in an enum lookup. Returns\n1 if yes and -1 if not.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_from_user_enum()) {\n        ....\n    };\n    ...\n",
 "timer_enable": "### timer_enable(timer_id, enable_disable)\n\n module: timer\n\nEnable/disable timer route specified by `timer_id`. Because of timer\ncore API the callback is not disabled immediately but is removed from\nhandler by itself not to decrease performance. Disabling and enabling in\nsequence may be tricky.\n\n- timer_id\n  references to timer declared by\n  declare_timer\n  .\n- enable_disable\n  \\- set to 1 to enable timer, to 0 to disable.\n\n<!-- -->\n\n    ...\n    timer_enable(\"MY_TIMER\", 1);\n    ...\n                    \n\n",
 "mq_add": "### mq_add(queue, key, value)\n\n module: mqueue\n\nAdd a new item (key, value) in the queue. If max size of queue is\nexceeded, the oldest one is removed.\n\n    ...\n    mq_add(\"myq\", \"$rU\", \"call from $fU\");\n    ...\n\n",
 "mq_fetch": "### mq_fetch(queue)\n\n module: mqueue\n\nTake oldest item from queue and fill \\$mqk(queue) and \\$mqv(queue)\npseudo variables.\n\nReturn: true on success (1); false on failure (-1) or no item fetched\n(-2).\n\n    ...\n    while(mq_fetch(\"myq\"))\n    {\n       xlog(\"$mqk(myq) - $mqv(myq)\\n\");\n    }\n    ...\n\n",
 "mq_pv_free": "### mq_pv_free(queue)\n\n module: mqueue\n\nFree the item fetched in pseudo-variables. It is optional, a new fetch\nfrees the previous values.\n\n    ...\n    mq_pv_free(\"myq\");\n    ...\n\n",
 "mq_size": "### mq_size(queue)\n\n module: mqueue\n\nReturns the current number of elements in the mqueue.\n\nIf the mqueue is empty, the function returns -1. If the mqueue is not\nfound, the function returns -2.\n\n    ...\n    $var(q_size) = mq_size(\"queue\");\n    xlog(\"L_INFO\", \"Size of queue is: $var(q_size)\\n\");\n    ...\n\n",
 "ds_select_dst": "### ds_select_dst(set, alg[, limit])\n\n module: dispatcher\n\nThe method selects a destination from addresses set. It returns true if\na new destination is set. The selected address is set to dst_uri field\n(aka the outbound proxy address or the \\$du variable), not being visible\nin the SIP request.\n\nIf the bit 2 in 'flags' parameter is set, the rest of the addresses from\nthe destination set are stored in XAVP list (limited with an optional\n'limit' parameter). You can use 'ds_next_dst()' to use next address in\norder to achieve serial forking to all possible destinations.\n\nMeaning of the parameters is as follows:\n\n- *set* - the id of the set from where to pick up destination address.\n  It is the first column in destination list file. The parameter can be\n  an integer or a variable holding an integer.\n\n- *alg* - the algorithm used to select the destination address. The\n  parameter can be an integer or a variable holding an integer.\n\n  - \u201c0\u201d - hash over callid\n\n  - \u201c1\u201d - hash over from URI.\n\n  - \u201c2\u201d - hash over to URI.\n\n  - \u201c3\u201d - hash over request-URI user.\n\n  - \u201c4\u201d - round-robin (next destination).\n\n  - \u201c5\u201d - hash over authorization-username (Proxy-Authorization or\n    \"normal\" authorization). If no username is found, round robin is\n    used.\n\n  - \u201c6\u201d - random destination (using rand()).\n\n  - \u201c7\u201d - hash over the content of PVs string. Note: This works only\n    when the parameter hash_pvar is set.\n\n  - \u201c8\u201d - select destination sorted by priority attribute value (serial\n    forking ordered by priority).\n\n  - \u201c9\u201d - use weight based load distribution. You have to set the\n    attribute 'weight' for each address (gateway) in destination set.\n    See also the description of the 'weight' attribute in the 'Special\n    Attributes' section.\n\n  - \u201c10\u201d - use call load distribution. You have to set the attribute\n    'duid' (as an unique string id) per each address in destination set.\n    Also, you must set the parameter 'ds_hash_size'.\n\n    The algorithm can be used even with stateless proxy mode, there is\n    no SIP dialog tracking depending on other modules, just an internal\n    lightweight call tracking by Call-Id, thus is fast and suitable even\n    for embedded systems.\n\n    The first destination selected by this algorithm is the one that has\n    the least number of calls associated. The rest of the destination\n    list is taken in order of the entries in set - anyhow, until a\n    re-route to next destination happens, the load on each address can\n    change.\n\n    This algorithm can be used only for dispatching INVITE requests as\n    it is the only SIP method creating a SIP call.\n\n  - \u201c11\u201d - use relative weight based load distribution. You have to set\n    the attribute 'rweight' per each address in destination set. Active\n    host usage probability is rweight/(SUM of all active host rweights\n    in destination group).\n\n    The major difference from the weight distribution is the probability\n    recalculation according to rweight value in case of destinations\n    being active or inactive.\n\n    For example, 100 calls in 3-destinations group with rweight params\n    1/2/1 will be distributed as 25/50/25. If the third destination\n    becomes inactive, the distribution is changed to 33/67/0. If the\n    computation of percentage per destination is not an exact integer\n    number, the value is trucated and the last destination is used to\n    fill the remaining percentage till 100.\n\n    Using this algorithm, you can also enable congestion control by\n    setting the attribute 'cc=1', when 'cc' is enabled the 'weight'\n    attribute will also be used to control congestion tolerance. When\n    facing congestion the weight of a gateway is lowered by 1 for every\n    ms of estimated congestion, a 'rweight' value of 50 is recommended.\n    See the example \"configuring load balancing with congestion\n    detection\" below.\n\n    The congestion estimation is done using an EWMA (see\n    ds_latency_estimator_alpha). If all the gateways in a set are above\n    their congestion threshold(weight), the load distribution is instead\n    done using the ratio of estimated congestion ms.\n\n    See also the description of the 'rweight' attribute in the 'Special\n    Attributes' section.\n\n  - \u201c12\u201d - dispatch to all destination in setid at once (parallel\n    forking). Note that the XAVPs are no longer set with the values of\n    the destination records, no re-routing making sense in this case.\n\n  - \u201c13\u201d - latency optimized dispatching\n\n    \\- The algorithm will load balance using round-robin prioritizing\n    the gateways with the highest priority.\n\n    \\- If ds_ping_latency_stats is active the algorithm will adjust the\n    priority of the gateway automatically, the priority will be lowered\n    by 1 point every time the latency ms is as high as the priority.\n\n    \\- If the attribute 'cc=1' is set, the latency used is congestion ms\n    : estimate (current latency ms) - average (normal condition latency\n    ms).\n\n        Using this simple formula :\n            ADJUSTED_PRIORITY = PRIORITY - (ESTIMATED_LATENCY_MS/PRIORITY)\n\n        GATEWAY | PRIORITY | ESTIMATED | ADJUSTED | LOAD\n           #    |          |  LATENCY  | PRIORITY | DISTRIBUTION\n           1    |    30    |    21     |    30    | 33%\n           2    |    30    |    91     |    27    | 0%\n           3    |    30    |    61     |    28    | 0%\n           4    |    30    |    19     |    30    | 33%\n           5    |    30    |    32     |    29    | 0%\n           6    |    30    |    0      |    30    | 33%\n           7    |    30    |    201    |    24    | 0%\n\n\n        With congestion control the formula becomes :\n            CONGESTION_MS = CURRENT_LATENCY_MS - NORMAL_CONDITION_LATENCY_MS\n            ADJUSTED_PRIORITY = PRIORITY - (CONGESTION_MS/PRIORITY)\n                        \n\n  - \u201cX\u201d - if the algorithm is not implemented, the first entry in set is\n    chosen.\n\n- *limit* - the maximum number of items to be stored in XAVP list for\n  further fail-overs (the first selected destination and default\n  destination are the first to be put in the list). This can improve the\n  performance especially if you are using a large list of gateways.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    ds_select_dst(\"1\", \"0\");\n    ...\n    $var(a) = 4;\n    ds_select_dst(\"1\", \"$var(a)\");\n    ...\n    ds_select_dst(\"1\", \"4\", \"3\");\n    ...\n\n    ...\n    # sample of SQL provisioning statements\n    INSERT INTO \"dispatcher\"\n    VALUES(1,1,'sip:192.168.0.1:5060',0,12,'rweight=50;weight=50;cc=1;','');\n    INSERT INTO \"dispatcher\"\n    VALUES(2,1,'sip:192.168.0.2:5060',0,12,'rweight=50;weight=50;cc=1;','');\n    ...\n    modparam(\"dispatcher\", \"ds_ping_interval\", 1) # ping gateways once/second\n    modparam(\"dispatcher\", \"ds_ping_latency_stats\", 1) # update congestion metrics\n    # configure the latency estimator\n    modparam(\"dispatcher\", \"ds_latency_estimator_alpha\", 900)\n    ...\n    if (!ds_select_dst(\"1\", \"11\")) { # use relative weight based load distribution\n    ...\n    # sample of output from 'kamcmd dispatcher.list'\n    DEST: {\n        URI: sip:192.168.0.1:5060\n        FLAGS: AP\n        PRIORITY: 12\n        ATTRS: {\n            BODY: rweight=50;weight=50;cc=1 # configuration values\n            DUID:\n            MAXLOAD: 0\n            WEIGHT: 50\n            RWEIGHT: 50\n            SOCKET:\n            SOCKNAME:\n            OBPROXY:\n        }\n        LATENCY: {\n            AVG: 20.104000\n            STD: 1.273000\n            # estimated congestion is currently 25ms = 45ms(EST) -20ms(AVG)\n            EST: 45.005000\n            MAX: 132\n            TIMEOUT: 3\n        }\n    }\n    ...\n\n",
 "ds_select_domain": "### ds_select_domain(set, alg[, limit])\n\n module: dispatcher\n\nThe method selects a destination from addresses set and rewrites the\nhost and port from R-URI. The parameters have same meaning as for\nds_select_dst().\n\nIf the bit 2 in 'flags' is set, the rest of the addresses from the\ndestination set are stored in XAVP list (limited with an optional\n'limit' parameter). You can use 'ds_next_domain()' to use next address\nto achieve serial forking to all possible destinations.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    $var(a) = 4;\n    if(ds_select_domain(\"1\", \"$var(a)\")) {\n        t_relay();\n        exit;\n    }\n    ...\n\n",
 "ds_select": "### ds_select(set, alg [, limit])\n\n module: dispatcher\n\nThe method selects a destination from addresses set and adds it in the\nXAVP specified for this module. It is not updating R-URI nor the\ndestination URI. The parameters have same meaning as for\nds_select_dst().\n\nIf the bit 2 in 'flags' is set, the rest of the addresses from the\ndestination set are stored in XAVP list (limited with an optional\n'limit' parameter). You can execute 'ds_next_domain()' or\n'ds_next_dst()' to use next address to achieve serial forking to all\npossible destinations.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(a) = 4;\n    if(ds_select(\"1\", \"$var(a)\")) {\n        ds_next_domain();\n        t_relay();\n        exit;\n    }\n    ...\n\n",
 "ds_select_routes": "### ds_select_routes(rules, mode [, limit])\n\n module: dispatcher\n\nThe method selects destinations following the rules combining groups add\nalgorithms, controlling where the first destination address is pushed,\nand optionally setting a limit of selected addresses.\n\nParameters:\n\n- *rules* - a string in the format \"grp1=alg1;grp2=alg2;...grpN=algN\",\n  where grpX is an integer number identifying a dispatcher set id and\n  algN is a dispatcher algorithm identifier. No white spaces should be\n  given in the parameter value. The parameter can contain\n  pseudo-variables.\n\n- *mode* - control where to push the first selected target address.\n  Valid values are: '0', 'd' or 'D' to push the address in destination\n  URI; '1', 'r' or 'R' to push the address in R-URI; '2', 'x' or 'X' to\n  push the address only in the XAVP when failure rerouting is enabled.\n  Note that only first character of the parameter matters, therefore one\n  can use a more meaningful value such as 'ruri' instead of 'r'. The\n  parameter can contain pseudo variables.\n\n- *limit* - a positive integer value to restrict the number of selected\n  target addresses. If it is 0, then no limit is considered. The\n  parameter can be a static integer or a variable holding an integer\n  value.\n\nIf the bit 2 in 'flags' is set, the rest of the addresses from the\ndestination groups are stored in XAVP list (limited with an optional\n'limit' parameter). You can execute 'ds_next_domain()' or\n'ds_next_dst()' to use next address to achieve serial forking to all\npossible destinations.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(alg) = 4;\n    $var(limit) = 8;\n    if(ds_select_routes(\"1=4;2=$var(alg)\", \"ruri\", \"$var(limit)\")) {\n        t_on_failure(\"REROUTE\");\n        t_relay();\n        exit;\n    }\n    failure_route[REROUTE] {\n        if(t_check_status(\"408|5[0-9][0-9]\")) {\n            if(ds_next_domain()) {\n                t_on_failure(\"REROUTE\");\n                t_relay();\n                exit;\n            }\n        }\n    }\n    ...\n\n",
 "ds_next_dst": "### ds_next_dst()\n\n module: dispatcher\n\nTakes the next destination address from the corresponding XAVPs and sets\nthe dst_uri (outbound proxy address).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n",
 "ds_next_domain": "### ds_next_domain()\n\n module: dispatcher\n\nTakes the next destination address from the corresponding XAVPs and sets\nthe domain part of the request URI.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n",
 "ds_set_dst": "### ds_set_dst()\n\n module: dispatcher\n\nTakes the current destination address from the corresponding XAVPs and\nsets the dst_uri (outbound proxy address).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n",
 "ds_set_domain": "### ds_set_domain()\n\n module: dispatcher\n\nTakes the current destination address from the corresponding XAVPs and\nsets the domain part of the request URI.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n",
 "ds_mark_dst": "### ds_mark_dst([state])\n\n module: dispatcher\n\nMark the last used address from destination set as inactive (\"i\"/\"I\"),\nactive (\"a\"/\"A\"), disabled (\"d\"/\"D\") or trying (\"t\"/\"T\"). Apart of\ndisabled state, a destination can be set in probing mode by adding\n(\"p\"/\"P\") flag. With this function, an automatic detection of failed\ngateways can be implemented. When an address is marked as inactive or\ndisabled, it will be ignored by 'ds_select_dst' and 'ds_select_domain'.\n\nThe parameter state is optional, when it is missing, then the\ndestination will be marked inactive (i.e., same as 'i').\n\nPossible values for state parameter:\n\n- *\"a\" or \"A\"* - the last destination should be set to active and the\n  error-counter should set to \"0\".\n\n- *\"i\" or \"I\"* - the last destination should be set to inactive and will\n  be ignored in future requests.\n\n- *\"t\" or \"T\"* - the last destination should be set to temporary trying\n  state and failure counter is incremented. When the failure counter\n  reaches the threshold, the destination will be set inactive.\n\n- *\"p\" and \"P\"* - this has to be used in addition to one of the previous\n  flags - the last destination will be set to probing. This mean the\n  destination will be pinged with SIP OPTIONS requests from time to time\n  to detect if it is up or down.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    failure_route[tryagain] {\n    ...\n       if(t_check_status(\"500\"))\n          ds_mark_dst(\"ip\"); # set to inactive and probing\n    ...\n    }\n    ...\n\n",
 "ds_list_exists": "### ds_list_exists(groupid)\n\n module: dispatcher\n\nFunction alias: ds_list_exist(groupid)\n\nCheck if a specific group is defined in dispatcher list or database.\n\n- *groupid* - A group ID to check.\n\nIt returns true (value 1) if the group exists, or otherwise false (-1\nwhen the group is not found; -2 when evaluating the parameter fails).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(ds_list_exists(\"10\")) {\n        ...\n    }\n    ...\n\n",
 "ds_is_from_list": "### ds_is_from_list([groupid [, mode [, uri] ] ])\n\n module: dispatcher\n\nThis function returns true, if there is a match of source address or uri\nwith an address in the given group of the dispatcher-list; otherwise\nfalse.\n\nDescription of parameters:\n\n- *groupid* (optional) - if not given or its value is -1, the matching\n  will be done over all addresses in all dispatcher groups. Otherwise\n  the matching will be done only against the addresses in the specific\n  group id. The parameter can be an integer or a variable holding an\n  integer value.\n\n- *mode* - (optional) - a bitmask to specify how the matching should be\n  done. If the parameter is missing, the matching is done with ignoring\n  the protocol (value 2). If parameter is 0, all ip, port and proto are\n  matched and active status is ignored. If bit one is set, then port is\n  ignored. If bit two is set, then protocol is ignored. If bit three is\n  set, then state must be active. The parameter can be an integer or a\n  variable holding an integer value. It must be provided if the uri\n  parameter is provided.\n\n- *uri* (optional) - if parameter is empty or missing, the matching is\n  done against source IP, port and protocol. Otherwise the value has to\n  be a valid SIP URI, used to match against addresses in the dispatcher\n  list. Only IP, port and protocol are matches, any additional\n  parameters are ignored. The parameter can be a static or dynamic (with\n  variables) string. The domain part of the URI can be an IP address or\n  a hostname.\n\nUpon a match, the variable specified by 'setid_pvname' parameter will be\nset to groupid of matching address and the attributes will be set in\nvariable specified by 'attrs_pvname'.\n\nNote that for backward compatibility mode, when no parameter is given or\nonly groupid is given, the matching is done only for IP address and port\n(protocol is ignored).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(ds_is_from_list()) {\n        ...\n    }\n    if(ds_is_from_list(\"10\")) {\n        ...\n    }\n    if(ds_is_from_list(\"10\", \"3\")) {\n        ...\n    }\n    if(ds_is_from_list(\"10\", \"3\", \"sip:127.0.0.1:5080\")) {\n        ...\n    }\n    ...\n\n",
 "ds_is_active": "### ds_is_active(groupid [, uri])\n\n module: dispatcher\n\nThis function returns true, if there is an active URI in the destination\ngroup; otherwise false. If the uri parameter is provided, then the\ncorresponding destination has to be active.\n\nDescription of parameters:\n\n- *groupid* - the group id. The parameter can be an integer or a\n  variable holding an integer value.\n\n- *uri* (optional) - the URI of the destination. if parameter is empty\n  or missing, the any destination is matched.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(ds_is_active(\"10\")) {\n        ...\n    }\n    if(ds_is_active(\"10\", \"sip:127.0.0.1:5080\")) {\n        ...\n    }\n    ...\n\n",
 "ds_load_update": "### ds_load_update()\n\n module: dispatcher\n\nUpdates the load state:\n\n- if it is a BYE or CANCEL - remove the load from destination address\n  used to forward the INVITE\n\n- if it is a reply to INVITE - set internal state to confirmed for call\n  load structure when reply code is 2xx.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE and ONREPLY_ROUTE.\n\n",
 "ds_load_unset": "### ds_load_unset()\n\n module: dispatcher\n\nRemove the call load for the destination that routed the call.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    route {\n        ...\n        if(is_method(\"BYE|CANCEL\"))\n            ds_load_update();\n        ...\n        ds_select_dst(\"1\", \"10\");\n        ...\n    }\n\n    onreply_route {\n        ...\n        if(is_method(\"INVITE\")\n        {\n            if(status=~\"2[0-9][0-9]\")\n                ds_load_update();\n            else if(status=~\"[3-7][0-9][0-9]\")\n                ds_load_unset();\n        }\n        ...\n    }\n    ...\n\n",
 "ds_reload": "### ds_reload()\n\n module: dispatcher\n\nReloads the groups and included destinations.\n\nName: *ds_reload*\n\nParameters: *none*\n\nThis function can be used from ANY_ROUTE.\n\n",
 "async_route": "### async_route(routename, seconds)\n\n module: async\n\nSimulate a sleep of 'seconds' and then continue the processing of the\nSIP request with the route\\[routename\\]. In case of internal errors, the\nfunction returns false, otherwise the function exits the execution of\nthe script at that moment (return 0 behaviour).\n\nThe routename parameter can be a static string or a dynamic string value\nwith config variables.\n\nThe sleep parameter represent the number of seconds to suspend the\nprocessing of a SIP request. Maximum value is 100. The parameter can be\na static integer or a variable holding an integer.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution state is practically lost. Therefore beware that the\nexecution of config after resume will end once the route\\[routename\\] is\nfinished.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    request_route {\n        ...\n        async_route(\"RESUME\", \"4\");\n        ...\n    }\n    route[RESUME] {\n       send_reply(\"404\", \"Not found\");\n       exit;\n    }\n    ...\n\n",
 "async_ms_route": "### async_ms_route(routename, milliseconds)\n\n module: async\n\nSimulate a sleep of 'milliseconds' and then continue the processing of\nthe SIP request with the route\\[routename\\]. In case of internal errors,\nthe function returns false, otherwise the function exits the execution\nof the script at that moment (return 0 behaviour). This function works\nonly if the ms_timer parameter has a value greater than 0.\n\nThe routename parameter can be a static string or a dynamic string value\nwith config variables.\n\nThe sleep parameter represent the number of milliseconds to suspend the\nprocessing of a SIP request. Maximum value is 30000 (30 sec). The\nparameter can be a static integer or a variable holding an integer.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution state is practically lost. Therefore beware that the\nexecution of config after resume will end once the route\\[routename\\] is\nfinished.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    request_route {\n        ...\n        async_ms_route(\"RESUME\", \"250\");\n        ...\n    }\n    route[RESUME] {\n       send_reply(\"404\", \"Not found\");\n       exit;\n    }\n    ...\n\n",
 "async_sleep": "### async_sleep(seconds)\n\n module: async\n\nSimulate a sleep of 'seconds' and then continue the processing of SIP\nrequest with the next action. In case of internal errors, the function\nreturns false.\n\nThe sleep parameter represent the number of seconds to suspend the\nprocessing of SIP request. Maximum value is 100. The parameter can be a\nstatic integer or a variable holding an integer.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    async_sleep(\"4\");\n    send_reply(\"404\", \"Not found\");\n    exit;\n    ...\n\n",
 "async_ms_sleep": "### async_ms_sleep(milliseconds)\n\n module: async\n\nSimulate a sleep of 'milliseconds' and then continue the processing of\nSIP request with the next action. In case of internal errors, the\nfunction returns false. This function works only if the ms_timer\nparameter has a value greater than 0.\n\nThe sleep parameter represent the number of milliseconds to suspend the\nprocessing of SIP request. Maximum value is 30000 (30 sec). The\nparameter can be a static integer or a variable holding an integer.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    route[REQUESTSHAPER] {\n        $var(res) = http_connect(\"leakybucket\",\n                \"/add?key=$fd\", $null, $null,\"$avp(delay)\");\n        $var(d) = $(avp(delay){s.int});\n        if ($var(d) > 0) {\n            # Delay the request by $avp(delay) ms\n            async_ms_sleep(\"$var(d)\");\n            if (!t_relay()) {\n                sl_reply_error();\n            }\n            exit;\n        }\n        # No delay\n        if (!t_relay()) {\n            sl_reply_error();\n        }\n        exit;\n    }\n    ...\n\n",
 "async_task_route": "### async_task_route(routename)\n\n module: async\n\nContinue the processing of the SIP request with the route\\[routename\\]\nin one of the processes from first group of core asynchronous framework.\nThe core parameter async_workers has to be set to enable asynchronous\nframework. The task is executed as soon as a process from asynchronous\nframework is idle, there is no wait time for the task like for\nasync_route(...).\n\nTo enable the core asynchronous framework, you need to set the\n*async_workers* core parameter in the configuration file. See the core\ncookbook for more information.\n\n    ...\n    # Enable 8 worker processes used by async and other modules\n    async_workers=8\n    ...\n\nIn case of internal errors, the function returns false, otherwise the\nfunction exits the execution of the script at that moment (return 0\nbehaviour).\n\nThe routename parameter can be a static string or a dynamic string value\nwith config variables.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution state is practically lost. Therefore beware that the\nexecution of config after resume will end once the route\\[routename\\] is\nfinished.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    request_route {\n        ...\n        async_task_route(\"RESUME\");\n        ...\n    }\n    route[RESUME] {\n       t_relay();\n       exit;\n    }\n    ...\n\n",
 "async_task_group_route": "### async_task_group_route(routename, groupname)\n\n module: async\n\nSimilar to async_task_route(), but allows to specify the name of the\ngroup for asynchronous workers. See also 'async_workers_group' core\nglobal parameter.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    async_workers_group=\"name=abc;workers=4;nonblock=0;usleep=0\"\n    ...\n    request_route {\n        ...\n        async_task_route(\"RESUME\", \"abc\");\n        ...\n    }\n    route[RESUME] {\n       t_relay();\n       exit;\n    }\n    ...\n\n",
 "async_task_data": "### async_task_data(routename, data)\n\n module: async\n\nSend the data to an asynchronous task process (in the first group) that\nexecutes the route\\[rountename\\] and makes the data available via\n\\$async(data).\n\nThe current SIP message is not suspended and it is not available in the\nasynchronous task process, a local faked SIP request is used there.\n\nThe parameters can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    async_workers_group=\"name=abc;workers=4;nonblock=0;usleep=0\"\n    ...\n    request_route {\n        ...\n        async_task_data(\"RESUME\", \"caller: $fU - callee: $tU\");\n        ...\n    }\n    route[RESUME] {\n       xinfo(\"$async(data)\\n\");\n       exit;\n    }\n    ...\n\n",
 "async_task_group_data": "### async_task_group_data(routename, groupname, data)\n\n module: async\n\nSimilar to async_task_route(), but allows to specify the name of the\ngroup for asynchronous workers. See also 'async_workers_group' core\nglobal parameter.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    async_workers_group=\"name=abc;workers=4;nonblock=0;usleep=0\"\n    ...\n    request_route {\n        ...\n        async_task_data(\"RESUME\", \"abc\", \"caller: $fU - callee: $tU\");\n        ...\n    }\n    route[RESUME] {\n       xinfo(\"$async(data)\\n\");\n       exit;\n    }\n    ...\n",
 "prom_counter_reset": "### prom_counter_reset(name, l0, l1, l2)\n\n module: xhttp_prom\n\nGet a counter based on its name and labels and reset its value to 0.\nName parameter is mandatory. Values of labels are optional (from none up\nto three). Name in prom_counter_reset has to match same name in\nprom_counter parameter. Number of labels in prom_counter_reset has to\nmatch number of labels in prom_counter parameter. First time a counter\nis used with this reset function the counter is created if it does not\nexist already.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *counter_reset_l0*, *counter_reset_l1*,\n*counter_reset_l2* and *counter_reset_l3*.\n\n    ...\n    # Definition of counter with prom_counter with labels method and IP\n    modparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt01; label=method:IP;\");\n    ...\n    # Reset cnt01 counter with two values \"push\" and \"192.168.0.1\" in labels to zero.\n    # First time we execute this function the counter will be created.\n    prom_counter_reset(\"cnt01\", \"push\", \"192.168.0.1\");\n    ...\n    # A metric like this will appear when listing this counter:\n    kamailio_cnt01 {method=\"push\", IP=\"192.168.0.1\"} 0 1234567890\n    ...\n            \n\n",
 "prom_gauge_reset": "### prom_gauge_reset(name, l0, l1, l2)\n\n module: xhttp_prom\n\nGet a gauge based on its name and labels and reset its value to 0. Name\nparameter is mandatory. Values of labels are optional (from none up to\nthree). Name in prom_gauge_reset has to match same name in prom_gauge\nparameter. Number of labels in prom_gauge_reset has to match number of\nlabels in prom_gauge parameter. First time a gauge is used with this\nreset function the gauge is created if it does not exist already.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *gauge_reset_l0*, *gauge_reset_l1*,\n*gauge_reset_l2* and *gauge_reset_l3*.\n\n    ...\n    # Definition of gauge with prom_gauge with labels method and IP\n    modparam(\"xhttp_prom\", \"prom_gauge\", \"name=cnt01; label=method:IP;\");\n    ...\n    # Reset cnt01 gauge with two values \"push\" and \"192.168.0.1\" in labels to zero.\n    # First time we execute this function the gauge will be created.\n    prom_gauge_reset(\"cnt01\", \"push\", \"192.168.0.1\");\n    ...\n    # A metric like this will appear when listing this gauge:\n    kamailio_cnt01 {method=\"push\", IP=\"192.168.0.1\"} 0 1234567890\n    ...\n            \n\n",
 "prom_counter_inc": "### prom_counter_inc(name, number, l0, l1, l2)\n\n module: xhttp_prom\n\nGet a counter identified by its name and labels and increase its value\nby a number. If counter does not exist it creates the counter,\ninitializes it to zero and adds the number.\n\nName is mandatory, number is mandatory. Number has to be positive or\nzero (integer). l0, l1, l2 are values of labels and are optional.\n\nname value and number of labels have to match a previous counter\ndefinition with prom_counter.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *counter_inc_l0*, *counter_inc_l1*,\n*counter_inc_l2* and *counter_inc_l3*.\n\n    ...\n    # Definition of cnt01 counter with no labels.\n    modparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt01;\");\n    ...\n    # Add 10 to value of cnt01 counter (with no labels) If counter does not exist it gets created.\n    prom_counter_inc(\"cnt01\", \"10\");\n    ...\n\n    # Definition of cnt02 counter with two labels method and IP\n    modparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt02; label=method:IP;\");\n    ...\n    # Add 15 to value of cnt02 counter with labels method and IP. It creates the counter if it does not exist.\n    prom_counter_inc(\"cnt02\", \"15\", \"push\", \"192.168.0.1\");\n    # When listed the metric it will show a line like this:\n    kamailio_cnt02 {method=\"push\", IP=\"192.168.0.1\"} 15 1234567890\n    ...\n            \n\n",
 "prom_gauge_set": "### prom_gauge_set(name, number, l0, l1, l2)\n\n module: xhttp_prom\n\nGet a gauge identified by its name and labels and set its value to a\nnumber. If gauge does not exist it creates the gauge and assigns the\nvalue to it.\n\nName is mandatory, number is mandatory. Number is a string that will be\nparsed as a float. l0, l1, l2 are values of labels and are optional.\n\nname value and number of labels have to match a previous gauge\ndefinition with prom_gauge.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *gauge_set_l0*, *gauge_set_l1*,\n*gauge_set_l2* and *gauge_set_l3*.\n\n    ...\n    # Definition of gg01 gauge with no labels.\n    modparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg01;\");\n    ...\n    # Assign -12.5 to value of gg01 gauge (with no labels) If gauge does not exist it gets created\n    prom_gauge_set(\"gg01\", \"-12.5\");\n    ...\n\n    # Definition of gg02 gauge with two labels method and IP\n    modparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg02; label=method:IP;\");\n    ...\n    # Assign 2.8 to value of gg02 gauge with labels method and IP. It creates the gauge if it does not exist.\n    prom_gauge_set(\"gg02\", \"2.8\", \"push\", \"192.168.0.1\");\n    # When listed the metric it will show a line like this:\n    kamailio_gg02 {method=\"push\", IP=\"192.168.0.1\"} 2.8 1234567890\n    ...\n            \n\n",
 "prom_histogram_observe": "### prom_histogram_observe(name, number, l0, l1, l2)\n\n module: xhttp_prom\n\nGet a histogram identified by its name and labels and observe a value in\nit. If histogram does not exist it creates the histogram and accumulate\nthe value in its buckets, counter and sum.\n\nName is mandatory, number is mandatory. Number is a string that will be\nparsed as a float. l0, l1, l2 are values of labels and are optional.\n\nname value and number of labels have to match a previous histogram\ndefinition with prom_histogram.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *histogram_observe_l0*,\n*histogram_observe_l1*, *histogram_observe_l2* and\n*histogram_observe_l3*.\n\n    ...\n    # Definition of hist01 histogram with no labels and default buckets.\n    modparam(\"xhttp_prom\", \"prom_histogram\", \"name=hist01;\");\n    ...\n    # Observe -12.5 value in hist01 histogram (with no labels). If histogram does not exist it gets created:\n    prom_histogram_observe(\"hist01\", \"-12.5\");\n    ...\n\n    # Definition of hist02 histogram with two labels method and IP and buckets [2.3, 5.8, +Inf]:\n    modparam(\"xhttp_prom\", \"prom_histogram\", \"name=hist02; label=method:IP; buckets=2.3:5.8\");\n    ...\n    # Observe 2.8 value in hist02 histogram with labels method and IP.\n    # It creates the histogram if it does not exist.\n    prom_histogram_observe(\"hist02\", \"2.8\", \"push\", \"192.168.0.1\");\n    # When listed the metric it will show lines like this:\n    hist02_bucket{method=\"push\", IP=\"192.168.0.1\", le=\"2.300000\"} 0 1592574659768\n    hist02_bucket{method=\"push\", IP=\"192.168.0.1\", le=\"5.800000\"} 1 1592574659768\n    hist02_bucket{method=\"push\", IP=\"192.168.0.1\", le=\"+Inf\"} 1 1592574659768\n    hist02_sum{method=\"push\", IP=\"192.168.0.1\"} 2.800000 1592574659768\n    hist02_count{method=\"push\", IP=\"192.168.0.1\"} 1 1592574659768\n\n    ...\n            \n\n",
 "prom_dispatch": "### prom_dispatch()\n\n module: xhttp_prom\n\nHandle the HTTP request and generate a response.\n\nAvailable via KEMI framework as *xhttp_prom.dispatch*\n\n    ...\n    # Needed to use SIP frames as HTTP ones.\n    tcp_accept_no_cl=yes\n    ...\n    # xhttp module depends on sl one.\n    loadmodule \"sl.so\"\n    loadmodule \"xhttp.so\"\n    loadmodule \"xhttp_prom.so\"\n    ...\n    # show all kamailio statistics.\n    modparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"all\")\n    ...\n    event_route[xhttp:request] {\n        $var(xhttp_prom_root) = $(hu{s.substr,0,8});\n        if ($var(xhttp_prom_root) == \"/metrics\")\n            prom_dispatch();\n        else\n            xhttp_reply(\"200\", \"OK\", \"text/html\",\n                    \"<html><body>Wrong URL $hu</body></html>\");\n    }\n    ...\n            \n\nAnother example with counters and gauge:\n\n    ...\n    # Needed to use SIP frames as HTTP ones.\n    tcp_accept_no_cl=yes\n\n    # xhttp module depends on sl one.\n    loadmodule \"sl.so\"\n    loadmodule \"xhttp.so\"\n    loadmodule \"xhttp_prom.so\"\n\n    # show Kamailio statistics for sl group\n    modparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"sl:\")\n\n    # Define two counters and a gauge\n    modparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_first;\");\n    modparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_second; label=method:IP\");\n    modparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg_first; label=handler\");\n\n    event_route[xhttp:request] {\n        $var(xhttp_prom_root) = $(hu{s.substr,0,8});\n        if ($var(xhttp_prom_root) == \"/metrics\") {\n            prom_counter_reset(\"cnt_first\");\n            prom_counter_inc(\"cnt_second\", \"10\", \"push\", \"192.168.0.1\");\n            prom_gauge_set(\"gg_first\", \"5.2\", \"my_handler\");\n            prom_dispatch();\n        } else\n            xhttp_reply(\"200\", \"OK\", \"text/html\",\n                    \"<html><body>Wrong URL $hu</body></html>\");\n    }\n    ...\n\n    We can manually check the result with a web browser:\n    We assume Kamailio runs in localhost and port is set to default (same as SIP: 5060)\n    http://localhost:5060\n    ...\n\n    # User defined metrics\n    kamailio_cnt_first 0 1554839325427\n    kamailio_cnt_second {method=\"push\", IP=\"192.168.0.1\"} 10 1554839325427\n    kamailio_gg_first{handler=\"my_handler\"} 5.2 1554839325427\n\n    # Kamailio internal statistics\n    kamailio_sl_1xx_replies 0 1554839325427\n    kamailio_sl_200_replies 15 1554839325427\n    kamailio_sl_202_replies 0 1554839325427\n    kamailio_sl_2xx_replies 0 1554839325427\n    kamailio_sl_300_replies 0 1554839325427\n    kamailio_sl_301_replies 0 1554839325427\n    kamailio_sl_302_replies 0 1554839325427\n    kamailio_sl_3xx_replies 0 1554839325427\n    kamailio_sl_400_replies 0 1554839325427\n    kamailio_sl_401_replies 0 1554839325427\n    kamailio_sl_403_replies 0 1554839325427\n    kamailio_sl_404_replies 0 1554839325427\n    kamailio_sl_407_replies 0 1554839325427\n    kamailio_sl_408_replies 0 1554839325427\n    kamailio_sl_483_replies 0 1554839325427\n    kamailio_sl_4xx_replies 0 1554839325427\n    kamailio_sl_500_replies 0 1554839325427\n    kamailio_sl_5xx_replies 0 1554839325427\n    kamailio_sl_6xx_replies 0 1554839325427\n    kamailio_sl_failures 0 1554839325427\n    kamailio_sl_received_ACKs 0 1554839325427\n    kamailio_sl_sent_err_replies 0 1554839325427\n    kamailio_sl_sent_replies 15 1554839325427\n    kamailio_sl_xxx_replies 0 1554839325461\n    ...\n            \n\n",
 "prom_check_uri": "### prom_check_uri()\n\n module: xhttp_prom\n\nCheck if path of HTTP URL equals /metrics. This avoids us to check hu\nvariable from xHTTP module.\n\nNOTE: Remember not to block /metrics URL in xHTTP module\n\nAvailable via KEMI framework as *xhttp_prom.check_uri*\n\n    ...\n    # Needed to use SIP frames as HTTP ones.\n    tcp_accept_no_cl=yes\n    ...\n    # xhttp module depends on sl one.\n    loadmodule \"sl.so\"\n    loadmodule \"xhttp.so\"\n    loadmodule \"xhttp_prom.so\"\n    ...\n    # show all kamailio statistics.\n    modparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"all\")\n    ...\n    event_route[xhttp:request] {\n        if (prom_check_uri())\n            prom_dispatch();\n        else\n            xhttp_reply(\"200\", \"OK\", \"text/html\",\n                    \"<html><body>Wrong URL $hu</body></html>\");\n    }\n    ...\n            \n\n",
 "isc_match_filter_reg": "### isc_match_filter_reg(reg_state,domain)\n\n module: ims_isc\n\nThis function checks if a REGISTER messages matches Initial Filter\nCriteria - if so it inserts the necessary route headers and modifies the\ndestination URI to forward to the relevant Application Server.\n\nA positive return code (1) means that the REGISTER message has matched\nto Initial Filter Criteria and is armed for routing.\n\nThis function handles also the Service Info (if sent by the HSS), the\nInsertRegisterRequest flag (if sent by the HSS) or the\nInsertRegisterResponse flag (if sent by the HSS). Either the Service\nInfo OR the original REGISTER request OR the original REGISTER response\nis added to the body of the REGISTER message, before it is forwarded to\nthe relevant Application Server. Multipart body is not supported in this\ncase.\n\nMeaning of the parameters is as follows:\n\n- *reg_state* if the user was previously registered 0 - for initial\n  registration, 1 for re/de-registration.\n\n- *domain* that usrloc_scscf uses to store user information.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    isc_match_filter_reg(\"1\",\"location\");\n    ...\n            \n\n",
 "isc_match_filter": "### isc_match_filter(direction,domain)\n\n module: ims_isc\n\nThis function checks if a non-REGISTER messages matches Initial Filter\nCriteria - if so it inserts the necessary route headers and modifies the\ndestination URI to forward to the relevant Application Server.\n\nA positive return code (1) means that the message has matched to Initial\nFilter Criteria and is armed for routing.\n\nMeaning of the parameters is as follows:\n\n- *direction* the direction of this message - orig, term, etc.\n\n- *domain* that usrloc_scscf uses to store user information.\n\nThis function can be used from REQUEST_ROUTE \\| FAILURE_ROUTE.\n\n    ...\n    isc_match_filter(\"orig\",\"location\");\n    ...\n            \n\n",
 "isc_from_as": "### isc_from_as(direction)\n\n module: ims_isc\n\nThis function checks if this message has come from an Application\nServer.\n\nA positive return code (1) means that the message has come from an\nApplication Server.\n\nMeaning of the parameters is as follows:\n\n- *direction* the direction of this message - orig, term, etc.\n\nThis function can be used from REQUEST_ROUTE \\| FAILURE_ROUTE.\n\n    ...\n    if (!isc_from_as(\"orig\")) {\n        remove_hf(\"P-Asserted-Identity\");\n    }\n    ...\n            \n",
 "erl_rpc": "### erl_rpc(mod, fun, args, reply)\n\n module: erlang\n\nThis function supports calling Erlang functions on remote nodes.\n\nThe parameter *mod* and *fun* are module and function name respectively.\nIt can be a static string or a dynamic string value with config\nvariables.\n\nThe parameter *args* is list of arguments passed to function, so it must\nbe *list*, or *xbuff* that contains list.\n\nThe parameter *reply* is result from RPC call. It must be *xbuff* to\naccept any result.\n\nFunction returns false on error to send or wrong arguments passed to\nfunction. If executing remote function caused error function still\nreturns true but error is encoded into *repl* parameter.\n\n    ...\n    # example of call erlang:list_to_tuple([\"one\",\"two\"])\n    # on remote node\n\n    $erl_list(L) = \"two\";\n    $erl_list(L) = \"one\";\n\n    # put list into list\n    $erl_list(args) = $erl_list(L);\n\n    erl_rpc(\"erlang\", \"list_to_tuple\", \"$erl_list(args)\", \"$erl_xbuff(repl)\");\n\n    xlogl(\"L_DEBUG\",\"type(repl): $erl_xbuff(repl=>type), format(repl): $erl_xbuff(repl=>format)\\n\");\n\n    > log output:\n    ...\n    DEBUG: <script>: 386:type(repl): tuple, format(repl): {\"one\", \"two\"}\n    ...\n                    \n\n",
 "erl_reg_send": "### erl_reg_send(server, msg)\n\n module: erlang\n\nThis function sends an Erlang term to a registered process.\n\nThe argument *server* is the registered name of the intended recipient\nprocess on remote node.\n\nThe argument *msg* is containing the message to be sent.\n\n    ...\n    # example of send message to registered process\n    # {notifier,'node1@erlang.lan'} ! {example,message}\n\n    $erl_atom(example) = \"example\";\n    $erl_atom(message) = \"message\";\n\n    $erl_tuple(M) = $erl_atom(message);\n    $erl_tuple(M) = $erl_atom(example);\n\n    erl_reg_send(\"notifier\",\"$erl_tuple(M)\");\n    ...\n                    \n\n",
 "erl_send": "### erl_send(pid, msg)\n\n module: erlang\n\nThis function sends an Erlang term to a process. This function can be\nused from ANY_ROUTE. The argument *pid* is the Erlang process id of the\nintended recipient process on remote node. The argument *msg* is\ncontaining the message to be sent.\n\n    ...\n    # example of send message to process\n    # Pid ! {example,message}\n\n    $erl_atom(notifier) = \"notifier\";\n    $erl_list(args) = $erl_atom(notifier);\n\n    erl_rpc(\"erlang\", \"whereis\", \"$erl_list(args)\", \"$erl_xbuff(pid)\");\n\n    $erl_atom(example) = \"example\";\n    $erl_atom(message) = \"message\";\n\n    $erl_tuple(M) = $erl_atom(message);\n    $erl_tuple(M) = $erl_atom(example);\n\n    erl_send(\"$erl_xbuff(pid)\",\"$erl_tuple(M)\");\n    ...\n                    \n\n",
 "erl_reply": "### erl_reply(msg)\n\n module: erlang\n\nFunction to send message from event route (pseudo process). Function\nsends reply message *msg* to the sender process.\n\n    ...\n    # event route acts as registered process\n    event_route[erlang:greetings] {\n\n        xlogl(\"L_INFO\",\"Received message: $erl_xbuff(msg=>format)\\n\");\n\n        $erl_atom(hello) = \"hello\";\n        $erl_tuple(reply) = \"Erlang\";\n        $erl_tuple(reply) = $erl_atom(hello);\n\n        # reply greeting\n        erl_reply(\"$erl_tuple(reply)\");\n    }\n    ...\n\n    %% in erlang shell\n\n    (node1@erlang.lan)24> {greetings,'proxy@kamailio.lan'} ! {hello,\"Kamailio\"}.\n    {hello,\"Kamailio\"}\n    (node1@erlang.lan)25> flush().\n    Shell got {hello,\"Erlang\"}\n    ok\n\n    > logged info message:\n    INFO: <script>: 951:Received message: {\"hello\", \"Kamailio\"}\n    >\n                    \n\n",
 "sj_serialize": "### sj_serialize(opt, ovar)\n\n module: sipjson\n\nDo the serialization of SIP message attributes into a JSON document.\n\nWhen there is a match, it uses the corresponding pseudo-variable name\nfor JSON attribute (e.g., 'ru' is the R-URI attribute name).\n\nMeaning of the parameters:\n\n- opt - list of optional groups of attributes to be serialized. Each\n  group of attributes has a corresponding character. These are:\n\n  - 0 - (zero) default attributes to be serialized. They are added even\n    if '0' is not provided as parameter, however, because 'opt'\n    parameter cannot be empty, '0' can be given when only default\n    attributes are wanted.\n\n  - B - (uppercase B) SIP message body\n\n  - c - (lowercase c) CSeq attributes\n\n  - t - (lowercase t) To header attributes\n\n- ovar - name of the output pseduo-variable\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sj_serialize(\"0B\", \"$var(json)\");\n    ...\n\n",
 "mono_exec": "### mono_exec(path [, param])\n\n module: app_mono\n\nExecute the managed code assembly stored in 'path'. The path can be a\nstring with pseudo-variables evaluated at runtime. A second parameter\ncan optionally be provided; it will be passed to the assembly.\n\nNote that the assembly is loaded every time from the file, so any change\nto it is immediately live. This function cannot be used if 'load'\nparameter is set.\n\n    ...\n    mono_exec(\"/usr/local/etc/kamailio/mono/myscript.exe\");\n    ...\n\n",
 "mono_run": "### mono_run([param])\n\n module: app_mono\n\nExecute the assembly specified by 'load' module parameter. The assembly\nis loaded at startup, so changes to it will be effective only after\nKamailio restart.\n\nAn optional parameter can be given and it will be passed over to the\nassembly. It can be a string with pseudo-variables; these will be\nevaluated at runtime.\n\n    ...\n    if(!mono_run(\"myparam\"))\n    {\n        xdbg(\"SCRIPT: failed to execute mono assembly!\\n\");\n    }\n    ...\n\n",
 "loose_route": "### loose_route()\n\n module: rr\n\nThe function performs routing of SIP requests which contain a route set.\nThe name is a little bit confusing, as this function also routes\nrequests which are in the \u201cstrict router\u201d format.\n\nThis function is usually used to route in-dialog requests (like ACK,\nBYE, reINVITE). Nevertheless also out-of-dialog requests can have a\n\u201cpre-loaded route set\u201d and my be routed with loose_route. It also takes\ncare of translating between strict-routers and loose-router.\n\nThe loose_route function analyzes the Route: headers in the requests. If\nthere is no Route: header, the function returns FALSE and routing should\nbe done with normal lookup functions. If a Route: header is found, the\nfunction returns 1 and behaves as described in section 16.12 of RFC\n3261. There is only one exception: If the request is out-of-dialog (no\nto-tag) and there is only one Route: header indicating the local proxy,\nthen the Route: header is removed and the function returns FALSE.\n\nWhen the \u201coutbound\u201d module was loaded before this module and the Route:\nheader contains a username part this function will attempt to use the\nusername part as a flow-token for routing. If route calculation based on\nflow-token succeeds, function returns TRUE even if there is only one\nRoute: header indicating the local proxy.\n\nMake sure your loose_routing function can't be used by attackers to\nbypass proxy authorization.\n\nThe loose_routing topic is very complex. See the RFC3261 for more\ndetails (grep for \u201croute set\u201d is a good starting point in this\ncomprehensive RFC).\n\nReturn codes:\n\n- *1* - route calculation has been successful\n\n- *2* - route calculation based on flow-token has been successful\n\n- *-1* - route calculation has been unsuccessful\n\n- *-2* - outbound flow-token shows evidence of tampering\n\n- *-3* - next hop is taken from a preloaded route set\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    loose_route();\n    ...\n\n",
 "loose_route_preloaded": "### loose_route_preloaded()\n\n module: rr\n\nThe function is similar to \\`loose_route()\\`, but it returns 1 (true)\nwhen the Route header is preloaded (is in an initial request) and -1\n(false) if processing of the Route header failed or it is for requests\nwithin dialog.\n\nIt is a convenient function to use for routing initial requests on an\nedge proxy that adds Path header to REGISTER requests.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if(!loose_route_preloaded()) {\n       sl_send_reply(\"404\" \"Preloaded route expected\");\n       exit;\n    }\n    ...\n\n",
 "loose_route_mode": "### loose_route_mode(vmode)\n\n module: rr\n\nThe function is similar to \\`loose_route()\\`, but it does only loose\nrouting processing if vmode==1, skipping the testing of r-uri==myself\nfor performing strict routing. If vmode==0, it behaves like\nloose_route().\n\nIt is a convenient function to use with application servers that set the\nContact URI to SIP server address.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if(has_totag() and uri==myself) {\n        if(loose_route_mode(\"1\")) {\n            rewritehostport(\"my.app.server:5090\");\n            t_relay();\n            exit;\n        }\n    }\n    ...\n\n",
 "record_route": "### record_route([sparams])\n\n module: rr\n\nThe function adds a new Record-Route header field. The header field will\nbe inserted in the message before any other Record-Route header fields.\n\nIf any string is passed as parameter, it will be appended as URI\nparameter to the Record-Route header. The string must follow the\n\u201c;name=value\u201d scheme and it may contain pseudo-variables.\n\nWhen the \u201coutbound\u201d module was loaded before this module this function\nwill determine whether outbound is required for the request and generate\nand add a flow-token as the username part of the Record-Route-URI.\n\nNote: if append From-tag is enabled and the function is used for\nrequests within dialog, it must be executed after loose_route() in order\nto detect properly the direction.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n    ...\n    record_route();\n    ...\n\n",
 "remove_record_route": "### remove_record_route()\n\n module: rr\n\nThe function removes the internal lumps added by record_route()\nfunctions.\n\nCan be used to revert adding Record-Route header(s).\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    remove_record_route();\n    ...\n\n",
 "record_route_preset": "### record_route_preset(string [,string2])\n\n module: rr\n\nThis function will put the string params into Record-Route, avoid to use\nit unless you know what you are doing.\n\nMeaning of the parameters is as follows:\n\n- *string* - String to be inserted into the first header field; it may\n  contain pseudo-variables.\n\n- *string2* - String to be inserted into the second header field; it may\n  contain pseudo-variables.\n\nNote: If 'string2' is present, then the 'string' param is pointing to\nthe outbound interface and the 'string2' param is pointing to the\ninbound interface.\n\nNote: The value of parameters must not contain the SIP protocol scheme\n(sip: or sips:), one is added based on routing requirements. Thus the\nvalue has to be like \"address:port;parameters\", the port and parameters\nare optional. If the second parameter is provided, do not forget to add\nthe parameter \"r2=on\" so the proxy processes both corresponding Route\nheaders at once.\n\nWhen the \u201coutbound\u201d module was loaded before this module this function\nwill determine whether outbound is required for the request and generate\nand add a flow-token as the username part of the Record-Route-URI.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n    ...\n    record_route_preset(\"1.2.3.4:5090\");\n    ...\n\n",
 "record_route_advertised_address": "### record_route_advertised_address(address)\n\n module: rr\n\nThe function adds a new Record-Route header field using the address\ngiven. The header field will be inserted in the message before any other\nRecord-Route header fields.\n\nWhen the \u201coutbound\u201d module was loaded before this module this function\nwill determine whether outbound is required for the request and generate\nand add a flow-token as the username part of the Record-Route-URI.\n\nMeaning of the parameter is as follows:\n\n- *address* - Advertised address to use in the header; it may contain\n  pseudo-variables.\n\nIf double record-routing is enabled two Record-Route headers will be\ninserted with the same given address with different transports if the\ntransport changes.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n    ...\n    record_route_advertised_address(\"1.2.3.4:5080\");\n    ...\n\n",
 "add_rr_param": "### add_rr_param(param)\n\n module: rr\n\nAdds a parameter to the Record-Route URI (param must be in \u201c;name=value\u201d\nformat. The function may be called also before or after the\nrecord_route(), record_route_advertised_address(), and\nrecord_route_preset() calls (see [](#rr.f.record_route) or\n[](#rr.f.record_route_adv_addr))).\n\nMeaning of the parameters is as follows:\n\n- *param* - String containing the URI parameter to be added. It must\n  follow the \u201c;name=value\u201d scheme; it may contain pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n    ...\n    add_rr_param(\";nat=yes\");\n    ...\n\n",
 "check_route_param": "### check_route_param(re)\n\n module: rr\n\nThe function checks if the URI parameters of the local Route header\n(corresponding to the local server) matches the given regular\nexpression. It must be called after loose_route() (see\n[](#rr.f.loose_route)).\n\nMeaning of the parameters is as follows:\n\n- *re* - regular expression to check against the Route URI parameters.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (check_route_param(\"nat=yes\")) {\n        setflag(6);\n    }\n    ...\n\n",
 "is_direction": "### is_direction(dir)\n\n module: rr\n\nThe function checks the flow direction of in-dialog requests. This\nfunction uses the \u201cftag\u201d parameter from the Route header, therefore the\nappend_fromtag (see [???](#rr.p.append_fromtag) module parameter must be\nenabled. Also this must be called only after loose_route() (see\n[](#rr.f.loose_route)).\n\nThe function returns true if the \u201cdir\u201d is the same with the request's\nflow direction.\n\nThe \u201cdownstream\u201d direction means that the request is in the same\ndirection as the initial request that created the dialog.\n\nMeaning of the parameters is as follows:\n\n- *dir* - string containing the direction to be checked. It may be\n  \u201cupstream\u201d (from callee to caller) or \u201cdownstream\u201d (caller to callee).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_direction(\"downstream\")) {\n        xdbg(\"in-dialog request from caller to callee (downstream) ($rm)\\n\");\n    } else {\n        xdbg(\"in-dialog request from callee to caller (upstream) ($rm)\\n\");\n    }\n    ...\n\n",
 "rr_next_hop_route": "### rr_next_hop_route()\n\n module: rr\n\nThe function returns 1 (true) if there is a Route header for the next\nhop address. It has to be used after loose_route(), when the local Route\nheaders are processed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(loose_route) {\n        if(rr_next_hop_route()) {\n            # next hop address is from Route header\n        }\n\n    }\n    ...\n\n",
 "python_exec": "### python_exec(method [, args])\n\n module: app_python3\n\nExecute the Python function with the name given by the parameter\n'method'. Optionally can be provided a second string with parameters to\nbe passed to the Python function.\n\nBoth parameters can contain pseudo-variables.\n\n    ...\n    python_exec(\"my_python_function\");\n    python_exec(\"my_python_function\", \"my_params\");\n    python_exec(\"my_python_function\", \"$rU\");\n    ...\n\n",
 "setsflag": "### setsflag(flag)\n\n module: kex\n\nSet the script flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the script flag to be set. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    setsflag(\"1\");\n    ...\n    $var(flag) = 11;\n    setsflag(\"$var(flag)\");\n    ...\n\n",
 "issflagset": "### issflagset(flag)\n\n module: kex\n\nReturn true if the script flag is set.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the script flag to be tested. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(issflagset(\"1\"))\n    {\n        ...\n    }\n    ...\n\n",
 "resetsflag": "### resetsflag(flag)\n\n module: kex\n\nReset the script flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the script flag to be reset. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    resetsflag(\"1\");\n    ...\n\n",
 "setbflag": "### setbflag(flag [, branch])\n\n module: kex\n\nSet the branch flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the branch flag to be set. Can be integer or\n  pseudo-variable with integer value.\n\n- *branch* - the index of the branch whose flag to be set. Can be\n  integer or pseudo-variable with integer value. If omitted, then branch\n  0 is used (R-URI).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    setbflag(\"1\");\n    ...\n    $var(flag) = 11;\n    setbflag(\"$var(flag)\", \"1\");\n    ...\n\n",
 "isbflagset": "### isbflagset(flag [, branch])\n\n module: kex\n\nReturn true if the branch flag is set.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the branch flag to be tested. Can be integer or\n  pseudo-variable with integer value.\n\n- *branch* - the index of the branch whose flag to be set. Can be\n  integer or pseudo-variable with integer value. If omitted, then branch\n  0 is used (R-URI).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(isbflagset(\"1\"))\n    {\n        ...\n    }\n    ...\n\n",
 "resetbflag": "### resetbflag(flag [, branch])\n\n module: kex\n\nReset the branch flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the branch flag to be reset. Can be integer or\n  pseudo-variable with integer value.\n\n- *branch* - the index of the branch whose flag to be set. Can be\n  integer or pseudo-variable with integer value. If omitted, then branch\n  0 is used (R-URI).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    resetbflag(\"1\");\n    ...\n\n",
 "setdsturi": "### setdsturi(uri)\n\n module: kex\n\nSet the destination address URI (outbound proxy address).\n\nMeaning of the parameters is as follows:\n\n- *uri* - Valid SIP URI representing the address where to send the\n  request. It must be a static string, no variables are evaluated at\n  runtime. If you need to set outbound proxy address via a variable, use\n  assignment to *\\$du*.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    setdsturi(\"sip:10.0.0.10\");\n    ...\n\n",
 "resetdsturi": "### resetdsturi()\n\n module: kex\n\nReset the destination address URI (outbound proxy address).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    resetdsturi();\n    ...\n\n",
 "isdsturiset": "### isdsturiset()\n\n module: kex\n\nCheck if the destination address URI (outbound proxy address) is set.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(isdsturiset())\n    {\n       ...\n    }\n    ...\n\n",
 "pv_printf": "### pv_printf(var, str)\n\n module: kex\n\nEvaluates the str and sets the resulting value to variable var. For\nbackward compatibility reasons, the same function can be executed via\n'avp_printf(var, str)'.\n\nMeaning of the parameters is as follows:\n\n- *var* - name of a writable variable\n\n- *str* - string that may contain variables which will be evaluated at\n  runtime.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pv_printf(\"$ru\", \"sip:$rU@$fd\");\n    pv_printf(\"$avp(x)\", \"From: $fU - To: $tU\");\n    ...\n\n",
 "is_myself": "### is_myself(uri)\n\n module: kex\n\nCheck if the parameter matches the 'myself' condition (i.e., is a local\nIP or domain). Note that if the port is missing in the URI, then no port\nmatching is done (in other words, port matching is skipped -- it does\nnot use default SIP ports 5060 or 5061 for matching).\n\nMeaning of the parameters is as follows:\n\n- *uri* - Valid SIP URI or IP address to check against the list of local\n  IP addresses or domains. The parameter value can contain\n  pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(is_myself(\"$fu\")) {\n        ...\n    }\n    ...\n\n",
 "setdebug": "### setdebug(level)\n\n module: kex\n\nSet the debug log level per process.\n\nMeaning of the parameters is as follows:\n\n- *level* - the debug log level to be set. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    setdebug(\"1\");\n    ...\n    $var(level) = 2;\n    setdebug(\"$var(level)\");\n    ...\n\n",
 "resetdebug": "### resetdebug()\n\n module: kex\n\nReset the local debug log level back to the value of core parameter\n'debug'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    resetdebug();\n    ...\n\n",
 "km_append_branch": "### km_append_branch([uri])\n\n module: kex\n\nThis function was replaced by append_branch() from corex module,\nstarting with version 4.0.0.\n\n",
 "geoip_match": "### geoip_match(ipaddr, pvc)\n\n module: geoip\n\nMatch ipaddr against the GeoIP database and set the pvc container. The\nfunction has to be called before accessing a key via: \\$gip(pvc=\\>key).\n\n    ...\n    if(geoip_match(\"$si\", \"src\"))\n        xlog(\"SIP message from: $gip(src=>cc)\\n\");\n    ...\n\n",
 "prefix2domain": "### prefix2domain(rewrite_mode, multidomain_mode)\n\n module: pdt\n\nBuild a new URI if it is necessary. Returns 1 when the translation was\nmade or there was nothing to translate (user part of the URI is empty,\nit does not match the prefix parameter or there is no domain associated\nwith a possible prefix from user part). Returns -1 in error cases.\n\nThe translation is done based on lookup up for an entry in the database\nwhere the sdomain equals the domain in FROM uri, and the prefix matches\nthe beginning of the user part of the RURI. If such an entry is found,\nthen the domain in RURI is updated with the domain of this entry\n(sdomain, prefix, domain).\n\nThere is also the possibility to have the translation of URI regardless\nof source domain. This can be achieved inserting in the database entries\nwhere sdomain has the value \"\\*\".\n\nThe \u201crewrite_mode\u201d parameter specifies whether to strip or not the\nprefix from user part. The possible values are:\n\n- 0: the prefix is removed along with the leading prefix.\n\n- 1: only the leading prefix is removed.\n\n- 2: the user part of the URI is not changed.\n\n- \\$PV : any PV holding one of the above values.\n\nThe \u201cmultidomain_mode\u201d parameter specifies the kind of multidomain\nsupport to use. The possible values are:\n\n- 0 : Translation of URI regardless of source domain.\n\n- 1 : Translation of URI using as source domain the domain in From-URI.\n\n- 2 : Translation of URI using as source domain the domain in From-URI.\n  In case there is no entry for the required sdomain, it tries the\n  translation using \"\\*\" as sdomain.\n\n- \\$PV : any PV holding one of the above values.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    prefix2domain(\"2\", \"2\");\n    ...\n    $var(a) = 1;\n    prefix2domain(\"$var(a)\", \"2\");\n    ...\n\n### prefix2domain(rewrite_mode)\n\n module: pdt\n\nThe same as prefix2domain(rewrite_mode, \"0\"), that is without\nmultidomain support, translation of URI being done regardless of the\nsource domain.\n\n    ...\n    prefix2domain(\"2\");\n    ...\n\n### prefix2domain()\n\n module: pdt\n\nThe same as prefix2domain(\"0\", \"0\").\n\n    ...\n    prefix2domain();\n    ...\n\n",
 "pd_translate": "### pd_translate(sdomain, rewrite_mode)\n\n module: pdt\n\nTranslate R-URI based on source domain and longest prefix matching.\nReturns 1 when the translation was made or there was nothing to\ntranslate. Returns -1 in error cases.\n\nThe translation is done based on lookup up for an entry in the database\nwhere the sdomain parameter equals the sdomain in database table.\n\nThe \u201csdomain\u201d parameter specifies the source domain to be used to match\nthe longest prefix. Can be a static string or dynamic parameter with\nvariables inside.\n\nThe \u201crewrite_mode\u201d parameter specifies whether to strip or not the\nprefix from user part. The possible values are:\n\n- 0: the prefix is removed along with the leading prefix.\n\n- 1: only the leading prefix is removed.\n\n- 2: the user part of the URI is not changed.\n\n- \\$PV : any PV holding one of the above values.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE or\nBRANCH_ROUTE.\n\n    ...\n    pd_translate(\"$fd\", \"2\");\n    ...\n    pd_translate(\"*\", \"$var(a)\");\n    ...\n\n",
 "xcap_auth_status": "### xcap_auth_status(watcher_uri, presentity_uri)\n\n module: utils\n\nFunction checks in the presence server database if a watcher is\nauthorized to subscribe to event \u201cpresence\u201d of presentity. Sphere\nchecking is not included.\n\nBoth watcher_uri and presentity_uri are pseudo variables. The function\nreturns ACTIVE_STATUS, if a subscription is allowed and PENDING_STATUS,\nTERMINATED_STATUS, or WAITING_STATUS otherwise. See presence/subscribe.h\nfor the corresponding integer codes. In case of error, function returns\n-1.\n\nFunction can be used from REQUEST_ROUTE.\n\n    ...\n    if (method==\"MESSAGE\") {\n        xcap_auth_status(\"$fu\", $ru\");\n        if ($retcode == 1) {\n            t_relay();\n        } else {\n            send_reply(\"403\", \"Forbidden\");\n        }\n    }\n    ...\n                    \n\n",
 "rabbitmq_publish": "### rabbitmq_publish(exchange, routing_key, content_type, messagebody)\n\n module: rabbitmq\n\nThe function publishes messagebody without waiting for a reply.\n\nMeaning of the parameters is as follows:\n\n- *exchange* - the amqp exchange.\n\n- *routing_key* - the amqp routing_key.\n\n- *content_type* - the content_type of the messagebody.\n\n- *messagebody* - the messagebody to be published.\n\nThis function can be used from REQUEST_ROUTE.\n\n    rabbitmq_publish(\"exchange\", \"routing_key\", \"application/json\", \"$avp(json_request)\");\n                    \n\n",
 "rabbitmq_publish_consume": "### rabbitmq_publish_consume(exchange, routing_key, content_type, messagebody, reply)\n\n module: rabbitmq\n\nThe function publishes messagebody and waits timeoute_sec + timeout_usec\nfor a reply. If the reply comes, one can read it in the *reply* avp.\n\nMeaning of the parameters is as follows:\n\n- *exchange* - the amqp exchange.\n\n- *routing_key* - the amqp routing_key.\n\n- *content_type* - the content_type of the messagebody.\n\n- *messagebody* - the messagebody to be published.\n\n- *reply* - the consumed reply.\n\nThis function can be used from REQUEST_ROUTE.\n\n    rabbitmq_publish_consume(\"exchange\", \"routing_key\", \"application/json\", \"$avp(json_request)\", \"$avp(json_reply)\");\n                    \n",
 "append_branch": "### append_branch([ uri, [ q ] ])\n\n module: corex\n\nAppend a new branch to the destination set, useful to build the set of\ndestination addresses for parallel forking or redirect replies.\n\nBoth parameters are optional, If no uri parameter is provided, then the\naddress from request URI (r-uri) is used to build the new branch.\n\nMeaning of the parameters is as follows:\n\n- *uri* - SIP address of the branch to be used as R-URI in the outgoing\n  request.\n\n- *q* - the Q value to set the priority of the branch based on Contact\n  address specifications\n\nThis function can be used from REQUEST_ROUTE or FAILURE_ROUTE.\n\n    ...\n        append_branch();\n        append_branch(\"$avp(uri)\", \"0.5\");\n    ...\n\n",
 "send_udp": "### send_udp([ host [ :port ] ])\n\n module: corex\n\nSend the original SIP message to a specific destination in stateless\nmode. No changes are applied to received message, no Via header is\nadded. Host can be an IP address or hostname. Port is optional and\ndefaults to 5060. Used protocol: UDP.\n\nThe parameter is optional and defaults to the destination URI from the\nSIP message if left out. Otherwise it's a string parameter (supporting\npseudo-variables) in format \"*hostname*\" or \"*hostname*:*port*\", where\n*hostname*\" can also be a numeric IP address.\n\nThis function can be used from REQUEST_ROUTE or FAILURE_ROUTE.\n\n    ...\n        send_udp();\n        send_udp(\"10.20.15.10\");\n        send_udp(\"sip.example.com:5070\");\n        send_udp(\"$var(res)\");\n    ...\n\n",
 "send_tcp": "### send_tcp([ host [ :port ] ])\n\n module: corex\n\nThis function is identical to *send_udp()* described above, except that\nit sends the SIP message using the TCP protocol instead of UDP.\n\n    ...\n        send_tcp();\n        send_tcp(\"10.20.15.10\");\n        send_tcp(\"sip.example.com:5070\");\n        send_tcp(\"$var(res)\");\n    ...\n\n",
 "send_data": "### send_data(uri, data)\n\n module: corex\n\nSend the data to address specified by uri. Both parameters can contain\npseudo-variables. The uri parameter has to be a valid SIP URI. The data\nparameter can by any arbitrary content.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        send_data(\"sip:example.com:5070;transport=sctp\", \"Message at $Ts\");\n    ...\n\n",
 "sendx": "### sendx(uri, sock, data)\n\n module: corex\n\nSend the data to address specified by uri using a specific local socket.\nAll parameters can contain pseudo-variables. The uri parameter has to be\na valid SIP URI. The sock parameter has to be a valid socket specifier\n(like values assigned to \\$fs). The data parameter can by any arbitrary\ncontent.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sendx(\"sip:example.com:5070;transport=sctp\", \"sctp:2.3.4.5:5060\", \"Message at $Ts\");\n    ...\n\n",
 "is_incoming": "### is_incoming()\n\n module: corex\n\nReturns true if contents of message buffer \\$mb are the data received\nfrom remote host, otherwise false indicating that the contents of \\$mb\nare data that is about to be sent out to remote host. This only works if\nnio_intercept parameter is set to non-zero.\n\nThis function can be used from event_route\\[network:msg\\].\n\n    ...\n    event_route[network:msg] {\n        if (is_incoming()) {\n            xlog(\"L_INFO\", \"Received message '$mb' \\n\");\n            $avp(msg) = $mb;\n        } else {\n            xlog(\"L_INFO\", \"Sending message '$mb' \\n\");\n            $avp(msg) = $mb;\n        };\n    }\n    ...\n\n",
 "msg_iflag_set": "### msg_iflag_set(flagname)\n\n module: corex\n\nSet internal SIP message flag. The parameter flagname can be:\nUSE_UAC_FROM, USE_UAC_TO or UAC_AUTH.\n\nThis functions should not be used in configuration file for (re)setting\nthe internal flags, those are done by various functions internally,\nhowever, in very particular cases they might be useful (e.g., changing\nFrom/To via textops functions).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        msg_iflag_set(\"UAC_AUTH\");\n    ...\n\n",
 "msg_iflag_reset": "### msg_iflag_reset(flagname)\n\n module: corex\n\nReset the internal flag given as parameter.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        msg_iflag_reset(\"UAC_AUTH\");\n    ...\n\n",
 "msg_iflag_is_set": "### msg_iflag_is_set(flagname)\n\n module: corex\n\nTest if the internal flag given as parameter is set.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        if(msg_iflag_is_set(\"UAC_AUTH\")) { ... }\n    ...\n\n",
 "file_read": "### file_read(fpath, var)\n\n module: corex\n\nRead content of a text file into a variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(file_read(\"/tmp/data.txt\", \"$var(data)\")) { ... }\n    ...\n\n",
 "file_write": "### file_write(fpath, content)\n\n module: corex\n\nWrite content of parameter to a text file.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(file_write(\"/tmp/data.txt\", \"Data is: $var(data)\")) { ... }\n    ...\n\n",
 "setxflag": "### setxflag(flag)\n\n module: corex\n\nSet the extended message (transaction) flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the flag to be set. Can be integer or\n  pseudo-variable with integer value (range 0-63).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    setxflag(\"1\");\n    ...\n    $var(flag) = 11;\n    setxflag(\"$var(flag)\");\n    ...\n\n",
 "isxflagset": "### isxflagset(flag)\n\n module: corex\n\nReturn true if the extended message (transaction) flag is set.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the flag to be tested. Can be integer or\n  pseudo-variable with integer value (range 0-63).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(isxflagset(\"1\"))\n    {\n        ...\n    }\n    ...\n\n",
 "resetxflag": "### resetxflag(flag)\n\n module: corex\n\nReset the extended message (transaction) flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the flag to be reset. Can be integer or\n  pseudo-variable with integer value (range 0-63).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    resetxflag(\"1\");\n    ...\n\n",
 "set_send_socket": "### set_send_socket(saddr)\n\n module: corex\n\nSet the socket for sending out.\n\nMeaning of the parameters is as follows:\n\n- *saddr* - the address of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    set_send_socket(\"udp:127.0.0.1:5060\");\n    ...\n\n",
 "set_send_socket_name": "### set_send_socket_name(sname)\n\n module: corex\n\nSet the socket for sending out.\n\nMeaning of the parameters is as follows:\n\n- *sname* - the name of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    set_send_socket_name(\"sock1\");\n    ...\n\n",
 "set_recv_socket": "### set_recv_socket(saddr)\n\n module: corex\n\nSwitch local socket used for receiving the message.\n\nMeaning of the parameters is as follows:\n\n- *saddr* - the address of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    set_recv_socket(\"udp:127.0.0.1:5060\");\n    ...\n\n",
 "set_recv_socket_name": "### set_recv_socket_name(sname)\n\n module: corex\n\nSwitch local socket used for receiving the message.\n\nMeaning of the parameters is as follows:\n\n- *sname* - the name of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    set_recv_socket_name(\"sock1\");\n    ...\n\n",
 "set_source_address": "### set_source_address(saddr)\n\n module: corex\n\nSet the source address for the message.\n\nMeaning of the parameters is as follows:\n\n- *saddr* - the source address in socket format. Can be a static string\n  or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    set_source_address(\"udp:127.0.0.1:5080\");\n    ...\n\n",
 "via_add_srvid": "### via_add_srvid(flags)\n\n module: corex\n\nControl if srvid parameter is added or not to local Via. If yes, the\nvalue is server_id, added only if it is different than 0.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - add srvid parameter; 0 - do not add srvid parameter.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    via_add_srv(\"1\");\n    ...\n\n",
 "via_add_xavp_params": "### via_add_xavp_params(flags)\n\n module: corex\n\nControl if fields of the xavp with the name specified by xavp_via_params\nglobal parameter are added or not to local Via.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - add xavp parameters; 0 - do not add xavp parameters.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xavp_via_params=\"xvia\"\n    ...\n    request_route {\n        ...\n        $xavp(xvia=>srvid) = \"1\";\n        $xavp(xvia[0]=>myval) = \"xyz\";\n        via_add_xavp_params(\"1\");\n        ...\n    }\n    ...\n\n",
 "via_use_xavp_fields": "### via_use_xavp_fields(flags)\n\n module: corex\n\nControl if fields of the xavp with the name specified by xavp_via_fields\nglobal parameter are used or not to build local Via.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - use xavp fields; 0 - do not use xavp fields.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xavp_via_fields=\"mvia\"\n    ...\n    request_route {\n        ...\n        $xavp(mvia=>address) = \"10.10.10.10\";\n        $xavp(mvia[0]=>port) = \"5060\";\n        via_use_xavp_fields(\"1\");\n        ...\n    }\n    ...\n\n",
 "is_faked_msg": "### is_faked_msg()\n\n module: corex\n\nReturns 1 (native config true) if the SIP message under processing is\nthe internal faked msg structure. Returns -1 (native config false) if\nthe SIP message under processing is received from the network.\n\nThe function should be useful in event route blocks or async route\nblocks where it can be processed either a message from the network or\nthe internal faked message.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    event_route[dispatcher:dst-down] {\n        if (is_faked_msg()) {\n            xinfo(\"Running with faked message\\n\");\n        }\n    }\n    ...\n\n",
 "is_socket_name": "### is_socket_name(sockname)\n\n module: corex\n\nReturns 1 (native config true) if the parameter matches a local socket\nname, otherwise -1 (native config false). The parameter can contain\nvariables.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n        if (is_socket_name(\"socktls\")) {\n            xinfo(\"matched local socket name\\n\");\n        }\n    ...\n\n",
 "forward_reply": "### forward_reply()\n\n module: corex\n\nForward received reply on demand.\n\nThis function can be used in CORE_ONREPLY_ROUTE.\n\n    ...\n    route[reply] {\n        forward_reply();\n    }\n    ...\n\n",
 "mt_match": "### mt_match(mtree, pv, mode)\n\n module: mtree\n\nMatch 'pv' value against 'mtree'. If 'mtree' type is 0 or 2 and value of\n'mode' is NOT 2, sets associated value of the longest matching prefix to\npseudo variable specified by pv_value parameter. If 'mtree' type is 0 or\n2 and value of 'mode' is 2, sets values of all matching prefixes to avp\nspecified by pv_values parameter so that a value of longest matching\nprefix is in avp index 0. Parameter 'mode' can be an integer constant or\na pseudo variable with integer value.\n\nReturns 1 if match succeeded and -1 otherwise.\n\n    ...\n    mt_match(\"mytree\", \"$rU\", \"0\");\n    ...\n\n",
 "statsd_set": "### statsd_set(key, value)\n\n module: statsd\n\nSets count the number of unique values passed to a key.\n\nIf this method is called multiple times with the same userid in the same\nsample period, that userid will only be counted once.\n\nThis function can be used in ALL ROUTES.\n\n    ...\n    failure_route[tryagain] {\n    ...\n        statsd_set(\"customerFailure\", 1);\n    ...\n    }\n    ...\n                    \n\n",
 "statsd_gauge": "### statsd_gauge(key, value)\n\n module: statsd\n\nGauges are a constant data type. They are not subject to averaging and\nthey don't change unless you change them. That is, once you set a gauge\nvalue, it will be a flat line on the graph until you change it again.\n\nGauges are useful for things that are already averaged, or don't need to\nreset periodically\n\nThis function can be used in ALL ROUTES.\n\nThe statsd server collects gauges under the stats.gauges prefix.\n\n    ...\n    route [gauge_method]{\n        statsd_gauge(\"method\"+$rm, \"+1\");\n        statsd_gauge(\"customer_credit\"+$var(customer),\"$var(customer_credit)\");\n    }\n    ...\n                    \n\n",
 "statsd_histogram": "### statsd_histogram(key, value)\n\n module: statsd\n\nThe histograms are a measure of time, but they are calculated at the\nserver side. As the data exported by the client is the same, this is\njust an alias for the Timer type.\n\nThis function can be used in ALL ROUTES.\n\nThe statsd server collects histograms under the stats.histograms prefix.\n\n    ...\n        statsd_histogram(\"latency\", 1000);\n    ...\n                    \n\n",
 "statsd_start": "### statsd_start(key)\n\n module: statsd\n\nstatsd_start set an avp with the key name, and when statsd_stop(key) is\nused, the module will send statsd the difference in milliseconds. this\nis useful to know the time of a SQL query, or how much time your replies\ntake.\n\nThis function can be used in all routes.\n\nThe statsd server collects all timers under the stats.timers prefix and\nwill calculate the lower bound, mean, 90th percentile, upper bound, and\ncount of each timer for each period (by the time it can be seen in\ngraphite, that's usually per minute).\n\n    ...\n    statsd_start(\"long_mysql_query\");\n    sql_query(\"ca\", \"select sleep(0.2)\", \"ra\");\n    statsd_stop(\"long_mysql_query\");\n    ...\n                    \n\n",
 "statsd_stop": "### statsd_stop(key)\n\n module: statsd\n\nstatsd_stop(key) get the avp string with the key and calculate the\ndifference from the start time. When finished the milliseconds used will\nbe sent to statsd.\n\nThis function can be used in all routes.\n\n    ...\n    statsd_start(\"long_mysql_query\");\n    sql_query(\"ca\", \"select sleep(0.2)\", \"ra\");\n    statsd_stop(\"long_mysql_query\");\n    ...\n                    \n\n",
 "statsd_incr": "### statsd_incr(key)\n\n module: statsd\n\nIncrement a statsd counter\n\nThis function can be used in all routes.\n\n    ...\n    if(geoip_match(\"$si\", \"src\")){\n        statsd_incr(\"country.\"+$(gip(src=>cc)));\n    }\n    ...\n                    \n\n",
 "statsd_decr": "### statsd_decr(key)\n\n module: statsd\n\nDecrement a counter\n\nThis function can be used in all routes.\n\n    ...\n    if (t_check_status(\"408\")) {\n        statsd_decr(\"kamailio.successfulCalls\");\n        statsd_incr(\"kamailio.reply.timeout\");\n    }\n    ...\n                    \n",
 "dns_sys_match_ip": "### dns_sys_match_ip(hostname, ipaddr)\n\n module: ipops\n\nReturns TRUE if ipaddr is associated by DNS to hostname. FALSE\notherwise. It does not use the internal DNS resolver, but directly\ngetaddrinfo(...). All addresses returned for the hostname are checked.\nNote that some hosts may return different lists of IP addresses for each\nquery, if the DNS server is configured in that way (e.g., for providing\nload balancing through DNS).\n\nParameters:\n\n- *hostname* - string or pseudo-variable containing the hostname. The\n  resulting IP addresses from DNS query are compared with ipaddr.\n\n- *ipaddr* - string or pseudo-variable containing the ip address.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (!dns_sys_match_ip(\"myhost.com\", \"1.2.3.4\")) {\n        xdbg(\"ip address not associated with hostname\\n\");\n    }\n    ...\n            \n\n",
 "dns_int_match_ip": "### dns_int_match_ip(hostname, ipaddr)\n\n module: ipops\n\nReturns TRUE if ipaddr is associated by DNS to hostname. FALSE\notherwise. It uses internal DNS resolver. At this moment, the function\nmight not check all the IP addresses as returned by dns_sys_match_ip(),\nbecause the internal resolver targets to discover the first address to\nbe used for relaying SIP traffic. Thus is better to use\ndns_sys_match_ip() if the host you want to check has many IP addresses,\nin different address families (IPv4/6).\n\nParameters:\n\n- *hostname* - string or pseudo-variable containing the hostname. The\n  resulting IP addresses from DNS query are compared with ipaddr.\n\n- *ipaddr* - string or pseudo-variable containing the ip address.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (!dns_int_match_ip(\"myhost.com\", \"1.2.3.4\")) {\n        xdbg(\"ip address not associated with hostname\\n\");\n    }\n    ...\n            \n\n",
 "dns_query": "### dns_query(hostname, pvid)\n\n module: ipops\n\nStore the IP addresses and their type that correspond to hostname in a\nconfig variable \\$dns(pvid=\\>key).\n\nParameters:\n\n- *hostname* - string or pseudo-variable containing the hostname. The\n  resulting IP addresses from DNS query are compared with ipaddr.\n\n- *pvid* - container id for script variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(dns_query(\"test.com\", \"xyz\"))\n    {\n        xlog(\" number of addresses: $dns(xyz=>count)\\n\");\n        xlog(\" ipv4 address found: $dns(xyz=>ipv4)\\n\");\n        xlog(\" ipv6 address found: $dns(xyz=>ipv6)\\n\");\n        $var(i) = 0;\n        while($var(i)<$dns(xyz=>count)) {\n            xlog(\" #[$var(i)] type ($dns(xyz=>type[$var(i)]))\"\n                 \" addr [$dns(xyz=>addr[$var(i)])]\\n\");\n            $var(i) = $var(i) + 1;\n        }\n    }\n    ...\n            \n\n",
 "srv_query": "### srv_query(srvcname, pvid)\n\n module: ipops\n\nQueries DNS SRV records to resolve a service/protocol name into a list\nof priorities, weights, ports, and targets sorted by priority and weight\nas outlined in [RFC 2782](http://tools.ietf.org/html/rfc2782).\n\nParameters:\n\n- *srvcname* - string or pseudo-variable containing the\n  service/protocol. For example, \"\\_sip.\\_tcp.example.com\".\n\n- *pvid* - container id for script variable.\n\nOutput:\n\nReturns a positive number indicating success or a negative number when\nan error is encountered. It can be used from ANY_ROUTE.\n\nThe \\$srvquery pseudo-variable (PV) is loaded with the results of the\nquery. Multiple queries can be stored in the PV using the pvid key. Each\nquery contains zero-indexed arrays sorted by priority and weight that\ncontain:\n\n- *count* - number of records found\n\n- *port \\[index\\]* - port number\n\n- *priority \\[index\\]* - priority number as defined by [RFC\n  2782](http://tools.ietf.org/html/rfc2782)\n\n- *target \\[index\\]* - target host name\n\n- *weight \\[index\\]* - weight number as defined by [RFC\n  2782](http://tools.ietf.org/html/rfc2782)\n\n<!-- -->\n\n    ...\n    if (srv_query (\"_sip._udp.example.com\", \"udp\") > 0) {\n      $var(cnt) = $srvquery(udp=>count);\n      $var(i) = 0;\n      while ($var(i) < $var(cnt)) {\n        xlog (\"port[$var(i)] $srvquery(udp=>port[$var(i)])\\n\");\n        xlog (\"priority[$var(i)] $srvquery(udp=>priority[$var(i)])\\n\");\n        xlog (\"target[$var(i)] $srvquery(udp=>target[$var(i)])\\n\");\n        xlog (\"weight[$var(i)] $srvquery(udp=>weight[$var(i)])\\n\");\n        $var(i) = $var(i) + 1;\n      }\n    }\n    ...\n            \n\n",
 "naptr_query": "### naptr_query(domain, pvid)\n\n module: ipops\n\nQueries DNS NAPTR records to resolve a domain name into a list of\norders, preferences, flags, services, regex, replaces sorted by orders\nand preferences as outlined in [RFC\n2915](http://tools.ietf.org/html/rfc2915).\n\nParameters:\n\n- *domain* - string or pseudo-variable containing the domain. For\n  example, \"example.com\".\n\n- *pvid* - container id for script variable.\n\nOutput:\n\nReturns a positive number indicating success or a negative number when\nan error is encountered. It can be used from ANY_ROUTE.\n\nThe \\$naptrquery pseudo-variable (PV) is loaded with the results of the\nquery. Multiple queries can be stored in the PV using the pvid key. Each\nquery contains zero-indexed arrays sorted by order and preference that\ncontain:\n\n- *count* - number of records found\n\n- *order \\[index\\]* - order as defined by [RFC\n  2915](http://tools.ietf.org/html/rfc2915)\n\n- *pref \\[index\\]* - preference as defined by [RFC\n  2915](http://tools.ietf.org/html/rfc2915)\n\n- *flags \\[index\\]* - flags\n\n- *services \\[index\\]* - services\n\n- *regex \\[index\\]* - regular expression\n\n- *replace \\[index\\]* - replace\n\n<!-- -->\n\n    ...\n    if (naptr_query (\"example.com\", \"res\") > 0) {\n      $var(cnt) = $naptrquery(res=>count);\n      $var(i) = 0;\n      while ($var(i) < $var(cnt)) {\n        xlog (\"order[$var(i)] $naptrquery(udp=>order[$var(i)])\\n\");\n        xlog (\"pref[$var(i)] $naptrquery(udp=>pref[$var(i)])\\n\");\n        xlog (\"flags[$var(i)] $naptrquery(udp=>flags[$var(i)])\\n\");\n        xlog (\"services[$var(i)] $naptrquery(udp=>services[$var(i)])\\n\");\n        xlog (\"regex[$var(i)] $naptrquery(udp=>regex[$var(i)])\\n\");\n        xlog (\"replace[$var(i)] $naptrquery(udp=>replace[$var(i)])\\n\");\n        $var(i) = $var(i) + 1;\n      }\n    }\n    ...\n            \n\n",
 "dns_set_local_ttl": "### dns_set_local_ttl(vttl)\n\n module: ipops\n\nSet local ttl for DNS query results. If vttl is 0, then the value of the\nresult and the core parameters are used.\n\nParameters:\n\n- *vttl* - TTL value in seconds. It can be static integer or a variable\n  holding an integer value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n      dns_set_local_ttl(\"7200\");\n      dns_query(\"test.com\", \"xyz\")\n      dns_set_local_ttl(\"0\");\n    ...\n            \n",
 "is_local": "### is_local(domain)\n\n module: uid_domain\n\nThis function can be used to test whether a given domain name in\nparameter belongs to one of the virtual domains defined in the domain\ntable. Such domain name is said to be local. The function returns 1 if\nthe domain name is found in the domain table and -1 otherwise.\n\nThe first parameter of the function can be anything that returns a\nstring with domain name. In its simplest form it can be a string with\ndomain name: is_local(\"iptel.org\"). You can also test a domain name\nstored in an attribute: is_local(\"\\$my_domain\"). And finally you can\ntest a domain name present in the SIP message with selects:\nis_local(\"@ruri.host\").\n\nNote: Unlike function `lookup_domain`, this function does not make\ndomain attributes of the virtual domain available to the script. Domain\nattributes are simply ignored by this function.\n\n    ...\n    if (is_local(\"@ruri.host\")) {\n        /* Domain part of Request-URI is local */\n    }\n    ...\n                \n\n",
 "lookup_domain": "### lookup_domain(domain [, prefix])\n\n module: domain\n\nThis function checks if domain given in domain argument is local and, if\nso, adds attributes associated with domain's id (did) to AVPs. If prefix\nargument (string) is given, names of attributes are prefixes by it. In\naddition to attributes given in domain_attrs table, AVP named did\ncontaining the did of domain is added.\n\nBoth parameters can contain pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n    ...\n    if (lookup_domain(\"$fd\", \"from_\")) {\n        xlog(\"L_INFO\", \"did of domain $fd is $avp(from_did)\\n\");\n    }\n    ...\n            \n\n",
 "t_relay": "### t_relay([host, port])\n\n module: tm\n\nRelay a message statefully either to the destination indicated in the\ncurrent URI (if called without any parameters) or to the specified host\nand port. In the later case (host and port specified) the protocol used\nis the same protocol on which the message was received.\n\n`t_relay()` is the stateful version for `forward()` while\n`t_relay(host, port)` is similar to `forward(host, port)`.\n\nIn the forward to uri case (`t_relay()`), if the original URI was\nrewritten (by UsrLoc, RR, strip/prefix, etc.) the new URI will be\ntaken). The destination (including the protocol) is determined from the\nuri, using SIP specific DNS resolving if needed (NAPTR, SRV a.s.o\ndepending also on the dns options).\n\nReturns a negative value on failure -- you may still want to send a\nnegative reply upstream statelessly not to leave upstream UAC in lurch.\n\n    ...\n    if (!t_relay())\n    {\n        sl_reply_error();\n        break;\n    };\n    ...\n            \n\n",
 "t_relay_to_udp": "### t_relay_to_udp([ip, port])\n\n module: tm\n\nRelay a message statefully using a fixed protocol either to the\nspecified fixed destination or to a destination derived from the message\nuri (if the host address and port are not specified). These along with\n`t_relay` are the functions most users want to use--all other are mostly\nfor programming. Programmers interested in writing TM logic should\nreview how t_relay is implemented in tm.c and how TM callbacks work.\n\nMeaning of the parameters is as follows:\n\n- *ip* - IP address where the message should be sent.\n\n- *port* - Port number.\n\nIf no parameters are specified the message is sent to a destination\nderived from the message uri (using sip specific DNS lookups), but with\nthe protocol corresponding to the function name.\n\n    ...\n    if (src_ip==10.0.0.0/8)\n        t_relay_to_udp(\"1.2.3.4\", \"5060\"); # sent to 1.2.3.4:5060 over udp\n    else\n        t_relay_to_tcp(); # relay to msg. uri, but over tcp\n    ...\n            \n\n",
 "t_relay_to_tcp": "### t_relay_to_tcp([ip, port])\n\n module: tm\n\nSee function `t_relay_to_udp([ip, port])`.\n\n",
 "t_relay_to_tls": "### t_relay_to_tls([ip, port])\n\n module: tm\n\nSee function `t_relay_to_udp([ip, port])`.\n\n",
 "t_relay_to_sctp": "### t_relay_to_sctp([ip, port])\n\n module: tm\n\nSee function `t_relay_to_udp([ip, port])`.\n\n",
 "t_on_failure": "### t_on_failure(failure_route)\n\n module: tm\n\nSets failure routing block, to which control is passed after a\ntransaction completed with a negative result but before sending a final\nreply. In the referred block, you can either start a new branch (good\nfor services such as forward_on_no_reply) or send a final reply on your\nown (good for example for message silo, which received a negative reply\nfrom upstream and wants to tell upstream \"202 I will take care of it\").\nNote that the set of commands which are usable within failure_routes is\nstrictly limited to rewriting URI, initiating new branches, logging, and\nsending stateful replies (`t_reply`). Any other commands may result in\nunpredictable behavior and possible server failure. Note that whenever\nfailure_route is entered, uri is reset to value which it had on\nrelaying. If it temporarily changed during a reply_route processing,\nsubsequent reply_route will ignore the changed value and use again the\noriginal one.\n\nMeaning of the parameters is as follows:\n\n- *failure_route* - Failure route block to be called.\n\n<!-- -->\n\n    ...\n    route {\n        t_on_failure(\"1\");\n        t_relay();\n    }\n\n    failure_route[1] {\n        revert_uri();\n        setuser(\"voicemail\");\n        append_branch();\n    }\n    ...\n            \n\nSee `misc/examples/mixed/onr.cfg` for a more complex example of\ncombination of serial with parallel forking.\n\n",
 "t_on_branch_failure": "### t_on_branch_failure(branch_failure_route)\n\n module: tm\n\nSets the branch_failure routing block, to which control is passed on\neach negative response to a transaction. This route is run before\ndeciding if the transaction is complete. In the referred block, you can\nstart a new branch which is required for failover of multiple outbound\nflows (RFC 5626). Note that the set of commands which are usable within\na branch_failure route is limited to a subset of the failure_route\ncommands including logging, rewriting URI and initiating new branches.\nAny other commands may generate errors or result in unpredictable\nbehavior. Note that whenever failure_route is entered, uri is reset to\nvalue which it had on relaying. If it temporarily changed during a\nreply_route processing, subsequent reply_route will ignore the changed\nvalue and use again the original one.\n\nFunction Parameters:\n\n- *branch_failure_route* - Name of the branch_failure route block to be\n  called (it is prefixed internally with 'tm:branch-failure:').\n\n<!-- -->\n\n    ...\n    route {\n        t_on_branch_failure(\"myroute\");\n        t_relay();\n    }\n\n    event_route[tm:branch-failure:myroute] {\n        if (t_check_status(\"430|403\") {\n            unregister(\"location\", \"$tu\", \"$T_reply_ruid\");\n        }\n    }\n    ...\n            \n\n",
 "t_on_reply": "### t_on_reply(onreply_route)\n\n module: tm\n\nSets the reply routing block, to which control is passed when a reply\nfor the current transaction is received. Note that the set of commands\nwhich are usable within onreply_routes is limited.\n\nMeaning of the parameters is as follows:\n\n- *onreply_route* - Onreply route block to be called.\n\n<!-- -->\n\n    ...\n    loadmodule \"/usr/local/lib/ser/modules/nathelper.so\"\n    ...\n    route {\n        /* if natted */\n        t_on_reply(\"1\");\n        t_relay();\n    }\n\n    onreply_route[1] {\n        if (status=~ \"(183)|2[0-9][0-9]\"){\n            force_rtp_proxy();\n            search_append('^(Contact|m)[ \\t]*:.*sip:[^>[:cntrl:]]*', ';nat=yes');\n        }\n        if (nat_uac_test(\"1\")){\n            fix_nated_contact();\n        }\n    }\n            \n\n",
 "t_on_branch": "### t_on_branch(branch_route)\n\n module: tm\n\nSets the branch routing block, to which control is passed after forking\n(when a new branch is created). For now branch routes are intended only\nfor last minute changes of the SIP messages (like adding new headers).\nNote that the set of commands which are usable within branch_routes is\nvery limited. It is not possible to generate a reply.\n\nMeaning of the parameters is as follows:\n\n- *branch_route* - branch route block to be called.\n\n<!-- -->\n\n    ...\n    route {\n        t_on_branch(\"1\");\n        t_relay();\n    }\n\n    branch_route[1] {\n        if (uri=~\"sip:[0-9]+\"){\n            append_hf(\"P-Warn: numeric uri\\r\\n\");\n        }\n    }\n            \n\n",
 "t_newtran": "### t_newtran()\n\n module: tm\n\nCreates a new transaction, returns a negative value on error. This is\nthe only way a script can add a new transaction in an atomic way.\nTypically, it is used to deploy a UAS.\n\nNote: once the t_newtran() is executed, the new message flag operations\n(i.e., setflag() and resetflag()) are not syncronized to the\ntransaction, being stored only in the private memory SIP message\nstructure. Use the tmx module function t_flush_flags() to synchronize\nthe modified message flags to the already created transaction.\n\n    ...\n    if (t_newtran()) {\n        xlog(\"the transaction has been created\\n\");\n        t_reply(\"999\",\"hello\");\n    } else {\n        sl_reply_error();\n    }\n    ...\n            \n\nSee `misc/examples/mixed/uas.cfg` for more examples.\n\n",
 "t_reply": "### t_reply(code, reason_phrase)\n\n module: tm\n\nSends a stateful reply after a transaction has been established. See\n`t_newtran` for usage.\n\nIf the code is in the range 300-399 (redirect reply), the current\ndestination set is appended to the reply as Contact headers. The\ndestination set contains the request URI (R-URI), if it is modified\ncompared to the received one, plus the branches added to the request\n(e.g., after an append_branch() or lookup(\"location\")). If the R-URI was\nchanged but it is not desired to be part of the destination set, it can\nbe reverted using the function revert_uri().\n\nCustom headers to the reply can be added using append_to_reply()\nfunction from textops module.\n\nMeaning of the parameters is as follows:\n\n- *code* - Reply code number.\n\n- *reason_phrase* - Reason string.\n\n<!-- -->\n\n    ...\n    t_reply(\"404\", \"Not found\");\n    ...\n            \n\n",
 "t_send_reply": "### t_send_reply(code, reason)\n\n module: tm\n\nCreates the transaction if it does not exist (executing internally\nt_newtran()) and sends a stateful reply (executing internally\nt_reply()). If transaction exists, this function does not stop the\nexecution of config, t_reply() being still executed.\n\nFor more, see the docs for t_newtran() and t_reply().\n\nMeaning of the parameters is as follows:\n\n- *code* - Reply code number.\n\n- *reason* - Reason string.\n\n<!-- -->\n\n    ...\n    t_send_reply(\"404\", \"Not found\");\n    ...\n            \n\n",
 "t_lookup_request": "### t_lookup_request()\n\n module: tm\n\nChecks if a transaction exists. Returns a positive value if so, negative\notherwise. Most likely you will not want to use it, as a typical\napplication of a look-up is to introduce a new transaction if none was\nfound. However this is safely (atomically) done using `t_newtran`.\n\n    ...\n    if (t_lookup_request()) {\n        ...\n    };\n    ...\n            \n\n",
 "t_retransmit_reply": "### t_retransmit_reply()\n\n module: tm\n\nRetransmits a reply sent previously by UAS transaction.\n\n    ...\n    t_retransmit_reply();\n    ...\n            \n\n",
 "t_release": "### t_release()\n\n module: tm\n\nRemove transaction from memory (it will be first put on a wait timer to\nabsorb delayed messages).\n\n    ...\n    t_release();\n    ...\n            \n\n",
 "t_forward_nonack": "### t_forward_nonack([ip, port])\n\n module: tm\n\nMainly for internal usage -- forward a non-ACK request statefully.\nVariants of this functions can enforce a specific transport protocol.\n\nMeaning of the parameters is as follows:\n\n- *ip* - IP address where the message should be sent.\n\n- *port* - Port number.\n\n<!-- -->\n\n    ...\n    t_forward_nonack(\"1.2.3.4\", \"5060\");\n    ...\n            \n\n",
 "t_forward_nonack_udp": "### t_forward_nonack_udp(ip, port)\n\n module: tm\n\nSee function `t_forward_nonack([ip, port])`.\n\n",
 "t_forward_nonack_tcp": "### t_forward_nonack_tcp(ip, port)\n\n module: tm\n\nSee function `t_forward_nonack([ip, port])`.\n\n",
 "t_forward_nonack_tls": "### t_forward_nonack_tls(ip, port)\n\n module: tm\n\nSee function `t_forward_nonack([ip, port])`.\n\n",
 "t_forward_nonack_sctp": "### t_forward_nonack_sctp(ip, port)\n\n module: tm\n\nSee function `t_forward_nonack([ip, port])`.\n\n",
 "t_set_fr": "### t_set_fr(fr_inv_timeout [, fr_timeout])\n\n module: tm\n\nSets the fr_inv_timeout and optionally fr_timeout for the current\ntransaction or for transactions created during the same script\ninvocation, after calling this function. If the transaction is already\ncreated (e.g called after `t_relay()` or in an onreply_route) all the\nbranches will have their final response timeout updated on-the-fly. If\none of the parameters is 0, its value won't be changed.\n\nMeaning of the parameters is as follows:\n\n- *fr_inv_timeout* - new final response timeout (in milliseconds) for\n  INVITEs. See also `fr_inv_timer`.\n\n  *fr_timeout* - new final response timeout (in milliseconds) for\n  non-INVITE transaction, or INVITEs which haven't received yet a\n  provisional response. See also `fr_timer`.\n\nSee also: `fr_timer`, `fr_inv_timer`, `t_reset_fr()`.\n\n    ...\n    route {\n        t_set_fr(10000); # set only fr invite timeout to 10s\n        t_on_branch(\"1\");\n        t_relay();\n    }\n\n    branch_route[1] {\n        # if we are calling the pstn, extend the invite timeout to 50s\n        # for all the branches, and set the no-reply-received timeout to 2s\n        if (uri=~\"sip:[0-9]+\"){\n            t_set_fr(50000, 2000);\n        }\n    }\n            \n\n",
 "t_reset_fr": "### t_reset_fr()\n\n module: tm\n\nResets the `fr_inv_timer` and `fr_timer` for the current transaction to\nthe default values (set using the tm module parameters `fr_inv_timer`\nand `fr_timer`).\n\nIt will effectively cancel any previous calls to `t_set_fr` for the same\ntransaction.\n\nSee also: `fr_timer`, `fr_inv_timer`, `t_set_fr`.\n\n    ...\n    route {\n    ...\n            t_reset_fr();\n    ...\n    }\n            \n\n",
 "t_set_max_lifetime": "### t_set_max_lifetime(inv_lifetime, noninv_lifetime)\n\n module: tm\n\nSets the maximum lifetime for the current INVITE or non-INVITE\ntransaction, or for transactions created during the same script\ninvocation, after calling this function (that's why it takes values for\nboth INVITE and non-INVITE). If one of the parameters is 0, its value\nwon't be changed.\n\nIt works as a per transaction `max_inv_lifetime` or\n`max_noninv_lifetime`.\n\nMeaning of the parameters is as follows:\n\n- *inv_lifetime* - maximum INVITE transaction lifetime (in\n  milliseconds). See also `max_inv_lifetime`.\n\n  *noninv_lifetime* - maximum non-INVITE transaction lifetime (in\n  milliseconds). See also `max_noninv_lifetime`.\n\nSee also: `max_inv_lifetime`, `max_noninv_lifetime`,\n`t_reset_max_lifetime`.\n\n    ...\n    route {\n        if (src_ip=1.2.3.4)\n            t_set_max_lifetime(120000, 0); # set only max_inv_lifetime to 120s\n        else\n            t_set_max_lifetime(90000, 15000); # set the maximum lifetime to 90s if\n                                              # the current transaction is an\n                                              # INVITE and to 15s if not\n    }\n\n            \n\n",
 "t_reset_max_lifetime": "### t_reset_max_lifetime()\n\n module: tm\n\nResets the maximum lifetime for the current INVITE or non-INVITE\ntransaction to the default value (set using the tm module parameter\n`max_inv_lifetime` or `max_noninv_lifetime`).\n\nIt will effectively cancel any previous calls to `t_set_max_lifetime`\nfor the same transaction.\n\nSee also: `max_inv_lifetime`, `max_noninv_lifetime`,\n`t_set_max_lifetime`.\n\n    ...\n    route {\n    ...\n            t_reset_max_lifetime();\n    ...\n    }\n            \n\n",
 "t_set_retr": "### t_set_retr(retr_t1_interval, retr_t2_interval)\n\n module: tm\n\nSets the retr_t1_interval and retr_t2_interval for the current\ntransaction or for transactions created during the same script\ninvocation, after calling this function. If one of the parameters is 0,\nit's value won't be changed. If the transaction is already created (e.g\ncalled after `t_relay()` or in an onreply_route) all the existing\nbranches will have their retransmissions intervals updated on-the-fly:\nif the retransmission interval for the branch has not yet reached T2 the\ninterval will be reset to retr_t1_interval, else to retr_t2_interval.\nNote that the change will happen after the current interval expires\n(after the next retransmission, the next-next retransmission will take\nplace at retr_t1_interval or retr_t2_interval). All new branches of the\nsame transaction will start with the new values. This function will work\neven if it's called in the script before a transaction creating function\n(e.g.: t_set_retr(500, 4000); t_relay()). All new transaction created\nafter this function call, during the same script invocation will use the\nnew values.\n\nMeaning of the parameters is as follows:\n\n- *retr_t1_interval* - new T1 retransmission interval (in milliseconds).\n  See also `retr_t1_timeout`.\n\n  *retr_t2_interval* - new T2 (or maximum) retransmission interval (in\n  milliseconds). See also `retr_t2_timeout`.\n\nSee also: `retr_timer1`, `retr_timer2`, `t_reset_retr()`.\n\n    ...\n    route {\n        t_set_retr(250, 0); # set only T1 to 250 ms\n        t_on_branch(\"1\");\n        t_relay();\n    }\n\n    branch_route[1] {\n        # if we are calling the a remote pstn, extend T1 and decrease T2\n        # for all the branches\n        if (uri=~\"sip:[0-9]+\"){\n            t_set_retr(500, 2000);\n        }\n    }\n            \n\n",
 "t_reset_retr": "### t_reset_retr()\n\n module: tm\n\nResets the `retr_timer1` and `retr_timer2` for the current transaction\nto the default values (set using the tm module parameters `retr_timer1`\nand `retr_timer2`).\n\nIt will effectively cancel any previous calls to `t_set_retr` for the\nsame transaction.\n\nSee also: `retr_timer1`, `retr_timer2`, `t_set_retr`.\n\n    ...\n    route {\n    ...\n            t_reset_retr();\n    ...\n    }\n            \n\n",
 "t_set_auto_inv_100": "### t_set_auto_inv_100(0|1)\n\n module: tm\n\nSwitch automatically sending 100 replies to INVITEs on/off on a per\ntransaction basis. It overrides the `auto_inv_100` value for the current\ntransaction.\n\nSee also: `auto_inv_100`.\n\n    ...\n    route {\n    ...\n        if (src_ip==1.2.3.0/24)\n            t_set_auto_inv_100(0); # turn off automatic 100 replies\n    ...\n    }\n            \n\n",
 "t_branch_timeout": "### t_branch_timeout()\n\n module: tm\n\nReturns true if the failure route is executed for a branch that did\ntimeout. It can be used from FAILURE_ROUTE and BRANCH_FAILURE_ROUTE\nevent route.\n\n    ...\n    failure_route[0]{\n        if (t_branch_timeout()){\n            log(\"timeout\\n\");\n            # ...\n        }\n    }\n            \n\n",
 "t_branch_replied": "### t_branch_replied()\n\n module: tm\n\nReturns true if the failure route is executed for a branch that did\nreceive at least one reply in the past (the \"current\" reply is not taken\ninto account). It can be used from *failure_route* and *branch-failure*\nevent route.\n\n    ...\n    failure_route[0]{\n        if (t_branch_timeout()){\n            if (t_branch_replied())\n                log(\"timeout after receiving a reply (no answer?)\\n\");\n            else\n                log(\"timeout, remote side seems to be down\\n\");\n            # ...\n        }\n    }\n            \n\n",
 "t_any_timeout": "### t_any_timeout()\n\n module: tm\n\nReturns true if at least one of the current transactions branches did\ntimeout.\n\n    ...\n    failure_route[0]{\n        if (!t_branch_timeout()){\n            if (t_any_timeout()){\n                log(\"one branch did timeout\\n\");\n                sl_send_reply(\"408\", \"Timeout\");\n            }\n        }\n    }\n            \n\n",
 "t_any_replied": "### t_any_replied()\n\n module: tm\n\nReturns true if at least one of the current transactions branches did\nreceive some reply in the past. If called from a failure or onreply\nroute, the \"current\" reply is not taken into account.\n\n    ...\n    onreply_route[0]{\n        if (!t_any_replied()){\n            log(\"first reply received\\n\");\n            # ...\n        }\n    }\n            \n\n",
 "t_grep_status": "### t_grep_status(\"code\")\n\n module: tm\n\nReturns true if \"code\" is the final reply received (or locally\ngenerated) in at least one of the current transactions branches.\n\n    ...\n    onreply_route[0]{\n        if (t_grep_status(\"486\")){\n            /* force a 486 reply, even if this is not the winning branch */\n            t_reply(\"486\", \"Busy\");\n        }\n    }\n            \n\n",
 "t_is_canceled": "### t_is_canceled()\n\n module: tm\n\nReturns true if the current transaction was canceled.\n\n    ...\n    failure_route[0]{\n        if (t_is_canceled()){\n            log(\"transaction canceled\\n\");\n            # ...\n        }\n    }\n            \n\n",
 "t_is_expired": "### t_is_expired()\n\n module: tm\n\nReturns true if the current transaction has already been expired, i.e.\nthe max_inv_lifetime/max_noninv_lifetime interval has already elapsed.\n\n    ...\n    failure_route[0]{\n        if (t_is_expired()){\n            log(\"transaction expired\\n\");\n            # There is no point in adding a new branch.\n        }\n    }\n            \n\n",
 "t_relay_cancel": "### t_relay_cancel()\n\n module: tm\n\nForwards the CANCEL if the corresponding INVITE transaction exists. The\nfunction is supposed to be used at the very beginning of the script,\nbecause the CANCELs can be caught and the rest of the script can be\nbypassed this way. Do not disable `reparse_invite` module parameter, and\ncall `t_relay_cancel()` right after the sanity tests.\n\nReturn value is 0 (drop) if the corresponding INVITE was found and the\nCANCELs were successfully sent to the pending branches, true if the\nINVITE was not found, and false in case of any error.\n\n    if (method == CANCEL) {\n        if (!t_relay_cancel()) {  # implicit drop if relaying was successful,\n                                      # nothing to do\n\n            # corresponding INVITE transaction found but error occurred\n            sl_reply(\"500\", \"Internal Server Error\");\n            drop;\n        }\n        # bad luck, corresponding INVITE transaction is missing,\n        # do the same as for INVITEs\n    }\n            \n\n",
 "t_lookup_cancel": "### t_lookup_cancel([1])\n\n module: tm\n\nReturns true if the corresponding INVITE transaction exists for a CANCEL\nrequest. The function can be called at the beginning of the script to\ncheck whether or not the CANCEL can be immediately forwarded bypassing\nthe rest of the script. Note however that `t_relay_cancel` includes\n`t_lookup_cancel` as well, therefore it is not needed to explicitly call\nthis function unless something has to be logged for example.\n\nIf the function parameter (optional) is set to 1, the message flags are\noverwritten with the flags of the INVITE. isflagset() can be used to\ncheck the flags of the previously forwarded INVITE in this case.\n\n    if (method == CANCEL) {\n        if (t_lookup_cancel()) {\n            log(\"INVITE transaction exists\");\n            if (!t_relay_cancel()) {  # implicit drop if\n                                              # relaying was successful,\n                                              # nothing to do\n\n                # corresponding INVITE transaction found\n                # but error occurred\n                sl_reply(\"500\", \"Internal Server Error\");\n                drop;\n            }\n        }\n        # bad luck, corresponding INVITE transaction is missing,\n        # do the same as for INVITEs\n    }\n            \n\n",
 "t_drop_replies": "### t_drop_replies([mode])\n\n module: tm\n\nDrops all the previously received replies in failure_route block to make\nsure that none of them is picked up again.\n\nThe parameter 'mode' controls which replies are dropped: 'a' or\nmissing - all replies are dropped; 'l' - replies received for last set\nof branches are dropped; 'n' - no reply is dropped.\n\nDropping replies works only if a new branch is added to the transaction,\nor it is explicitly replied in the script!\n\n    ...\n    failure_route[0]{\n        if (t_check_status(\"5[0-9][0-9]\")){\n            # I do not like the 5xx responses,\n            # so I give another chance to \"foobar.com\",\n            # and I drop all the replies to make sure that\n            # they are not forwarded to the caller.\n            t_drop_replies();\n\n            rewritehostport(\"foobar.com\");\n            append_branch();\n            t_relay();\n        }\n    }\n            \n\n",
 "t_save_lumps": "### t_save_lumps()\n\n module: tm\n\nForces the modifications of the processed SIP message to be saved in\nshared memory before t_relay() is called. The new branches which are\ncreated in failure_route will contain the same modifications, and any\nother modification after t_save_lumps() will be lost.\n\nNote that t_relay() automatically saves the modifications when it is\ncalled the first time, there is no need for t_save_lumps() unless\nmessage changes between t_save_lumps() and t_relay() must not be\npropagated to failure_route.\n\nThe transaction must be created by t_newtran() before calling\nt_save_lumps().\n\n    route {\n        ...\n        t_newtran();\n        append_hf(\"hf1: my first header\\r\\n\");\n        ...\n        t_save_lumps();\n        append_hf(\"hf2: my second header\\r\\n\");\n        ...\n        t_on_failure(\"1\");\n        t_relay();\n    }\n\n    failure_route[1] {\n        append_branch();\n        append_hf(\"hf3: my third header\\r\\n\");\n        #\n        # This branch contains hf1 and hf3, but does\n        # not contain hf2 header.\n        # hf2 would be also present here without\n        # t_save_lumps().\n        ...\n        t_relay();\n    }\n            \n\n",
 "t_load_contacts": "### t_load_contacts([mode])\n\n module: tm\n\nThis is the first of the three functions that can be used to implement\nserial/parallel forking based on q and +sip.instance values of\nindividual branches in the destination set.\n\nFunction `t_load_contacts()` removes all branches from the current\ndestination set and stores them into the XAVP whose name is configured\nwith the parameter `contacts_avp`. Note that you have to configure this\nparameter before you can use the function, the parameter is set to NULL\nby default, which disables the function.\n\nIf the destination set contains only one branch, the function does\nnothing.\n\nIf the current destination set contains more than one branch, the\nfunction sorts them according to the algorithm selected with the 'mode'\nparamenter and then stores the branches in reverse order into the XAVP.\n\nThe q parameter of a branch contains a value from range 0-1.0 and it\nexpresses relative preference of the branch among all branches in the\ndestination set. The higher the q value the more preference the user\nagent gave to the branch. The parameter 'mode' controls which type of\nalgorithm kamailio will apply to sort the branches based on the q\nvalues:\n\n\\- '0' or missing: branches with higher q values will be tried before\nbranches with lower ones when serial forking takes place Equals q values\nwill result in a parallel forking.\n\n\\- '1': branches are ordered using a proportional algorithm that uses to\nq value as the weight of the branch. Higher is the q value, higher is\nthe probability to be tried as first. Equals q values means equals\nprobability to be tried. Differently from the previous mode there is no\npossibility to have parallel forking. Branches with q values equals to 0\nor lower are not considered by the ordering algorithm, but just added at\nthe end of the list as backup option if all other branches fail. This\nalgorithm can be useful in case of endpoints in ACTIVE-ACTIVE\nconfiguration to load-balance the calls.\n\nAfter calling `t_load_contacts()`, function `t_next_contacts()` and\npossibly also `t_next_contact_flow()` need to be called one or more\ntimes in order to retrieve the branches based on their order.\n\nFunction returns 1 if loading of contacts succeeded or there was nothing\nto do. In case of an error, function returns -1 (see syslog).\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (!t_load_contacts()) {\n            sl_send_reply(\"500\", \"Server Internal Error - Cannot load contacts\");\n            exit;\n    };\n    ...\n\n",
 "t_next_contacts": "### t_next_contacts()\n\n module: tm\n\nFunction `t_next_contacts()` is the second of the three functions that\ncan be used to implement serial/parallel forking based on the q value of\nthe individual branches in a destination set.\n\nThe function adds to request a new destination set that includes the\nhighest priority contacts in contacts_avp, but only one contact with the\nsame +sip.instance value is included. Duplicate contacts are added to\ncontact_flows_avp for later consumption by function\n`next_contact_flow()`. Upon each call, Request URI is rewritten with the\nfirst contact and the remaining contacts (if any) are added as branches.\nThen all highest priority contacts are removed from contacts_avp.\n\nFunction does nothing if `contact_avp` has no values.\n\nFunction returns 1 if contacts_avp was not empty and a destination set\nwas successfully added, returns -2 if contacts_avp was empty and thus\nthere was nothing to do, and returns -1 in case of an error (see\nsyslog). Function can be called from REQUEST_ROUTE and FAILURE_ROUTE.\n\nNote that if you use `t_load_contacts` and `t_next_contacts` functions\nthen you should also set the value of `restart_fr_on_each_reply`\nparameter to 0. If you do not do that, it can happen that a broken user\nagent that retransmits 180 periodically will keep resetting the\nfr_inv_timer value and serial forking never happens.\n\nBefore calling t_relay(), you can check if the previous call of\n`next_contacts()` consumed all branches by checking if `contact_avp` and\n`contact_flows_avp` are not anymore set. Based on that test, you can\nthen use t_set_fr() function to set timers according to your needs.\n\n    ...\n    # First call after t_load_contacts() when transaction does not exist yet\n    # and contacts should be available\n    if (!t_next_contacts()) {\n            sl_send_reply(\"500\", \"Server Internal Error - Cannot get contacts\");\n    } else {\n            t_relay();\n    };\n    ...\n    # Following call, when transaction exists and there may or may not be\n    # contacts left\n    if (!t_next_contacts()) {\n            t_reply(\"408\", \"Request Timeout\");\n    } else {\n            t_relay();\n    };\n    ...\n\n",
 "t_next_contact_flow": "### t_next_contact_flow()\n\n module: tm\n\nFunction `t_next_contact_flow()` is the last of the three functions that\ncan be used to implement serial/parallel forking based on the q value\nand instance value of individual branches in a destination set.\n\nFunction adds a new branch to the request that includes the first\ncontact from `contact_flows_avp` that matches the +sip.instance value of\nthe flow that has failed. Upon each call, Request URI is rewritten with\nthe contact. The used contact is removed from `contact_flows_avp`.\n\nFunction does nothing if there are no `contact_flows_avp` values.\n\nFunction returns 1 if `contact_flows_avp` was not empty and a\ndestination set was successfully added, returns -2 if `contacts_avp` was\nempty and thus there was nothing to do, and returns -1 in case of an\nerror (see syslog). This function can be used from a\nBRANCH_FAILURE_ROUTE event route.\n\n    ...\n    event_route[tm:branch-failure:outbound]\n    {\n        if (t_next_contact_flow())\n        {\n            t_relay();\n        } else {\n            xlog(\"L_INFO\", \"No more flows\\n\");\n        }\n    ...\n\n",
 "t_check_status": "### t_check_status(re)\n\n module: tm\n\nReturns true if the regular expression \u201cre\u201d match the reply code of the\nresponse message as follows:\n\n- *in routing block* - the code of the last sent reply.\n\n- *in on_reply block* - the code of the current received reply.\n\n- *in on_failure block* - the code of the selected negative final reply.\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    if (t_check_status(\"(487)|(408)\")) {\n        log(\"487 or 408 negative reply\\n\");\n    }\n    ...\n\n",
 "t_check_trans": "### t_check_trans()\n\n module: tm\n\n`t_check_trans()` can be used to quickly check if a message belongs or\nis related to a transaction. It behaves differently for different types\nof messages:\n\n- For a SIP Reply it returns true if the reply belongs to an existing\n  transaction and false otherwise.\n\n- For a CANCEL it behaves exactly as `t_lookup_cancel()`: returns true\n  if a corresponding INVITE transaction exists for the CANCEL and false\n  otherwise.\n\n- For ACKs to negative replies or for ACKs to local transactions it will\n  terminate the script if the ACK belongs to a transaction (it would\n  make very little sense to process an ACK to a negative reply for an\n  existing transaction in some other way then to simply pass it to tm)\n  or return false if not.\n\n- For end-to-end ACKs (ACKs to 2xx responses for forwarded INVITE\n  transactions) it will return true if the corresponding INVITE\n  transaction is found and still active and false if not.\n\n  <div class=\"note\">\n\n  Note that the e2e ACK matching is more of a hint then a certainty. A\n  delayed e2e ACK might arrive after the transaction wait time elapses,\n  when the INVITE transaction no longer exists and thus would not match\n  anything. There are also cases when tm would not keep all the\n  information needed for e2e ACK matching (since this is not needed for\n  a stateful proxy and it requires additional memory, tm will not keep\n  this information unless needed by some other module or callbacks).\n\n  </div>\n\n- For other requests (non ACKs and non CANCELs), in case of a\n  retransmission matching a transaction, it resends the last reply for\n  that transaction and terminates the config execution. Otherwise, it\n  returns false (in case of new requests for which no transaction exists\n  yet).\n\n<div class=\"note\">\n\nAn important difference from kamailio version is that for an ACK to\nnegative reply or for a local transaction, the script execution will be\nimmediately stopped and the message handled by tm, instead of returning\ntrue.\n\n</div>\n\n`t_check_trans()` functionality for requests, except for the e2e ACK\nmatching, can be replicated in the script using `t_lookup_cancel()` and\n`t_lookup_request()`.\n\nSee also: `t_lookup_request()`, `t_lookup_cancel()`.\n\n    if ( method == \"CANCEL\" && !t_check_trans())\n        sl_reply(\"403\", \"cancel out of the blue forbidden\");\n    # note: in this example t_check_trans() can be replaced by t_lookup_cancel()\n\n            \n\n",
 "t_set_disable_6xx": "### t_set_disable_6xx(0|1)\n\n module: tm\n\nTurn off/on 6xx replies special rfc conforming handling on a per\ntransaction basis. If turned off (`t_set_disable_6xx(\"1\")`) 6XXs will be\ntreated like normal replies.\n\nIt overrides the `disable_6xx_block` value for the current transaction.\n\nSee also: `disable_6xx_block`.\n\n    ...\n    route {\n    ...\n        if (src_ip==1.2.3.4) # bad user agent that sends 603\n            t_set_disable_6xx(1); # turn off 6xx special handling\n    ...\n    }\n            \n\n",
 "t_set_disable_failover": "### t_set_disable_failover(0|1)\n\n module: tm\n\nTurn off/on dns failover on a per transaction basis.\n\nSee also: `use_dns_failover`.\n\n    ...\n    route {\n    ...\n        if (uri=~\"@foo.bar$\")\n            t_set_disable_failover(1); # turn off dns failover\n    ...\n    }\n            \n\n",
 "t_set_disable_internal_reply": "### t_set_disable_internal_reply(0|1)\n\n module: tm\n\nTurn off/on sending internally a SIP reply in case of relay errors.\n\n    ...\n    t_set_disable_internal_reply(1); # turn off sending internal reply on error\n    if(!t_relay()) {\n       send_reply(\"500\", \"Server error\");\n    }\n    ...\n            \n\n",
 "t_replicate": "### t_replicate([params])\n\n module: tm\n\nReplicate the SIP request to a specific address. Return values are the\nsame as for `t_relay()`. Note that responses to the replicated request\nare suppressed and will not show up in any reply_route.\n\nThere are several function prototypes:\n\n- `t_replicate([uri])`,\n\n- `t_replicate(host, port)`,\n\n- `t_replicate_udp(host, port)`\n\n- `t_replicate_tcp(host, port)`\n\n- `t_replicate_tls(host, port)`\n\n- `t_replicate_sctp(host, port)`\n\n- `t_replicate_to(proto, hostport)`\n\nMeaning of the parameters is as follows:\n\n- *uri* - SIP URI where the message should be sent. It can be given via\n  a script variable. It is optional - when missing, the dst-uri or r-uri\n  are used as next hop address.\n\n- *host* - host address where the message should be sent.\n\n- *port* - port number.\n\n- *proto* - transport protocol to be used.\n\n- *hostport* - address in \"host:port\" format. It can be given via an\n  AVP.\n\n<!-- -->\n\n    ...\n    # sent to 1.2.3.4:5060 over tcp\n    t_replicate(\"sip:1.2.3.4:5060;transport=tcp\");\n\n    # sent to 1.2.3.4:5061 over tls\n    $var(h) = \"1.2.3.4:5061\";\n    t_replicate(\"sip:$var(h);transport=tls\");\n\n    # sent to 1.2.3.4:5060 over udp\n    t_replicate_to_udp(\"1.2.3.4\", \"5060\");\n    ...\n            \n\n",
 "t_relay_to": "### t_relay_to(proxy, flags)\n\n module: tm\n\nForward the SIP request to a specific address, controlling internal\nbehavior via flags.\n\nThere are several function prototypes:\n\n- `t_relay_to()`,\n\n- `t_relay_to(proxy)`,\n\n- `t_relay_to(flags)`\n\n- `t_relay_to(proxy, flags)`\n\nMeaning of the parameters is as follows:\n\n- *proxy* - address where the request should be sent. Format is:\n  \"proto:host:port\" - any of proto or port can be omitted, along with\n  the semicolon after or before.\n\n- *flags* - bitmask integer value to control the internal behavior. Bits\n  can be:\n\n  - *0x01* - do not generate 100 reply.\n\n  - *0x02* - do not generate reply on internal error.\n\n  - *0x04* - disable dns failover.\n\n<!-- -->\n\n    ...\n    # sent to 1.2.3.4:5060 over tcp\n    t_relay_to(\"tcp:1.2.3.4:5060\");\n\n    # sent to 1.2.3.4 over tls\n    t_relay_to(\"tls:1.2.3.4\");\n\n    # sent to dst URI or R-URI without a 100 reply\n    t_relay_to(\"0x01\");\n    ...\n            \n\n",
 "t_set_no_e2e_cancel_reason": "### t_set_no_e2e_cancel_reason(0|1)\n\n module: tm\n\nEnables/disables reason header (RFC 3326) copying from the triggering\nreceived CANCEL to the generated hop-by-hop CANCEL. 0 enables and 1\ndisables.\n\nIt overrides the `e2e_cancel_reason` setting (module parameter) for the\ncurrent transaction.\n\nNote: the function has to be used when processing the INVITE (not when\nprocessing the CANCEL).\n\nSee also: `e2e_cancel_reason`.\n\n    ...\n    route {\n    ...\n        if (src_ip!=10.0.0.0/8) #  don't trust CANCELs from the outside\n            t_set_no_e2e_cancel_reason(1); # turn off CANCEL reason header copying\n    ...\n    }\n            \n\n",
 "t_is_set": "### t_is_set(target)\n\n module: tm\n\nReturn true if the attribute specified by 'target' is set for\ntransaction.\n\nThe target parameter can be:\n\n- *branch_route* - the function returns true if a branch route is set to\n  be executed.\n\n- *failure_route* - the function returns true if a failure route is set\n  to be executed.\n\n- *onreply_route* - the function returns true if an onreply route is set\n  to be executed.\n\n<!-- -->\n\n    ...\n    if(!t_is_set(\"failure_route\"))\n        LM_DBG(\"no failure route will be executed for current transaction\\n\");\n    ...\n            \n\n",
 "t_use_uac_headers": "### t_use_uac_headers()\n\n module: tm\n\nSet internal flags to tell tm to use UAC side for building headers for\nlocal generated requests (ACK, CANCEL) - useful when changing From/To\nheaders using other functions than uac_replace\\_\\[from\\|to\\]().\n\nIt returns true.\n\n    ...\n    t_use_uac_headers();\n    ...\n            \n\n",
 "t_is_retr_async_reply": "### t_is_retr_async_reply()\n\n module: tm\n\nCheck to see if the reply is a retransmitted reply on a transaction that\nis currently suspended asynchronously (suspended during reply\nprocessing). Right now the check is only on the transaction, we don't\nactually check to see if the reply message is an actual retransmission\nof the suspended reply. This is expected as you should not process\nanother reply until the suspended reply processing has been completed.\nThe trick here is to make sure you don't suspend for too long or even\nworse, indefinitely.\n\nreturns true if the transaction is currently reply suspended or false if\nnot.\n\n    ...\n    if (t_is_retr_async_reply()) {\n        xlog(\"L_DBG\", \"Dropping retransmitted reply which is still currently suspended\\n\");\n            drop();\n    }\n    ...\n            \n\n",
 "t_uac_send": "### t_uac_send(method, ruri, nexthop, socket, headers, body)\n\n module: tm\n\nSend a UAC request.\n\nIt returns true (1) if successful, false (-1) on failure.\n\nThe parameters:\n\n- *method* - SIP method.\n\n- *ruri* - request URI.\n\n- *nexthop* - destination URI (can be empty).\n\n- *socket* - local send socket (can be empty).\n\n- *headers* - SIP headers. At least From and To have to be provided. It\n  can include From/To tags, Call-ID, CSeq. If body is provided, then\n  Content-Type header must exist.\n\n- *body* - SIP message body (can be empty).\n\n<!-- -->\n\n    ...\n    t_uac_send(\"OPTIONS\", \"sip:alice@kamailio.org\", \"\", \"\",\n        \"From: bob@kamailio.org;tag=2w3e\\r\\nTo: bob@kamailio.org\", \"\");\n    ...\n            \n\n",
 "t_get_status_code": "### t_get_status_code()\n\n module: tm\n\nReturn the status code for transaction - the most relevant SIP reply\nstatus code, or -1 in case of error or no status code was set.\n\n    ...\n    $var(ts) = t_get_status_code();\n    if($var(ts) == 500) { ... }\n    ...\n            \n\n",
 "t_clean": "### t_clean()\n\n module: tm\n\nCleans active but very old transactions. Returns true (1). Can be called\nfrom any route.\n\n    ...\n    t_clean();\n    ...\n            \n\n",
 "t_exists": "### t_exists()\n\n module: tm\n\nReturn true of the transaction for current message exists, without\nsetting the global references.\n\n    ...\n    reply_route {\n        if (!t_exists()) {\n            drop();\n        }\n    }\n    ...\n            \n\n",
 "pua_xmpp_notify": "### pua_xmpp_notify()\n\n module: pua_xmpp\n\nFunction that handles Notify messages addressed to a user from an xmpp\ndomain. It requires filtering after method and domain in configuration\nfile. If the function is successful, a 2xx reply must be sent.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        if( is_method(\"NOTIFY\") && uri=~\"sip:.+@sip-xmpp.kamailio.org\")\n        {\n            if(pua_xmpp_notify())\n                t_reply(\"200\", \"OK\");\n            exit;\n        }\n    ...\n\n",
 "pua_xmpp_req_winfo": "### pua_xmpp_req_winfo(request_uri, expires)\n\n module: pua_xmpp\n\nFunction called when a Subscribe addressed to a user from an xmpp domain\nis received. It calls sending a Subscribe for winfo for the user, and\nthe following Notify with dialog-info is translated into a subscription\nin xmpp. It also requires filtering in configuration file, after method,\ndomain and event(only for presence).\n\nIt takes 2 parameters: request_uri and the value of Expires header field\nin received Subscribe.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        if( is_method(\"SUBSCRIBE\"))\n        {\n            handle_subscribe();\n            if(uri=~\"sip:.+@sip-xmpp.siphub.ro\" && $hdr(Event)== \"presence\")\n            {\n                pua_xmpp_req_winfo(\"$ruri\", \"$hdr(Expires)\");\n            }\n            t_release();\n        }\n\n    ...\n            \n\n",
 "tps_set_context": "### tps_set_context(ctx)\n\n module: topos\n\nUpdate the context at runtime. If the value is emtpy string, then the\nruntime context is reset.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        tps_set_context(\"srvone\");\n        ...\n    }\n    ...\n\n",
 "m_store": "### m_store([owner])\n\n module: msilo\n\nThe method stores certain parts of the current SIP request (it should be\ncalled when the request type is MESSAGE and the destination user is\noffline or his UA does not support MESSAGE requests). If the user is\nregistered with a UA which does not support MESSAGE requests you should\nnot use mode=\u201c0\u201d if you have changed the request uri with the contact\naddress of user's UA.\n\nMeaning of the parameters is as follows:\n\n- *owner* - is a string that must contain a SIP URI in whose inbox the\n  message will be stored. It can have any pseudo variable. If \"owner\" is\n  missing, the SIP address is taken from R-URI.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    m_store();\n    m_store(\"$tu\");\n    ...\n\n",
 "m_dump": "### m_dump([owner])\n\n module: msilo\n\nThe method sends stored messages for the SIP user that has registered to\nthe contact address in the registration. The method should be called\nwhen a REGISTER request is received and the \u201cExpire\u201d header has a value\ngreater than zero.\n\nMeaning of the parameters is as follows:\n\n- *owner* - is a string that must contain a SIP URI whose inbox will be\n  dumped. It can have any pseudo variable. If \"owner\" is missing, the\n  SIP address is taken from To URI.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    m_dump();\n    m_dump(\"$fu\");\n    ...\n\n",
 "allow_routing": "### allow_routing()\n\n module: permissions\n\nReturns true if all pairs constructed as described in [Call\nRouting](#sec-call-routing) have appropriate permissions according to\nthe configuration files. This function uses default configuration files\nspecified in `default_allow_file` and `default_deny_file`.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (allow_routing()) {\n        t_relay();\n    };\n    ...\n\n### allow_routing(basename)\n\n module: permissions\n\nReturns true if all pairs constructed as described in [Call\nRouting](#sec-call-routing) have appropriate permissions according to\nthe configuration files given as parameters.\n\nMeaning of the parameters is as follows:\n\n- *basename* - Basename from which allow and deny filenames will be\n  created by appending contents of `allow_suffix` and `deny_suffix`\n  parameters.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (allow_routing(\"basename\")) {\n        t_relay();\n    };\n    ...\n\n### allow_routing(allow_file, deny_file)\n\n module: permissions\n\nReturns true if all pairs constructed as described in [Call\nRouting](#sec-call-routing) have appropriate permissions according to\nthe configuration files given as parameters.\n\nMeaning of the parameters is as follows:\n\n- *allow_file* - File containing allow rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\n- *deny_file* - File containing deny rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (allow_routing(\"rules.allow\", \"rules.deny\")) {\n        t_relay();\n    };\n    ...\n\n",
 "allow_register": "### allow_register(basename)\n\n module: permissions\n\nThe function returns true if all pairs constructed as described in\n[Registration Permissions](#sec-registration-permissions) have\nappropriate permissions according to the configuration files given as\nparameters.\n\nMeaning of the parameters is as follows:\n\n- *basename* - Basename from which allow and deny filenames will be\n  created by appending contents of `allow_suffix` and `deny_suffix`\n  parameters.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (method==\"REGISTER\") {\n        if (allow_register(\"register\")) {\n            save(\"location\");\n            exit;\n        } else {\n            sl_send_reply(\"403\", \"Forbidden\");\n        };\n    };\n    ...\n\n### allow_register(allow_file, deny_file)\n\n module: permissions\n\nThe function returns true if all pairs constructed as described in\n[Registration Permissions](#sec-registration-permissions) have\nappropriate permissions according to the configuration files given as\nparameters.\n\nMeaning of the parameters is as follows:\n\n- *allow_file* - File containing allow rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\n- *deny_file* - File containing deny rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (method==\"REGISTER\") {\n        if (allow_register(\"register.allow\", \"register.deny\")) {\n            save(\"location\");\n            exit;\n        } else {\n            sl_send_reply(\"403\", \"Forbidden\");\n        };\n    };\n    ...\n\n",
 "allow_uri": "### allow_uri(basename, pvar)\n\n module: permissions\n\nReturns true if the pair constructed as described in [URI\nPermissions](#sec-uri-permissions) have appropriate permissions\naccording to the configuration files specified by the parameter.\n\nMeaning of the parameter is as follows:\n\n- *basename* - Basename from which allow and deny filenames will be\n  created by appending contents of `allow_suffix` and `deny_suffix`\n  parameters.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\n- *pvar* - Any pseudo-variable defined in Kamailio.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (allow_uri(\"basename\", \"$rt\")) {  // Check Refer-To URI\n        t_relay();\n    };\n    if (allow_uri(\"basename\", \"$avp(i:705)\") {  // Check URI stored in $avp(i:705)\n        t_relay();\n    };\n    ...\n\n",
 "allow_address": "### allow_address(group_id, ip_addr_pvar, port_pvar)\n\n module: permissions\n\nReturns true if the address and port given as values of pvar arguments\nbelonging to a group given as group_id argument matches an IP subnet or\na DNS domain name found in cached address table.\n\nWhen matching is done if the argument is an IP address, it is matched\nwith the records from that group that are of type exact IP or subnet. If\nthe argument is not an IP it is tried to be matched with the records\nthat are DNS domain names. No DNS lookup is performed, only strict\nmatching. Cached address table entry containing port value \u201c0\u201d matches\nany port. The \u201cgroup_id\u201d argument can be an integer string or a pseudo\nvariable.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n\n    // Check if source address/port is in group 1\n    if (!allow_address(\"1\", \"$si\", \"$sp\")) {\n        sl_send_reply(\"403\", \"Forbidden\");\n    };\n    // Check address/port stored in AVPs src_adr/src_port is in group 2\n    $avp(dst_adr) = \"sipdomain.com\";\n    $avp(dst_port) = \"0\";\n    if (!allow_address(\"2\", \"$avp(dst_adr)\", \"$avp(dst_port)\") {\n        sl_send_reply(\"403\", \"Forbidden\");\n    };\n    ...\n\n",
 "allow_source_address": "### allow_source_address([group_id])\n\n module: permissions\n\nEqual to \u201callow_address(group_id, \"\\$si\", \"\\$sp\")\u201d. If 'group_id' is\nmissing, the function is equal to allow_address(\"1\", \"\\$si\", \"\\$sp\").\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n\n    // Check source address/port of request\n    if (!allow_source_address(\"1\")) {\n        sl_send_reply(\"403\", \"Forbidden\");\n    };\n    ...\n\n",
 "allow_source_address_group": "### allow_source_address_group()\n\n module: permissions\n\nChecks if source address/port is found in cached address or subnet table\nin any group. If yes, returns that group. If not returns -1. Port value\n0 in cached address and group table matches any port.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n\n    $var(group) = allow_source_address_group();\n    if ($var(group) != -1) {\n       # do something with $var(group)\n    };\n    ...\n\n",
 "allow_address_group": "### allow_address_group(addr, port)\n\n module: permissions\n\nChecks if address/port is found in cached address or subnet table in any\ngroup. If yes, returns that group. If not returns -1. Port value 0 in\ncached address and group table matches any port. The parameters can be\npseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n\n    $var(group) = allow_address_group(\"1.2.3.4\", \"5060\");\n    if ($var(group) != -1) {\n       # do something with $var(group)\n    };\n    ...\n\n",
 "allow_trusted": "### allow_trusted([src_ip_pvar, proto_pvar, furi_pvar])\n\n module: permissions\n\nChecks based either on request's source address and transport protocol\nor source address and transport protocol given in pvar arguments, and\nFrom URI of request (or furi_pvar if provided) if request can be trusted\nwithout authentication. Returns \u201c1\u201d if a match is found as described in\n[Trusted Requests](#sec-trusted-requests) and \u201c-1\u201d otherwise. If a match\nis found and `peer_tag_avp` has been defined, adds a non-NULL tag column\nvalue of the matching peer to AVP peer_tag_avp.\n\nNOTE: source IP is matched using string comparison. Be careful if the IP\ncan have different forms, for a safer alternative for matching IP\naddresses, look at allow_source_address or allow_address().\n\nSource address, transport protocol and uri given in the arguments must\nbe in string format and they can contain script variables. Valid\ntransport protocol values are (ignoring case) \"any\", \"udp, \"tcp\", \"tls\",\n\"ws\", \"wss\" and \"sctp\".\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (allow_trusted()) {\n        t_relay();\n    }\n    ...\n    if (allow_trusted(\"$si\", \"$proto\")) {\n        t_relay();\n    }\n    ...\n    if (allow_trusted(\"$si\", \"any\", \"$ai\")) {\n        t_relay();\n    }\n    ...\n\n",
 "print": "### print(txt)\n\n module: print\n\nPrints string to stdout.\n\nMeaning of the parameters is as follows:\n\n- *txt* - string to be printed.\n\n<!-- -->\n\n    ...\n    print(\"The answer is 42\\n\");\n    ...\n            \n",
 "pow": "### pow(base, power, res)\n\n module: math\n\nThe exponentiation function, computing the base raised to power, storing\nin res.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        math_pow(\"2\", \"10\", \"$var(res)\");\n        $var(base) = 2;\n        $var(power) = 10;\n        math_pow(\"$var(base)\", \"$var(power)\", \"$var(res)\");\n    ...\n\n",
 "math_log2": "### math_log2(x, res)\n\n module: math\n\nThe function computes the base-2 logarithm of x and stores the result in\nres.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        math_log2(\"16\", \"$var(res)\");\n        $var(x) = 16;\n        math_log2(\"$var(x)\", \"$var(res)\");\n    ...\n\n",
 "math_log10": "### math_log10(x, res)\n\n module: math\n\nThe function computes the base-10 logarithm of x and stores the result\nin res.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        math_log10(\"100\", \"$var(res)\");\n        $var(x) = 100;\n        math_log10(\"$var(x)\", \"$var(res)\");\n    ...\n\n",
 "math_sqrt": "### math_sqrt(x, res)\n\n module: math\n\nThe function computes the square root of x and stores the result in res.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        math_sqrt(\"16\", \"$var(res)\");\n        $var(x) = 16;\n        math_sqrt(\"$var(x)\", \"$var(res)\");\n    ...\n",
 "search": "### search(re)\n\n module: textops\n\nSearches for the re in the message.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\nNote: it performs Posix regex matching and the 're' parameter is\ncompiled with the flags REG_EXTENDED\\|REG_ICASE\\|REG_NEWLINE.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if ( search(\"[Ss][Ii][Pp]\") ) { /*....*/ };\n    ...\n\n",
 "search_body": "### search_body(re)\n\n module: textops\n\nSearches for the re in the body of the message.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if ( search_body(\"[Ss][Ii][Pp]\") ) { /*....*/ };\n    ...\n\n",
 "search_str": "### search_str(text, re)\n\n module: textops\n\nSearches for the re in the body of the message.\n\nMeaning of the parameters is as follows:\n\n- *text* - text to perform regex searching over it.\n\n- *re* - regular expression to match over the 'text' parameter.\n\nBoth parameters can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if ( search_str(\"$ru\", \";transport=tcp\") ) { /*....*/ };\n    ...\n\n",
 "search_hf": "### search_hf(hf, re, flags)\n\n module: textops\n\nSearches for the re in the body of a header field.\n\nMeaning of the parameters is as follows:\n\n- *hf* - header field name.\n\n- *re* - regular expression.\n\n- *flags* - control flags - it has to be one of: a - all headers\n  matching the name; f - only first header matching the name; l - only\n  the last header matching the name.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if ( search_hf(\"From\", \":test@\", \"a\") ) { /*....*/ };\n    ...\n\n",
 "search_append": "### search_append(re, txt)\n\n module: textops\n\nSearches for the first match of re and appends txt after it.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String to be appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    search_append(\"[Oo]pen[Ss]er\", \" SIP Proxy\");\n    ...\n\n",
 "search_append_body": "### search_append_body(re, txt)\n\n module: textops\n\nSearches for the first match of re in the body of the message and\nappends txt after it.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String to be appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    search_append_body(\"[Oo]pen[Ss]er\", \" SIP Proxy\");\n    ...\n\n",
 "replace": "### replace(re, txt)\n\n module: textops\n\nReplaces the first occurrence of re with txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    replace(\"server\", \"Kamailio SIP Proxy\");\n    ...\n\n",
 "replace_body": "### replace_body(re, txt)\n\n module: textops\n\nReplaces the first occurrence of re in the body of the message with txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    replace_body(\"server\", \"Kamailio SIP Proxy\");\n    ...\n\n",
 "replace_hdrs": "### replace_hdrs(re, txt)\n\n module: textops\n\nReplaces the first occurrence of re in the SIP headers of the message\nwith txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    replace_hdrs(\"Kamailio\", \"Kamailio SIP Proxy\");\n    ...\n\n",
 "replace_all": "### replace_all(re, txt)\n\n module: textops\n\nReplaces all occurrence of re with txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    replace_all(\"server\", \"Kamailio SIP Proxy\");\n    ...\n\n",
 "replace_body_all": "### replace_body_all(re, txt)\n\n module: textops\n\nReplaces all occurrence of re in the body of the message with txt.\nMatching is done on a per-line basis.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    replace_body_all(\"server\", \"Kamailio SIP Proxy\");\n    ...\n\n",
 "replace_body_atonce": "### replace_body_atonce(re, txt)\n\n module: textops\n\nReplaces all occurrence of re in the body of the message with txt.\nMatching is done over the whole body.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    # strip the whole body from the message:\n    if(has_body() && replace_body_atonce(\"^.+$\", \"\"))\n            remove_hf(\"Content-Type\");\n    ...\n\n",
 "replace_str": "### replace_str(match, repl, mode)\n\n module: textops\n\nReplaces the first or all occurrence of 'match' with 'repl' by doing\nstring comparison for matching. It is applied over headers and message\nbody (not over the first line).\n\nMeaning of the parameters is as follows:\n\n- *match* - string to be matched.\n\n- *repl* - string to be used as replacement.\n\n- *mode* - 'f' - replace only first match; 'a' - replace all matches.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    replace_str(\"Kamailio\", \"Kamailio SIP Proxy\", \"a\");\n    ...\n\n",
 "replace_body_str": "### replace_body_str(match, repl, mode)\n\n module: textops\n\nReplaces the first or all occurrence of 'match' with 'repl' by doing\nstring comparison for matching. It is applied over the message body.\n\nMeaning of the parameters is as follows:\n\n- *match* - string to be matched.\n\n- *repl* - string to be used as replacement.\n\n- *mode* - 'f' - replace only first match; 'a' - replace all matches.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    replace_body_str(\"Kamailio\", \"Kamailio SIP Proxy\", \"a\");\n    ...\n\n",
 "replace_hdrs_str": "### replace_hdrs_str(match, repl, mode)\n\n module: textops\n\nReplaces the first or all occurrence of 'match' with 'repl' by doing\nstring comparison for matching. It is applied over the part with headers\nof the SIP message.\n\nMeaning of the parameters is as follows:\n\n- *match* - string to be matched.\n\n- *repl* - string to be used as replacement.\n\n- *mode* - 'f' - replace only first match; 'a' - replace all matches.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    replace_hdrs_str(\"Kamailio\", \"Kamailio SIP Proxy\", \"a\");\n    ...\n\n",
 "subst": "### subst('/re/repl/flags')\n\n module: textops\n\nReplaces re with repl.\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    # replace the uri in to: with the message uri (just an example)\n    if ( subst('/^To:(.*)sip:[^@]*@[a-zA-Z0-9.]+(.*)$/t:\\1\\u\\2/ig') ) {};\n\n    # replace the uri in to: with the value of avp sip_address (just an example)\n    if ( subst('/^To:(.*)sip:[^@]*@[a-zA-Z0-9.]+(.*)$/t:\\1$avp(sip_address)\\2/ig') ) {};\n\n    ...\n\n",
 "subst_uri": "### subst_uri('/re/repl/flags')\n\n module: textops\n\nRuns the re substitution on the message uri (like subst but works only\non the uri)\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    # adds 3463 prefix to numeric uris, and save the original uri (\\0 match)\n    # as a parameter: orig_uri (just an example)\n    if (subst_uri('/^sip:([0-9]+)@(.*)$/sip:3463\\1@\\2;orig_uri=\\0/i')){$\n\n    # adds the avp 'uri_prefix' as prefix to numeric uris, and save the original\n    # uri (\\0 match) as a parameter: orig_uri (just an example)\n    if (subst_uri('/^sip:([0-9]+)@(.*)$/sip:$avp(uri_prefix)\\1@\\2;orig_uri=\\0/i')){$\n\n    ...\n\n",
 "subst_user": "### subst_user('/re/repl/flags')\n\n module: textops\n\nRuns the re substitution on the message uri (like subst_uri but works\nonly on the user portion of the uri)\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    # adds 3463 prefix to uris ending with 3642 (just an example)\n    if (subst_user('/3642$/36423463/')){$\n\n    ...\n    # adds avp 'user_prefix' as prefix to username in r-uri ending with 3642\n    if (subst_user('/(.*)3642$/$avp(user_prefix)\\13642/')){$\n\n    ...\n\n",
 "subst_body": "### subst_body('/re/repl/flags')\n\n module: textops\n\nReplaces re with repl in the body of the message.\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if ( subst_body('/^o=(.*) /o=$fU /') ) {};\n\n    ...\n\n",
 "subst_hf": "### subst_hf(hf, subexp, flags)\n\n module: textops\n\nSubstitutions in the body of a header field.\n\nMeaning of the parameters is as follows:\n\n- *hf* - header field name.\n\n- *subexp* - substitution expression in the same format as of the\n  'subst' function parameter.\n\n- *flags* - control flags - it has to be one of: a - all headers\n  matching the name; f - only first header matching the name; l - only\n  the last header matching the name.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if ( subst_hf(\"From\", \"/:test@/:best@/\", \"a\") ) { /*....*/ };\n    ...\n\n",
 "set_body": "### set_body(txt, content_type)\n\n module: textops\n\nSet body to a SIP message.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    set_body(\"test\", \"text/plain\");\n    ...\n\n",
 "set_reply_body": "### set_reply_body(txt, content_type)\n\n module: textops\n\nSet body to a SIP reply to be generated by Kamailio.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    set_reply_body(\"test\", \"text/plain\");\n    ...\n\n",
 "filter_body": "### filter_body(content_type)\n\n module: textops\n\nFilters multipart/mixed body by leaving out all other body parts except\nthe first body part of given type.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - Content type to be left in the body.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if (has_body(\"multipart/mixed\")) {\n        if (filter_body(\"application/sdp\")) {\n            remove_hf(\"Content-Type\");\n            append_hf(\"Content-Type: application/sdp\\r\\n\");\n        } else {\n            xlog(\"Body part application/sdp not found\\n\");\n        }\n    }\n    ...\n\n",
 "append_to_reply": "### append_to_reply(txt)\n\n module: textops\n\nAppend txt as header to the reply that is going to be generated by\nKamailio (e.g., via sl_send_reply(...)).\n\nMeaning of the parameters is as follows:\n\n- *txt* - String which may contains pseudo-variables. Note that the\n  value has to be ended with \"\\r\\n\" (end of header characters sequence).\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nFAILURE_ROUTE, ERROR_ROUTE.\n\n    ...\n    append_to_reply(\"Foo: bar\\r\\n\");\n    append_to_reply(\"Foo: $rm at $Ts\\r\\n\");\n    ...\n\n",
 "append_hf": "### append_hf(txt[, hdr])\n\n module: textops\n\nAppends 'txt' as header at the end of all the headers, or after last\nheader named 'hdr' if the second parameter is provided.\n\nMeaning of the parameters is as follows:\n\n- *txt* - Header field to be appended. The value can contain\n  pseudo-variables which will be replaced at run time. Note that the\n  value has to be ended with \"\\r\\n\" (end of header characters sequence).\n\n- *hdr* - Header name after which the 'txt' is appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    append_hf(\"P-hint: VOICEMAIL\\r\\n\");\n    append_hf(\"From-username: $fU\\r\\n\", \"Call-ID\");\n    ...\n\n",
 "insert_hf": "### insert_hf(txt[, hdr])\n\n module: textops\n\nInserts 'txt' as header before the first header field, or before first\nheader named 'hdr' if the second parameter is provided.\n\nMeaning of the parameters is as follows:\n\n- *txt* - Header field to be inserted. The value can contain\n  pseudo-variables which will be replaced at run time. Note that the\n  value has to be ended with \"\\r\\n\" (end of header characters sequence).\n\n- *hdr* - Header name before which the 'txt' is inserted.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    insert_hf(\"P-hint: VOICEMAIL\\r\\n\");\n    insert_hf(\"To-username: $tU\\r\\n\");\n    insert_hf(\"P-hint: VOICEMAIL\\r\\n\", \"Call-ID\");\n    insert_hf(\"To-username: $tU\\r\\n\", \"Call-ID\");\n    ...\n\n",
 "append_urihf": "### append_urihf(prefix, suffix)\n\n module: textops\n\nAppend header field name with original Request-URI in middle.\n\nMeaning of the parameters is as follows:\n\n- *prefix* - string (usually at least header field name).\n\n- *suffix* - string (usually at least line terminator).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    append_urihf(\"CC-Diversion: \", \"\\r\\n\");\n    ...\n\n",
 "is_present_hf": "### is_present_hf(hf_name)\n\n module: textops\n\nReturn true if a header field is present in message.\n\n<div class=\"note\">\n\nThe function is also able to distinguish the compact names. For exmaple\n\u201cFrom\u201d will match with \u201cf\u201d\n\n</div>\n\nMeaning of the parameters is as follows:\n\n- *hf_name* - Header field name (long or compact form). It can be only a\n  static string value.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if (is_present_hf(\"From\")) xlog(\"From HF Present\");\n    ...\n\n",
 "is_present_hf_pv": "### is_present_hf_pv(hf_name)\n\n module: textops\n\nSame as is_present_hf() function, but the parameter can contain\nvariables.\n\n    ...\n    if (is_present_hf_pv(\"$var(hname)\")) xinfo(\"Header $var(hname) is present\\n\");\n    ...\n\n",
 "is_present_hf_re": "### is_present_hf_re(hf_name_re)\n\n module: textops\n\nReturn true if a header field whose name matches regular expression\n'hf_name_re' is present in message.\n\nMeaning of the parameters is as follows:\n\n- *hf_name_re* - Regular expression to match header field name. It can\n  be only a static string value.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if (is_present_hf_re(\"^P-\"))\n        xlog(\"There are headers starting with P-\\n\");\n    ...\n\n",
 "is_present_hf_re_pv": "### is_present_hf_re_pv(hf_name_re)\n\n module: textops\n\nSame as is_present_hf_re() function, but the parameter can contain\nvariables.\n\n    ...\n    if (is_present_hf_re_pv_(\"^$var(prefix)\"))\n        xlog(\"There are headers starting with $var(prefix)\\n\");\n    ...\n\n",
 "append_time": "### append_time()\n\n module: textops\n\nAdds a time header to the reply of the request. You must use it before\nfunctions that are likely to send a reply, e.g., save() from 'registrar'\nmodule. Header format is: \u201cDate: %a, %d %b %Y %H:%M:%S GMT\u201d, with the\nlegend:\n\n- *%a* abbreviated week of day name (locale)\n\n- *%d* day of month as decimal number\n\n- *%b* abbreviated month name (locale)\n\n- *%Y* year with century\n\n- *%H* hour\n\n- *%M* minutes\n\n- *%S* seconds\n\nReturn true if a header was successfully appended.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    append_time();\n    ...\n\n",
 "append_time_to_request": "### append_time_to_request()\n\n module: textops\n\nAdds a time header to the request. Header format is: \u201cDate: %a, %d %b %Y\n%H:%M:%S GMT\u201d, with the legend:\n\n- *%a* abbreviated week of day name (locale)\n\n- *%d* day of month as decimal number\n\n- *%b* abbreviated month name (locale)\n\n- *%Y* year with century\n\n- *%H* hour\n\n- *%M* minutes\n\n- *%S* seconds\n\nReturn true if a header was successfully appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    if(!is_present_hf(\"Date\"))\n        append_time_to_request();\n    ...\n\n",
 "is_method": "### is_method(name)\n\n module: textops\n\nCheck if the method of the message matches the name. If name is a known\nmethod (invite, cancel, ack, bye, options, info, update, register,\nmessage, subscribe, notify, refer, prack), the function performs method\nID testing (integer comparison) instead of ignore case string\ncomparison.\n\nThe 'name' can be a list of methods in the form of\n'method1\\|method2\\|...'. In this case, the function returns true if the\nSIP message's method is one from the list. IMPORTANT NOTE: in the list\nmust be only methods defined in Kamailio with ID (invite, cancel, ack,\nbye, options, info, update, register, message, subscribe, notify, refer,\nprack, publish; for more see:\n<http://www.iana.org/assignments/sip-parameters>).\n\nIf used for replies, the function tests the value of method field from\nCSeq header.\n\nMeaning of the parameters is as follows:\n\n- *name* - SIP method name\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n    ...\n    if(is_method(\"INVITE\"))\n    {\n        # process INVITEs here\n    }\n    if(is_method(\"OPTION|UPDATE\"))\n    {\n        # process OPTIONs and UPDATEs here\n    }\n    ...\n\n",
 "remove_hf": "### remove_hf(hname)\n\n module: textops\n\nRemove from message all headers with name \u201chname\u201d. Header matching is\ncase-insensitive. Matches and removes also the compact header forms.\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *hname* - header name to be removed. It can be only a static string\n  (because of the optimizations done at startup to speed up execution at\n  runtime).\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if(remove_hf(\"User-Agent\"))\n    {\n        # User Agent header removed\n    }\n    # compact form: remove \"Contact\" or \"m\" header\n    remove_hf(\"Contact\");\n    # compact form: remove \"Contact\" or \"m\" header\n    remove_hf(\"m\");\n    ...\n\n",
 "remove_hf_pv": "### remove_hf_pv(hname)\n\n module: textops\n\nSame as remove_hf() function, but the parameter can contain variables.\n\n    ...\n    remove_hf_pv(\"$var(hname)\");\n    ...\n\n",
 "remove_hf_re": "### remove_hf_re(re)\n\n module: textops\n\nRemove from message all headers with name matching regular expression\n\u201cre\u201d\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *re* - regular expression to match the header name to be removed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(remove_hf_re(\"^P-\"))\n    {\n        # All headers starting with \"P-\" removed\n    }\n    ...\n\n",
 "remove_hf_re_pv": "### remove_hf_re_pv(re)\n\n module: textops\n\nSame as remove_hf_re() function, but the parameter can contain\nvariables.\n\n    ...\n    if(remove_hf_re_pv(\"^$var(prefix)\"))\n    {\n        # All headers starting with $var(prefix) value removed\n    }\n    ...\n\n",
 "remove_hf_exp": "### remove_hf_exp(expmatch, expskip)\n\n module: textops\n\nRemove from message all headers with name matching regular expression\n\u201cexpmatch\u201d, but not matching regular expression \u201cexpskip\u201d.\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *expmatch* - regular expression to match the header name to be\n  removed.\n\n- *expskip* - regular expression to match the header name to be skipped\n  from removal.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(remove_hf_exp(\"^P-\", \"^P-Keep-\"))\n    {\n        # All headers starting with \"P-\" removed,\n        # except the ones starting with \"P-Keep-\"\n    }\n    ...\n\n",
 "remove_hf_exp_pv": "### remove_hf_exp_pv(expmatch, expskip)\n\n module: textops\n\nSame as remove_hf_exp() function, but the parameters can contain\nvariables.\n\n    ...\n    if(remove_hf_exp_pv(\"^$var(match)\", \"^$var(keep)\"))\n    {\n        # All headers starting with $var(match) value removed,\n        # except the ones starting with $var(keep) value\n    }\n    ...\n\n",
 "remove_hf_idx": "### remove_hf_idx(hname, idx)\n\n module: textops\n\nRemove from message the headers matching by name 'hname' with the index\n'idx'.\n\nReturns true if the header is removed.\n\nMeaning of the parameters is as follows:\n\n- *hname* - header name.\n\n- *idx* - index of the header, starting from 0 with first header;\n  negative values count from the end of the headers, -1 being the last\n  header matching the name.\n\nThe parameters can be config variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    remove_hf_idx(\"X-My-Header\", \"-1\");\n    ...\n\n",
 "remove_hf_match": "### remove_hf_match(hname, op, expr)\n\n module: textops\n\nRemove from message all headers with name 'hname' matching the body with\nexpression \u201cexpr\u201d, based on operator \u201cop\u201d.\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *hanem* - name of the header.\n\n- *op* - operator - it can be: 'eq' - equal; 'ne' - not equal; 'in' -\n  include; 're' - regular expression match.\n\n- *expr* - expression to match.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(remove_hf_match(\"X-Info\", \"in\", \"^data\")) {\n        # all headers with name \"X-Info\" that have the body matching regular\n        # expression \"^data\" are removed\n    }\n    ...\n\n",
 "has_body": "### has_body(), has_body(mime)\n\n module: textops\n\nThe function returns *true* if the SIP message has a body attached. The\ncheck includes also the \u201cContent-Length\u201d header presence and value.\n\nIf a parameter is given, the mime described will be also checked against\nthe \u201cContent-Type\u201d header.\n\nMeaning of the parameters is as follows:\n\n- *mime* - mime to be checked against the \u201cContent-Type\u201d header. If not\n  present or 0, this check will be disabled.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if(has_body(\"application/sdp\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "is_audio_on_hold": "### is_audio_on_hold()\n\n module: textops\n\nThe function returns *true* if the SIP message has a body attached and\nat least one audio stream in on hold. The return code of the function\nindicates the detected hold type:\n\n- *1* - RFC2543 hold type: null connection IP detected\n\n- *2* - RFC3264 hold type: inactive or sendonly attributes detected\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if(is_audio_on_hold())\n    {\n        switch ($rc) {\n        case 1:\n            # RFC2543 hold type\n            # do interesting stuff here\n            break;\n        case 2:\n            # RFC3264 hold type\n            # do interesting stuff here\n            break;\n    }\n    ...\n\n",
 "is_privacy": "### is_privacy(privacy_type)\n\n module: textops\n\nThe function returns *true* if the SIP message has a Privacy header\nfield that includes the given privacy_type among its privacy values. See\n<http://www.iana.org/assignments/sip-priv-values> for possible privacy\ntype values.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if(is_privacy(\"id\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "in_list": "### in_list(subject, list, separator)\n\n module: textops\n\nFunction checks if subject string is found in list string where list\nitems are separated by separator string. Subject and list strings may\ncontain pseudo variables. Separator string needs to be one character\nlong. Returns 1 if subject is found and -1 otherwise.\n\nFunction can be used from all kinds of routes.\n\n    ...\n    $var(subject) = \"fi\";\n    $var(list) = \"dk,fi,no,se\";\n    if (in_list(\"$var(subject)\", \"$var(list)\", \",\")) {\n        xlog(\"L_INFO\", \"subject is found in list\\n\");\n    }\n    ...\n                \n\n",
 "in_list_prefix": "### in_list_prefix(subject, list, separator)\n\n module: textops\n\nFunction checks if any element in list string is a prefix for subject\nstring where list items are separated by separator string. Subject and\nlist strings may contain pseudo variables. Separator string needs to be\none character long. Returns 1 if subject is found and -1 otherwise.\n\nFunction can be used from all kinds of routes.\n\n    ...\n    $var(subject) = \"final\";\n    $var(list) = \"dk,fi,no,se\";\n    if (in_list_prefix(\"$var(subject)\", \"$var(list)\", \",\")) {\n        xlog(\"L_INFO\", \"prefix for subject is found in list\\n\");\n    }\n    ...\n                \n\n",
 "cmp_str": "### cmp_str(str1, str2)\n\n module: textops\n\nThe function returns *true* if the two parameters matches as string case\nsensitive comparison.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if(cmp_str(\"$rU\", \"kamailio\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "cmp_istr": "### cmp_istr(str1, str2)\n\n module: textops\n\nThe function returns *true* if the two parameters matches as string case\ninsensitive comparison.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if(cmp_istr(\"$rU@you\", \"kamailio@YOU\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "starts_with": "### starts_with(str1, str2)\n\n module: textops\n\nThe function returns *true* if the first string starts with the second\nstring.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if (starts_with(\"$rU\", \"+358\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "ends_with": "### ends_with(str1, str2)\n\n module: textops\n\nThe function returns *true* if the first string ends with the second\nstring. The parameters can contain variables.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if (ends_with(\"$rU\", \"8800\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "str_find": "### str_find(str1, str2)\n\n module: textops\n\nThe function returns *true* (greater than 0) if the str2 string is found\nin str1, case sensitive comparison.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (str_find(\"$rU\", \"8800\")) {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "str_ifind": "### str_ifind(str1, str2)\n\n module: textops\n\nThe function returns *true* (greater than 0) if the str2 string is found\nin str1, case insensitive comparison.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (str_ifind(\"$rU\", \"Alice\")) {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "str_any_in": "### str_any_in(txt, clist)\n\n module: textops\n\nReturn 1 (true) if any character in \"clist\" is found inside \"txt\". Both\nparamters can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (str_any_in(\"$hdr(X-Hdr)\", \";',:\")) {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "set_body_multipart": "### set_body_multipart([txt, content_type][, boundary])\n\n module: textops\n\nSet multipart body to a SIP message. If called with no parameters, will\nconvert present body to multipart.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\n- *boundary* - string to use as boundary, can include pseudo-variables.\n  Default: unique-boundary-1\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n    ...\n    set_body_multipart(\"test\", \"text/plain\", \"delimiter\");\n    msg_apply_changes();\n    append_body_part(...);\n    msg_apply_changes();\n\n    ...\n\n    # Will produce:\n\n    ...\n    Content-Type: multipart/mixed;boundary=\"delimiter\"\n    Mime-Version: 1.0\n\n    --delimiter\n    Content-Type: text/plain\n\n    text\n\n    --delimiter\n    ...\n\n",
 "append_body_part": "### append_body_part(txt, content_type[, content_disposition])\n\n module: textops\n\nAppend a part on multipart body SIP message. Will use\n\"unique-boundary-1\" as boundary.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the multipart body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\n- *content_disposition* - value of Content-Disposition header, can\n  include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n    ...\n    $var(b) = \"7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\";\n    append_body_part(\"$var(b)\", \"application/vnd.cirpack.isdn-ext\", \"signal;handling=required\");\n    msg_apply_changes();\n    ...\n\n    # Will append this to the body:\n\n    ...\n    Content-Type: application/vnd.cirpack.isdn-ext\n    Content-Disposition: signal;handling=required\n\n    7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\n\n    --unique-boundary-1\n    ...\n\nIf other headers should be added to a MIME body part, they can be\nappended after the value of the content-type parameter, separated by\n\\`\\r\\n\\` (at the very end do not add the '\\r\\n').\n\n    ...\n    $var(b) = \"7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\";\n    append_body_part(\"$var(b)\", \"application/vnd.cirpack.isdn-ext\\r\\nX-Header: xyz\", \"signal;handling=required\");\n    msg_apply_changes();\n    ...\n\n    # Will append this to the body:\n\n    ...\n    Content-Type: application/vnd.cirpack.isdn-ext\n    X-Header: xyz\n    Content-Disposition: signal;handling=required\n\n    7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\n\n    --unique-boundary-1\n    ...\n\n",
 "append_body_part_hex": "### append_body_part_hex(txt, content_type[, content_disposition])\n\n module: textops\n\nAppend a part on multipart body SIP message, with the content provided\nin hexa format. Will use \"unique-boundary-1\" as boundary.\n\nMeaning of the parameters is as follows:\n\n- *txt* - content for the multipart body in hexa format. Spaces can be\n  used between the pairs of hexa digits to make it easier to read in the\n  config, they are ignored and not added in the body part. The parameter\n  can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\n- *content_disposition* - value of Content-Disposition header, can\n  include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n    ...\n    $var(b) = \"6b 61 6d 61 69 6c 69 6f\";\n    append_body_part_hex(\"$var(b)\", \"application/my-custom-ext\");\n    msg_apply_changes();\n    ...\n\n    # Will append this to the body:\n\n    ...\n    Content-Type: application/my-custom-ext\n\n    kamailio\n\n    --unique-boundary-1\n    ...\n\nIf other headers should be added to a MIME body part, see the docs for\nappend_body_part(...) function.\n\n",
 "get_body_part": "### get_body_part(content_type, opv)\n\n module: textops\n\nReturn the content of a multipart body SIP message, storing it in opv.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - value of Content-Type header of the part to be\n  returned. If more than one exists the first occurrence will be\n  returned.\n\n- *opv* - variable name where to store the result.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    get_body_part(\"application/vnd.cirpack.isdn-ext\", \"$var(pbody)\");\n    ...\n\n",
 "get_body_part_raw": "### get_body_part_raw(content_type, opv)\n\n module: textops\n\nReturn the content of a multipart body SIP message, including headers\nand boundary string, storing it in opv.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - value of Content-Type header of the part to be\n  returned. If more than one exists the first occurrence will be\n  returned.\n\n- *opv* - variable name where to store the result.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    get_body_part(\"application/vnd.cirpack.isdn-ext\", \"$var(hbody)\");\n    ...\n\n",
 "remove_body_part": "### remove_body_part(content_type)\n\n module: textops\n\nRemove a part on a multipart body SIP message.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - value of Content-Type header of the part to be\n  removed. If more than one exists the first occurrence will be removed.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n    ...\n    remove_body_part(\"application/vnd.cirpack.isdn-ext\");\n    msg_apply_changes();\n    ...\n\n",
 "regex_substring": "### regex_substring(itext, regexp, mindex, mcount, dpv)\n\n module: textops\n\nSearch in text with given regular expression then set dpv\npseudo-variable with the matched token at provided index.\n\nMeaning of the parameters is as follows:\n\n- *itext* - text to be searched (dynamic string)\n\n- *regexp* - regular expression (dynamic string)\n\n- *mindex* - index of the matched token (int or variable holding int)\n\n- *mcount* - the number of maximum expected matches (int or variable\n  holding int)\n\n- *dpv* - variable to be set with matched token (static string with a\n  name of a variable)\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nNote that the regular expression extended is used. More info at:\n<https://www.regular-expressions.info/posix.html>.\n\n        ...\n        regex_substring(\"___ abc123def ___ ghi456 ___\", \"([a-z]*)([0-9]+)([a-z]*)\",\n                1, 3, \"$var(asd)\");\n        xlog(\"L_WARN\",\"RESULT: $var(asd)\\r\\n\");\n        ------\n        result:\n        abc\n        ----\n        ...\n        \n\n",
 "load_textops": "### load_textops(*import_structure)\n\n module: textops\n\nFor programmatic use only--import the Textops API.\n\nMeaning of the parameters is as follows:\n\n- *import_structure* - Pointer to the import structure - see \u201cstruct\n  textops_binds\u201d in modules/textops/api.h\n",
 "verify_destination": "### verify_destination()\n\n module: peering\n\nFunction verify_destination() queries from broker's Radius server if\ndomain (host part) of Request URI is served by a trusted peer. Radius\nrequest contains the following attributes/values:\n\n- User-Name - Request-URI host\n\n- SIP-URI-User - Request-URI user\n\n- SIP-From-Tag - From tag\n\n- SIP-Call-Id - Call id\n\n- Service-Type - verify_destination_service_type\n\nFunction returns value 1 if domain of Request URI is served by a trusted\npeer and -1 otherwise. In case of positive result, the Radius server\nreturns a set of SIP-AVP reply attributes. The value of each SIP-AVP is\nof form:\n\n\\[#\\]name(:\\|#)value\n\nValue of each SIP-AVP reply attribute is mapped to a Kamailio AVP.\nPrefix \\# in front of name or value indicates a string name or string\nvalue, respectively.\n\nOne of the SIP-AVP reply attributes contains a string that the source\npeer must include \"as is\" in a *P-Request-Hash:* header when it sends\nthe SIP request to the destination peer. The string value may, for\nexample, be of form hash@timestamp, where hash contains a hash\ncalculated by the broker based on the attributes of the query and some\nlocal information and timestamp is the time when the calculation was\ndone.\n\nAVP names used in reply attributes are assigned by the broker.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (verify_destination()) {\n       append_hf(\"P-Request-Hash: $avp(i:200)\\r\\n\");\n    }\n    ...\n\n",
 "verify_source": "### verify_source()\n\n module: peering\n\nFunction verify_source() queries the broker's Radius server whether the\nSIP request was received from a trusted peer. The Radius request\ncontains the following attributes/values:\n\n- User-Name - Request-URI host\n\n- SIP-URI-User - Request-URI user\n\n- SIP-From-Tag - From tag\n\n- SIP-Call-Id - Call id\n\n- SIP-Request-Hash - body of P-Request-Hash header\n\n- Service-Type - verify_source_service_type\n\nFunction returns value 1 if SIP request was received from a trusted peer\nand -1 otherwise. In case of positive result, Radius server may return a\nset of SIP-AVP reply attributes. Value of each SIP-AVP is of form:\n\n\\[#\\]name(:\\|#)value\n\nValue of each SIP-AVP reply attribute is mapped to a Kamailio AVP.\nPrefix \\# in front of name or value indicates a string name or string\nvalue, respectively.\n\nAVP names used in reply attributes are assigned by the broker.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if (is_present_hf(\"P-Request-Hash\")) {\n       if (verify_source()) {\n          xlog(\"L_INFO\", \"Request came from trusted peer\\n\")\n       }\n    }\n    ...\n",
 "maxfwd_process": "### maxfwd_process(max_value)\n\n module: maxfwd\n\nIf no Max-Forward header is present in the received request, a header\nwill be added having the original value equal with \u201cmax_value\u201d. If a\nMax-Forward header is already present, its value will be decremented (if\nnot 0). The parameter can be a variable.\n\nReturn codes:\n\n- *2 (true)* - header was not found and a new header was successfully\n  added.\n\n- *1 (true)* - header was found and its value was successfully\n  decremented (had a non-0 value).\n\n- *-1 (false)* - the header was found and its value is 0 (cannot be\n  decremented).\n\n- *-2 (false)* - error during processing.\n\nThe return code may be extensively tested via script variable \u201cretcode\u201d\n(or \u201c\\$?\u201d).\n\nMeaning of the parameters is as follows:\n\n- *max_value* - Value to be added if there is no Max-Forwards header\n  field in the message.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    # initial sanity checks -- messages with\n    # max_forwards==0, or excessively long requests\n    if (!maxfwd_process(\"10\") && $retcode==-1) {\n        sl_send_reply(\"483\",\"Too Many Hops\");\n        exit;\n    };\n    ...\n\n",
 "mf_process_maxfwd_header": "### mf_process_maxfwd_header(max_value)\n\n module: maxfwd\n\nSame as maxfwd_process(max_value).\n\n",
 "process_maxfwd": "### process_maxfwd(max_value)\n\n module: maxfwd\n\nSame as maxfwd_process(max_value).\n\n",
 "is_maxfwd_lt": "### is_maxfwd_lt(max_value)\n\n module: maxfwd\n\nChecks if the Max-Forward header value is less than the \u201cmax_value\u201d\nparameter value. It considers also the value of the new inserted header\n(if locally added). The parameter can be a variable.\n\nRetuning codes:\n\n- *1 (true)* - header was found or set and its value is strictly less\n  than \u201cmax_value\u201d.\n\n- *-1 (false)* - the header was found or set and its value is greater or\n  equal to \u201cmax_value\u201d.\n\n- *-2 (false)* - header was not found or not set.\n\n- *-3 (false)* - error during processing.\n\nThe return code may be extensively tested via script variable \u201cretcode\u201d\n(or \u201c\\$?\u201d).\n\nMeaning of the parameters is as follows:\n\n- *max_value* - value to check the Max-Forward.value against (as less\n  than).\n\n<!-- -->\n\n    ...\n    # next hop is a gateway, so make no sense to\n    # forward if MF is 0 (after decrement)\n    if ( is_maxfwd_lt(\"1\") ) {\n        sl_send_reply(\"483\",\"Too Many Hops\");\n        exit;\n    };\n    ...\n\n",
 "maxfwd_at_least": "### maxfwd_at_least(max_value)\n\n module: maxfwd\n\nSame as is_maxfwd_lt(max_value).\n\n",
 "mf_lowlimit": "### mf_lowlimit(max_value)\n\n module: maxfwd\n\nSame as is_maxfwd_lt(max_value).\n",
 "dp_replace": "### dp_replace(dpid, inval, outvar)\n\n module: dialplan\n\nThe function translates the input value 'inval' using the rules with\ndialplan id 'dpid', storing the value in the variable 'outvar'. If the\nrule that was applied has attributes, they are stored in the variable\nprovided via the module parameter 'attrs_pvar'.\n\nThe behavior is same as dp_translate(\"dpid\", \"inval/outvar\"), but the\nparameters have a more flexible format.\n\nMeaning of the parameters is as follows:\n\n- *dpid* - the dialplan id to match the rules and apply the\n  transformations. It can be a static string or a config variable\n  holding an integer value.\n\n- *inval* - input value. It can be a static or a dynamic string. The\n  dynamic string can contain config variables, combined or not with\n  static strings, that are evaluated at runtime.\n\n- *outvar* - output variable name. The value resulted after applying the\n  matching rule is stored in this variable. The name must refer to a\n  writable variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    dp_replace(\"240\", \"$rU\", \"$var(newru)\");\n    xlog(\"'$rU' was translated to '$var(newru)'\\n\");\n    dp_replace(\"240\", \"+49$rU\", \"$var(newval)\");\n    ...\n        \n\n",
 "dp_match": "### dp_match(dpid, inval)\n\n module: dialplan\n\nThe function matches the input value 'inval' using the rules with\ndialplan id 'dpid'. If the rule that was applied has attributes, they\nare stored in the variable provided via the module parameter\n'attrs_pvar'.\n\nThe behavior is same as dp_translate(\"dpid\", \"inval\"), but the\nparameters have a more flexible format.\n\nMeaning of the parameters is as follows:\n\n- *dpid* - the dialplan id to match the rules and apply the\n  transformations. It can be a static string or a config variable\n  holding an integer value.\n\n- *inval* - input value. It can be a static or a dynamic string. The\n  dynamic string can contain config variables, combined or not with\n  static strings, that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    dp_match(\"240\", \"+49$rU\");\n    xlog(\"the attributes associated with '+49$rU' are '$var(attrs)'\\n\");\n    ...\n        \n\n",
 "dp_translate": "### dp_translate(id, [src[/dest]])\n\n module: dialplan\n\nWill try to translate \u201csrc\u201d into \u201cdest\u201d according to the translation\nrules in the dialplan identified by \u201cid\u201d . If src/dest is missing the\ndefault parameter \u201cruri.user/ruri.user\u201d will be used, thus translating\nthe request URI user part. If only \u201cdest\u201d is missing, only matching and\nstoring of the matching rule's attributes is done.\n\nReturns 1, if translation succeeded, -1 in case of some error occurred,\nand -2 if dialplan with ID equal to id does not exist.\n\nMeaning of the parameters is as follows:\n\n- *id* -the dialplan id of the possible matching rules. This parameter\n  can have the following types:\n\n  - *integer*- the dialplan id is statically assigned\n\n  - *avp var* - the dialplan id is the value of an existing avp variable\n\n  - *script var* - the dialplan id is the value of an existing script\n    variable.\n\n- *src/dest* - input and output of the function.\n\n  Input parameter src can be any pseudo variable. Output parameter dest\n  can be:\n\n  - *R-URI*\n\n    \\- the string is the r-uri or r-uri user part\n\n  - *avp var*\n\n    \\- At input the function will get the input string from an existing\n    avp variable. At output the function will add an avp with the value\n    of the output string.\n\n  - *script var*\n\n    \\- At input the function will get the input string from an existing\n    script variable. At output the function will set a script variable\n    with the value of the output string.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    dp_translate(\"240\", \"$ruri.user/$avp(s:dest)\");\n    xlog(\"translated to var $avp(s:dest) \\n\");\n    ...\n        \n\n    ...\n    $avp(s:src) = $ruri.user;\n    dp_translate(\"$var(x)\", \"$avp(s:src)/$var(y)\");\n    xlog(\"translated to var $var(y) \\n\");\n    ...\n        \n\n",
 "dp_reload": "### dp_reload()\n\n module: dialplan\n\nReload the translation rules from the database. Note that there is a\nrate limiting defined by 'reload_delta' parameter. By default is allowed\nmaximum one reload in five seconds.\n\nName: *dp_reload*\n\nParameters: *none*\n\nThis function can be used from ANY_ROUTE.\n\n",
 "perl_exec_simple": "### perl_exec_simple(func, [param])\n\n module: app_perl\n\nCalls a perl function *without* passing it the current SIP message. May\nbe used for very simple simple requests that do not have to fiddle with\nthe message themselves, but rather return information values about the\nenvironment.\n\nThe first parameter is the function to be called. An arbitrary string\nmay optionally be passed as a parameter.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if (method==\"INVITE\") {\n        perl_exec_simple(\"dosomething\", \"on invite messages\");\n    };\n    ...\n\n",
 "perl_exec": "### perl_exec(func, [param])\n\n module: app_perl\n\nCalls a perl function *with* passing it the current SIP message. The SIP\nmessage is reflected by a Perl module that gives you access to the\ninformation in the current SIP message (Kamailio::Message).\n\nThe first parameter is the function to be called. An arbitrary string\nmay be passed as a parameter.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE and BRANCH_ROUTE.\n\n    ...\n    if (perl_exec(\"ldapalias\")) {\n        ...\n    };\n    ...\n\n",
 "autheph_proxy": "### autheph_proxy(realm)\n\n module: auth_ephemeral\n\nThis function performs proxy authentication.\n\n<div class=\"note\">\n\nThis function can only be used when the *auth* module is loaded before\nthis module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *realm* - realm is an opaque string that the user agent should present\n  to the user so that he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be an empty string \u201c\u201d. Apart from a static string, a\n  typical value is the From-URI domain (i.e., \\$fd).\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_proxy(\"$fd\")) {\n        auth_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "autheph_www": "### autheph_www(realm[, method])\n\n module: auth_ephemeral\n\nThis function performs WWW digest authentication.\n\n<div class=\"note\">\n\nThis function can only be used when the *auth* module is loaded before\nthis module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *realm* - realm is an opaque string that the user agent should present\n  to the user so that he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be an empty string \u201c\u201d. Apart from a static string, a\n  typical value is the From-URI domain (i.e., \\$fd).\n\n  The string may contain pseudo variables.\n\n- *method* - the method to be used for authentication. This parameter is\n  optional and if not set the first \"word\" on the request-line is used.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_www(\"$fd\")) {\n        auth_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "autheph_check": "### autheph_check(realm)\n\n module: auth_ephemeral\n\nThis function combines the functionalities of `autheph_www` and\n`autheph_proxy`, the first being executed if the SIP request is a\nREGISTER, the second for the rest.\n\n<div class=\"note\">\n\nThis function can only be used when the *auth* module is loaded before\nthis module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *realm* - realm is an opaque string that the user agent should present\n  to the user so that he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be an empty string \u201c\u201d. Apart from a static string, a\n  typical value is the From-URI domain (i.e., \\$fd).\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_check(\"$fd\")) {\n        auth_challenge(\"$fd\", \"1\");\n        exit;\n    }\n    ...\n\n",
 "autheph_authenticate": "### autheph_authenticate(username, password)\n\n module: auth_ephemeral\n\nThis function performs non-digest ephemeral authentication. This may be\nused when digest authentication cannot. For example, during WebSocket\nhandshake the username may be part of the requested URI and the password\npresented in a Cookie: header.\n\n<div class=\"note\">\n\nThis function may be used without loading the *auth* module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *username* - the username returned in the response from the\n  web-service.\n\n- *password* - the password returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_authenticate(\"$var(username)\", \"$var(password)\")) {\n        sl_send_reply(\"403\", \"Forbidden\");\n        exit;\n    }\n    ...\n\n",
 "autheph_check_from": "### autheph_check_from([username])\n\n module: auth_ephemeral\n\nThis function checks that the username (or username and domain) in the\nFrom: URI matches the credentials.\n\nWhen used without the *username* parameter it compares the From: URI\nwith the credentials used to authenticate the request (in the\nAuthorization: or Proxy-Authorization: headers).\n\nThe *username* parameter can be used to check the From: when individual\nSIP requests are not authenticated (for example, when they are over\nWebSockets and the connection was authenticated during the handshake).\nIn this scenario the username should be cached (perhaps in a hash-table)\nat the point the authentication occurs.\n\n<div class=\"note\">\n\nThis function must have the optional *username* parameter specified to\nuse it without loading the *auth* module before this module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *username* (optional) - the username returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_check_from()) {\n        sl_send_reply(\"403\", \"Forbidden\");\n        exit;\n    }\n    ...\n\n",
 "autheph_check_to": "### autheph_check_to([username])\n\n module: auth_ephemeral\n\nThis function checks that the username (or username and domain) in the\nTo: URI matches the credentials.\n\nWhen used without the *username* parameter it compares the To: URI with\nthe credentials used to authenticate the request (in the Authorization:\nor Proxy-Authorization: headers).\n\nThe *username* parameter can be used to check the From: when individual\nSIP requests are not authenticated (for example, when they are over\nWebSockets and the connection was authenticated during the handshake).\nIn this scenario the username should be cached (perhaps in a hash-table)\nat the point the authentication occurs.\n\n<div class=\"note\">\n\nThis function must have the optional *username* parameter specified to\nuse it without loading the *auth* module before this module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *username* (optional) - the username returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_check_to()) {\n        sl_send_reply(\"403\", \"Forbidden\");\n        exit;\n    }\n    ...\n\n",
 "autheph_check_timestamp": "### autheph_check_timestamp(username)\n\n module: auth_ephemeral\n\nThis function checks that the timestamp in the *username* parameter has\nnot expired. The *autheph\\_(check\\|proxy\\|www)* functions all do this\nautomatically, but in a scenario when individual SIP requests are not\nauthenticated (for example, when they are over WebSockets and the\nconnection was authenticated during the handshake) you may want to\nre-check for each new out-of-dialog request. In this scenario the\nusername should be cached (perhaps in a hash-table) at the point\nauthentication occurs.\n\n<div class=\"note\">\n\nThis function may be used without loading the *auth* module.\n\n</div>\n\nThe meaning of the parameters are as follows:\n\n- *username* - the username returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (!autheph_check_timestamp(\"$var(username)\")) {\n        sl_send_reply(\"403\", \"Forbidden\");\n        exit;\n    }\n    ...\n\n",
 "set_dlg_profile": "### set_dlg_profile(profile[, value])\n\n module: ims_dialog\n\nInserts the current dialog into a profile. Note that if the profile does\nnot supports values, this will be silently discarded. Also, there is no\ncheck for inserting the same dialog in the same profile for multiple\ntimes.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to be added to;\n\n- *value* (optional) - string value to define the belonging of the\n  dialog to the profile - note that the profile must support values.\n  Pseudo-variables are supported.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n    ...\n    set_dlg_profile(\"inbound_call\");\n    set_dlg_profile(\"caller\",\"$fu\");\n    ...\n                    \n\n",
 "unset_dlg_profile": "### unset_dlg_profile(profile[, value])\n\n module: ims_dialog\n\nRemoves the current dialog from a profile.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to be removed from;\n\n- *value* (optional) - string value to define the belonging of the\n  dialog to the profile - note that the profile must support values.\n  Pseudo-variables are supported.\n\nThis function can be used from BRANCH_ROUTE, REPLY_ROUTE and\nFAILURE_ROUTE.\n\n    ...\n    unset_dlg_profile(\"inbound_call\");\n    unset_dlg_profile(\"caller\",\"$fu\");\n    ...\n                    \n\n",
 "is_in_profile": "### is_in_profile(profile[, value])\n\n module: ims_dialog\n\nChecks if the current dialog belongs to a profile. If the profile\nsupports values, the check can be reinforced to take into account a\nspecific value - if the dialog was inserted into the profile for a\nspecific value. If no value is passed, only the simply belonging of the\ndialog to the profile is checked. Note that if the profile does not\nsupports values, this will be silently discarded.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to be checked against;\n\n- *value* (optional) - string value to further restrict the check.\n  Pseudo-variables are supported.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n    ...\n    if (is_in_profile(\"inbound_call\")) {\n        log(\"this request belongs to an inbound call\\n\");\n    }\n    ...\n    if (is_in_profile(\"caller\",\"XX\")) {\n        log(\"this request belongs to a call of user XX\\n\");\n    }\n    ...\n                    \n\n",
 "get_profile_size": "### get_profile_size(profile[, value], size)\n\n module: ims_dialog\n\nReturns the number of dialogs belonging to a profile. If the profile\nsupports values, the check can be reinforced to take into account a\nspecific value - how many dialogs were inserted into the profile with a\nspecific value. If no value is passed, only simply belonging of the\ndialog to the profile is checked. Note that if the profile does not\nsupports values, this will be silently discarded.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to get the size for;\n\n- *value* (optional) - string value to further restrict the check.\n  Pseudo-variables are supported;\n\n- *size* - an AVP or script variable to return the profile size in.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n    ...\n    if(get_profile_size(\"inbound_call\",\"$avp(size)\"))\n        xlog(\"currently there are $avp(size) inbound calls\\n\");\n    ...\n    if(get_profile_size(\"caller\",\"$fu\",\"$avp(size)\"))\n        xlog(\"currently, the user $fu has $avp(size) active outgoing calls\\n\");\n    ...\n                    \n\n",
 "dlg_isflagset": "### dlg_isflagset(flag)\n\n module: ims_dialog\n\nCheck if the dialog flag is set or not.\n\nMeaning of the parameters is as follows:\n\n- *flag* - index of the flag - can be pseudo-variable.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if(dlg_isflagset(\"1\"))\n    {\n        ...\n    }\n    ...\n                    \n\n",
 "dlg_setflag": "### dlg_setflag(flag)\n\n module: ims_dialog\n\nSet the dialog flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - index of the flag - can be pseudo-variable.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n    ...\n    dlg_setflag(\"1\");\n    ...\n                    \n\n",
 "dlg_resetflag": "### dlg_resetflag(flag)\n\n module: ims_dialog\n\nReset the dialog flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - index of the flag - can be pseudo-variable.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n    ...\n    dlg_resetflag(\"1\");\n    ...\n                    \n\n",
 "dlg_bye": "### dlg_bye(side)\n\n module: dialog\n\nSend BYE to parties of a dialog or - if in early stage - a CANCEL to the\nB-Party and a SIP response to the A-Party (as defined in bye_early_code\n/ bye_early_reason).\n\nMeaning of the parameters is as follows:\n\n- *side* - where to send the BYE. It can be: 'caller', 'callee', or\n  'all' (send to both sides).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    dlg_bye(\"all\");\n    ...\n\n",
 "dlg_refer": "### dlg_refer(side, address)\n\n module: ims_dialog\n\nThis function is currently not supported by the ims_dialog module. To be\nincorporated in the future.\n\n",
 "dlg_manage": "### dlg_manage()\n\n module: ims_dialog\n\nThis has been deprecated in ims_dialog. Instead set dialog flag for\ninitial INVITE and Route-parameter-callback execution for within-dialog\nrequests.\n\n",
 "dlg_bridge": "### dlg_bridge(from, to, op)\n\n module: ims_dialog\n\nThis function is currently not supported by the ims_dialog module. To be\nincorporated in the future.\n\n",
 "dlg_get": "### dlg_get(callid, ftag, ttag)\n\n module: ims_dialog\n\nSearch and set current dialog based on Call-ID, From-Tag and To-Tag\nparameters.\n\nMeaning of the parameters is as follows:\n\n- *callid* - SIP call-id.\n\n- *ftag* - SIP From tag.\n\n- *ttag* - SIP To tag.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if(dlg_get(\"abcdef\", \"123\", \"456\"))\n    {\n        dlg_bye(\"all\");\n    }\n    ...\n\n",
 "dlg_get_var": "### dlg_get_var(callid, ftag, ttag, name, dst)\n\n module: dialog\n\nGet dlg_var of another dialog value based on Call-ID, From-Tag and\nTo-Tag parameters.\n\nMeaning of the parameters is as follows:\n\n- *callid* - SIP call-id.\n\n- *ftag* - SIP From tag.\n\n- *ttag* - SIP To tag. Use \"\" value to indicate early dialog.\n\n- *name* - key name of the \\$dlg_var.\n\n- *dst* - pv to store the value of \\$dlg_var(name).\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if(dlg_get_var(\"$var(ci)\", \"$var(ft)\", \"456\", \"test\", \"$var(tmp)\"))\n    {\n        xdbg(\"$$dlg_var(test):$var(tmp)\\n\");\n    }\n    ...\n\n",
 "dlg_set_var": "### dlg_set_var(callid, ftag, ttag, name, value)\n\n module: dialog\n\nSet dlg_var of another dialog value based on Call-ID, From-Tag and\nTo-Tag parameters.\n\nMeaning of the parameters is as follows:\n\n- *callid* - SIP call-id.\n\n- *ftag* - SIP From tag.\n\n- *ttag* - SIP To tag. Use \"\" value to indicate early dialog.\n\n- *name* - key name of the \\$dlg_var.\n\n- *value* - string value to store at \\$dlg_var(name).\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n    ...\n    if(dlg_set_var(\"$var(ci)\", \"$var(ft)\", \"456\", \"test\", \"$var(tmp)\"))\n    {\n        xdbg(\"set $$dlg_var(test):$var(tmp)\\n\");\n    }\n    # you can set vars in early dialog too\n    if(dlg_set_var(\"$var(ci)\", \"$var(ft)\", \"\", \"test\", \"$var(tmp)\"))\n    {\n        xdbg(\"set $$dlg_var(test):$var(tmp)\\n\");\n    }\n    ...\n\n",
 "is_known_dlg": "### is_known_dlg()\n\n module: ims_dialog\n\nThis function is currently not supported by the ims_dialog module. To be\nincorporated in the future.\n\n",
 "dlg_set_timeout": "### dlg_set_timeout(timeout [, h_entry, h_id])\n\n module: dialog\n\nSet the dialog timeout. Dialog timeout will be updated if it was already\nset. If h_entry and h_id parameters are not provided, the dialog will be\nsearched based on (callid, fromtag, totag) of currently processed SIP\nmessage.\n\nMeaning of the parameters is as follows:\n\n- *timeout* - the interval in seconds after which the dialog will time\n  out.\n\n- *h_entry* - h_entry value of the iternal dialog identifier.\n\n- *h_id* - h_id value if the internal dialog identifier.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(dlg_set_timeout(\"180\", \"123\", \"456\"))\n    {\n        ...\n    }\n    ...\n\n",
 "dlg_set_timeout_by_profile": "### dlg_set_timeout_by_profile(profile, [value], timeout)\n\n module: dialog\n\nLike *dlg_set_timeout()*, but simultaneously sets the timeout of all\ndialogs in a given profile. Can be constrained by profile value.\n\nMeaning of the parameters is as follows:\n\n- *profile* - The dialog profile across which to apply the timeout.\n\n  *value* (optional) - The profile value to use when applying the dialog\n  timeout.\n\n  *timeout* - the interval in seconds after which the dialog will time\n  out.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # All dialogs belonging to user abc123 (tracked via set_dlg_profile())\n    # will be timed out in 3 seconds.\n\n    dlg_set_timeout_by_profile(\"users\", \"abc123\", \"3\");\n    ...\n\n",
 "dlg_set_property": "### dlg_set_property(attr)\n\n module: dialog\n\nSet a dialog property - an attribute that enable/disable various\nbehaviours (e.g., sending keep alive requests).\n\nMeaning of the parameters is as follows:\n\n- *attr* - name of property. It can be:\n\n  - 'ka-src' - send keep alive OPTION requests to caller\n  - 'ka-dst' - send keep alive OPTION requests to callee\n  - 'timeout-noreset' - don't reset timeout on in-dialog messages\n    reception\n\nIf keep alive is enabled for a dialog, the module will send SIP OPTIONS\nrequests with CSeq lower or equal than last request within dialog, with\nthe scope of detecting if the destination is still in the call. If the\nkeep alive request results in a local timeout or '481 Call\nLeg/Transaction Does Not Exist', then the dialog is ended from the\nserver.\n\nIf 'timeout-noreset' is set, dialog timeout won't be reset upon\nreception of in-dialog messages (default behavior).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    dlg_set_property(\"ka-src\");\n    dlg_set_property(\"ka-dst\");\n    dlg_set_property(\"timeout-noreset\");\n    ...\n\n",
 "dlg_remote_profile": "### dlg_remote_profile(cmd, profile, value, uid, expires)\n\n module: dialog\n\nManage remote profile via config file. A remote profile item is\nconsidered when the dialog is not managed by this server instance. The\nnotification to add/remove can be received via SIP or a RPC command, the\noperation can be then triggered from configuration file. This should\nallow counting active dialogs in a profile that are managed by multiple\nSIP server instances.\n\nMeaning of the parameters is as follows:\n\n- *cmd* - the operations to do: add - add an item in profile; rm -\n  remove an item from profile\n\n- *profile* - name of profile\n\n- *value* - value for profile (if no value is needed for that profile,\n  use an empty string.\n\n- *expires* - absolute time (unix timestamp) when this profile item\n  should be removed automatically (time based), if still in the profile\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(exp) = 3600 + $Ts;\n    dlg_remote_profile(\"add\", \"caller\", \"test\", \"$sruid\", \"$var(exp)\");\n    ...\n\n",
 "dlg_set_ruri": "### dlg_set_ruri()\n\n module: dialog\n\nThis function sets the R-URI with the corresponding endpoint address\nstored in dialog structure (i.e., its Contact field).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(has_totag() and is_present_hf(\"Route\") and uri==myself ) {\n        if(dlg_set_ruri()) {\n            xlog(\"Request URI changed from [$ou] to dlg value: [$ru]\\n\");\n        }\n    }\n    ...\n\n",
 "dlg_db_load_callid": "### dlg_db_load_callid(cival)\n\n module: dialog\n\nLoad dialog record from database matching on Call-Id provided as\nparameter.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(has_totag()) {\n        if(!is_known_dlg()) {\n            dlg_db_load_callid(\"$ci\");\n            if(!is_known_dlg()) {\n                xlog(\"no dialog found with callid: $ci\\n\");\n            }\n        }\n    }\n    ...\n\n",
 "dlg_db_load_extra": "### dlg_db_load_extra()\n\n module: dialog\n\nLoad all dialog records from database that are not in memory of the\ncurrent Kamailio instance.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(has_totag()) {\n        if(!is_known_dlg()) {\n            dlg_db_load_extra();\n            if(!is_known_dlg()) {\n                xlog(\"no dialog found with callid: $ci\\n\");\n            }\n        }\n    }\n    ...\n\n",
 "dlg_reset_property": "### dlg_reset_property(attr)\n\n module: dialog\n\nReset a dialog property - an attribute that enable/disable various\nbehaviours (e.g., sending keep alive requests).\n\nMeaning of the parameters is as follows:\n\n- *attr* - name of property. It can be:\n\n  - 'ka-src' - send keep alive OPTION requests to caller\n  - 'ka-dst' - send keep alive OPTION requests to callee\n  - 'timeout-noreset' - don't reset timeout on in-dialog messages\n    reception\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    dlg_reset_property(\"ka-src\");\n    dlg_reset_property(\"ka-dst\");\n    dlg_reset_property(\"timeout-noreset\");\n    ...\n\n",
 "dlg_req_within": "### dlg_req_within(side, method, [headers], [content_type, content])\n\n module: dialog\n\nSends an in-dialog SIP Request with method to a party of a dialog\nindicated by the side parameter.\n\nMeaning of the parameters is as follows:\n\n- *side* - where to send the request. It can be: 'caller', 'callee', or\n  'all' (send to both sides).\n\n- *method* - Method of the request\n\n- *headers* (optional) - additional headers to be added to the request.\n\n- *content_type* (optional) - Content-Type of the request body - will be\n  added as Content-Type Header.\n\n- *content* (optional) - Content to be sent as body.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        # Send a simple request:\n        dlg_req_within(\"all\", \"OPTIONS\");\n    ...\n        # Send a simple request with extra headers:\n        dlg_req_within(\"caller\", \"OPTIONS\", \"X-Info: Bandwidth granted\\r\\nX-Info-2: Go ahead\\r\\n\");\n    ...\n        # Send a simple request with body:\n        dlg_req_within(\"caller\", \"UPDATE\", \"application/sdp\", \"...some SDP...\");\n    ...\n        # Send a simple request with extra headers and body:\n        dlg_req_within(\"callee\", \"INFO\", \"X-Info: Bandwidth granted\\r\\n\", \"application/sdp\", \"...some SDP...\");\n    ...\n            \n\n",
 "sanity_check": "### sanity_check([msg_checks [, uri_checks]])\n\n module: sanity\n\nThis function makes a row of sanity checks over the given SIP request.\nThe behavior of the function is also controlled by `autodrop` parameter.\nIf autodrop=0, the function returns false (-1) if one of the checks\nfailed. When autodrop=1, the function stops the execution of\nconfiguration file. In both cases, if one of the checks fails the module\nsends a precise error reply via SL `send_reply()`. Thus there is no need\nto reply with a generic error message.\n\nThe parameters can be static integers or variables holding integer\nvalues.\n\n    ...\n    if (!sanity_check()) {\n        exit;\n    }\n    ...\n\n            \n\nOptionally the function takes an integer argument which overwrites the\nglobal module parameter `default_checks`. This makes it possible to run\ncertain tests from script regions. The integer value is again the sum of\nthe checks (like for the module parameter) which should be executed at\nthis function call.\n\n    ...\n    if (method==\"REGISTER\" && !sanity_check(\"256\")) {\n        /* the register contains an invalid expires value and is replied with a 400 */\n        exit;\n    }\n    ...\n\n            \n\nOptionally the function takes a second integer argument which overwrites\nthe global module parameter uri_checks and thus determines which URIs\nwill be checked if the parse uri test will be executed.\n\n    ...\n    if (method==\"INVITE\" && !sanity_check(\"1024\", \"6\")) {\n        /* the INVITE contains an invalid From or To header and is replied with a 400 */\n        exit;\n    }\n    ...\n\n            \n\n",
 "sanity_reply": "### sanity_reply()\n\n module: sanity\n\nSend a SIP reply using the code and reason text set internally by the\nmodule when detecting errors while performing the sanity checks. It is\ndone only when parameter noreply is set to 1.\n\n    ...\n    if(!sanity_check(\"1024\", \"6\")) {\n       xdbg(\"sanity checks failed\\n\");\n       sanity_reply();\n       exit;\n    }\n    ...\n            \n",
 "lwsc_notify": "### lwsc_notify(wsurl, data)\n\n module: lwsc\n\nSend data via websockets to the address specified by wsurl. No response\nis expected. Transmission is not guaranteed (e.g., cannot connect to\ntarget).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        jwt_notify(\"ws://10.1.1.10:8080/log\",\n            \"caller=$fU;callee=$tU;callid=$ci\");\n    ...\n\n",
 "lwsc_notify_proto": "### lwsc_notify_proto(wsurl, wsproto, data)\n\n module: lwsc\n\nSend data via websockets to the address specified by wsurl, providing\nwebsocket protocol. No response is expected. Transmission is not\nguaranteed (e.g., cannot connect to target).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- wsproto - websocket protocol\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        jwt_notify_proto(\"ws://10.1.1.10:8080/log\", \"kmsg\"\n            \"caller=$fU;callee=$tU;callid=$ci\");\n    ...\n\n",
 "lwsc_request": "### lwsc_request(wsurl, data)\n\n module: lwsc\n\nSend data via websockets to the address specified by wsurl, a response\nis expected and made available in \\$lwsc(rdata).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        jwt_request(\"ws://10.1.1.10:8080/log\",\n            \"caller=$fU;callee=$tU;srcip=$si\");\n    ...\n\n",
 "lwsc_request_proto": "### lwsc_request_proto(wsurl, wsproto, data)\n\n module: lwsc\n\nSend data via websockets to the address specified by wsurl, providing\nwebsocket protocol. A response is expected and made available in\n\\$lwsc(rdata).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- wsproto - websocket protocol\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        jwt_request_proto(\"ws://10.1.1.10:8080/log\", \"kmsg\",\n            \"caller=$fU;callee=$tU;srcip=$si\");\n    ...\n\n",
 "ccr_result": "### ccr_result(resultcode, grantedunits, finalunit)\n\n module: ims_ocs\n\nThis method sets the response code of the Diameter Request.\n\nMeaning of the parameters is as follows:\n\n- *resultcode* - the Diameter Response code for the request. Typical\n  response codes are:\n\n  - \u201c2001\u201d - Ok\n\n  - \u201c5030\u201d - User unknown\n\n  - \u201c5031\u201d - Rating failed\n\n  - \u201c4010\u201d - End-User Service denied (e.g. Service blocked)\n\n  - \u201c5006\u201d - Resources exceeded (e.g. too many concurrent calls)\n\n- *grantedunits* - the number of granted units for this particular user\n\n- *finalunit* - indication, that all following requests will be denied\n  (this is the final unit for the session)\n\nThis function can be used from the event route.\n\n    ...\n    ccr_result(\"2001\", \"600\", \"0\");\n    ...\n    $var(result) = 2001;\n    $var(granted) = $hdr(P-Requested-Units);\n    $var(final) = 0;\n    ccr_result(\"$var(result)\", \"$var(granted)\", \"$var(final)\");\n    ...\n    ccr_result(\"2001\", \"$hdr(P-Requested-Units)\", \"0\");\n    ...\n\n",
 "mt_mem_alloc": "### mt_mem_alloc(size)\n\n module: misctest\n\nAllocates size bytes.\n\n<div class=\"note\">\n\nThis is a debugging function for simulating memory leaks or stressing\nthe memory allocator. It should not be used in production setups\n\n</div>\n\n    ...\n    mem_alloc(1048576); # 1MB\n    ...\n                \n\n",
 "mt_mem_free": "### mt_mem_free()\n\n module: misctest\n\nFrees all the memory allocated with mem_alloc() up to this point.\n\n<div class=\"note\">\n\nThis is a debugging function for simulating memory leaks or stressing\nthe memory allocator. It should not be used in production setups\n\n</div>\n\n    ...\n    mem_free();\n    ...\n                \n\n",
 "pvh_collect_headers": "### pvh_collect_headers()\n\n module: pv_headers\n\nCollects all headers from the message into the XAVP. It should be used\npreferably just when the SIP message is received by Kamailio.\n\nThis function can be used from ANY_ROUTE.\n\n",
 "pvh_apply_headers": "### pvh_apply_headers()\n\n module: pv_headers\n\nApplies the current XAVP headers state to the real headers. Should be\ncalled only once per branch when the message is about to leave Kamailio.\n\nThe following rules apply:\n\n- all headers in the XAVP except for ones provided in the\n  skip_headers\n  parameter and From/To are recreated in the\n  SIP\n  message.\n- From/To headers are processed by the uac module if it is loaded.\n- From/To headers are not changed in the reply messages.\n- headers with NULL value are removed if exist in the\n  SIP\n  message.\n- the initial order of the\n  SIP\n  headers is preserved.\n\nThis function can be used from ANY_ROUTE.\n\n",
 "pvh_reset_headers": "### pvh_reset_headers()\n\n module: pv_headers\n\nCollects all headers from the message into the XAVP. It should be used\npreferably just when the SIP message is received by \\>Kamailio.\n\nThis function can be used from ANY_ROUTE.\n\n",
 "pvh_check_header": "### pvh_check_header(hname)\n\n module: pv_headers\n\nChecks if the header \u201chname\u201d already exists in the XAVP.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n\n",
 "pvh_append_header": "### pvh_append_header(hname, hvalue)\n\n module: pv_headers\n\nAppends a new header \u201chname\u201d with the value \u201chvalue\u201d into the XAVP.\nPlease note that subsequent \"pv_append_header\" calls will result in\nmultiple headers.\n\nIf the provided \u201chvalue\u201d is \\$null then the header is added into the\nXAVP but it is not going to be added into the message.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n\n",
 "pvh_modify_header": "### pvh_modify_header(hname, hvalue, [idx])\n\n module: pv_headers\n\nModifies an existing header in the XAVP \u201chname\u201d with the value \u201chvalue\u201d\ninto the XAVP. Index order is top to bottom. Please note that subsequent\n[pvh_append_header](#) calls will result in multiple headers.\n\nPlease note that if the header \u201chname\u201ddoes not exist it will be\nexplicitly appended. If there are multiple headers with the same name\nand \u201cidx\u201d is omitted, only the first one will be affected.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n\n",
 "pvh_remove_header": "### pvh_remove_header(hname, [idx])\n\n module: pv_headers\n\nRemoves an existing header \u201chname\u201d from the XAVP. Index order is top to\nbottom.\n\nIf there are multiple headers with the same name and \u201cidx\u201d is omitted,\nall of them will be removed.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n\n",
 "pvh_value_exists": "### pvh_value_exists(hname, hparameter)\n\n module: pv_headers\n\nChecks if the parameter \u201chparameter\u201d is present in the header \u201chname\u201d\nfrom XAVP.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) have been called or with \u201cauto_msg\u201d parameter\nenabled.\n\n",
 "pvh_remove_header_param": "### pvh_remove_header_param(hname, hparameter)\n\n module: pv_headers\n\nRemoves an existing parameter \u201chparameter\u201d in the header \u201chname\u201d from\nthe XAVP.\n\nIf there are multiple headers, only the one containing the parameter\nwill be modified.\n\nThe parameter can be located in any position (beginning, middle or end)\nof the list of parameters.\n\nIf the parameter is the only one present, the header will be removed.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) have been called or with \u201cauto_msg\u201d parameter\nenabled.\n\n",
 "rl_check": "### rl_check([pvar])\n\n module: ratelimit\n\nCheck the current request against the matched ratelimit algorithm. If no\nparameter is provided, the queue will be matched based on method type,\nand then the pipe will be identified based on the matched queue. If a\npipe number is provided as a parameter, then the given pipe number will\nbe used for identifying the ratelimit algorithm. The pipe number must be\nprovided as number or via a pseudovariable.\n\nThe method will return an error code if the limit for the matched\nalgorithm is reached.\n\nMeaning of the parameters is as follows:\n\n- *pvar* - the pseudovariable holding the pipe id to be used by\n  ratelimit.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        # perform queue/pipe match for current method\n        if (!rl_check()) {\n            append_to_reply(\"Retry-After: 5\\r\\n\");\n            sl_send_reply(\"503\",\"Limiting\");\n            exit;\n        }\n    ...\n        # use pipe no 1 for the current method\n        # set int pvar to 1\n        $var(p) = 1;\n        if (!rl_check(\"$var(p)\")) {\n            append_to_reply(\"Retry-After: 5\\r\\n\");\n            sl_send_reply(\"503\",\"Limiting\");\n            exit;\n        }\n    ...\n\n",
 "rl_check_pipe": "### rl_check_pipe(pipe_no)\n\n module: ratelimit\n\nCheck the current request against the matched ratelimit algorithm of the\npipe provided as parameter. The parameter can be provided as number or\nvariable.\n\nThe method will return an error code if the limit for the matched\nalgorithm is reached.\n\nMeaning of the parameters is as follows:\n\n- *pipe_no* - the pipe id to be used by ratelimit.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        # use pipe no 1 for the current method\n        if (!rl_check_pipe(\"1\") {\n            append_to_reply(\"Retry-After: 5\\r\\n\");\n            sl_send_reply(\"503\",\"Limiting\");\n            exit;\n        }\n    ...\n\n",
 "prefix_route": "### prefix_route([user])\n\n module: prefix_route\n\nThis function tries to find a route from the user part of the request\nURI (if no parameter is provided), or from the value of the parameter.\nThe parameter can contain config variables.\n\nIf a route is found, it will be used for further processing. Otherwise\nthe function will return false.\n\n    ...\n      if (!prefix_route()) {\n          xlog(\"L_ERR\", \"prefix_route(): no matching routes\\n\");\n      }\n    ...\n      if (!prefix_route(\"$fU\")) {\n          xlog(\"L_ERR\", \"prefix_route(): no matching routes\\n\");\n      }\n\n    ...\n                \n\n",
 "sdp_mangle_ip": "### sdp_mangle_ip(pattern, newip)\n\n module: mangler\n\nChanges IP addresses inside SDP document in lines describing connections\nlike c=IN IP4 . Currently this function only changes IP4 addresses since\nIP6 probably will not need to traverse NAT :)\n\nThe function returns negative on error, or number of replacements + 1.\n\nMeaning of the parameters is as follows:\n\n- *pattern* - An IP address/mask pair used to match IP's located inside\n  SDP package in lines c=IN IP4 ip. This line will only be changed if\n  located IP is in the network described by this pattern. Examples of\n  valid patterns are \"10.0.0.0/255.0.0.0\" or \"10.0.0.0/8\" etc.\n\n- *newip* - A string representing the new IP to be put inside SDP\n  package if old IP address matches pattern.\n\n<!-- -->\n\n    ...\n    sdp_mangle_ip(\"10.0.0.0/8\",\"193.175.135.38\");\n    ...\n            \n\n",
 "sdp_mangle_port": "### sdp_mangle_port(offset)\n\n module: mangler\n\nChanges ports in SDP document in lines starting a media section like\n\"m=audio 13451\".\n\nThe function returns negative on error, or number of replacements + 1.\n\nMeaning of the parameters is as follows:\n\n- *offset* - A string representing an integer which will be\n  added/subtracted from the located port.\n\n<!-- -->\n\n    ...\n    sdp_mangle_port(\"-12000\");\n    ...\n            \n\n",
 "encode_contact": "### encode_contact(encoding_prefix, hostpart)\n\n module: siputils\n\nThis function will encode uri-s inside Contact header in the following\nmanner sip:username:password@ip:port;transport=protocol goes\nsip:encoding_prefix\\*username\\*password\\*ip\\*port\\*protocol@hostpart.\n\n\\* is the default separator and can be changed by setting the\ncontact_flds_separator module parameter.\n\nNote: This function discards all of the URI parameters. Thus, none of\nthe parameters (except the transport parameter which is encoded into the\nuserpart) can be restored.\n\nThe function returns negative on error, 1 on success.\n\nMeaning of the parameters is as follows:\n\n- *encoding_prefix* - Something to allow us to determine that a contact\n  is encoded.\n\n- *hostpart* - An IP address or a hostname.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    if (src_ip == 10.0.0.0/8) encode_contact(\"natted_client\",\"1.2.3.4\");\n    ...\n\n",
 "decode_contact": "### decode_contact()\n\n module: siputils\n\nThis function will decode the request URI. If the RURI is in the format\nsip:encoding_prefix\\*username\\*password\\*ip\\*port\\*protocol@hostpart it\nwill be decoded to sip:username:password@ip:port;transport=protocol. It\nuses the default set parameter for contact encoding separator.\n\nThe function returns negative on error, 1 on success.\n\nMeaning of the parameters is as follows:\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (uri =~ \"^sip:natted_client\") { decode_contact(); }\n    ...\n\n",
 "decode_contact_header": "### decode_contact_header()\n\n module: siputils\n\nThis function will decode URIs inside Contact header. If the URI in the\nformat sip:encoding_prefix\\*username\\*ip\\*port\\*protocol@hostpart it\nwill be decoded to sip:username:password@ip:port;transport=protocol. It\nuses the default set parameter for contact encoding separator.\n\nThe function returns negative on error, 1 on success.\n\nMeaning of the parameters is as follows:\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    reply_route[2] {\n        ...\n        decode_contact_header();\n        ...\n    }\n    ...\n\n",
 "pcscf_save": "### pcscf_save(domain)\n\n module: ims_registrar_pcscf\n\nThe function processes a reply to a *REGISTER* message. It can add,\nremove or modify location records (in usrloc) depending on Contact and\nExpires HFs in the REGISTER message.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n<!-- -->\n\n    ...\n    pcscf_save(\"location\");\n    ...\n\n",
 "pcscf_save_pending": "### pcscf_save_pending(domain)\n\n module: ims_registrar_pcscf\n\nSame as pcscf_save(), but it will store the registration in a \"Pending\"\nstate.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\nThe return code may have the following values:\n\n- *( 1)* OK\n\n- *(-1)* Parsing of contact data failed\n\n- *(-2)* Deregistration in progress\n\nFor db_mode = DB_ONLY (3) setting for ims_usrloc_pcscf module modparam\nfollowing logic is implemented:\n\n- To avoid race time conditions between a REREGISTER and the expiry\n  handler state machine in the scscf an approach is chosen to refuse a\n  REREGISTER in time window of 20 seconds after pcontact expiry on the\n  pcscf (thus allowing expiry handling to finish). REREGISTER is refused\n  in this scenario with return code -2.\n\n- In case a REREGISTER arrives at pcscf and the respective pcontact is\n  expired longer than time window of 20 seconds registration also is\n  refused with return code -2 and additionaly PUBLISH is sent to scscf\n  with expiry = 0.\n\n- The rc -2 shall be handled in register.cfg script as follows:\n\n  pcscf_save_pending(\"location\");\n\n  switch (\\$retcode) {\n\n  case -1:\n\n  .......\n\n  case -2:\n\n  send_reply(\"500\", \"Deregister in progress - Please try again\");\n\n  exit;\n\n  break;\n\n  }\n\n",
 "pcscf_follows_service_routes": "### pcscf_follows_service_routes(domain)\n\n module: ims_registrar_pcscf\n\nReturns true, if the request is following the \"learned\" service-routes\nduring registration.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n",
 "pcscf_force_service_routes": "### pcscf_force_service_routes(domain)\n\n module: ims_registrar_pcscf\n\nRemove existing route-headers and force the Service-Routes, that were\nlearned during registration.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n",
 "pcscf_is_registered": "### pcscf_is_registered(domain)\n\n module: ims_registrar_pcscf\n\nReturns true, if the request is coming from a \"registered\" endpoint.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n",
 "handle_publish": "### handle_publish([sender_uri])\n\n module: presence\n\nHandles PUBLISH requests by storing and updating published information\nin memory cache and database, then calls functions to send NOTIFY\nmessages when changes in the published information occur. It takes one\nargument -\\> sender_uri. The parameter was added for enabling BLA\nimplementation. If present, notification of a change in published state\nis not sent to the respective uri even though a subscription exists. It\nshould be taken from the Sender header. It was left at the decision of\nthe administrator whether or not to transmit the content of this header\nas parameter for handle_publish, to prevent security problems.\n\nThis function can be used from REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - if success*.\n\n- *-1 - if error*.\n\nThe module sends an appropriate stateless reply in all cases.\n\n    ...\n        if(is_method(\"PUBLISH\"))\n        {\n            if($hdr(Sender)!= NULL)\n                handle_publish(\"$hdr(Sender)\");\n            else\n                handle_publish();\n            t_release();\n        }\n    ...\n\n",
 "handle_subscribe": "### handle_subscribe([watcher_uri])\n\n module: presence\n\nThe function which handles SUBSCRIBE requests. It stores or updates\ninformation in memory and database and calls functions to send NOTIFY\nmessages when a SUBSCRIBE which initiate a dialog is received.\n\nBy default this function uses the From: URI from the SUBSCRIBE request\nas the Watcher URI. The optional watcher_uri parameter can be used to\nspecify a different Watcher URI, possibly taken from a SIP header like\nP-Asserted-Identity:.\n\nThis function can be used from REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - if success*.\n\n- *-1 - if error*.\n\nThe module sends an appropriate stateless reply in all cases.\n\n    ...\n    if(method==\"SUBSCRIBE\")\n        handle_subscribe();\n    ...\n\n",
 "pres_auth_status": "### pres_auth_status(watcher_uri, presentity_uri)\n\n module: presence\n\nThe function checks if watcher URI is authorized to subscribe event\n'presence' of presentity URI. Both watcher_uri and presentity_uri can be\nstatic strings or contain pseudo variables.\n\nThe function returns ACTIVE_STATUS, if subscription is allowed, and\nPENDING_STATUS, TERMINATED_STATUS, or WAITING_STATUS otherwise. See\npresence/subscribe.h for the corresponding integer codes. In case of\nerror, function returns -1.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (method==\"MESSAGE\") {\n        pres_auth_status(\"$fu\", $ru\");\n        if ($retcode == 1) {\n            t_relay();\n        } else {\n            send_reply(\"403\", \"Forbidden\");\n        }\n    }\n    ...\n\n",
 "pres_has_subscribers": "### pres_has_subscribers(presentity_uri, event)\n\n module: presence\n\nAllows to check if presentity has any subscribers of event.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(pres_has_subscribers($var(uri), \"message-summary\"))\n        # do something...;\n    ...\n\n",
 "pres_refresh_watchers": "### pres_refresh_watchers(uri, event, type[, file_uri, filename])\n\n module: presence\n\nThe function can be used in configuration to trigger notifies to\nwatchers if a change in watchers authorization or in published state\noccurred (i.e., updates of xcap documents).\n\nParameters:\n\n- uri - the uri of the user who made the change and whose watchers\n  should be informed.\n\n- event - the event package.\n\n- type - it distinguishes between the three different types of events\n  that can trigger the refresh, depending on its value:\n\n  - 0 - a change in watchers authentication.\n\n  - 1 - a statical update in published state through direct update in db\n    table.\n\n  - 2 - a statical update in published state by modifying the pidf\n    manipulation document.\n\n- file_uri - the uri of the pidf-manipulation file on the XCAP server\n  (only used for type 2).\n\n- filename - the name of the pidf-manipulation file on the XCAP server\n  (only used for type 2).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pres_refresh_watchers(\"sip:test@kamailio.org\", \"presence\", 1);\n    ...\n\n",
 "pres_update_watchers": "### pres_update_watchers(uri, event)\n\n module: presence\n\nThe function can be used in configuration to trigger updates to watchers\nstatus if a change in watchers authorization state occurred (i.e.,\nupdates of xcap documents change state from pending to active).\n\nParameters:\n\n- uri - the uri of the user who made the change and whose watchers\n  should be informed. Can be PV.\n\n- event - the event package (e.g., presence).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pres_update_watchers(\"sip:test@kamailio.org\", \"presence\");\n    ...\n\n",
 "set_rtpengine_set": "### set_rtpengine_set(setid[, setid])\n\n module: rtpengine\n\nSets the ID of the RTP proxy set to be used for the next\nrtpengine_delete(), rtpengine_offer(), rtpengine_answer() or\nrtpengine_manage() command. The parameter can be an integer or a config\nvariable holding an integer.\n\nA second set ID can be specified to daisy-chain two RTP proxies. The two\nset IDs must be distinct from each other and there must not be any\noverlap in the proxies present in both sets. In this use case, the\nrequest (offer, answer, etc) is first sent to an RTP proxy from the\nfirst set, which rewrites the SDP body and sends it back to the module.\nThe rewritten SDP body is then used to make another request to an RTP\nproxy from the second set, which rewrites the SDP body another time and\nsends it back to the module to be placed back into the SIP message. This\nis useful if you have a set of RTP proxies that the caller must use, and\nanother distinct set of RTP proxies that the callee must use. This is\nsupported by all rtpengine commands except rtpengine_manage().\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    set_rtpengine_set(\"2\");\n    rtpengine_offer();\n    ...\n\n",
 "rtpengine_offer": "### rtpengine_offer([flags])\n\n module: rtpengine\n\nRewrites SDP body to ensure that media is passed through an RTP proxy.\nTo be invoked on INVITE for the cases the SDP bodies are in INVITE and\n200 OK and on 200 OK when SDP bodies are in 200 OK and ACK.\n\nThe function will return true on success and false (-1) on various\nfailures, like using rtp_engine_offer() on a SIP MESSAGE request or\ncommunication with rtpengine fails.\n\nMeaning of the parameters is as follows:\n\n- *flags* - flags to turn on some features.\n\n  The \u201cflags\u201d string is a list of space-separated items. Each item is\n  either an individual token, or a token in \u201ckey=value\u201d format. The\n  possible tokens are described below.\n\n  - *via-branch=...* - Include the \u201cbranch\u201d value of one of the \u201cVia\u201d\n    headers in the request to the RTP proxy. Possible values are: \u201c1\u201d -\n    use the first \u201cVia\u201d header; \u201c2\u201d - use the second \u201cVia\u201d header;\n    \u201cauto\u201d - use the first \u201cVia\u201d header if this is a request, or the\n    second one if this is a reply; \u201cextra\u201d - don't take the value from a\n    header, but instead use the value of the \u201cextra_id_pv\u201d variable;\n    \u201cnext\u201d - use the branch ID generated by Kamailio for the next\n    outgoing branch; \u201cauto-next\u201d - use \u201cnext\u201d in requests and \u201c1\u201d in\n    replies; \u201cauto-extra\u201d - use \u201cextra\u201d in requests and \u201c1\u201d in replies.\n    This can be used to create one media session per branch on the RTP\n    proxy. When sending a subsequent \u201cdelete\u201d command to the RTP proxy,\n    you can then stop just the session for a specific branch when\n    passing the flag '1' or '2' in the \u201crtpengine_delete\u201d, or stop all\n    sessions for a call when not passing one of those two flags there.\n    This is especially useful if you have serially forked call scenarios\n    where the RTP proxy gets an \u201coffer\u201d command for a new branch, and\n    then a \u201cdelete\u201d command for the previous branch, which would\n    otherwise delete the full call, breaking the subsequent \u201canswer\u201d for\n    the new branch. *This flag is only supported by the Sipwise\n    rtpengine RTP proxy at the moment!*\n\n  - *asymmetric* - flags that UA from which message is received doesn't\n    support symmetric RTP. Disables learning of endpoint addresses in\n    the Sipwise rtpengine proxy.\n\n  - *no-redis-update* - this flag can be used by Kamailio in order to\n    tell rtpengine not to persist the call into Redis upon receiving\n    offer/answer() control commands. If flag is not set, default action\n    is rtpengine persists call to redis.\n\n  - *force-answer* - force \u201canswer\u201d, that is, only rewrite SDP when\n    corresponding session already exists in the RTP proxy. By default is\n    on when the session is to be completed. This is only necessary when\n    the offer was sent by `rtpengine_offer()`, and the answer is handled\n    by `rtpengine_manage()`.\n\n  - *direction=...* - this option specifies a logical network interface\n    and should be given exactly twice. It enables RTP bridging between\n    different addresses or networks of the same family (e.g. IPv4 to\n    IPv4). The first instance of the option specifies the interface that\n    the originator of this message should be using, while the second\n    instance specifies the interface that the target should be using.\n    For example, if the SIP message was sent by an endpoint on a private\n    network and will be sent to an endpoint on the public internet, you\n    would use \u201cdirection=priv direction=pub\u201d if those two logical\n    network interfaces were called \u201cpriv\u201d and \u201cpub\u201d in your RTP proxy's\n    configuration respectively. The direction must only be specified in\n    for initial SDP offer; answers or subsequent offers can omit this\n    option.\n\n  - *internal, external* - shorthand for \u201cdirection=internal\u201d and\n    \u201cdirection=external\u201d respectively. Useful for brevity or as legacy\n    option if the RTP proxy only supports two network interfaces instead\n    of multiple, arbitrarily named ones.\n\n  - *address-family=...* - instructs the RTP proxy that the recipient of\n    this SDP body expects to see addresses of a particular family.\n    Possible values are \u201cIP4\u201d and \u201cIP6\u201d. For example, if the SDP body\n    contains IPv4 addresses but the recipient only speaks IPv6, you\n    would use \u201caddress-family=IP6\u201d to bridge between the two address\n    families.\n\n    Sipwise rtpengine remembers the address family preference of each\n    party after it has seen an SDP body from them. This means that\n    normally it is only necessary to explicitly specify the address\n    family in the \u201coffer\u201d, but not in the \u201canswer\u201d.\n\n    Note: Please note, that this will only work properly with\n    non-dual-stack user-agents or with dual-stack clients according to\n    RFC6157 (which suggest ICE for Dual-Stack implementations). This\n    short-cut will not work properly with RFC4091 (ANAT) compatible\n    clients, which suggests having different m-lines with different\n    IP-protocols grouped together.\n\n  - *force* - instructs the RTP proxy to ignore marks inserted by\n    another RTP proxy in transit to indicate that the session already\n    goes through another proxy. Allows creating a chain of proxies. Not\n    supported and ignored by Sipwise rtpengine.\n\n  - *trust-address* - flags that IP address in SDP should be trusted.\n    Starting with rtpengine 3.8, this is the default behaviour. In older\n    versions, without this flag the RTP proxy ignores the address in the\n    SDP and uses source address of the SIP message as media address\n    which is passed to the RTP proxy.\n\n  - *SIP-source-address* - the opposite of *trust-address*. Restores the\n    old default behaviour of ignoring endpoint addresses in the SDP\n    body.\n\n  - *received-from=IP* - Configure the SIP-source-address IP explicitly,\n    which will be useful when two kamailio is cascaded where first\n    kamailio is handling NAT and second kamailio RTPEngine.\n\n  - *replace-origin* - flags that IP from the origin description (o=)\n    should be also changed.\n\n  - *replace-session-connection* - flags to change the session-level SDP\n    connection (c=) IP if media description also includes connection\n    information.\n\n  - *symmetric* - flags that for the UA from which message is received,\n    support symmetric RTP must be forced. Does nothing with the Sipwise\n    rtpengine proxy as it is the default.\n\n  - *repacketize=NN* - requests the RTP proxy to perform\n    re-packetization of RTP traffic coming from the UA which has sent\n    the current message to increase or decrease payload size per each\n    RTP packet forwarded if possible. The NN is the target payload size\n    in ms, for the most codecs its value should be in 10ms increments,\n    however for some codecs the increment could differ (e.g. 30ms for\n    GSM or 20ms for G.723). The RTP proxy would select the closest value\n    supported by the codec. This feature could be used for significantly\n    reducing bandwith overhead for low bitrate codecs, for example with\n    G.729 going from 10ms to 100ms saves two thirds of the network\n    bandwith. Not supported by Sipwise rtpengine.\n\n  - *ICE=...* - controls the RTP proxy's behaviour regarding ICE\n    attributes within the SDP body. Possible values are: \u201cforce\u201d -\n    discard any ICE attributes already present in the SDP body and then\n    generate and insert new ICE data, leaving itself as the *only* ICE\n    candidates; \u201cforce-relay\u201d - discard any \u201crelay\u201d type ICE attributes\n    already present in the SDP body and then generate and insert itself\n    as the *only* ICE \u201crelay\u201d candidates; \u201cremove\u201d instructs the RTP\n    proxy to discard any ICE attributes and not insert any new ones into\n    the SDP. The default (if no \u201cICE=...\u201d is given at all), new ICE data\n    will only be generated if no ICE was present in the SDP originally;\n    otherwise the RTP proxy will only insert itself as *additional* ICE\n    candidate. Other SDP substitutions (c=, m=, etc) are unaffected by\n    this flag.\n\n  - *RTP, SRTP, DTLS, AVP, AVPF* - These flags control the RTP transport\n    protocol that should be used towards the recipient of the SDP. If\n    none of them are specified, the protocol given in the SDP is left\n    untouched. Otherwise, the \u201cSRTP\u201d flag indicates that SRTP should be\n    used, while \u201cRTP\u201d indicates that both SRTP and AVPF should not be\n    used. \u201cAVPF\u201d indicates that the advanced RTCP profile with feedback\n    messages should be used, and \u201cAVP\u201d indicates that the regular RTCP\n    profile should be used. See also the next set of flags below.\n\n  - *RTP/AVP, RTP/SAVP, UDP/TLS/RTP/SAVP, RTP/AVPF, RTP/SAVPF,\n    UDP/TLS/RTP/SAVPF* - these serve as an alternative, more explicit\n    way to select between the different RTP protocols and profiles\n    supported by the RTP proxy. For example, giving the flag \u201cRTP/SAVPF\u201d\n    has the same effect as giving the two flags \u201cSRTP AVPF\u201d.\n\n  - *to-tag* - force inclusion of the \u201cTo\u201d tag. Normally, the \u201cTo\u201d tag\n    is always included when present, except for \u201cdelete\u201d messages.\n    Including the \u201cTo\u201d tag in a \u201cdelete\u201d messages allows you to be more\n    selective about which dialogues within a call are being torn down.\n\n  - *to-tag=...* - use the specified string as \u201cTo\u201d tag instead of the\n    actual \u201cTo\u201d tag from the SIP message, and force inclusion of the tag\n    in the message as per above.\n\n  - *from-tag=...* - use the specified string as \u201cFrom\u201d tag instead of\n    the actual \u201cFrom\u201d tag from the SIP message.\n\n  - *call-id=...* - use the specified string as \u201cCall-ID\u201d instead of the\n    actual \u201cCall-ID\u201d from the SIP message.\n\n  - *rtcp-mux-demux* - if rtcp-mux (RFC 5761) was offered, make the RTP\n    proxy accept the offer, but not offer it to the recipient of this\n    message.\n\n  - *rtcp-mux-reject* - if rtcp-mux was offered, make the RTP proxy\n    reject the offer, but still offer it to the recipient. Can be\n    combined with \u201crtcp-mux-offer\u201d to always offer it.\n\n  - *rtcp-mux-offer* - make the RTP proxy offer rtcp-mux to the\n    recipient of this message, regardless of whether it was offered\n    originally or not.\n\n  - *rtcp-mux-accept* - if rtcp-mux was offered, make the RTP proxy\n    accept the offer and also offer it to the recipient of this message.\n    Can be combined with \u201crtcp-mux-offer\u201d to always offer it.\n\n  - *media-address=...* - force a particular media address to be used in\n    the SDP body. Address family is detected automatically.\n\n  - *TOS=...* - change the IP TOS value for all outgoing RTP packets\n    within the entire call in both directions. Only honoured in an\n    \u201coffer\u201d, ignored for an \u201canswer\u201d. Valid values are 0 through 255,\n    given in decimal. If this option is not specified, the TOS value\n    will revert to the default TOS (normally 184). A value of -1 may be\n    used to leave the currently used TOS unchanged.\n\n  - *delete-delay=...* - override the default delay (in seconds) before\n    a call is actually deleted from memory. Can be set to zero to\n    effectuate immediate deletion. This option only makes sense for\n    *delete* operations.\n\n  - *strict-source* - instructs the RTP proxy to check the source\n    addresses of all incoming RTP packets and drop the packets if the\n    address doesn't match.\n\n  - *media-handover* - the antithesis of *strict-source*. Instructs the\n    RTP proxy not only to accept mismatching RTP source addresses (as it\n    normally would), but also to accept them as the new endpoint address\n    of the opposite media flow. Not recommended as it allows media\n    streams to be hijacked by an attacker.\n\n  - *DTLS=...* - influence the behaviour of DTLS-SRTP. Possible values\n    are \u201cno\u201d or \u201coff\u201d to suppress offering or accepting DTLS-SRTP, and\n    \u201cpassive\u201d to prefer participating in DTLS-SRTP in a passive role.\n\n  - *SDES-off* - don't offer SDES when it normally would. In an SRTP\n    context, this leaves DTLS-SRTP as the only other option.\n\n  - *SDES-unencrypted_srtp, SDES-unencrypted_srtcp,\n    SDES-unauthenticated_srtp* - these directly reflect the SDES session\n    parameters from RFC 4568 and will make the RTP proxy offer these\n    parameters when offering SDES.\n\n  - *SDES-encrypted_srtp, SDES-encrypted_srtcp,\n    SDES-authenticated_srtp* - the opposites of the flags above. Useful\n    if accepting these parameters is not desired and they should be\n    rejected instead.\n\n  - *SDES-nonew* - don't add any new crypto suites into the offer. This\n    means, offered SDES crypto suites will be accepted, meanwhile no new\n    is going to be generated by RTPEngine. It takes precedence over the\n    \\`SDES-no\\` and \\`SDES-only\\` flags, if used in combination.\n\n  - *SDES-pad* - RFC 4568 (section 6.1) is somewhat ambiguous regarding\n    the base64 encoding format of \\`a=crypto\\` parameters added to an\n    SDP body. The default interpretation is that trailing \\`=\\`\n    characters used for padding should be omitted. With this flag set,\n    these padding characters will be left in place.\n\n  - *unidirectional* - allows kernelization of one-way streams in the\n    Sipwise rtpengine proxy. This is especially useful when the first\n    call leg is handled by some rtpengine machine while the second call\n    leg is handled by other rtpengine machine.\n\n  - *record-call=on* - instructs RTPEngine to record the session. Use it\n    in rtpengine_offer() to start recording immediately and save the\n    call metadata, as alternative to start_recording().\n\n  - *metadata* - a generic metadata string. The metadata will be used\n    when recording calls to provide custom additional information. More\n    details about this are found in the rtpengine README.\n\n  - *codec-transcode=...* - allows codecs to be added to the list of\n    offered codecs even if they were not present in the original list of\n    codecs. In this case, the transcoding engine will be engaged. Only\n    codecs that are supported for both decoding and encoding can be\n    added in this manner. More details about this are found in the\n    rtpengine README.\n\n  - *codec-set=...* - set codec options (bitrate etc) for codecs that\n    are implicitly accepted for transcoding from the offering side.\n\n  - *codec-strip=...* - strips given codec from sdp\n\n  - *codec-offer=...* - offer given codec from sdp. More details about\n    this are found in the rtpengine README.\n\n  - *codec-except=...* - same as *codec-offer* but preserves original\n    order\n\n  - *codec-mask=...* - Similar to strip except that codecs listed here\n    will still be accepted and used for transcoding on the offering\n    side. Useful only in combination with codec-transcode. *all* keyword\n    can be used to mask all offered codecs\n\n  - *codec-accept=...* - Similar to \\`mask\\` and \\`consume\\` but doesn't\n    remove the codec from the list of offered codecs. This means that a\n    codec listed under \\`accept\\` will still be offered to the remote\n    peer, but if the remote peer rejects it, it will still be accepted\n    towards the original offerer and then used for transcoding. It is a\n    more selective version of what the \\`always transcode\\` flag does.\n\n  - *T.38=decode* - If the offered SDP contains a media section\n    advertising T.38 over UDPTL, translate it to a regular audio media\n    section over RTP. By default, PCMU and PCMA will be used as audio\n    codecs, but that can be overridden using the codec options described\n    above. Other transport protocols (e.g. SRTP) can also be selected in\n    the same way. If the offered SDP does not contain a T.38 section,\n    then this flag has no effect.\n\n  - *T.38=force* - Any audio media section (over RTP) in the offered SDP\n    will be translated into a T.38 section over UDPTL.\n\n  - *T.38=stop* - Stops a previously established T.38 to audio gateway\n    and reverts the session back to media passthrough. This is useful\n    when handling a rejected T.38 offer.\n\n  Check also the documentation of RTPEngine, these flags are documented\n  there as well: <https://github.com/sipwise/rtpengine>.\n\nThis function can be used from ANY_ROUTE.\n\n    route {\n    ...\n        if (is_method(\"INVITE\")) {\n            if (has_body(\"application/sdp\")) {\n                if (rtpengine_offer())\n                    t_on_reply(\"1\");\n            } else {\n                t_on_reply(\"2\");\n            }\n        }\n        if (is_method(\"ACK\") && has_body(\"application/sdp\"))\n            rtpengine_answer();\n    ...\n    }\n\n    onreply_route[1]\n    {\n    ...\n        if (has_body(\"application/sdp\"))\n            rtpengine_answer();\n    ...\n    }\n\n    onreply_route[2]\n    {\n    ...\n        if (has_body(\"application/sdp\"))\n            rtpengine_offer();\n    ...\n    }\n    ...\n    if (has_body(\"application/sdp\")) {\n            if (rtpengine_offer(\"codec-mask=all codec-transcode=PCMU codec-transcode=PCMA\"))\n                    t_on_reply(\"1\");\n    }\n\n    ...\n\n    route {\n    ...\n        if (is_method(\"INVITE\")) {\n            if (has_body(\"application/sdp\")) {\n                if (rtpengine_offer(\"codec-mask=opus codec-accept=opus codec-strip=PCMU codec-transcode=PCMU\"))\n                    t_on_reply(\"1\");\n            }\n        }\n    ...\n    }\n\n    onreply_route[1]\n    {\n    ...\n        if (has_body(\"application/sdp\"))\n            rtpengine_answer(\"codec-strip=PCMU codec-strip=PCMA\");\n    ...\n    }\n    ...\n\n",
 "rtpengine_answer": "### rtpengine_answer([flags])\n\n module: rtpengine\n\nRewrites SDP body to ensure that media is passed through an RTP proxy.\nTo be invoked on 200 OK for the cases the SDP bodies are in INVITE and\n200 OK and on ACK when SDP bodies are in 200 OK and ACK.\n\nSee rtpengine_offer() function description above for the meaning of the\nparameters.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\nSee rtpengine_offer() function example above for example.\n\n",
 "rtpengine_info": "### rtpengine_info([flags])\n\n module: rtpengine\n\nSend an updated offer to rtpengine. This is meant to be used when\nprocessing Trickle ICE SDP Fragments that are carried in SIP INFO\nmessages and are proxied to endpoints that do not support ICE. With a\nmatching content type, the SDP fragment is used to update rtpengine's\nlist of ICE candidates. No new SDP is returned and so the SIP INFO\nmessage should be consumed after calling this function.\n\nWhile this function supports the same flags as \u201crtpengine_offer\u201d et al,\nit is not normally necessary to provide any.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    rtpengine_info();\n    ...\n\n",
 "rtpengine_delete": "### rtpengine_delete([flags])\n\n module: rtpengine\n\nTears down the RTP proxy session for the current call. This populates\nthe statistics pseudovariables (such \u201cmos_min_pv\u201d etc).\n\nSee rtpengine_offer() function description above for the meaning of the\nparameters. Note that not all flags make sense for a \u201cdelete\u201d.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    rtpengine_delete();\n    ...\n\n",
 "rtpengine_query": "### rtpengine_query([flags])\n\n module: rtpengine\n\nQueries the RTP proxy about the current status and statistics of a\nrunning call. This populates the statistics pseudovariables (such\n\u201cmos_min_pv\u201d etc).\n\nSee rtpengine_offer() function description above for the meaning of the\nparameters. Note that not all flags make sense for a \u201cquery\u201d.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    rtpengine_query();\n    ...\n\n",
 "rtpengine_query_v": "### rtpengine_query_v(fmt, var)\n\n module: rtpengine\n\nQueries the RTP proxy about the current status and statistics of a\nrunning call, converts the response to JSON according to fmt and sets\nthe variable var with the result.\n\nThe fmt parameter can be 'j' for compacted JSON and 'jp' for\npretty-formatted JSON.\n\nThe var parameter has to be the name of a writable variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(rtpengine_query_v(\"j\", \"$var(rdata)\")) {\n        xinfo(\"rtpengine query response: $var(rdata)\\n\");\n    }\n    ...\n\n",
 "rtpengine_manage": "### rtpengine_manage([flags])\n\n module: rtpengine\n\nManage the RTPEngine session - it combines the functionality of\nrtpengine_offer(), rtpengine_answer() and rtpengine_delete(), detecting\ninternally based on message type and method which one to execute.\n\nIt can take the same parameters as `rtpengine_offer()`. The flags\nparameter to rtpengine_manage() can be a configuration variable\ncontaining the flags as a string.\n\nFunctionality:\n\n- If INVITE with SDP, then do `rtpengine_offer()`\n\n- If INVITE with SDP, when the tm module is loaded, mark transaction\n  with internal flag FL_SDP_BODY to know that the 1xx and 2xx are for\n  `rtpengine_answer()`\n\n- If ACK with SDP, then do `rtpengine_answer()`\n\n- If BYE or CANCEL, or called within a FAILURE_ROUTE\\[\\], then call\n  `rtpengine_delete()`. Be careful with calling this function after\n  resuming a suspended transaction (e.g., after t_continue()), because\n  the context of executed route is FAILURE ROUTE (in other words,\n  rtpengine_manage() in the route block of t_continue() does the same as\n  in failure_route; use a branch route to engage rtpengine for a\n  forwarded branch after resuming the transaction).\n\n- It does nothing if used inside event_route\\[tm:branch-failure:...\\]\n\n- If reply to INVITE with code \\>= 300 do `rtpengine_delete()`\n\n- If reply with SDP to INVITE having code 1xx and 2xx, then do\n  `rtpengine_answer()` if the request had SDP or tm is not loaded,\n  otherwise do `rtpengine_offer()`\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    rtpengine_manage();\n    ...\n\n",
 "stop_recording": "### stop_recording([flags])\n\n module: rtpengine\n\nThis function will send a signal to the RTP relay to stop recording the\nRTP stream flowing through it. See also the option \u201crecord-call=off\u201d for\nrtpengine_manage()/rtpengine_offer(), which offers an alternative for\ncall recording.\n\nIt can take the same parameters as `rtpengine_manage()`. The flags\nparameter to start_recording can be a configuration variable containing\nthe flags as a string. The call-id flag can be used to stop recording\nfor a different call.\n\nThis function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    stop_recording();\n    ...\n            \n\n",
 "block_dtmf": "### block_dtmf([flags])\n\n module: rtpengine\n\nThis function will instruct the RTP proxy to start blocking DTMF event\npackets (RFC 4733). DTMF events will still be processed by the RTP\nproxy, but they won't be forwarded to the receiving peer.\n\nThe call-id flag can be used to block DTMF for a different call.\n\nWithout any flags given, DTMF events will be blocked for the entire\ncall. It's possible to block DTMF directionally only for individual\nparticipants. If the \u201cdirectional\u201d flag is given, DTMF events will be\nblocked for the UA with the currently matching \u201cFrom\u201d tag. Events can be\nblocked for a different UA either by specifying an alternative\n\u201cfrom-tag=...\u201d, or by matching UAs against the media address they\nadvertised in the SDP using the \u201caddress=...\u201d flag (which can contain\neither an IPv4 or IPv6 address).\n\nThis function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.\n\n    ...\n    block_dtmf();\n    block_dtmf(\"directional\");\n    block_dtmf(\"address=192.168.42.42\");\n    ...\n            \n\n",
 "unblock_dtmf": "### unblock_dtmf([flags])\n\n module: rtpengine\n\nReverses the effects of a previously issued `block_dtmf` call. See above\nfor a description of which flags can be used.\n\nIf DTMF events were previously blocked for individual UAs, then\nunblocking DTMF events for the entire call (i.e. no flags given) will\nnot remove these blocks. The flag \u201call\u201d can be used to achieve this.\n\n    ...\n    unblock_dtmf();\n    unblock_dtmf(\"all\");\n    ...\n            \n\n",
 "block_media": "### block_media([flags])\n\n module: rtpengine\n\nAnalogous to \u201cblock_dtmf\u201d, but blocks media RTP packets instead of DTMF\nevents. When media is blocked, DTMF events still pass through the RTP\nproxy.\n\nSee \u201cblock_dtmf\u201d for a description of the flags that can be used.\n\n    ...\n    block_media();\n    block_media(\"directional\");\n    block_media(\"address=192.168.42.42\");\n    ...\n            \n\n",
 "unblock_media": "### unblock_media([flags])\n\n module: rtpengine\n\nAnalogous to \u201cunblock_dtmf\u201d, but applies to media RTP packets instead of\nDTMF events.\n\nSee \u201cunblock_dtmf\u201d for a description of the flags that can be used.\n\n    ...\n    unblock_media();\n    unblock_media(\"all\");\n    ...\n            \n\n",
 "silence_media": "### silence_media([flags])\n\n module: rtpengine\n\nIdentical to \u201cblock_media\u201d except that media RTP packets are not simply\nblocked, but instead have their audio payload replaced by silence audio.\nThis is only supported for certain trivial audio codecs (e.g. G.711,\nG.722).\n\nSee \u201cblock_dtmf\u201d for a description of the flags that can be used.\n\n    ...\n    silence_media();\n    silence_media(\"directional\");\n    silence_media(\"address=192.168.42.42\");\n    ...\n            \n\n",
 "unsilence_media": "### unsilence_media([flags])\n\n module: rtpengine\n\nIdentical to \u201cunblock_media\u201d except that it's the counterpart to\n\u201csilence_media\u201d.\n\nSee \u201cunblock_dtmf\u201d for a description of the flags that can be used.\n\n    ...\n    unsilence_media();\n    unsilence_media(\"all\");\n    ...\n            \n\n",
 "start_forwarding": "### start_forwarding([flags])\n\n module: rtpengine\n\nControls the PCM forwarding feature of the recording daemon. Unlike the\nrecording feature, PCM forwarding can be done directionally for\nindividual call participants only, therefore this command takes the same\nflags as the media/DTMF blocking commands above.\n\nSee \u201cblock_dtmf\u201d for a description of the flags that can be used.\n\n    ...\n    start_forwarding();\n    start_forwarding(\"directional\");\n    start_forwarding(\"address=192.168.42.42\");\n    ...\n            \n\n",
 "stop_forwarding": "### stop_forwarding([flags])\n\n module: rtpengine\n\nAnalogous to \u201cunblock_dtmf\u201d, but controls the PCM forwarding feature\ninstead of DTMF blocking.\n\nSee \u201cunblock_dtmf\u201d for a description of the flags that can be used.\n\n    ...\n    stop_forwarding();\n    stop_forwarding(\"all\");\n    ...\n            \n\n",
 "play_media": "### play_media([flags])\n\n module: rtpengine\n\nInstructs rtpengine to play a prerecorded announcement to the selected\ncall participant, either from a local file or from a file stored in a\ndatabase. The participant must be selected using the same flags as are\ndescribed under the \u201cblock_dtmf\u201d function. If none of these flags are\ngiven, then the \u201cFrom\u201d tag from the current SIP message context is used.\n\nIf successful, the \u201cmedia_duration\u201d pseudovariable is filled in with the\nduration of the media being played, expressed in milliseconds. If the\nlength of the media could not be determined, it's set to -1.\n\n    ...\n    play_media(\"file=/use/share/media/hello.wav\");\n    play_media(\"from-tag=tfugklbildfydrtuykgfv db-id=12345\");\n    ...\n            \n\n",
 "stop_media": "### stop_media([flags])\n\n module: rtpengine\n\nStops the playback of media previously started by \u201cplay_media\u201d. Media\nplayback is automatically stopped when the end of the media file is\nreached, so this function is only useful to prematurely stop playback.\n\n    ...\n    stop_media();\n    stop_media(\"from-tag=5yqaeriguhxcikxj\");\n    ...\n            \n\n",
 "play_dtmf": "### play_dtmf([flags])\n\n module: rtpengine\n\nInjects a DTMF event into the media stream. Depending on which codecs\nwere negotiated, this either injects an RFC 2833/4733 DTMF event, or an\nin-band PCM DTMF tone into the audio stream. The flag \u201cinject DTMF\u201d must\nhave been present in both offer and answer messages when the call was\nestablished, which forces all audio to go through rtpengine's\ntranscoding engine.\n\nUsage is similar to \u201cplay_media\u201d with the following exceptions. The\nselected party is not the party that will receive the DTMF event, but\nrather the party which is generating the event. This is to support DTMF\nevents that are carried in SIP INFO messages. Instead of specifying a\nmedia file, a DTMF event code must be specified, as well as optionally a\nduration and the volume. The \u201ccode\u201d can be a number 0 through 15, or a\nDTMF digit (0-9, A-D, \\*, \\#). The \u201cduration\u201d is specified in\nmilliseconds and defaults to 250, within a range of 100-5000. The\n\u201cvolume\u201d is specified in absolute decibels, with a default of -8 db.\n\nMultiple consecutive DTMF events can be queued up by calling this\nfunction multiple times consecutively. RTPengine will play out the DTMF\nevents in sequence, separated by a default pause of 100 ms. An\nalternative pause length can be given through the \u201cpause\u201d option,\nbetween 100 and 5000 ms.\n\n    ...\n    play_dtmf(\"from-tag=5yqaeriguhxcikxj code=#\");\n    play_dtmf(\"code=1 volume=5 duration=300 pause=150\");\n    ...\n            \n\n",
 "msg_apply_changes": "### msg_apply_changes()\n\n module: textopsx\n\nUse this function to apply changes performed on SIP message content. Be\ncareful when using this function; due to special handling of changes to\nthe SIP message buffer so far, using this function might change the\nbehaviour of your config. Do test your config properly!\n\nThe function returns true (1) on success. If it is failure before the\nnew content is built, the function returns false (-1), the old content\nis still in place. If parsing of the new content is failing, the\nfunction stops executions of the config file (the internal structure is\nno longer valid for config processing, like it happens when a broken\nmessage is received from network).\n\nThis function can be used from REQUEST_ROUTE or core REPLY_ROUTE.\n\nNote: It must be used before the transaction is created in request_route\nand not inside the onreply_route\\[name\\] executed by tm module. Also, do\nnot use after resuming a suspended request or reply, at that moment the\ntransaction is already created.\n\n    ...\n    append_hf(\"My-Header: yes\\r\\n\");\n    if(msg_apply_changes())\n    {\n        # msg buffer has a new content\n        if(is_present_hf(\"My-Header\"))\n        {\n            # will get here always\n        }\n    }\n    ...\n\n",
 "msg_set_buffer": "### msg_set_buffer(data)\n\n module: textopsx\n\nSet the content of the SIP message buffer, replacing the exiting data.\nThe parameter can contain variables, its value must be a valid SIP\nrequest or reply, a matter of what the old message is.\n\nThis function can be used from REQUEST_ROUTE or core REPLY_ROUTE.\n\nNote: It must be used before the transaction is created in request_route\nand not inside the onreply_route\\[name\\] executed by tm module. Also, do\nnot use after resuming a suspended request or reply, at that moment the\ntransaction is already created.\n\n    ...\n    msg_set_buffer(\"INVITE sip:...\");\n    ...\n\n",
 "change_reply_status": "### change_reply_status(code, reason)\n\n module: textopsx\n\nIntercept a SIP reply (in an onreply_route) and change its status code\nand reason phrase prior to forwarding it.\n\nMeaning of the parameters is as follows:\n\n- *code* - Status code.\n\n- *reason* - Reason phrase.\n\nThis function can be used from ONREPLY_ROUTE.\n\n    ...\n    reply_route {\n        if (status == \"603\") {\n            change_reply_status(404, \"Not Found\");\n            exit;\n        }\n    }\n    ...\n            \n\n",
 "change_reply_status_code": "### change_reply_status_code(vcode)\n\n module: textopsx\n\nChange the status code for a SIP reply .\n\nMeaning of the parameters is as follows:\n\n- *vcode* - the new status code.\n\nThis function can be used from ONREPLY_ROUTE.\n\n    ...\n    reply_route {\n        if (status == \"604\") {\n            change_reply_status_code(\"404\");\n            exit;\n        }\n    }\n    ...\n            \n\n",
 "remove_body": "### remove_body()\n\n module: textopsx\n\nUse this function to remove the body of SIP requests or replies.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    remove_body();\n    ...\n\n",
 "keep_hf": "### keep_hf([regexp])\n\n module: textopsx\n\nRemove headers that don't match the regular expression regexp. Several\nheader are ignored always (thus not removed): Via, From, To, Call-ID,\nCSeq, Content-Length, Content-Type, Max-Forwards, Contact, Route,\nRecord-Route -- these can be removed one by one with remove_hf(). If\nregexp is missing, then only the headers listed above are kept, the rest\nare removed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    keep_hf(\"User-Agent\");\n    ...\n\n",
 "fnmatch": "### fnmatch(value, expr [, flags])\n\n module: textopsx\n\nMatch the value against the expr using shell-style pattern for file name\nmatching (see man page for C function fnmatch()). It is known to be\nfaster and use less-memory than regular expressions.\n\nParameter 'flags' is optional and can be 'i' to do case insensitive\nmatching.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(fnmatch(\"$rU\", \"123*\"))\n    {\n        ...\n    }\n    ...\n\n",
 "append_hf_value": "### append_hf_value(hf, hvalue)\n\n module: textopsx\n\nAppend new header value after an existing header, if no index acquired\nappend at the end of list. Note that a header may consist of comma\ndelimited list of values.\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field to be appended. Format: HFNAME \\[ \\[IDX\\] \\]. If\n  index is not specified new header is inserted at the end of message.\n  The index 1 correxponds to the first header.\n\n- *hvalue* - Value to be added, config var formatting supported.\n\n<!-- -->\n\n    ...\n    append_hf_value(\"foo\", \"gogo;stamp=$Ts\")   # add new header\n    append_hf_value(\"foo[1]\", \"gogo\")  # add new value behind first value\n    append_hf_value(\"foo[-1]\", \"$var(Bar)\") # try add value to the last header, if not exists add new header\n    ...\n            \n\n",
 "insert_hf_value": "### insert_hf_value(hf, hvalue)\n\n module: textopsx\n\nInsert new header value before an existing header, if no index acquired\ninsert before first hf header. Note that a header may consist of comma\ndelimited list of values. To insert a value behind the last value use\n`append_hf_value`.\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field to be appended. Format: HFNAME \\[ \\[IDX\\] \\]. If\n  index is not specified new header is inserted at the top of message.\n  The index 1 correxponds to the first header.\n\n- *hvalue* - Value to be added, config var formatting supported.\n\n<!-- -->\n\n    ...\n    insert_hf_value(\"foo[2]\", \"gogo\")\n    insert_hf_value(\"foo\", \"$avp(foo)\")   # add new header at the top of list\n    insert_hf_value(\"foo[1]\", \"gogo\") # try add to the first header\n    ...\n            \n\n",
 "remove_hf_value": "### remove_hf_value(hf_par)\n\n module: textopsx\n\nRemove the header value from existing header, Note that a header may\nconsist of comma delimited list of values.\n\nMeaning of the parameters is as follows:\n\n- *hf_par* - Header field/param to be removed. Format: HFNAME \\[ \\[IDX\\]\n  \\] \\[. PARAM \\] If asterisk is specified as index then all values are\n  affected. The index 1 correxponds to the first header.\n\n<!-- -->\n\n    ...\n    remove_hf_value(\"foo\")  # remove foo[1]\n    remove_hf_value(\"foo[*]\")  # remove all foo's headers\n    remove_hf_value(\"foo[-1]\") # last foo\n    remove_hf_value(\"foo.bar\")  # delete parameter\n    remove_hf_value(\"foo[*].bar\") # for each foo delete bar parameters\n    ...\n            \n\n",
 "remove_hf_value2": "### remove_hf_value2(hf_par)\n\n module: textopsx\n\nRemove specified header or parameter. It is expected header in\nAuthorization format (comma delimiters are not treated as multi-value\ndelimiters).\n\nMeaning of the parameters is as follows:\n\n- *hf_par* - Header/param to be removed. Format: HFNAME \\[ \\[IDX\\] \\]\n  \\[. PARAM \\] If asterisk is specified as index then all values are\n  affected. The index 1 correxponds to the first header.\n\n<!-- -->\n\n    ...\n    remove_hf_value2(\"foo\")  # remove foo[1]\n    remove_hf_value2(\"foo[*]\")  # remove all foo's headers, the same as remove_hf_header(\"foo[*]\");\n    remove_hf_value2(\"foo[-1]\") # last foo\n    remove_hf_value2(\"foo.bar\")  # delete parameter\n    remove_hf_value2(\"foo[*].bar\") # for each foo delete bar parameters\n    ...\n            \n\n",
 "assign_hf_value": "### assign_hf_value(hf, hvalue)\n\n module: textopsx\n\nAssign value to specified header value / param.\n\nMeaning of the parameters is as follows:\n\n- *hf_para* - Header field value / param to be appended. Format: HFNAME\n  \\[ \\[IDX\\] \\] \\[. PARAM\\] If asterisk is specified as index then all\n  values are affected. The index 1 correxponds to the first header.\n\n- *hvalue* - Value to be assigned, config var formatting supported. If\n  value is empty then no equal sign appears in param.\n\n<!-- -->\n\n    ...\n    assign_hf_value(\"foo\", \"gogo\")  # foo[1]\n    assign_hf_value(\"foo[-1]\", \"gogo\")  # foo[last_foo]\n\n    assign_hf_value(\"foo.bar\", \"\")\n    assign_hf_value(\"foo[3].bar\", \"\")\n    assign_hf_value(\"foo[*]\", \"\")  # remove all foo's, empty value remains\n    assign_hf_value(\"foo[*].bar\", \"\")  # set empty value (ex. lr)\n    ...\n            \n\n",
 "assign_hf_value2": "### assign_hf_value2(hf, hvalue)\n\n module: textopsx\n\nAssign value to specified header. It is expected header in Authorization\nformat (comma delimiters are not treated as multi-value delimiters).\n\nMeaning of the parameters is as follows:\n\n- *hf_para* - Header field value / param to be appended. Format: HFNAME\n  \\[ \\[IDX\\] \\] \\[. PARAM\\] If asterisk is specified as index then all\n  values are affected. The index 1 correxponds to the first header.\n\n- *hvalue* - Value to be assigned, config var formatting supported. If\n  value is empty then no equal sign appears in param.\n\n<!-- -->\n\n    ...\n    assign_hf_value2(\"Authorization.integrity-protected\", \"\\\"yes\\\"\")\n    assign_hf_value2(\"foo[-1]\", \"gogo\")  # foo[last_foo]\n    assign_hf_value2(\"foo[*].bar\", \"\")  # set empty value (ex. lr)\n    ...\n            \n\n",
 "include_hf_value": "### include_hf_value(hf, hvalue)\n\n module: textopsx\n\nAdd value in set if not exists, eg. \"Supported: path,100rel\".\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field name to be affected.\n\n- *hvalue* - config var formatting supported.\n\n<!-- -->\n\n    ...\n    include_hf_value(\"Supported\", \"path\");\n    ...\n            \n\n",
 "exclude_hf_value": "### exclude_hf_value(hf, hvalue)\n\n module: textopsx\n\nRemove value from set if exists, eg. \"Supported: path,100rel\".\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field name to be affected.\n\n- *hvalue* - config formatting supported.\n\n<!-- -->\n\n    ...\n    exclude_hf_value(\"Supported\", \"100rel\");\n    ...\n            \n\n",
 "hf_value_exists": "### hf_value_exists(hf, hvalue)\n\n module: textopsx\n\nCheck if value exists in set. Alternate select\n*@hf_value_exists.HF.VALUE* may be used. It returns one or zero.\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field name to be affected. Underscores are treated as\n  dashes.\n\n- *hvalue* - config var formatting supported.\n\n<!-- -->\n\n    ...\n    if (hf_value_exists(\"Supported\", \"100rel\")) {\n\n    }\n\n    if (@hf_value_exists.supported.path == \"1\") {\n\n    }\n    ...\n            \n\n",
 "hf_iterator_start": "### hf_iterator_start(iname)\n\n module: textopsx\n\nStart an iterator for headers in the current SIP message. The parameter\niname is used to identify the iterator. There can be up to 4 iterators\nat the same time, with different name.\n\nThe parameter can be a dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    hf_iterator_start(\"i1\");\n    ...\n\n",
 "hf_iterator_end": "### hf_iterator_end(iname)\n\n module: textopsx\n\nClose the iterator identified by iname parameter. The iname value must\nbe the same used for hf_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    hf_iterator_end(\"i1\");\n    ...\n\n",
 "hf_iterator_next": "### hf_iterator_next(iname)\n\n module: textopsx\n\nMove the iterator to the next header. It must be called also after\nhf_iterator_start() to get the first header.\n\nThe return code is false when there is no other header in the list.\n\nThe item name and value are accessible via variables: \\$hfitname(iname)\nand \\$hfitbody(iname).\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        hf_iterator_start(\"i1\");\n        while(hf_iterator_next(\"i1\")) {\n            xlog(\"hdr[$hfitname(i1)] is: $hfitbody(i1)\\n\");\n        }\n        hf_iterator_end(\"i1\");\n    ...\n\n",
 "hf_iterator_prev": "### hf_iterator_prev(iname)\n\n module: textopsx\n\nMove the iterator to the previous header. It must be called also after\nhf_iterator_start() and hf_iterator_next().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        hf_iterator_start(\"i1\");\n        hf_iterator_next(\"i1\");\n    ...\n        hf_iterator_next(\"i1\");\n    ...\n        hf_iterator_prev(\"i1\");\n    ...\n        hf_iterator_end(\"i1\");\n    ...\n\n",
 "hf_iterator_rm": "### hf_iterator_rm(iname)\n\n module: textopsx\n\nRemove the header at the current iterator position.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        hf_iterator_start(\"i1\");\n        while(hf_iterator_next(\"i1\")) {\n            if($hfitname(i1)==\"My-Header\") {\n                hf_iterator_rm(\"i1\");\n            }\n        }\n        hf_iterator_end(\"i1\");\n    ...\n\n",
 "hf_iterator_append": "### hf_iterator_append(iname, htext)\n\n module: textopsx\n\nAdd headers after the one at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        hf_iterator_start(\"i1\");\n        while(hf_iterator_next(\"i1\")) {\n            if($hfitname(i1)==\"My-Header\") {\n                hf_iterator_append(\"i1\", \"My-New-Header: abc\\r\\n\");\n                break;\n            }\n        }\n        hf_iterator_end(\"i1\");\n    ...\n\n",
 "hf_iterator_insert": "### hf_iterator_insert(iname, htext)\n\n module: textopsx\n\nAdd headers before the one at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        hf_iterator_start(\"i1\");\n        while(hf_iterator_next(\"i1\")) {\n            if($hfitname(i1)==\"My-Header\") {\n                hf_iterator_insert(\"i1\", \"My-New-Header: abc\\r\\n\");\n                break;\n            }\n        }\n        hf_iterator_end(\"i1\");\n    ...\n\n",
 "bl_iterator_start": "### bl_iterator_start(iname)\n\n module: textopsx\n\nStart an iterator for lines in the body of the current SIP message. The\nparameter iname is used to identify the iterator. There can be up to 4\niterators at the same time, with different name.\n\nThe parameter can be a dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    bl_iterator_start(\"b1\");\n    ...\n\n",
 "bl_iterator_end": "### bl_iterator_end(iname)\n\n module: textopsx\n\nClose the iterator identified by iname parameter. The iname value must\nbe the same used for bl_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    bl_iterator_end(\"b1\");\n    ...\n\n",
 "bl_iterator_next": "### bl_iterator_next(iname)\n\n module: textopsx\n\nMove the iterator to the next line in the body. It must be called also\nafter bl_iterator_start() to get the first header.\n\nThe return code is false when there is no other header in the list.\n\nThe body line accessible via variable \\$blitval(iname) - it contains\nalso the EOL chars.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        bl_iterator_start(\"b1\");\n        while(bl_iterator_next(\"b1\")) {\n            xlog(\"body line: $blitval(b1)\");\n        }\n        bl_iterator_end(\"b1\");\n    ...\n\n",
 "bl_iterator_rm": "### bl_iterator_rm(iname)\n\n module: textopsx\n\nRemove the body line at the current iterator position.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        bl_iterator_start(\"b1\");\n        while(bl_iterator_next(\"b1\")) {\n            if($blitval(b1)=~\"abc\") {\n                bl_iterator_rm(\"b1\");\n            }\n        }\n        bl_iterator_end(\"b1\");\n    ...\n\n",
 "bl_iterator_append": "### bl_iterator_append(iname, text)\n\n module: textopsx\n\nAdd text after the line at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        bl_iterator_start(\"b1\");\n        while(bl_iterator_next(\"b1\")) {\n            if($blitval(b1)=~\"^a=info:xyz\") {\n                bl_iterator_append(\"b1\", \"a=info:abc\\r\\n\");\n                break;\n            }\n        }\n        bl_iterator_end(\"b1\");\n    ...\n\n",
 "bl_iterator_insert": "### bl_iterator_insert(iname, text)\n\n module: textopsx\n\nAdd text before the line at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        bl_iterator_start(\"b1\");\n        while(bl_iterator_next(\"b1\")) {\n            if($blitval(b1)=~\"^a=info:xyz\") {\n                bl_iterator_insert(\"b1\", \"a=info:abc\\r\\n\");\n                break;\n            }\n        }\n        bl_iterator_end(\"b1\");\n    ...\n\n",
 "nats_publish": "### nats_publish(subject, payload, reply)\n\n module: nats\n\nPublishes the payload to subject, with an optional reply subject.\n\n    ...\n    $var(my_info) = \"$ci=\" + $ci + \" $fU=\" + $fU;\n    nats_publish(\"mysubject\", \"$var(my_info)\"); # publish $var(my_info) to \"mysubject\"\n\n    # publish $var(my_info) to \"mysubject\" with a reply.topic topic, so a response\n    # can be published back from the other side, like the NATS Request-Reply mode.\n    nats_publish(\"mysubject\", \"$var(my_info)\", \"reply.topic\");\n    ...\n                    \n\n",
 "json_get_field": "### json_get_field(json_string, field_name, destination)\n\n module: json\n\nCopy field 'field_name' from json object 'json_string' and store it in\npvar 'destination'.\n\nNote that the result is the string representation of that JSON filed.\nFor example, if you want to retrieve a field that has a string value,\nthen the result is the value enclosed in quotes. If the field value is a\nstructure, then the result is the string-formatted representation of\nthat structure.\n\n    ...\n    json_get_field(\"{'foo':'bar'}\", \"foo\", \"$var(foo)\");\n    xlog(\"foo is $var(foo)\");\n    ...\n            \n\n",
 "json_get_string": "### json_get_string(json_string, field_name, destination)\n\n module: json\n\nCopy field 'field_name' from json object 'json_string' and store it in\npvar 'destination'.\n\n    ...\n    json_get_string(\"{'foo':'bar'}\", \"foo\", \"$var(foo)\");\n    xlog(\"foo is $var(foo)\");\n    ...\n            \n\n",
 "sd_lookup": "### sd_lookup(table [, owner])\n\n module: speeddial\n\nThe function lookups the short dial number from R-URI in 'table' and\nreplaces the R-URI with associated address.\n\nMeaning of the parameters is as follows:\n\n- *table* - The name of the table storing the speed dial records.\n\n- *owner* - The SIP URI of the owner of short dialing codes. If not\n  present, URI of From header is used.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    # 'speed_dial' is the default table name created by kamailio db script\n    if(uri=~\"sip:[0-9]{2}@.*\")\n        sd_lookup(\"speed_dial\");\n    # use auth username\n    if(uri=~\"sip:[0-9]{2}@.*\")\n        sd_lookup(\"speed_dial\", \"sip:$au@$fd\");\n    ...\n\n",
 "is_peer_verified": "### is_peer_verified()\n\n module: tls\n\nReturns true if the connection on which the message was received is TLS,\nthe peer presented an X509 certificate and the certificate chain\nverified ok.\n\nIt can be used only in a request route.\n\n    ...\n        if (proto==TLS && !is_peer_verified()) {\n            sl_send_reply(\"400\", \"No certificate or verification failed\");\n            exit;\n        }\n    ...\n\n",
 "tls_set_connect_server_id": "### tls_set_connect_server_id(srvid)\n\n module: tls\n\nSet the server id of the tls profile to be used by next client connect,\nbeing reset after use. It is an alternative to the use of xavp to\nspecify server id of a client profile for the cases when xavps are no\nlonger available (e.g., after event_route\\[tm:local-request\\]).\n\nIf the parameter is an empty string, then the value is reset.\n\nIt can be used only in ANY_ROUTE.\n\n    ...\n        tls_set_connect_server_id(\"clientone\");\n    ...\n\n",
 "ts_store": "### ts_store([uri])\n\n module: tsilo\n\nThe method stores uri, tindex and tlabel of the current transaction. If\nthe uri parameter is missing, then the value is taken from r-uri. The\nuri parameter can contain variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (is_method(\"INVITE\")) {\n        if (t_newtran()) {\n            ts_store();\n            # ts_store(\"sip:alice@$td\");\n        }\n    }\n    ...\n\n",
 "ts_append": "### ts_append(domain, ruri)\n\n module: tsilo\n\nThe method add branches to all the stored transactions for the SIP ruri\npassed as parameter, performing a contact lookup on the table specified\nby the domain parameter. The method should be called when a REGISTER\nrequest is received.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for looking up new\n  contacts for r-uri.\n\n- *ruri* - The r-uri for which we want to check existing transactions\n  and add them new branches. Can be a static string value or a dynamic\n  string with pseudo-variables.\n\nReturn codes:\n\n- *1* - branches added.\n\n  *-1* - an internal error has produced (parsing error, memory error).\n\n  *-2* - no records found for the r-uri.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (is_method(\"REGISTER\")) {\n        ts_append(\"location\", \"$tu\");\n    }\n    ...\n\n",
 "ts_append_by_contact": "### ts_append_by_contact(domain, ruri [, contact])\n\n module: tsilo\n\nHas almost the same intention as the ts_append(), but gives a\npossibility to append branches only for a specific location record\n(Contact URI). The contact's URI value can be either taken from the\ncurrently processed REGISTER or (optionally) given as a third parameter.\nIf the Contact URI for a lookup is given as the parameter, it is\npossible to provide it as a pseudo-variable. The contact lookup is\nperformed on the table specified by the domain parameter. The method\nshould be called when a REGISTER request is received.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for looking up new\n  contacts for r-uri.\n\n- *ruri* - The r-uri for which we want to check existing transactions\n  and add them new branches. Can be a static string value or a dynamic\n  string with pseudo-variables.\n\n- *contact* - Optional, a value of the location record (contact URI)\n  based on which to perform the branch appending. If not given, the\n  value will be taken from the currently processed REGISTER. If a\n  location lookup based on this Contact URI fails (no location record\n  found), then the branch append will not happen.\n\nReturn codes:\n\n- *1* - branches added.\n\n  *-1* - an internal error has produced (parsing error, memory error).\n\n  *-2* - no records found for the r-uri.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (is_method(\"REGISTER\")) {\n        $var(formated_ct) = $(x_hdr(Contact){nameaddr.uri});\n        ts_append_by_contact(\"location\", \"$tu\", \"$var(formated_ct)\");\n    }\n    ...\n\n",
 "ts_append_to": "### ts_append_to(tindex, tlabel, domain, [uri])\n\n module: tsilo\n\nThe method add branches to the transaction identified by tindex and\ntlabel, performing a contacts lookup on the table specified by the\ndomain parameter. The method should be called when a REGISTER request is\nreceived.\n\nMeaning of the parameters is as follows:\n\n- *tindex* - internal index of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *tlabel* - internal label of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *domain* - Name of table that should be used for looking up new\n  contacts for r-uri.\n\n- *uri* (optional) - uri for which to do lookup for new destinations.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    if (is_method(\"REGISTER\")) {\n        $var(tindex) = ...\n        $var(tlabel) = ...\n        ts_append_to(\"$var(tindex)\", \"$var(tlabel)\", \"location\");\n    }\n    ...\n\n",
 "lookup_path_to_contact": "### lookup_path_to_contact(uri)\n\n module: ims_registrar_scscf\n\nThis function take a URI and tries to find the contact in usrloc. If the\ncontact is found and has a path set, then a path header is added to the\nSIP message so it can be loose routed.\n\nMeaning of the parameters is as follows:\n\n- uri - URI of contact to lookup\n\nReturn codes:\n\n- *1* - Success\n\n- -1 - Failure\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    lookup_path_to_contact($ruri);\n    ...\n\n",
 "assign_server_unreg": "### assign_server_unreg(aysnc_reply_route, domain, direction)\n\n module: ims_registrar_scscf\n\nTBD\n\nused in REQUEST_ROUTE\n\n",
 "impu_registered": "### impu_registered(domain)\n\n module: ims_registrar_scscf\n\nThis function checks if the IMPU in the To header is registered in\nusrloc.\n\nMeaning of the parameters is as follows:\n\n- *domain*- Logical domain within registrar.\n\nReturn codes:\n\n- 1 - True, IMPU exists in registered state in usrloc\n\n- *-1 - False, IMPU not registered*\n\nThis function can be used in REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    impu_registered(\"location\");\n    switch ($retcode) {\n        case -1:\n            sl_send_reply(\"404\", \"Not Found\");\n            exit;\n        case 1:\n            #true, continue with normal processing\n    };\n    ...\n\n",
 "term_impu_registered": "### term_impu_registered(domain)\n\n module: ims_registrar_scscf\n\nThis function checks if the IMPU in the Request-URI is registered in\nusrloc.\n\nMeaning of the parameters is as follows:\n\n- *domain*- Logical domain within registrar.\n\nReturn codes:\n\n- 1 - True, IMPU exists in registered state in usrloc\n\n- *-1 - False, IMPU not registered*\n\nThis function can be used in REQUEST_ROUTE, FAILURE_ROUTE\n\n    ...\n    term_impu_registered(\"location\");\n    switch ($retcode) {\n         case -1:\n              sl_send_reply(\"404\", \"Not Found\");\n              exit;\n         case 1:\n              #true, continue with normal processing\n    };\n    ...\n\n",
 "can_subscribe_to_reg": "### can_subscribe_to_reg(domain)\n\n module: ims_registrar_scscf\n\nThis function checks to see that a SUBSCRIBE request is authorised to\nsubscribe to the particular identity. Only 3 entities can subscribe:\n\n- *The user agent to its own state*\n\n- The P-CSCF specified in the path header for that user\n\n- Application Server (AS) not yet implemented\n\nMeaning of the parameters is as follows:\n\n- *domain - Logical domain within registrar.*\n\nThis function can be used in REQUEST_ROUTE\n\n    ...\n    if (can_subscribe_to_reg(\"location\")){\n         $var(ret)= subscribe_to_reg(\"location\");\n    }\n    ...\n\n",
 "subscribe_to_reg": "### subscribe_to_reg(domain)\n\n module: ims_registrar_scscf\n\nSave the subscription to the REG event for the UAC or the appropriate\nP-CSCF (in the path to the UAC).\n\nMeaning of the parameters is as follows:\n\n- *domain - Logical domain within registrar.*\n\nThis function can be used in REQUEST_ROUTE\n\n    ...\n    if (can_subscribe_to_reg(\"location\")){\n         $var(ret)= subscribe_to_reg(\"location\");\n    }\n    ...\n\n",
 "can_publish_reg": "### can_publish_reg(domain)\n\n module: ims_registrar_scscf\n\nThis function checks to see that a PUBLISH request is authorised to\npublish for a particular identity. Only 3 entities can publish:\n\n- *The user agent to its own state*\n\n- The P-CSCF specified in the path header for that user\n\n- Application Server (AS) not yet implemented\n\nMeaning of the parameters is as follows:\n\n- *domain - Logical domain within registrar.*\n\nThis function can be used in REQUEST_ROUTE\n\n    ...\n    if (can_publish_reg(\"location\")){\n        $var(ret)= publish_reg(\"location\");\n    }\n    ...\n\n",
 "publish_reg": "### publish_reg(domain)\n\n module: ims_registrar_scscf\n\nSave the publish to the REG event for the UAC or the appropriate P-CSCF\n(in the path to the UAC).\n\nMeaning of the parameters is as follows:\n\n- *domain - Logical domain within registrar.*\n\nThis function can be used in REQUEST_ROUTE\n\n    ...\n    if (can_publish_reg(\"location\")){\n        $var(ret)= publish_reg(\"location\");\n    }\n    ...\n\n",
 "diameter_www_authorize": "### diameter_www_authorize(realm)\n\n module: auth_diameter\n\nSIP Server checks for authorization having a DIAMETER server in backend.\nIf no credentials are provided inside the SIP request then a challenge\nis sent back to UAC. If the credentials don't match the ones computed by\nDISC then \u201c403 Forbidden\u201d is sent back.\n\nNegative codes may be interpreted as follows:\n\n- *-5 (generic error)* - some generic error occurred and no reply was\n  sent out;\n\n- *-3 (stale nonce)* - stale nonce;\n\nMeaning of the parameters is as follows:\n\n- *realm* - the realm to be use for authentication and authorization.\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if(!diameter_www_authorize(\"siphub.net\"))\n    { /* user is not authorized */\n        exit;\n    };\n    ...\n\n",
 "diameter_proxy_authorize": "### diameter_proxy_authorize(realm)\n\n module: auth_diameter\n\nSIP Proxy checks for authorization having a DIAMETER server in backend.\nIf no credentials are provided inside the SIP request then a challenge\nis sent back to UAC. If the credentials don't match the ones computed by\nDISC then \u201c403 Forbidden\u201d is sent back. For more about the negative\nreturn codes, see the above function.\n\nMeaning of the parameters is as follows:\n\n- *realm* - the realm to be use for authentication and authorization.\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if(!diameter_proxy_authorize(\"siphub.net\"))\n    { /* user is not authorized */\n        exit;\n    };\n    ...\n\n",
 "diameter_is_user_in": "### diameter_is_user_in(who, group)\n\n module: auth_diameter\n\nThe method performs group membership checking with DISC.\n\nMeaning of the parameters is as follows:\n\n- *who* - what header to be used to get the SIP URI that is wanted to be\n  checked being member in a certain group. It can be: \u201cRequest-URI\u201d,\n  \u201cFrom\u201d, \u201cTo\u201d or \u201cCredentials\u201d.\n\n- *group* - the group name where to check if the user is part of.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if(!diameter_is_user_in(\"From\", \"voicemail\"))\n    { /* user is not authorized */\n        exit;\n    };\n    ...\n\n",
 "xplog": "### xplog(level, format)\n\n module: xprint\n\nPrint a formatted message using LOG function.\n\nMeaning of the parameters is as follows:\n\n- *level* - The level that will be used in LOG function. It can be:\n\n  - L_ALERT\n\n  - L_CRIT\n\n  - L_ERR\n\n  - L_WARN\n\n  - L_NOTICE\n\n  - L_INFO\n\n  - L_DBG\n\n  What really matters is the third letter of the value.\n\n- *format* - The formatted string to be printed.\n\n<!-- -->\n\n    ...\n    xplog(\"L_ERR\", \"time [%Tf] method <%rm> r-uri <%ru> 2nd via <%{via[1]}>\\n\");\n    ...\n\n            \n\n",
 "xpdbg": "### xpdbg(format)\n\n module: xprint\n\nPrint a formatted message using DBG function.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\n<!-- -->\n\n    ...\n    xpdbg(\"time [%Tf] method <%rm> r-uri <%ru>\\n\");\n    ...\n\n            \n\n",
 "rtjson_init_routes": "### rtjson_init_routes(rtdoc)\n\n module: rtjson\n\nInitialize routing based on JSON document stored in rtdoc parameter.\n\nThe rtdoc parameter can be a static string or a dynamic string value\nwith config variables. It has to result in a valid JSON document with\nthe structure specified in chapter 'JSON Routing Structure'.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    rtjson_init_routes(\"$var(json)\");\n    ...\n\n",
 "rtjson_push_routes": "### rtjson_push_routes()\n\n module: rtjson\n\nPush the routes given in JSON document to rtjson_init_routes(rtdoc) to\nthe internal fields used by Kamailio for routing.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    rtjson_init_routes(\"$var(json)\");\n    rtjson_push_routes();\n    ...\n\n",
 "rtjson_next_route": "### rtjson_next_route()\n\n module: rtjson\n\nTo be used in failure_route for serial forking, to push the next route\nto the internal fields used by Kamailio for routing.\n\nThis function can be used from FAILURE_ROUTE.\n\n    ...\n    rtjson_init_routes(\"$var(json)\");\n    rtjson_push_routes();\n    t_on_failure(\"REROUTE\");\n    t_relay();\n    ...\n    failure_route[REROUTE] {\n        rtjson_next_route();\n    }\n    ...\n\n",
 "rtjson_update_branch": "### rtjson_update_branch()\n\n module: rtjson\n\nTo be used in branch_route if the JSON document had attributes that\nneeds to be set for each branch.\n\nThis function can be used from BRANCH_ROUTE.\n\n    ...\n    rtjson_init_routes(\"$var(json)\");\n    rtjson_push_routes();\n    t_on_branch(\"OUTGOING\");\n    t_relay();\n    ...\n    branch_route[OUTGOING] {\n        rtjson_update_branch();\n    }\n    ...\n\n",
 "xlog": "### xlog([ [facility,] level,] format)\n\n module: xlog\n\nOutput a formatted log message.\n\nMeaning of the parameters are as follows:\n\n- *facility* - The syslog facility that will be used for this single log\n  message.\n\n  If this parameter is missing, the implicit facility is either the\n  facility set with the 'log_facility' module parameter or the core's\n  log facility.\n\n- *level* - The level that will be used in LOG function. It can be:\n\n  - L_ALERT - log level -5\n\n  - L_BUG - log level -4\n\n  - L_CRIT - log level -3\n\n  - L_ERR - log level -1\n\n  - L_WARN - log level 0\n\n  - L_NOTICE - log level 1\n\n  - L_INFO - log level 2\n\n  - L_DBG - log level 3\n\n  - \\$pv - any valid pseudo-variable, that has an integer value. See\n    above options for valid log levels.\n\n  If it is not a pseudo-variable, then what really matters is the third\n  letter of the value. If the log level is higher than the \u201cdebug\u201d\n  global parameter, the message is not printed to syslog.\n\n  If this parameter is missing, the implicit log level is 'L_ERR'.\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xlog(\"L_ERR\", \"time [$Tf] method ($rm) r-uri ($ru) 2nd via ($hdr(via[1]))\\n\");\n    ...\n    xlog(\"time [$Tf] method ($rm) r-uri ($ru) 2nd via ($hdr(via[1]))\\n\");\n    ...\n    $var(loglevel) = 2;\n    xlog(\"$var(loglevel)\", \"time [$Tf] method ($rm) r-uri ($ru)\\n\");\n    ...\n    xlog(\"LOG_LOCAL3\", \"L_ERR\", \"this message will be sent to syslog facility LOG_LOCAL3\\n\");\n    ...\n\n",
 "xdbg": "### xdbg(format)\n\n module: xlog\n\nPrint a formatted message using DBG function.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xdbg(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xinfo": "### xinfo(format)\n\n module: xlog\n\nPrint a formatted log message at L_INFO level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xinfo(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xnotice": "### xnotice(format)\n\n module: xlog\n\nPrint a formatted log message at L_NOTICE level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xnotice(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xwarn": "### xwarn(format)\n\n module: xlog\n\nPrint a formatted log message at L_WARN level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xwarn(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xerr": "### xerr(format)\n\n module: xlog\n\nPrint a formatted log message at L_ERR level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xerr(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xbug": "### xbug(format)\n\n module: xlog\n\nPrint a formatted log message at L_BUG level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xbug(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xcrit": "### xcrit(format)\n\n module: xlog\n\nPrint a formatted log message at L_CRIT level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xcrit(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xalert": "### xalert(format)\n\n module: xlog\n\nPrint a formatted log message at L_ALERT level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    xalert(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n    ...\n\n",
 "xlogl": "### xlogl([ [facility,] level,] format)\n\n module: xlog\n\nSimilar to xlog(), in addition prints configuration file line number at\nthe beginning of message.\n\n",
 "xdbgl": "### xdbgl(format)\n\n module: xlog\n\nSimilar to xdbg(), in addition prints configuration file line number at\nthe beginning of message.\n\n",
 "xlogm": "### xlogm(level, format)\n\n module: xlog\n\nSimilar to xlog(level, format), but skips writing the log messages for\nSIP requests and responses that match the SIP method id with\nmethods_filter parameter value.\n",
 "xmpp_send_message": "### xmpp_send_message()\n\n module: xmpp\n\nConverts SIP messages to XMPP(jabber) messages, in order to be relayed\nto a XMPP(jabber) client.\n\n    ...\n    xmpp_send_message();\n    ...\n\n",
 "jsdt_dofile": "### jsdt_dofile(path)\n\n module: app_jsdt\n\nExecute the JavaScript script stored in 'path'. The parameter can be a\nstring with pseudo-variables evaluated at runtime.\n\n    ...\n    jsdt_dofile(\"/usr/local/etc/kamailio/js/myscript.js\");\n    ...\n\n",
 "jsdt_dostring": "### jsdt_dostring(script)\n\n module: app_jsdt\n\nExecute the JavaScript script stored in parameter. The parameter can be\na string with pseudo-variables.\n\n    ...\n    if(!jsdt_dostring('KSR.dbg(\"test message\\n\")'))\n    {\n        xdbg(\"SCRIPT: failed to execute js script!\\n\");\n    }\n    ...\n\n",
 "jsdt_run": "### jsdt_run(function, params)\n\n module: app_jsdt\n\nExecute the JS function 'func' giving params as parameters. There can be\nup to 3 string parameters. The function must exist in the script loaded\nat startup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n    ...\n    if(!jsdt_run(\"js_append_fu_to_reply\"))\n    {\n        xdbg(\"SCRIPT: failed to execute js function!\\n\");\n    }\n    ...\n    jsdt_run(\"js_funcx\", \"$rU\", \"2\");\n    ...\n\n",
 "jsdt_runstring": "### jsdt_runstring(script)\n\n module: app_jsdt\n\nExecute the JS script stored in parameter. The parameter can be a string\nwith pseudo-variables. The script is executed in JS context specific to\nloaded JS files at startup.\n\n    ...\n    if(!jsdt_runstring('KSR.dbg(\"Hello World from $fU\\n\")'))\n    {\n        xdbg(\"failed to execute js script!\\n\");\n    }\n    ...\n\n",
 "uac_replace_from": "### uac_replace_from(display, uri)\n\n module: uac\n\nReplace in FROM header the *display* name and the *URI* part.\n\n*display* and *URI* parameters can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE and from BRANCH_ROUTE.\n\nNOTE: Previous versions of this function added double quotes\nautomatically to display variable. That is no longer the case, if you\nexpect that behavior, you will have to add the quotes by yourself.\n\nIf you set restore_mode to AUTO, the URI will be modified automatically\nin all subsequent requests and replies in that dialog.\n\nThere are two ways in which the AUTO mode can be achieved.\n\nOne uses the rr module and appends to the Record-Route header a\nparameter containing some strings from which the original and new URI\ncan be computed. The problem with this mode is that it relies on the\nfact the parties will send the Route exactly as it was received. In case\nthere is a change, the resulting URIs will not be correct.\n\nThe other one uses the dialog module to store the original and new URI.\nIf you already use dialog module in your configuration, this is the\nadvisable mode. All you need to do to use this is to call dlg_manage()\nbefore calling uac_replace_from(). It works by storing the URIs as\ndialog variables and registering callbacks in dialog module for in\ndialog requests.\n\n    ...\n    # replace both display and uri\n    uac_replace_from(\"$avp(s:display)\",\"$avp(s:uri)\");\n    # replace only display and do not touch uri\n    uac_replace_from(\"batman\",\"\");   # display is replaced with: batman\n    uac_replace_from(\"\\\"batman\\\"\",\"\");  # display is replaced with: \"batman\"\n    # remove display and replace uri\n    uac_replace_from(\"\",\"sip:robin@gotham.org\");\n    # remove display and do not touch uri\n    uac_replace_from(\"\",\"\");\n    ...\n                    \n\n### uac_replace_from(uri)\n\n module: uac\n\nReplace in FROM header the *URI* part without altering the display name.\n\n*URI* parameter can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE and from BRANCH_ROUTE.\n\n    ...\n    uac_replace_from(\"sip:batman@gotham.org\");\n    ...\n                    \n\n",
 "uac_restore_from": "### uac_restore_from()\n\n module: uac\n\nThis function will check if the FROM URI was modified and will use the\ninformation stored in header parameter to restore the original FROM URI\nvalue.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    uac_restore_from();\n    ...\n                    \n\n",
 "uac_replace_to": "### uac_replace_to(display, uri)\n\n module: uac\n\nReplace in TO header the *display* name and the *URI* part.\n\n*display* and *URI* parameters can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE and from BRANCH_ROUTE.\n\nNOTE: Previous versions of this function added double quotes\nautomatically to display variable. That is no longer the case, if you\nexpect that behavior, you will have to add the quotes by yourself.\n\n    ...\n    # replace both display and uri\n    uac_replace_to(\"$avp(display)\",\"$avp(uri)\");\n    # replace only display and do not touch uri\n    uac_replace_to(\"batman\",\"\");   # display is replaced with: batman\n    uac_replace_to(\"\\\"batman\\\"\",\"\");  # display is replaced with: \"batman\"\n    # remove display and replace uri\n    uac_replace_to(\"\",\"sip:robin@gotham.org\");\n    # remove display and do not touch uri\n    uac_replace_to(\"\",\"\");\n    ...\n                    \n\n### uac_replace_to(uri)\n\n module: uac\n\nReplace in TO header the *URI* part without altering the display name.\n\n*URI* parameter can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE and from BRANCH_ROUTE.\n\nIf you set restore_mode to AUTO, the URI will be modified automatically\nin all subsequent requests and replies in that dialog.\n\nThere are two ways in which the AUTO mode can be achieved.\n\nOne uses the rr module and appends to the Record-Route header a\nparameter containing some strings from which the original and new URI\ncan be computed. The problem with this mode is that it relies on the\nfact the parties will send the Route exactly as it was received. In case\nthere is a change, the resulting URIs will not be correct.\n\nThe other one uses the dialog module to store the original and new URI.\nIf you already use dialog module in your configuration, this is the\nadvisable mode. All you need to do to use this is to call dlg_manage()\nbefore calling uac_replace_to(). It works by storing the URIs as dialog\nvariables and registering callbacks in dialog module for in dialog\nrequests.\n\n    ...\n    uac_replace_to(\"sip:batman@gotham.org\");\n    ...\n                    \n\n",
 "uac_restore_to": "### uac_restore_to()\n\n module: uac\n\nThis function will check if the TO URI was modified and will use the\ninformation stored in header parameter to restore the original TO URI\nvalue.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    uac_restore_to();\n    ...\n                    \n\n",
 "uac_auth": "### uac_auth([mode])\n\n module: uac\n\nThis function can be called only from failure route and will build the\nauthentication response header and insert it into the request without\nsending anything.\n\nIf mode is set to 1, then the password has to be provided in HA1 format.\nThe parameter can be a static integer or a variable holding an integer\nvalue.\n\nThis function can be used from FAILURE_ROUTE and BRANCH_FAILURE_ROUTE\nevent route.\n\n    ...\n    modparam(\"uac\",\"auth_username_avp\",\"$avp(auser)\")\n    modparam(\"uac\",\"auth_password_avp\",\"$avp(apass)\")\n    modparam(\"uac\",\"auth_realm_avp\",\"$avp(arealm)\")\n\n    request_route {\n       ...\n       if(is_method(\"INVITE\")) {\n          t_on_failure(\"TRUNKAUTH\");\n       }\n       ...\n    }\n\n    failure_route[TRUNKAUTH] {\n\n        if (t_is_canceled()) {\n            exit;\n        }\n        if(t_check_status(\"401|407\")) {\n            $avp(auser) = \"test\";\n            $avp(apass) = \"test\";\n            # $avp(apass) = \"36d0a02793542b4961e8348347236dbf\";\n            # if (uac_auth(\"1\")) {\n            if (uac_auth()) {\n                t_relay();\n            }\n            exit;\n        }\n    }\n    ...\n                    \n\n",
 "uac_auth_mode": "### uac_auth_mode(vmode)\n\n module: uac\n\nThis function can be called only from failure route and will build the\nauthentication response header and insert it into the request without\nsending anything.\n\nIf mode is set to 1, then the password has to be provided in HA1 format.\nThe parameter can be a static integer or a variable holding an integer\nvalue.\n\nThis function can be used from FAILURE_ROUTE and BRANCH_FAILURE_ROUTE\nevent route.\n\n    ...\n    modparam(\"uac\",\"auth_username_avp\",\"$avp(auser)\")\n    modparam(\"uac\",\"auth_password_avp\",\"$avp(apass)\")\n    modparam(\"uac\",\"auth_realm_avp\",\"$avp(arealm)\")\n\n    request_route {\n       ...\n       if(is_method(\"INVITE\")) {\n          t_on_failure(\"TRUNKAUTH\");\n       }\n       ...\n    }\n\n    failure_route[TRUNKAUTH] {\n\n        if (t_is_canceled()) {\n            exit;\n        }\n        if(t_check_status(\"401|407\")) {\n            $avp(auser) = \"test\";\n            $avp(apass) = \"test\";\n            # $avp(apass) = \"36d0a02793542b4961e8348347236dbf\";\n            if (uac_auth_mode(\"1\")) {\n                t_relay();\n            }\n            exit;\n        }\n    }\n    ...\n                    \n\n",
 "uac_req_send": "### uac_req_send()\n\n module: uac\n\nThis function sends a SIP message from the configuration file. The\nmessage is built out of \\$uac_req(...) pseudo-variable.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, ONREPLY_ROUTE, LOCAL_ROUTE.\n\n    ...\n    $uac_req(method)=\"OPTIONS\";\n    $uac_req(ruri)=\"sip:kamailio.org\";\n    $uac_req(furi)=\"sip:kamailio.org\";\n    $uac_req(turi)=\"sip:kamailio.org\";\n    $uac_req(callid)=$(mb{s.md5});\n    uac_req_send();\n    ...\n                    \n\n",
 "uac_reg_lookup": "### uac_reg_lookup(uuid, dst)\n\n module: uac\n\nThis function sets the PV dst to SIP URI that correspond to uuid in uac\nregistrations table. uuid and dst must be pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n\n    if(uac_reg_lookup(\"$rU\", \"$ru\"))\n    {\n        lookup(\"location\");\n    }\n    ...\n                    \n\n",
 "uac_reg_lookup_uri": "### uac_reg_lookup_uri(uri, dst)\n\n module: uac\n\nThis function sets the PV dst to SIP URI that correspond to the URI user\nin uac registrations table. The uri can contain pseudo-variables and dst\nmust be the name of a pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n\n    if(uac_reg_lookup(\"$var(uri)\", \"$ru\"))\n    {\n        lookup(\"location\");\n    }\n    ...\n                    \n\n",
 "uac_reg_status": "### uac_reg_status(uuid)\n\n module: uac\n\nThis function returns the current registration status for the uuid.\n\nReturn values:\n\n- 1 - a valid registration exists.\n\n- -1 - uuid does not exist or an error occurred while executing the\n  function.\n\n- -2 - a registration attempt is ongoing (and currently there is no\n  valid registration).\n\n- -3 - registration is disabled.\n\n- -99 - no valid registration, waiting for new registration attempt.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(status) = uac_reg_status(\"$rU\");\n    ...\n                    \n\n",
 "uac_reg_request_to": "### uac_reg_request_to(user, mode)\n\n module: uac\n\nThis function can be used to send an authenticated request to a remote\nuser in the uac registrations table. It sets the request-uri, dst-uri\nand auth\\_\\*\\_avp variables to the values that correspond to the\nsupplied user.\n\nThe mode is a bitwise set of flags controlling how the matching of the\nrecord is done and what field is used to set auth_password_avp:\n\n- indicates whether the user should match the local uuid (bit value=0),\n  or the username (bit value=1, int value=1).\n\n- indicates whether the auth_password value is used to set\n  auth_password_avp (bit value=0), or the auth_ha1 value (bit value=1,\n  int value=2).\n\nThe auth\\_\\*\\_avp module parameters must be set to valid pv's.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n\n    if(uac_reg_request_to(\"$fU\", 0))\n    {\n        xlog(\"L_NOTICE\", \"Found remote user [$rU] on [$rd] via [$du]\");\n        t_on_failure(\"REMOTE_AUTH\");\n\n        t_relay()\n    }\n    ...\n    failure_route[REMOTE_AUTH] {\n        if ($T_reply_code == 401 or $T_reply_code == 407) {\n            xlog(\"L_NOTICE\", \"Remote asked for authentication\");\n            uac_auth();\n        }\n    }\n    ...\n                    \n\n",
 "uac_reg_enable": "### uac_reg_enable(attr, val)\n\n module: uac\n\nEnable a remote registration record based on a filter specified by\nattribute and value. The attribute can be: l_uuid, l_username,\nr_username or auth_username. The value is what should be matched against\nthe value of the attribute in the remote registration record.\n\nThe SIP processing is done on the next timer routine.\n\n    ...\n       uac_reg_enable(\"l_uuid\", \"account123\");\n    ...\n                \n\n",
 "uac_reg_disable": "### uac_reg_disable(attr, val)\n\n module: uac\n\nDisable a remote registration record based on a filter specified by\nattribute and value. The attribute can be: l_uuid, l_username,\nr_username or auth_username. The value is what should be matched against\nthe value of the attribute in the remote registration record.\n\nThe SIP processing is done on the next timer routine.\n\n    ...\n       uac_reg_disable(\"l_uuid\", \"account123\");\n    ...\n                \n\n",
 "uac_reg_refresh": "### uac_reg_refresh(luuid)\n\n module: uac\n\nRefresh the uac remote registration record based on local uuid. If the\nrecord was already loaded, new values are taken from database, otherwise\na new record is created.\n\n    ...\n       uac_reg_refresh(\"account123\");\n    ...\n                \n\n",
 "jsonrpc_notification": "### jsonrpc_notification(method, parameters)\n\n module: jsonrpcc\n\nInvokes the remote 'method' with the given 'parameters' as a\nnotification. Unlike jsonrpc_request (below), notifications do not\nreceive a response. Script processing continues in the usual fashion as\nsoon as the notification has been sent.\n\nThe method and parameters can be a static string or dynamic string value\nwith config variables.\n\n    ...\n    jsonrpc_notification(\"update_user\", \"{'id': 1234, 'name': 'Petros'}\")\n    ...\n                    \n\n",
 "jsonrpc_request": "### jsonrpc_request(method, parameters, return_route, error_route, result_var)\n\n module: jsonrpcc\n\nInvokes the remote 'method' with the given 'parameters'. When the\nresponse is received, continues processing of the SIP request with the\nroute\\[return_route\\]. If a timeout occurs, no servers can be reached,\nor a jsonrpc error message is received, continues process at\nroute\\[error_route\\]. In this case, the result_var will contain one of\n\"timeout\", \"failure\", or the error message received back from the\njsonrpc server.\n\nThe method, parameters, return_route, and error_route can be a static\nstring or a dynamic string value with config variables.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution is lost. As mentioned above, only shared variables\n(\\$shv, etc) should be used for any value that will be needed when the\nscript is resumed.\n\nThe result is stored in the pseudo-variable 'result_var'. Since this\nvariable is set *after* the response is received, it is possible to use\na \\$var for this parameter.\n\n    ...\n    jsonrpc_request(\"get_user\", \"{'id': 1234}\", \"RESPONSE\", \"ERROR\", \"$var(result)\");\n    ...\n    route[RESPONSE] {\n        xlog(\"Result received: $var(result)\");\n        ...\n    }\n    ...\n    route[ERROR] {\n        xlog(\"Error received: $var(result)\");\n        ...\n    }\n    ...\n                    \n",
 "sip_trace": "### sip_trace([address][, correlation_id][, mode])\n\n module: siptrace\n\nStore or forward the current processed SIP message/transaction/dialog in\na database. It is stored in the form prior applying changes made to it.\nBased on mode, one can trace the current message('m'), the current\ntransaction('t') or the current dialog('d'). If no mode is given, it\nfalls back to the default mode - transaction tracking when trace_flag is\nset, otherwise only the current message.\n\nMeaning of the parameters is as follows:\n\n- *address* - The address in form of SIP URI where to send a duplicate\n  of traced message. This parameter trumps duplicate_uri and allows\n  tracing to more than one server.\n\n- *correlation_id* - A string with a correlation ID to be added to the\n  HEP header when using HEPv3. It's possible to use PVs.\n\n- *mode* - SIP messages to be traced. One can trace the current message\n  (function can be called on either a reply or a request), the current\n  transaction(the route must belong to a request) or the current\n  dialog(the message has to be an invite).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\nDefault value is \"NULL\".\n\n    ...\n    sip_trace();\n    ...\n    sip_trace(\"sip:10.1.1.2:5085\");\n    ...\n    sip_trace(\"sip:10.1.1.2:5085\", \"$ci-abc\");\n    ...\n    /* trace current dialog; needs to be done on initial INVITE and dialog has to be loaded */\n    sip_trace(\"sip:10.1.1.2:5085\", \"$ci-abc\", \"d\");\n    ...\n\n",
 "sip_trace_mode": "### sip_trace_mode(tmode)\n\n module: siptrace\n\nSet the tracing mode: message, transaction or dialog. Only the first\ncharacter of the parameter matters: m or M for message; t or T for\ntransaction; d or D for dialog.\n\nIn message tracing mode only the current message is stored or mirrored.\nIn transaction tracing mode, all the messages of the current transaction\nare stored or mirrored. In dialog tracing mode, all the messages of the\ncurrent dialog are stored or mirrored.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    sip_trace_mode(\"t\");\n    ...\n\n",
 "hlog": "### hlog([correlation_id,] message)\n\n module: siptrace\n\nSends a log event as a HEP3 packet to the homer host configured in\n*duplicate_uri*.\n\nMeaning of the parameters is as follows:\n\n- *correlation_id* (optional) - Homer correlation ID for this event. If\n  this parameter is not set, the current message's call-id will be used.\n  (This parameter may contain PVs)\n\n- *message* - The text to send to Homer as log event. (This parameter\n  may contain PVs)\n\n<!-- -->\n\n    ...\n    hlog(\"[cfg:$cfg(line)] This is a log from kamailio to Homer\");\n    ...\n    hlog(\"$hdr(P-MyID)\", \"Another one with a custom correlation ID\");\n    ...\n\n",
 "check_uri": "### check_uri(uri)\n\n module: uri_db\n\nCheck the username from the given uri against URI table (if\nuse_uri_table is set) or digest credentials (no DB backend required).\n\nDescription of parameters:\n\n- *uri* Has to be a valid SIP URI, used to extract the username from.\n  The parameter can be a static or dynamic (with variables) string.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (check_uri(\"$var(uri)\")) {\n        ...\n    };\n    ...\n\n",
 "exec_dset": "### exec_dset(command)\n\n module: exec\n\nExecutes an external command. Current URI is passed to the command as\nparameter. Output of the command is considered URI set (separated by\nlines).\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables;\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_dset(\"print-contact.sh '\\$ct'\");\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    exec_dset(\"echo TEST > /tmp/test.txt\");\n    exec_dset(\"echo TEST > /tmp/$(rU).txt\");\n    ...\n\n",
 "exec_msg": "### exec_msg(command)\n\n module: exec\n\nExecutes an external command. The whole message is passed to it in\ninput, no command-line parameters are added, output of the command is\nnot processed.\n\nThe \u201cexamples\u201d directory in the source tarball contains several examples\nthat shows how to use this function.\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables.\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_msg(\"print-contact.sh '\\$ct'\");\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    exec_msg(\"echo TEST > /tmp/test.txt\");\n    exec_msg(\"echo TEST > /tmp/$(rU).txt\");\n    ...\n\n",
 "exec_avp": "### exec_avp(command [, avplist])\n\n module: exec\n\nExecutes an external command. Each line from output of the command is\nsaved in an AVP from 'avplist'. If 'avplist' is missing, the AVPs are\nnamed 1, 2, 3, ...\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables;\n\n- *avplist* - comma separated list with AVP names to store the result\n  in;\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_avp(\"print-contact.sh '\\$ct'\");\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    exec_avp(\"echo TEST\");\n    exec_avp(\"echo TEST\", \"$avp(s:test)\");\n    ...\n\n",
 "exec_cmd": "### exec_cmd(command)\n\n module: exec\n\nExecutes an external command. It is a lightweight version, which does\nnot pass the SIP message as parameter, does not set the environment\nvariables and it does not use the output of the command.\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables.\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_msg(\"print-contact.sh '\\$ct'\");\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    exec_cmd(\"echo TEST > /tmp/test.txt\");\n    exec_cmd(\"echo TEST > /tmp/$(rU).txt\");\n    ...\n\n",
 "print_stderr": "### print_stderr(txt)\n\n module: print_lib\n\nPrints string to stderr.\n\nMeaning of the parameters is as follows:\n\n- *txt* - string to be printed.\n\n<!-- -->\n\n    ...\n    print_stderr(\"The answer is 42\\n\");\n    ...\n            \n",
 "secsipid_check_identity": "### secsipid_check_identity(keyPath)\n\n module: secsipid\n\nCheck the validity of the Identity header using the keys stored in the\nfile specified by \"keyPath\". If the parameter is empty, the function is\ndownloading the key using the URL from \"info\" parameter of the Identity\nheader, using the value of \"timeout\" parameter to limit the download\ntime. The validity of the JWT body in the Identity header is also\nchecked against the \"expire\" parameter.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(secsipid_check_identity(\"/secsipid/$si/cert.pem\")) { ... }\n        ...\n        if(secsipid_check_identity(\"\")) { ... }\n        ...\n    }\n    ...\n\nFurther checks can be done with config operations, decoding the JWT\nheader and payload using {s.select} and {s.decode.base64t}\ntransformations together with jansson module.\n\n",
 "secsipid_check_identity_pubkey": "### secsipid_check_identity_pubkey(pubkeyVal)\n\n module: secsipid\n\nSimilar to secsipid_check_identity() with the public key value provided\nin the parameter.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n      ...\n      http_client_query(\"https://provider.com/stir-shaken/cert.pem\", \"$var(pubkey)\");\n      ...\n      if(secsipid_check_identity_pubkey(\"$var(pubkey)\")) { ... }\n      ...\n    }\n    ...\n\n",
 "secsipid_check": "### secsipid_check(sIdentity, keyPath)\n\n module: secsipid\n\nCheck the validity of the \"sIdentity\" parameter using the keys stored in\nthe file specified by \"keyPath\". If the keyPath parameter is empty, the\nfunction is downloading the key using the URL from \"info\" parameter of\nthe sIdentity, using the value of \"timeout\" parameter to limit the\ndownload time. The validity of the JWT in the sIdentity value is also\nchecked against the \"expire\" parameter.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(secsipid_check(\"...\", \"/secsipid/$si/cert.pem\")) { ... }\n        ...\n        if(secsipid_check(\"...\", \"\")) { ... }\n        ...\n    }\n    ...\n\nFurther checks can be done with config operations, decoding the JWT\nheader and payload using {s.select} and {s.decode.base64t}\ntransformations together with jansson module.\n\n",
 "secsipid_get_url": "### secsipid_get_url(url, ovar)\n\n module: secsipid\n\nGet the content of a URL and store the result in a variable.\n\nThe url parameters can contain pseudo-variables and ovar has to be the\nname of a writable pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n      ...\n      if(secsipid_get_url(\"https://$fd/stirshaken/cert.pem\", \"$var(pubkey)\")) { ... }\n      ...\n    }\n    ...\n\n",
 "secsipid_add_identity": "### secsipid_add_identity(origTN, destTN, attest, origID, x5u, keyPath)\n\n module: secsipid\n\nAdd Identity header using the key specified by \"keyPath\" to sign the JWT\nbody. If origID is empty, a UUID string is generated to fill the field.\nThe origTN represents the origination telephone number; destTN\nrepresents the destination telephone number; x5u is the HTTP URL\nreferencing to the public key that should be used to verify the\nsignature; attest represents the attestation level (should be \"A\", \"B\"\nor \"C\").\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        secsipid_add_identity(\"$fU\", \"$rU\", \"A\", \"\",\n            \"https://kamailio.org/stir/$rd/cert.pem\", \"/secsipid/$rd/key.pem\");\n        ...\n    }\n    ...\n\n",
 "secsipid_build_identity": "### secsipid_build_identity(origTN, destTN, attest, origID, x5u, keyPath)\n\n module: secsipid\n\nBuild Identity value using the key specified by \"keyPath\" to sign the\nJWT body. If origID is empty, a UUID string is generated to fill the\nfield. The origTN represents the origination telephone number; destTN\nrepresents the destination telephone number; x5u is the HTTP URL\nreferencing to the public key that should be used to verify the\nsignature; attest represents the attestation level (should be \"A\", \"B\"\nor \"C\"). On success, the Indentity value is stored in variable\n\\$secsipid(val). It also sets \\$secsipid(ret) to the return value of the\nlibsecsipid functions.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(secsipid_build_identity(\"$fU\", \"$rU\", \"A\", \"\",\n                \"https://kamailio.org/stir/$rd/cert.pem\", \"/secsipid/$rd/key.pem\")) {\n            xinfo(\"Identity value: $secsipid(val)\\n\");\n        }\n        ...\n    }\n    ...\n\n",
 "secsipid_build_identity_prvkey": "### secsipid_build_identity_prvkey(origTN, destTN, attest, origID, x5u, keyData)\n\n module: secsipid\n\nSimilar to secsipid_build_identity(), but the private key data is\nprovided as parameter instead to the file path.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(secsipid_build_identity_prvkey(\"$fU\", \"$rU\", \"A\", \"\",\n                \"https://kamailio.org/stir/$rd/cert.pem\", \"$var(prvkey)\")) {\n            xinfo(\"Identity value: $secsipid(val)\\n\");\n        }\n        ...\n    }\n    ...\n\n",
 "secsipid_sign": "### secsipid_sign(sheaders, spaypload, keyPath)\n\n module: secsipid\n\nBuild Identity value using the key specified by \"keyPath\" to sign the\nJWT body. The sheaders and spayload have to be string representation of\nJSON headers and payload to be signed. On success, the Indentity value\nis stored in variable \\$secsipid(val). It also sets \\$secsipid(ret) to\nthe return value of the libsecsipid functions.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(secsipid_sign(\"_JSON_HEADERS_\", \"_JSON_PAYLOAD_\",\n                \"/secsipid/$rd/key.pem\")) {\n            xinfo(\"Identity value: $secsipid(val)\\n\");\n        }\n        ...\n    }\n    ...\n\n",
 "tmrec_match": "### tmrec_match(timerec [, timestamp])\n\n module: tmrec\n\nMatch a time recurrence rule against the timestamp (UNIX epoch format).\nIf the timestamp parameter is missing, the current UNIX epoch time is\nused.\n\nThe parameters can include pseudo-variables.\n\nThe timerec paramter is a list of attributes defined by RFC2445,\ndelimited by the 'separator' (module parameter) character. The format of\ntimerec parameter, using '\\|' as the separator, is (all in one line\nwithout white spaces):\n\n    ...\n    [startdate]|[duration]|[frequency]|[until]|[interval]|[byday]\n      |[bymonthday]|[byyearday]|[byweekno]|[bymonth]\n    ...\n\nWhen an attribute is not specified, the corresponding place must be left\nempty, provided that one or more additional attributes follow.\n\nDescription of time recurrence attributes:\n\n- *startdate* - date for the start of the first period.\n\n- *duration* - the duration of the time period. For a recurring\n  interval, the \u201cduration\u201d parameter MUST be small enough such that\n  subsequent intervals do not overlap. For non-recurring intervals,\n  durations of any positive length are permitted. Zero-length duration\n  means \u201cforever\u201d. Negative-length durations are not allowed.\n\n  See RFC 2445 for the format of duration. In short for common cases\n  when the duration doesn't exceed a data, it must start with PT\n  followed by the value for hours, minutes or seconds - e.g., a duration\n  of 8 hours must be written as PT8H.\n\n- *frequency* - can be one of the following values: \u201cdaily\u201d - specify\n  repeating periods based on an interval of a day or more; \u201cweekly\u201d -\n  specify repeating periods based on an interval of a week or more;\n  \u201cmonthly\u201d - specify repeating periods based on an interval of a month\n  or more; \u201cyearly\u201d - specify repeating periods based on an interval of\n  a year or more. These values are case-insensitive.\n\n- *until* - defines an iCalendar COS DATE or DATE-TIME value which\n  bounds the recurrence rule in an inclusive manner. If the value\n  specified by \u201cuntil\u201d is synchronized with the specified recurrence,\n  this date or date-time becomes the last instance of the recurrence. If\n  it is not present, the recurrence is considered to repeat forever.\n\n- *interval* - a positive integer representing how often the recurrence\n  rule repeats. The default value is \u201c1\u201d, meaning every day for a\n  \u201cdaily\u201d rule, every week for a \u201cweekly\u201d rule, every month for a\n  \u201cmonthly\u201d rule and every year for a \u201cyearly\u201d rule.\n\n- *byday* - a comma-separated list short codes of days of the week. The\n  days are specified as: \u201cMO\u201d for Monday; \u201cTU\u201d for Tuesday; \u201cWE\u201d for\n  Wednesday; \u201cTH\u201d for Thursday; \u201cFR\u201d for Friday; \u201cSA\u201d for Saturday; \u201cSU\u201d\n  for Sunday. These values are case insensitive.\n\n  Each \u201cbyday\u201d value can also be prefixed by a positive (+n) or negative\n  (-n) integer. If present, this indicates the n-th occurrence of the\n  specific day within the \u201cmonthly\u201d or \u201cyearly\u201d recurrence. For example,\n  within a \u201cmonthly\u201d rule, +1MO (or simply 1MO) represents the first\n  Monday within the month, whereas -1MO represents the last Monday of\n  the month. If an integer modifier is not present, it means all days of\n  this type within the specified frequency. For example, within a\n  \u201cmonthly\u201d rule, MO represents all Mondays within the month.\n\n- *bymonthday* - a comma-separated list of days of the month. Valid\n  values are 1 to 31 or -31 to -1. For example, -10 represents the tenth\n  to the last day of the month.\n\n- *byyearday* - a comma-separated list of days of the year. Valid values\n  are 1 to 366 or -366 to -1. For example, -1 represents the last day of\n  the year (December 31st) and -306 represents the 306th day before the\n  last day of the year (March 1st).\n\n- *byweekno* - a comma-separated list of ordinals specifying weeks of\n  the year. Valid values are 1 to 53 or -53 to -1.\n\n- *bymonth* - parameter specifies a comma-separated list of months of\n  the year. Valid values are 1 to 12.\n\nA recurrence is specified by including the \u201cfrequency\u201d parameter, which\nindicates the type of the recurrence rule. Parameters other than\n\u201cstartdate\u201d and \u201cduration\u201d SHOULD NOT be specified unless \u201cfrequency\u201d is\nset.\n\nIf invalid byxxx parameter values are found (ie, bymonthday=\u201c30\u201d in\nFebruary), they are simply ignored.\n\nByxxx parameters modify the recurrence rule matching. The Byxxx rule, as\nan attribute for a period of time which is greater than or equal to the\nfrequency, generally reduces or limits the number of occurrences for the\nrecurrence definition. For example, frequency=\u201cdaily\u201d bymonth=\u201c3\u201d\nreduces the number of recurrence instances from all days (if the\n\u201cbymonth\u201d parameter is not present) to all days in March. Byxxx\nparameters for a period of time less than the frequency generally\nincreases or expands the number of occurrences of the recurrence. For\nexample, frequency=\u201cyearly\u201d bymonth=\u201c8,9\u201d increases the number of days\nwithin the yearly recurrence set from 1 (if \u201cbymonth\u201d parameter is not\npresent) to 2.\n\nIf multiple Byxxx parameters are specified, then after evaluating the\nspecified \u201cfrequency\u201d and \u201cinterval\u201d parameters, the Byxxx parameters\nare applied to the current set of evaluated occurrences in the following\norder: \u201cbymonth\u201d, \u201cbyweekno\u201d, \u201cbyyearday\u201d, \u201cbymonthday\u201d, \u201cbyday\u201d; then\n\u201cuntil\u201d is evaluated.\n\nNext is an example of evaluating multiple Byxxx parameters.\n\nstartdate=\u201c20100101T093000\u201d duration=\u201cPT10H30M\u201d frequency=\u201cyearly\u201d\ninterval=\u201c4\u201d bymonth=\u201c3\u201d byday=\u201cSU\u201d\n\nFirst, the interval=\u201c4\u201d would be applied to frequency=\u201cyearly\u201d to match\non \u201cevery 4th year\u201d . Then, bymonth=\u201c1\u201d would be applied to match on\n\u201cevery March, every 4th year\u201d. Then, byday=\u201cSU\u201d would be applied to\nmatch on \u201cevery Sunday in March, every 4th year, from 9:30 to 20:00 \u201d.\nThe start and end hours:minutes have been retrieved from the \u201cstartdate\u201d\nand \u201cduration\u201d parameters.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n        if(tmrec_match(\"20120101T000000|PT24H|weekly|||SA,SU\")\n            xdbg(\"it is weekend!\\n\");\n        if(tmrec_match(\"20120101T083000|PT10H|weekly|||MO,TU,WE,TH,FR\")\n            xdbg(\"it is with working hours\\n\");\n    ...\n\n",
 "is_leap_year": "### is_leap_year([year])\n\n module: tmrec\n\nReturn true if the value from parameter is a leap year. If the parameter\nis missing, then the year from the current time is taken.\n\nThe parameter can be pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    if(is_leap_year(\"2010\"))\n    ...\n\n",
 "time_period_match": "### time_period_match(period [, timestamp])\n\n module: tmrec\n\nMatches the point in time specified by the timestamp parameter, or the\ncurrent time if the parameter is missing, against the given period\nspecification. Returns 1 if it matches, -1 if it doesn't, and a value\n\\<= -2 if there was an error.\n\nThe time period specification follows the Perl Time::Period module. It\nis a string and consists of zero or more sub-period specifications,\nseparated by commas. The period matches if at least one of the\nsub-periods matches, or if no sub-periods were given at all (an empty\nstring).\n\nEach sub-period is a list of one or more scale definitions, optionally\nseparated by space characters. The sub-period matches if all of the\ngiven scales within that sub-period match. For each scale given, a\nsingle value or a range of values (which is two values separated by a\nhyphen) can be specified. Multiple values or multiple ranges (or a\ncombination thereof) within a single scale is also possible. If a\ncertain scale is specified more than once, the previous values or ranges\nfor that scale are extended by the newly given ones. If a particular\nscale is not mentioned at all within a sub-period, then no matching is\nperformed for that scale.\n\nThe following scales are supported and understood. Each scale also has a\nrespective short code, either one can be used. A single scale definition\nconsists of the scale name, followed by an opening brace, followed by\nthe list of values, followed by a closing brace.\n\n- *year* or *yr* - Either given as a full 4-digit number \\>= 1970, or as\n  a 2-digit number, in which case it will be understood to be within the\n  current century.\n\n- *month* or *mo* - Month of the year, either a number between 1 and 12,\n  or at least the first 3 letters of a spelled out month name, e.g.\n  \u201cjan\u201d, \u201cjanua\u201d or \u201cjanuary\u201d will all work.\n\n- *week* or *wk* - Week of the month, a number between 1 and 6. The\n  first day of the week is Sunday.\n\n- *yday* or *yd* - Day of the year, a number between 1 and 366.\n\n- *mday* or *md* - Day of the month, a number between 1 and 31.\n\n- *wday* or *wd* - Day of the week, either a number between 1 and 7, or\n  at least the first 2 letters of a spelled out weekday name (analogous\n  to the \u201cmonth\u201d scale). Sunday is the first day of the week.\n\n- *hour* or *hr* - A number between 0 and 23. Unlike the Perl\n  Time::Period module, \u201cam\u201d or \u201cpm\u201d specifications are not supported.\n\n- *minute* or *min* - A number between 0 and 59.\n\n- *second* or *sec* - A number between 0 and 60 (to allow for leap\n  seconds).\n\nThe parameters can include pseudo-variables. Whitespace (more precisely,\nthe space character only) can occur anywhere, but is optional. Ranges in\nall scales (with the exception of the \u201cyear\u201d scale) are allowed to\nwrap-around, e.g. a weekday scale of \u201c{fri-tue}\u201d is equivalent to\n\u201c{fri-sat,sun-tue}\u201d.\n\n    ...\n    if(time_period_match(\"wd{2-6} hr{8-16}, wd{2-6} hr{17} min{0-29}\"))\n        xdbg(\"Monday to Friday, 8:00 to 17:30\\n\");\n\n    if(time_period_match(\"wday { sat sun }, wday {mo-fr} hr {17-8},wd{mo-wed}hr{15 16 9}\"))\n        xdbg(\"We're closed - open only Monday to Wednesday 10:00-15:00, Thursday and Friday 9:00-17:00\");\n    ...\n",
 "dbg_breakpoint": "### dbg_breakpoint(mode)\n\n module: debugger\n\nAnchor a breakpoint at the current line of the config (the one on which\nthis function is called). The 'mode' specifies whether the breakpoint is\nenabled (1) or disabled (0) at startup.\n\nNote that this version of the module does not export this anchors to RPC\nfor interactive debugging (temporarily disabled).\n\n    ...\n    if($si==\"10.0.0.10\")\n        dbg_breakpoint(\"1\");\n    ...\n\n",
 "dbg_pv_dump": "### dbg_pv_dump([mask] [, level])\n\n module: debugger\n\nPrints the content of pv_cache on json format. Defaults are mask=31 and\nlevel = \"L_DBG\"\n\n<!-- -->\n\n    ...\n    $var(temp) = 1;\n    $avp(s:more_avp) = 2;\n    $avp(s:more_avp) = 3;\n    $xavp(x=>more) = \"bye\";\n    $xavp(x[0]=>more) = \"hi\";\n    $xavp(x[0]=>other) = 1;\n    $xavp(x[0]=>other) = 2;\n    $xavp(x=>different) = \"foo\";\n    $var(empty) = $null;\n\n    dbg_pv_dump(30, \"L_DBG\");\n    ...\n\nOutput\n\n    ...\n     4(30943) DEBUG: debugger [debugger_api.c:1613]: dbg_dump_json(): {\"$sp\":37597,\"$var(rc)\":0,\"$var(temp)\":1,\"$avp(more_avp)\":[3,2],\"$si\":\"127.0.0.1\",\"$rc\":0,\"$xavp(x)\":[{\"different\":[\"foo\"]},{\"other\":[2,1],\"more\":[\"hi\",\"bye\"]}],\"$T_branch_idx\":0,\"$var(empty)\":0}\n     ...\n\n",
 "dbg_sip_msg": "### dbg_sip_msg([log_level], [facility])\n\n module: debugger\n\nPrints how the sip message *would look* like if it *would be sent* out\nat that point in the config(i.e. if the current lump lists would have\nbeen applied at that point in the config). It also prints a diff list\nfor both header and body of sip msg which contain the lump lists\ncontent. The lumps deleted are printed with \"-\" sign whereas the lumps\nadded have no sign. The config line where the function has been called\nis also printed.\n\nNOTE that dbg_sip_msg function does not modify the initially received\nSIP message. Just displays how it WOULD look like if it were to send it\nat that point.\n\nNOTE that the lump lists are usually applied only once, just before\nsending, to spare message reparse processing. All the changes present in\nlump list are applied on the *initially received* SIP message. One can\nforce the lump application using msg_apply_changes() function from\ntextopsx module.\n\n    ...\n        dbg_sip_msg();\n        dbg_sip_msg(\"L_ERR\");\n        dbg_sip_msg(\"L_ERR\", \"LOG_LOCAL0\");\n    ...\n            \n\nOutput when dbg_sip_msg(\"L_ERR\") is called after *append_hf(\"P-Hint: My\nhint\\r\\n\"); remove_hf(\"Contact\");*\n\n    ERROR: debugger [debugger_mod.c:467]: w_dbg_sip_msg(): CONFIG LINE 338\n    ------------------------- START OF SIP message debug --------------------------\n    OPTIONS sip:nobody@127.0.0.1 SIP/2.0\n    Via: SIP/2.0/UDP 127.0.1.1:56872;branch=z9hG4bK.6d7c487a;rport;alias\n    From: sip:sipsak@127.0.1.1:56872;tag=188b7433\n    To: sip:nobody@127.0.0.1\n    Call-ID: 411792435@127.0.1.1\n    CSeq: 1 OPTIONS\n    Content-Length: 0\n    Max-Forwards: 70\n    User-Agent: sipsak 0.9.6\n    Accept: text/plain\n    P-Hint: My hintt\n\n    ------------------------------ SIP header diffs -------------------------------\n    - Contact: sip:sipsak@127.0.1.1:56872\n    P-Hint: My hint\n    ------------------------------- SIP body diffs --------------------------------\n    -------------------------- END OF SIP message debug ---------------------------\n            \n\n",
 "set_iattr": "### set_iattr(attribute, value)\n\n module: avp\n\nCreate an AVP of type integer.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP to be created.\n\n- *value* - Integer value of the AVP.\n\n<!-- -->\n\n    ...\n    set_iattr(\"fr_inv_timer\", \"60\")\n    ...\n            \n\n",
 "flags2attr": "### flags2attr(\"$avp\")\n\n module: avp\n\nStore the current state of Kamailio flags into the specified AVP.\n\n    ...\n    flags2attr(\"$msg_flags\")\n    ...\n            \n\n",
 "set_sattr": "### set_sattr(attribute, value)\n\n module: avp\n\nCreate an AVP of type string.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP to be created.\n\n- *value* - String value of the AVP.\n\n<!-- -->\n\n    ...\n    set_sattr(\"called_number\", \"1234\")\n    ...\n            \n\n",
 "print_attr": "### print_attr($attribute)\n\n module: avp\n\nPrint the value of an AVP to syslog.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n",
 "attr2uri": "### attr2uri($attribute[, uri-part])\n\n module: avp\n\nRewrite the whole Request-URI of the message being processed with the\nvalue of an AVP, or if an `uri-part` is specified, rewrite only that\nspecific part.\n\nMeaning of the parameter is as follows:\n\n- *\\$attribute* - The name of the AVP.\n\n- *uri-part* - The name of the part of the uri that will be rewritten.\n  The supported values are: \"prefix\", \"uri\", \"username\", \"user\",\n  \"usernamepassword\", \"userpass\", \"domain\", \"host\", \"domainport\",\n  \"hostport\", \"port\", \"strip\", \"strip_tail\". \"prefix\" will add the AVP\n  as a prefix to the username (equivalent to prefix(\"string\")), \"strip\"\n  and \"strip_tail\" expect a number in the AVP and they will remove the\n  specified number of characters from the beginning, respective the end\n  of the username part of the uri. The rest of the uri-part values names\n  are self-explaining.\n\n",
 "attr_exists": "### attr_exists(attribute)\n\n module: avp\n\nTest for the existence of AVP with given name. The function returns 1 if\ngiven AVP exists and -1 if not.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n<!-- -->\n\n    ...\n    if (attr_exists(\"saved_ruri\")) {\n        attr2uri(\"saved_uri\");\n    } else {\n        rewriteuri(\"sip:a@iptel.org\");\n    };\n    ...\n            \n\n",
 "attr_equals": "### attr_equals(attribute, value)\n\n module: avp\n\nTest whether an AVP with given name and value exists. The function\nreturns 1 if the AVP with given name and value exists and -1 if not. The\nvalue of the AVP is compared string-wise. The comparison is case\nsensitive.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n- *value* - The AVP value to look for.\n\n",
 "attr_equals_xl": "### attr_equals_xl(attribute, xl_format)\n\n module: avp\n\nTest whether an AVP with given name and value exists. The function\nreturns 1 if the AVP with given name and value exists and -1 if not. The\nvalue of the AVP is compared string-wise to the result of xprint\nformatting call. The comparison is case sensitive.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n- *xl_format* - The xprint formatting string, result of which is looked\n  for in AVP.\n\nNote: You must ensure, that the xprint module is loaded to be able to\nuse this function.\n\n    ...\n    if (attr_equals_xl(\"my_avp\", \"%ct\")) {\n      # my_avp has value equal to current Contact header field\n    } else {\n      # my_avp was different\n    }\n    ...\n            \n\n",
 "dump_attrs": "### dump_attrs()\n\n module: avp\n\nDumps all AVPs in user lists to the debug output (with level INFO).\n\nThe function does not require any parameters.\n\n",
 "xlset_attr": "### xlset_attr($attribute, xl_format)\n\n module: avp\n\nCreates new AVP identified by *attribute* and assigns the result string\nof xprint formatting rules as its value.\n\nMeaning of the parameter is as follows:\n\n- *\\$attribute* - The name of the AVP.\n\n- *xl_format* - String used for xprint formatting. For detailed info see\n  documentation of xprint module.\n\nNote: You must ensure, that the xprint module is loaded to be able to\nuse this function.\n\n",
 "xlfix_attr": "### xlfix_attr($attribute)\n\n module: avp\n\nFixes an xl formatted *attribute* value to pure string.\n\nMeaning of the parameter is as follows:\n\n- *\\$attribute* - The name of the AVP.\n\n",
 "insert_attr_hf": "### insert_attr_hf(name)\n\n module: avp\n\nInserts new header into the request, which is being forwarded. The AVP\nname is the name of the header field. If you need to insert header with\nname which differs from the AVP name use\n`insert_attr_hf(header_name, $avp_name)` instead.\n\nInserting means putting the header to the beginning of the request,\nbefore any others.\n\nMeaning of the parameter is as follows:\n\n- *name* - The name of the header field which is inserted into forwarded\n  request as well as name of AVP which's value is put as the header\n  field value.\n\n### insert_attr_hf(header_name, $avp_name)\n\n module: avp\n\nInserts new header into the request, which is being forwarded.\n\nInserting means putting the header to the beginning of the request,\nbefore any others.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is inserted into\n  forwarded request.\n\n- *\\$avp_name* - The name of AVP which's value is put as the header\n  field value.\n\n<!-- -->\n\n    ...\n    set_sattr(\"my_route\",\"<sip:user@host:port;lr>\");\n    insert_attr_hf(\"Route\", \"$my_route\");\n    ...\n            \n\n",
 "append_attr_hf": "### append_attr_hf(name)\n\n module: avp\n\nAppends new header into the request, which is being forwarded. The AVP\nname is the name of the header field. If you need to append header with\nname which differs from the AVP name use\n`append_attr_hf(header_name, $avp_name)` instead.\n\nAppending means putting the header to the end of the request, after any\nothers.\n\nMeaning of the parameter is as follows:\n\n- *name* - The name of the header field which is appended into forwarded\n  request as well as name of AVP which's value is put as the header\n  field value.\n\n### append_attr_hf(header_name, $avp_name)\n\n module: avp\n\nAppends new header into the request, which is being forwarded.\n\nAppending means putting the header to the end of the request, after any\nothers.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is appended into\n  forwarded request.\n\n- *\\$avp_name* - The name of AVP which's value is put as the header\n  field value.\n\n",
 "replace_attr_hf": "### replace_attr_hf(name)\n\n module: avp\n\nReplaces header in the request, which is being forwarded. The AVP name\nis the same as the name of the header field. If you need to replace\nheader with name which differs from the AVP name use\n`replace_attr_hf(header_name, $avp_name)` instead.\n\nReplacing means removing all the headers with specified name and\nappending new one at the end, with the value from AVP.\n\nMeaning of the parameter is as follows:\n\n- *name* - The name of the header field which is replaced in forwarded\n  request as well as name of AVP which's value is put as the header\n  field value.\n\n### replace_attr_hf(header_name, $avp_name)\n\n module: avp\n\nReplaces header in the request, which is being forwarded.\n\nReplacing means removing all the headers with specified name and\nappending new one at the end, with the value from AVP.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is replaced in\n  forwarded request.\n\n- *\\$avp_name* - The name of AVP which's value is put as the header\n  field value.\n\n",
 "attr_to_reply": "### attr_to_reply(name)\n\n module: avp\n\nAppends new header into the reply at the request time processing. The\nAVP name is the name of the header field. If you need to append header\nwith name which differs from the AVP name use\n`attr_to_reply(header_name, $avp_name)` instead.\n\nIf you need to append headers during reply processing you can use\ninsert_attr_hf and append_attr_hf. This function stores data and waits\nfor the reply being created.\n\nMeaning of the parameter is as follows:\n\n- *name* - The name of the header field which is appended into reply as\n  well as name of AVP which's value is put as the header field value.\n\n### attr_to_reply(header_name, $avp_name)\n\n module: avp\n\nAppends new header into the reply at the request time processing.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is appended into\n  reply.\n\n- *\\$avp_name* - The name of AVP which's value is put as the header\n  field value.\n\n<!-- -->\n\n    ...\n    xlset_attr(\"$my_route\",\"<sip:%Hf:5080;lr>\";\n    attr_to_reply(\"P-Hint-Route\", \"my_route\");\n    ...\n            \n\n",
 "attr_destination": "### attr_destination($avp_name)\n\n module: avp\n\nSets the destination of the forwarded request to the value of AVP, which\nmust be either a SIP URI or a string in nameaddr format (e.g. \"Foo Bar\"\n\\<sip:uri\\>).\n\nMeaning of the parameter is as follows:\n\n- *\\$avp_name* - The name of AVP which's value is used for further\n  request forwarding.\n\n<!-- -->\n\n    ...\n    xlset_attr(\"$my_route\",\"<sip:%<next_host>:%<next_port>;myparam=a123;lr>\");\n    insert_attr_hf(\"Route\", \"$my_route\");\n    attr_destination(\"$my_route\");\n    t_relay();\n    ...\n            \n\n",
 "xlset_destination": "### xlset_destination(xl_format)\n\n module: avp\n\nSets the destination of the forwarded request to the value of result of\nxprint formatted string. Either SIP URI or nameaddr format is allowed.\n\nMeaning of the parameter is as follows:\n\n- *xl_format* - xprint module formatting string, the result is used for\n  request forwarding.\n\nNote: You must ensure, that the xprint module is loaded to be able to\nuse this function.\n\n    ...\n    xlset_destination(\"%<next_host>:%<next_port>\");\n    t_relay();\n    ...\n            \n\n",
 "subst_attr": "### subst_attr($avp_name, subst_re)\n\n module: avp\n\nThe value of the AVP identified by *\\$avp_name* name is matched and\nsubstitued according to the *subst_re* sed like expression. Result of\nthe substitution is then stored in the original AVP.\n\nMeaning of the parameter is as follows:\n\n- *\\$avp_name* - Name of the AVP which will be used for the\n  substitution.\n\n- *subst_re* - SED like match&replace regullar expression.\n\n<!-- -->\n\n    ...\n    subst_attr(\"$uri\",\"/tel:[0-9]*/sip:\\1@foo.bar;user=phone/\");\n    ...\n            \n\n",
 "del_attr": "### del_attr($avp_name)\n\n module: avp\n\nThe AVP identified by *\\$avp_name* name is deleted.\n\nMeaning of the parameter is as follows:\n\n- *\\$avp_name* - Name of the AVP which will be deleted.\n\n<!-- -->\n\n    ...\n    failure_route[1] {\n        if (status=~4[0-9][0-9]) {\n            if (attr_exists(\"backup_gw\") {\n                append_branch;\n                attr_destination(\"backup_gw\");\n                del_attr(\"backup_gw\");\n                t_relay();\n            }\n        }\n    ...\n            \n\n",
 "hdr_body2attrs": "### hdr_body2attrs(headername, prefix)\n\n module: avp\n\nFunction parses a header body content scans for fld1=val1,fld2=val2,...\nand creates bunch of avps prefixfld1:= val1, prefixfld2:= val2, .... If\npossible stores values as integers.\n\nMeaning of the parameter is as follows:\n\n- *headername* - The header name, which will be scanned for the\n  name=value pairs.\n\n  If you want to create only AVPs with integer value use \"/i\" postfix to\n  the header name.\n\n  If you want to create only AVPs with string value use \"/s\" postfix to\n  the header name.\n\n- *prefix* - The prefix, which is added before the name parsed from the\n  header body.\n\n",
 "hdr_body2attrs2": "### hdr_body2attrs2(headername, prefix)\n\n module: avp\n\nFunction parses a header body content scans for\nfld1=val1,val2;fld2=val3,... and creates bunch of avps prefixfld1#1:=\nval1, prefixfld1#2:= val2, prefixfld2:=val3 .... If possible stores\nvalues as integers.\n\nMeaning of the parameter is as follows:\n\n- *headername* - The header name, which will be scanned for the\n  name=value pairs.\n\n  If you want to create only AVPs with integer value use \"/i\" postfix to\n  the header name.\n\n  If you want to create only AVPs with string value use \"/s\" postfix to\n  the header name.\n\n- *prefix* - The prefix, which is added before the name parsed from the\n  header body.\n\n<!-- -->\n\n    if (method==\"BYE\") {\n        # QoS reporting\n        if (search(\"^User-Agent: AVM FRITZ!Box Fon*\")) {\n            hdr_body2attrs2(\"X-RTP-Stat/i\", \"QoS_\");\n            xplog(\"L_INFO\", \"QoS: %Ts, %fu, %tu, %ci, %{User-Agent}, %{X-RTP-Stat}\\n\");\n        } else if (search(\"^User-Agent: Sipura/*\")) {\n            hdr_body2attrs(\"P-RTP-Stat/i\", \"QoS_\");\n            xplog(\"L_INFO\", \"QoS: %Ts, %fu, %tu, %ci, %{User-Agent}, %{P-RTP-Stat}\\n\");\n        }\n    }\n    # AVP QoS_xx now contain the values from appropriate header\n    # e.g. QoS_JI is jitter\n        \n\n",
 "acc_rad_request": "### acc_rad_request(comment)\n\n module: acc_radius\n\nLike `acc_log_request` of acc module, `acc_rad_request` reports on a SIP\nrequest event. It reports to radius server as configured in\n\u201cradius_config\u201d.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The first token can be a SIP\n  response code that it is wanted to be interpreted as event type (e.g.,\n  using 200 means the transaction is considered successfully responded).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n    ...\n    acc_rad_request(\"Some comment\");\n    ...\n    # write record as when the transaction was responded with a 200 code\n    acc_rad_request(\"200 From Config\");\n    ...\n",
 "pl_check": "### pl_check(name [, algorithm, limit])\n\n module: pipelimit\n\nCheck the current request against the 'name' pipe.\n\nIf algorithm and limit are provided, the function attempts to create a\nnew pipe if one with that name doesn't exit. If it exists, no changes to\nalgorithm is done and the pipe limit is set to the 'limit' parameter\nvalue, if this is greater than 0. Algorithm is case sensitive.\n\nThe pipe name can be provided via a pseudo variable.\n\nThe method will return:\n\n- *-2* if no pipe was found\n\n- *-1* if pipe limit was reached\n\n- *1* if pipe limit was NOT reached\n\n- *2* if pipe has NOP algorithm\n\nMeaning of the parameters is as follows:\n\n- *name* - the string or pseudovariable with the pipe name.\n\n- *algorithm* - the string or pseudovariable with the algorithm. The\n  values can be: TAILDROP, RED, NETWORK, or FEEDBACK - see readme of\n  ratelimit module for details on each algorithm.\n\n- *limit* - the integer or pseudovariable with the limit value per\n  timer_interval.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        # perform pipe match for current method\n        if (!pl_check(\"one\")) {\n            pl_drop();\n            exit;\n        }\n    ...\n        # use pipe 'one' for the current method via PV\n        $var(p) = \"one\";\n        $var(check_result) = pl_check(\"$var(p)\");\n        switch($var(check_result)) {\n        case -2:\n            xlog(\"L_ALERT\",\"pl_check(\\\"$var(p)\\\") drop -pipe NOT found\\n\");\n            pl_drop();\n            exit;\n            break;\n        case -1:\n            xlog(\"L_ALERT\",\"pl_check(\\\"$var(p)\\\") drop\\n\");\n            pl_drop();\n            exit;\n            break;\n        case 1:\n            xlog(\"L_INFO\", \"pl_check(\\\"$var(p)\\\") pass\\n\");\n            break;\n        case 2:\n            xlog(\"L_ALERT\",\"pl_check(\\\"$var(p)\\\") pass -NOP algorithm\\n\");\n            break;\n        default:\n            xlog(\"L_ERR\",\"pl_check(\\\"$var(p)\\\") dropping \\\n    with unexpected retcode=$var(check_result)\\n\");\n            pl_drop();\n            exit;\n        }\n    ...\n        # perform pipe match for authenticated user\n        $var(limit) = 20;\n        if (!pl_check(\"$au\", \"TAILDROP\", \"$var(limit)\")) {\n            pl_drop();\n            exit;\n        }\n    ...\n        # perform pipe match for INVITE\n        if (is_method(\"INVITE\")) {\n            $var(invlimit) = 10;\n            if (!pl_check(\"$si\", \"TAILDROP\", \"$var(invlimit)\")) {\n                pl_drop();\n                exit;\n            }\n        }\n    ...\n\n",
 "pl_active": "### pl_active(name)\n\n module: pipelimit\n\nCheck the pipe 'name' was already created. Return 1 (true) if the pipe\nis found, -1 (false) if the pipe is not found.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        if (!pl_active(\"one\")) {\n            # pipe does not exist\n            exit;\n        }\n    ...\n\n",
 "pl_drop": "### pl_drop([ [min ], max ])\n\n module: pipelimit\n\nFor the current request, a \"503 - Server Unavailable\" reply is sent\nback. The reply may or may not have a \"Retry-After\" header. If no\nparameter is given, there will be no \"Retry-After\" header. If only the\n*max* parameter is given, the reply will contain a \"Retry-After: *max*\"\nheader. If both *min* and *max* params are given, the reply will contain\na \"Retry-After: *random*\" header with *random* being a random value\nbetween the given min and max.\n\nMeaning of the parameters is as follows:\n\n- *min* - the minimum value of \"Retry-After\" header.\n\n- *max* - the maximum value of \"Retry-After\" header.\n\nThis function can be used from\nREQUEST_ROUTE\\|BRANCH_ROUTE\\|FAILURE_ROUTE\\|ONSEND_ROUTE.\n\n    ...\n        if (!pl_check(\"one\")) {\n            # send back a \"503 - Server Unavailable\"\n            # with a \"Retry-After: 5\"\n            pl_drop(\"5\");\n            exit;\n        }\n    ...\n\n",
 "pua_set_publish": "### pua_set_publish()\n\n module: pua_usrloc\n\nThe function is used to mark REGISTER requests that have to issue a\nPUBLISH. The PUBLISH is issued when REGISTER is saved in location table.\n\n    ...\n    if(is_method(\"REGISTER\") && from_uri=~\"john@kamailio.org\")\n        pua_set_publish();\n    ...\n",
 "slack_send": "### slack_send(format)\n\n module: slack\n\nSend a formatted message to slack channel.\n\nThe parameters are:\n\n- format - The formatted string to be sent.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        slack_send(\"Hello from Kamailio! caller=$fU;callee=$tU;callid=$ci\");\n    ...\n",
 "cnt_inc": "### cnt_inc([group.]name)\n\n module: counters\n\nIncrements the counter *group.name*. The counter must be defined using\nthe `script_counter` module parameter. If the group name is missing, the\ngroup specified by the `script_cnt_grp_name` modparam will be used.\n\n    ...\n    modparam(\"counters\", \"script_counter\", \"reqs\")\n    modparam(\"counters\", \"script_counter\", \"out.reqs  forwarded requests\")\n    ...\n    route {\n        cnt_inc(\"reqs\");\n        if (forward(uri:host, uri:port))\n            cnt_inc(\"out.reqs\");\n    ...\n    }\n            \n\n",
 "cnt_add": "### cnt_add([group.]name, number)\n\n module: counters\n\nAdds *number* the counter *group.name*. The counter must be defined\nusing the `script_counter` module parameter. If the group name is\nmissing, the group specified by the `script_cnt_grp_name` modparam will\nbe used.\n\n    ...\n    modparam(\"counters\", \"script_counter\", \"reqs10  reqs times 10\")\n    ...\n    route {\n        cnt_add(\"reqs10\", 10);\n    ...\n    }\n            \n\n",
 "cnt_reset": "### cnt_reset([group.]name)\n\n module: counters\n\nResets the counter *group.name*. The counter must be defined using the\n`script_counter` module parameter. If the group name is missing, the\ngroup specified by the `script_cnt_grp_name` modparam will be used.\n\n    ...\n    modparam(\"counters\", \"script_counter\", \"reqs\")\n    ...\n    route {\n        if (...)\n            cnt_reset(\"reqs\");\n    ...\n    }\n            \n\n",
 "cnxcc_set_max_credit": "### cnxcc_set_max_credit(customer, maxcredit, connect, cps, ipulse, fpulse)\n\n module: cnxcc\n\nAssociates the call with a customer id and sets the max credit, connect\ncost, cost per second, initial pulse and final pulse. The discount is\ncalculated in pulses (1/1, 60/1, etc) and subtracted from the pool of\ncredit.\n\nThe customer value can be provided as a string or a variable holding a\nstring. This value identifies all calls from the same customer.\n\nThe maxcredit (float) value is the maximum credit available for the\ncurrent call.\n\nThe connect (float) value is the connect cost for the current call.\n\nThe cps (float) value is the cost per second for the current call.\n\nThe ipuse (integer) value is the initial pulse and establishes the\nminimum time to be charged. For example, value 1 establishes a charge\nper second and value 60 sets a charge per minute. If it is taken as\nvalue 60, even if the duration is 5 seconds, 1 minute will be charged.\n\nThe fpulse (integer) value is the final pulse and establishes, from the\ninitial pulse, the time range to be charged. For example, the value 1\nestablishes a charge per second, 5 sets a charge in blocks of 5 seconds,\n60 sets a full minute charge.\n\n1/1 will make a charge per seconds for the entire call. 60/1 will make a\ncharge per seconds with the first full minute. 60/60 always perform a\nfull minute charge.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n- *-4 - call-id already present for this client*\n\n<!-- -->\n\n    ...\n    cnxcc_set_max_credit(\"john-doe\", \"100\", \"3.0\", \"0.5\", 60, 1);\n    ...\n    $var(customer)  = \"john-doe\"; # customer id\n    $var(credit)    = \"100\";      # max credit for all calls with the same\n                                  # customer id\n    $var(connect)   = \"3.0\";      # connect cost or initial cost for the call\n    $var(cps)       = \"0.5\";      # cost per second\n    $var(initial_p) = 60;         # initial pulse (60 = the first minute will be\n                                  # charged even if the call is shorter)\n    $var(final_p)   = 1;          # final pulse (after the first minute, it will\n                                  # be charge in ranges of 1 second)\n    cnxcc_set_max_credit(\"$var(customer)\", \"$var(credit)\", \"$var(connect)\",\n            \"$var(cps)\", \"$var(initial_p)\", \"$var(final_p)\");\n    ...\n\n",
 "cnxcc_set_max_time": "### cnxcc_set_max_time(customer, maxtime)\n\n module: cnxcc\n\nSpecifies the amount of time the call should last at most.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\nThe maxtime value is an integer values, it can be also given via a\nvariable holding an integer.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n- *-4 - call-id already present for this client*\n\n<!-- -->\n\n    ...\n    $var(customer) = \"john-doe-basic\";\n    $var(max_time) = 120;\n    cnxcc_set_max_time(\"$var(customer)\", \"$var(max_time)\");\n    ...\n\n",
 "cnxcc_update_max_time": "### cnxcc_update_max_time(customer, maxtime)\n\n module: cnxcc\n\nUpdates max-time of an established and monitored call. This can be used\nto grant minimum values and to update them every short periods on time\nas a mean to prevent frauds and/or to mimic requested/granted units of\ntime of Credit Control Application behavior.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\nThe maxtime value is an integer values, it can be also given via a\nvariable holding an integer.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n    ...\n    $var(client)       = \"john-doe-basic\";\n    $var(update_time)  = 5;\n\n    if (!cnxcc_update_max_time(\"$var(client)\", \"$var(update_time)\")) {\n        xlog(\"Error updating max-time\");\n        return;\n        }\n    ...\n\n",
 "cnxcc_set_max_channel": "### cnxcc_set_max_channel(customer, maxchan)\n\n module: cnxcc\n\nSpecifies a limit for the number of simultaneous calls.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\nThe maxchan value is an integer values, it can be also given via a\nvariable holding an integer.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n- *-2 - failed, calls established plus calls being established result in\n  more than the limit you specified*\n\n- *-3 - failed, number of calls established is more than the limit you\n  specified*\n\n- *-4 - call-id already present for this client*\n\n<!-- -->\n\n    ...\n    $var(customer)  = \"john-doe-123-basic\";\n    $var(max_chan)  = 2;\n    $var(retcode)   = cnxcc_set_max_channels(\"$var(customer)\", \"$var(max_chan)\");\n\n    if ($var(retcode) == -1) {\n        xlog(\"Error setting up credit control\");\n        return;\n    }\n\n    if ($var(retcode) < -1) {\n        xlog(\"Too many channels for customer\");\n        sl_send_reply(403, \"Forbidden\");\n\n        if (!cnxcc_terminate_all(\"$var(customer)\")) {\n            xlog(\"Error terminating customer's calls\");\n        }\n\n        exit;\n    }\n    ...\n\n",
 "cnxcc_terminate_all": "### cnxcc_terminate_all(customer)\n\n module: cnxcc\n\nTerminates all calls of the specified customer/profile.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n    ...\n    $var(customer)  = \"john-doe-123-basic\";\n\n    if (!cnxcc_terminate_all(\"$var(customer)\")) {\n        xlog(\"Error terminating customer's calls\");\n    }\n    ...\n\n",
 "xhttp_reply": "### xhttp_reply(code, reason, ctype, body)\n\n module: xhttp\n\nSend back a reply with content-type and body.\n\n    ...\n    event_route[xhttp:request] {\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n            \"<html><body>OK - [$si:$sp]</body></html>\");\n    }\n    ...\n\n",
 "redis_cmd": "### redis_cmd(srvname, command, ..., replyid)\n\n module: ndb_redis\n\nSend a command to REDIS server identified by srvname. The reply will be\nstored in a local container identified by replyid. All the parameters\ncan be strings with pseudo-variables that are evaluated at runtime.\n\nMinimum required arguments are srvname, command and replyid. Command\nargument can be separated into several ones using %s token. (See\nexamples) Total number of arguments cannot exceed six.\n\nThe reply can be accessed via pseudo-variable \\$redis(key). The key can\nbe: type - type of the reply (as in hiredis.h); value - the value\nreturned by REDIS server; info - in case of error from REDIS, it will\ncontain an info message.\n\nIf reply type is an array (as in hiredis.h), there are other keys\navailable:\n\n- size - returns number of elements in the array.\n\n- type\\[n\\] - returns the type of the nth element in the array. type -\n  returns array type.\n\n- value\\[n\\] - returns value of the nth element. value - returns null\n  for an array. You need to get each element by index.\n\nIn case one of the members of the array is also an array (for example\ncalling SMEMBERS in a MULTI/EXEC transaction), the members of the array\ncan be accessed by adding any of the above keys, after a value\\[n\\] key.\nThe first value\\[n\\] references the element in the first array, while\nthe next key references an element of the referenced array.\n\nThe result type can be compared with \\$redisd(key) variable to test its\nvalue. The key can be: rpl_str, rpl_arr, rpl_int, rpl_err, rpl_sts,\nrpl_nil.\n\n    ...\n    if(redis_cmd(\"srvN\", \"INCR cnt\", \"r\")) {\n        # success - the incremented value is in $redis(r=>value)\n        xlog(\"===== $redis(r=>type) * $redis(r=>value)\\n\");\n    }\n\n    # set a value\n    redis_cmd(\"srvN\", \"SET foo bar\", \"r\");\n\n    redis_cmd(\"srvN\", \"SET ruri $ru\", \"r\");\n\n    # get a value\n    redis_cmd(\"srvN\", \"GET foo\", \"r\");\n\n    # same command separated into two arguments:\n    redis_cmd(\"srvN\", \"GET %s\", \"foo\", \"r\");\n\n    # if we have a key with spaces within it:\n    redis_cmd(\"srvN\", \"GET %s\", \"foo bar\", \"r\");\n\n    # several values substitution:\n    redis_cmd(\"srvN\", \"HMGET %s %s %s\", \"key1\", \"field1\", \"field2\", \"r\");\n\n\n    # array example\n    if(redis_cmd(\"srvN\", \"HMGET foo_key field1 field3\", \"r\")) {\n        xlog(\"array size: $redis(r=>size)\\n\");\n        xlog(\"first values: $redis(r=>value[0]) , $redis(r=>value[1])\\n\");\n    }\n\n\n    # array as element of an array example\n    redis_cmd(\"srvN\", \"MULTI\", \"r1\");\n    redis_cmd(\"srvN\", \"SMEMBERS foo\", \"r2\");\n    if (redis_cmd(\"srvN\", \"EXEC\", \"r\")) {\n        xlog(\"array size: $redis(r=>value[0]=>size)\\n\");\n        xlog(\"first member of the set:$redis(r=>value[0]=>value[0])\\n\");\n        xlog(\"type of the second member of the set:$redis(r=>value[0]=>type[1])\\n\");\n    }\n    ...\n\n",
 "redis_pipe_cmd": "### redis_pipe_cmd(srvname, command, ..., replyid)\n\n module: ndb_redis\n\nAdd a command to be sent to REDIS server identified by srvname. All the\ncommands will be stored in a buffer until a call to redis_execute is\nmade. When calling redis_execute the stored commands are sent using the\npipelining functionality of redis. The replies will be stored in local\ncontainers identified by the replyid of each added command. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThis command is similar in syntax with redis_cmd, the only difference is\nthat it does not send the command but instead appends it to a buffer.\n\nSee examples from redis_execute.\n\nNote: Pipelining feature is incompatible with the clustering feature. If\ncluster parameter is set to 1, this function will log an error and do\nnothing.\n\n",
 "redis_execute": "### redis_execute(srvname)\n\n module: ndb_redis\n\nSends commands to REDIS server identified by srvname. Commands are added\nwith redis_pipe_cmd function, and will be stored for an existing REDIS\nserver. When this function is called all the commands will be sent in a\nsingle message to the REDIS server.\n\nWhen using redis_cmd together with redis_pipe_cmd it is recommended that\na call to redis_execute is made before calling redis_cmd in case there\nare pipelined commands, otherwise when calling redis_cmd, if pipelined\nmessages exist, a call to redis_execute is made automatically and a\nwarning message is logged.\n\nNote: Pipelining feature is incompatible with the clustering feature. If\ncluster parameter is set to 1, this function will log an error and do\nnothing.\n\n    ...\n    After several redis command calls:\n        redis_pipe_cmd(\"srvA\", \"SET foo bar\", \"r1\");\n\n        redis_pipe_cmd(\"srvB\", \"SET ruri $ru\", \"r2\");\n\n        redis_pipe_cmd(\"srvB\", \"GET foo\", \"r3\");\n\n    Send the data and retrieve the results:\n        redis_execute(\"srvA\"); //send command to srvA and wait for reply. Store the reply in r1\n\n        redis_execute(\"srvB\"); //send command to srvA and wait for reply. Store the replies in r2 (for SET ruri $ru) and r3 (for GET foo)\n\n    Using both redis_cmd and redis_pipe_cmd:\n        redis_pipe_cmd(\"srvA\", \"SET foo bar\", \"r1\");\n\n        redis_pipe_cmd(\"srvA\", \"SET ruri $ru\", \"r2\");\n\n        redis_execute(\"srvA\"); //send commands to srvA and wait for reply. Store replies in r1 and r2\n\n        redis_cmd(\"srvA\", \"GET foo\", \"r3\"); //send command, wait for reply and store it in r3\n\n\n        redis_pipe_cmd(\"srvA\", \"SET foo bar\", \"r1\");\n\n        redis_pipe_cmd(\"srvA\", \"SET ruri $ru\", \"r2\");\n\n        redis_cmd(\"srvA\", \"GET foo\", \"r3\"); //first call redis execute (replies are stored in r1 and r2), log warning and execute redis_cmd\n\n        redis_execute(\"srvA\"); //this does nothing as there are no more pipelined commands. The call is not necessary\n    ...\n            \n\n",
 "redis_free": "### redis_free(replyid)\n\n module: ndb_redis\n\nFrees data in a previous reply from memory. After this function call,\naccessing to a freed replyid returns null value.\n\nIt is not necessary to free a reply to use it again in a new redis_cmd\nfunction. When ndb_redis module closes, all pending replies are freed\nautomatically.\n\n    ...\n    After a redis command call:\n        redis_cmd(\"srvN\", \"INCR cnt\", \"r\");\n\n    free reply data:\n        redis_free(\"r\");\n    ...\n            \n",
 "reginfo_handle_notify": "### reginfo_handle_notify(uldomain)\n\n module: pua_reginfo\n\nThis function processes received \"NOTIFY\"-requests and updates the local\nregistry accordingly.\n\nThis method does not create any SIP-Response, this has to be done by the\nscript-writer.\n\nThe parameter has to correspond to user location table (domain) where to\nstore the record.\n\nReturn codes:\n\n- *2* - contacts successfully updated, but no more contacts online now.\n\n  *1* - contacts successfully updated and at at least one contact still\n  registered.\n\n  *-1* - Invalid NOTIFY or other error (see log-file)\n\n<!-- -->\n\n    ...\n    if(is_method(\"NOTIFY\"))\n        if (reginfo_handle_notify(\"location\"))\n            send_reply(\"202\", \"Accepted\");\n    ...\n                    \n\n",
 "reginfo_subscribe": "### reginfo_subscribe(uri[, expires])\n\n module: pua_reginfo\n\nThis function will subscribe for reginfo-information at the given server\nURI.\n\nMeaning of the parameters is as follows:\n\n- *uri* - SIP-URI of the server, where to subscribe, may contain\n  pseudo-variables.\n\n  *expires* - Expiration date for this subscription, in seconds (default\n  3600)\n\n<!-- -->\n\n    ...\n    route {\n        t_on_reply(\"1\");\n        t_relay();\n    }\n\n    reply_route[1] {\n        if (t_check_status(\"200\"))\n            reginfo_subscribe(\"$ru\");\n    }\n    ...\n                    \n",
 "geoip2_match": "### geoip2_match(ipaddr, pvc)\n\n module: geoip2\n\nMatch ipaddr against the GeoIP database and set the pvc container. The\nfunction has to be called before accessing a key via: \\$gip2(pvc=\\>key).\nAt least one function needs to be present that access the pvc container,\notherwise this function will not work.\n\n    ...\n    if(geoip2_match(\"$si\", \"src\"))\n        xlog(\"SIP message from: $gip2(src=>cc)\\n\");\n    ...\n\n",
 "auth_date_proc": "### auth_date_proc()\n\n module: auth_identity\n\nNote: this function is for authorizer service.\n\nIf a message, the auth service should authorize, contains Date header\nthen this function checks whether it falls in message timeout (set by\n*msg_timeout* parameter). If there is not any Date header then the\nmodule adds one. This function also checks whether the certificate of\nthe authentication service (set by *certificate_path* parameter) has\nexpired.\n\n",
 "auth_add_identity": "### auth_add_identity()\n\n module: auth_identity\n\nNote: this function is for authorizer service.\n\nAssembles digest-string from the message, calculates its SHA1 hash,\nencrypts it with the private key (set by *privatekey_path* parameter) of\nthe authorizer service, base64 encodes it and adds to the outgoing\nmessage as the value of *Identity* header. This function also adds\nIdentity-Info header which contains an URI (set by *certificate_url*\nparameter) from which the certificate of auth service can be acquired.\n\n*Note: this function needs the final outgoing message for authorization,\nso no module may modify any digest string related headers (From, To,\nCall-ID, CSeq, Date, Contact) and body after auth_add_identity()'s been\ncalled*\n\n",
 "vrfy_check_date": "### vrfy_check_date()\n\n module: auth_identity\n\nNote: this function is for verifier service.\n\nChecks Date header of the incoming message whether falls in validity\ntime (set by *auth_validity_time* parameter)\n\n",
 "vrfy_get_certificate": "### vrfy_get_certificate()\n\n module: auth_identity\n\nNote: this function is for verifier service.\n\nTries to get certificate defined by the value of *Identity-info* header\nfrom certificate table (which size is set by *certificate_cache_limit*\nparameter). If the required certificate is not found there then this\nfunction downloads it.\n\n",
 "vrfy_check_certificate": "### vrfy_check_certificate()\n\n module: auth_identity\n\nNote: this function is for verifier service.\n\nChecks whether the downloaded certificate is valid (is not expired, its\nsubject and the domain part of the URL are the same) and adds it to\ncertificate table.\n\n",
 "vrfy_check_msgvalidity": "### vrfy_check_msgvalidity()\n\n module: auth_identity\n\nNote: this function is for verifier service.\n\nAssembles digest-string from the message, create SHA1 hash and compares\nit with the decrypted value of *Identity* header.\n\n",
 "vrfy_check_callid": "### vrfy_check_callid()\n\n module: auth_identity\n\nNote: this function is for verifier service.\n\nChecks whether the current call's been already processed in validity\ntime (set by *auth_validity_time*) to recognize call replay attacks. If\nthis call (identified by Call-id, Cseq, and tag of From header triple)\nhas not been replayed then adds it to callid table (which size is set by\n*callid_cache_limit* parameter).\n\n",
 "radius_www_authorize": "### radius_www_authorize(realm [, uri_user])\n\n module: auth_radius\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions).\n\nIf the function was unable to verify the credentials for some reason, it\nfails and assigns a WWW-Authorize header containing a new challenge to\ndigest_challenge AVP (see modules/auth). The script should then respond\nwith 401 that includes this header, which will challenge the user again.\n\nNegative result codes may be interpreted as follows:\n\n- *-7 (internal error)* - some internal error occurred (see syslog);\n\n- *-6 (nonce reused)* - nonce is used more than once;\n\n- *-5 (no credentials)* - credentials were not found in request;\n\n- *-4 (stale nonce)* - stale nonce;\n\n- *-2 (authorization failed)* - RADIUS responded with Access Reject\n  which may be, for example, due to user not found or wrong password;\n\n- *-1 (error)* - some error occurred during authorization (see syslog);\n\nThis function will perform sanity checks over the received credentials\nand then pass them along to RADIUS server which will verify the\ncredentials and return whether they are valid or not.\n\nMeaning of the parameter is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use. In\n  case of REGISTER requests it is usually hostpart of To URI.\n\n  The string may contain pseudo variables.\n\n- *uri_user* - Uri_user is an optional pseudo variable parameter whose\n  value, if present, will be given to Radius server as value of\n  SIP-URI-User check item. If uri_user pseudo variable parameter is not\n  present, the server will generate SIP-URI-User check item value from\n  user part of To/From URI.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        if (!radius_www_authorize(\"$td\")) {\n            switch ($rc) {\n            case -7:\n            send_reply(\"500\", \"Server Internal Error\");\n            exit;\n            case -1:\n            send_reply(\"400\", \"Bad Request\");\n            exit;\n            default:\n            };\n            if (defined($avp(digest_challenge)) &&\n                    ($avp(digest_challenge) != \"\")) {\n                append_to_reply(\"$avp(digest_challenge)\");\n            };\n            send_reply(\"401\", \"Unauthorized\");\n            exit;\n        };\n    ...\n\n",
 "radius_proxy_authorize": "### radius_proxy_authorize(realm [, uri_user])\n\n module: auth_radius\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions).\n\nIf the function was unable to verify the credentials for some reason, it\nfails and assigns a Proxy-Authorize header containing a new challenge to\ndigest_challenge AVP. The script should then respond with 407 that\nincludes this header, which will challenge the user again. For negative\nresult codes, see the above function.\n\nThis function will perform sanity checks over the received credentials\nand then pass them along to RADIUS server which will verify the\ncredentials and return whether they are valid or not.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use. In\n  case of non-REGISTER requests it is usually hostpart of From or\n  P-Preferred-Identity URI.\n\n  The string may contain pseudo variables.\n\n- *uri_user* - Uri_user is an optional pseudo variable parameter whose\n  value, if present, will be given to Radius server as value of\n  SIP-URI-User check item. If uri_user pseudo variable parameter is not\n  present, the server will generate SIP-URI-User check item value from\n  user part of To/From URI.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n        if (!radius_proxy_authorize(\"$pd\", \"$pU\")) { # Realm and URI user are taken\n            switch ($rc) {                           # from P-Preferred-Identity\n            case -7:                                 # header field\n            send_reply(\"500\", \"Server Internal Error\");\n            exit;\n            case -1:\n            send_reply(\"400\", \"Bad Request\");\n            exit;\n            default:\n            };\n            if (defined($avp(digest_challenge)) &&\n                    ($avp(digest_challenge) != \"\")) {\n                append_to_reply(\"$avp(digest_challenge)\");\n            };\n            send_reply(\"407\", \"Proxy Authentication Required\");\n            exit;\n        };\n    ...\n",
 "sipdump_send": "### sipdump_send(tag)\n\n module: sipdump\n\nSend the details of the current SIP message to the writer process and\nget it stored in the file.\n\nThe parameter \"tag\" can be any string, it is going to be written in the\ntag attribute inside the storage file.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sipdump_send(\"cfg\");\n    ...\n\n",
 "mqtt_subscribe": "### mqtt_subscribe(topic, qos)\n\n module: mqtt\n\nSubscribe to the given topic. Mqtt qos levels 0, 1 and 2 can be used.\n\nThe function is passing the task to mqtt dispatcher process, therefore\nthe SIP worker process is not blocked.\n\nIncoming messages for this topic are then handled by the same process\nand exposed to the event_route\\[mqtt:message\\].\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    mqtt_subscribe(\"kamailio/script\", 0);\n    ...\n\n",
 "mqtt_unsubscribe": "### mqtt_unsubscribe(topic)\n\n module: mqtt\n\nUnsubscribe to a previously subscribed topic. The mqtt broker will stop\nforwarding messages for this topic.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    mqtt_unsubscribe(\"kamailio/script\");\n    ...\n\n",
 "mqtt_publish": "### mqtt_publish(topic, message, qos)\n\n module: mqtt\n\nSend out a message to a topic with a specified mqtt qos level (0, 1, 2).\nAgain the actual sending is done in a mqtt dispatcher process and will\nnot block the SIP worker.\n\n    ...\n    mqtt_publish(\"kamailio/event\", \"some message\", 0);\n    ...\n\n",
 "sht_print": "### sht_print()\n\n module: htable\n\nDump content of hash table to L_ERR log level. Intended for debug\npurposes.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\n    ...\n    sht_print();\n    ...\n\n",
 "sht_rm": "### sht_rm(htname, itname)\n\n module: htable\n\nDelete the item with the name 'itname' from hash table 'htname'. This\nAPI function is equivalent to '\\$sht(htname=\\>itname) = \\$null'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_rm(\"ha\", \"test\"\");\n    ...\n\n",
 "sht_rm_name_re": "### sht_rm_name_re(htable=>regexp)\n\n module: htable\n\nDelete all entries in the htable that match the name against regular\nexpression.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\n    ...\n    sht_rm_name_re(\"ha=>.*\");\n    ...\n\n",
 "sht_rm_value_re": "### sht_rm_value_re(htable=>regexp)\n\n module: htable\n\nDelete all entries in the htable that match the value against regular\nexpression.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\n    ...\n    sht_rm_value_re(\"ha=>.*\");\n    ...\n\n",
 "sht_rm_name": "### sht_rm_name(htable, op, val)\n\n module: htable\n\nDelete all entries in the htable that match the name against the val\nparameter.\n\nThe op parameter can be:\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with'.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_rm_name(\"ha\", \"re\", \".*\");\n    ...\n\n",
 "sht_rm_value": "### sht_rm_value(htable, op, val)\n\n module: htable\n\nDelete all entries in the htable that match the value against the val\nparameter.\n\nThe op parameter can be:\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with'.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_rm_value(\"ha\", \"re\", \".*\");\n    ...\n\n",
 "sht_setxs": "### sht_setxs(htname, itname, itval, exval)\n\n module: htable\n\nSet the item with the name 'itname' from hash table 'htname' to string\nvalue 'itval' and expire property to 'exval'.\n\nThe parameters can be with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_setxs(\"ha\", \"test\", \"abc\", \"10\");\n    ...\n\n",
 "sht_setxi": "### sht_setxi(htname, itname, itval, exval)\n\n module: htable\n\nSet the item with the name 'itname' from hash table 'htname' to integer\nvalue 'itval' and expire property to 'exval'.\n\nThe parameters can be with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_setxs(\"ha\", \"test\", \"100\", \"10\");\n    ...\n\n",
 "sht_reset": "### sht_reset(htable)\n\n module: htable\n\nDelete all entries in the htable. The name of the hash table can be a\ndynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_reset(\"ha$var(x)\");\n    ...\n\n",
 "sht_lock": "### sht_lock(htable=>key)\n\n module: htable\n\nLock the slot in htable corresponding to the key item. Note that the\nlocking is re-entrant for the process, therefore the lock and unlock\nshould be done by the same process.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_lock(\"ha=>test\");\n    ...\n\n",
 "sht_unlock": "### sht_unlock(htable=>key)\n\n module: htable\n\nUnlock the slot in htable corresponding to the key item. Note that the\nlocking is re-entrant for the process, therefore the lock and unlock\nshould be done by the same process.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_lock(\"ha=>test\");\n    $sht(ha=>test) = $sht(ha=>test) + 10;\n    sht_unlock(\"ha=>test\");\n    ...\n\n",
 "sht_iterator_start": "### sht_iterator_start(iname, hname)\n\n module: htable\n\nStart an iterator for hash table named by the value of parameter hname.\nThe parameter iname is used to identify the iterator. There can be up to\n4 iterators at the same time, with different name.\n\nBoth parameters can be dynamic strings with variables.\n\nIMPORTANT: the slot of the hash table is left locked when retrieving in\nitem. Therefore be sure you do not update the content of the hash table\nin between sht_iterator_start() and sht_iterator_end(), because it may\nend up in dead lock.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_iterator_start(\"i1\", \"h1\");\n    ...\n\n",
 "sht_iterator_end": "### sht_iterator_end(iname)\n\n module: htable\n\nClose the iterator identified by iname parameter and release the hash\ntable slot acquired by the iterator. The iname value must be the same\nused for sht_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sht_iterator_end(\"i1\");\n    ...\n\n",
 "sht_iterator_next": "### sht_iterator_next(iname)\n\n module: htable\n\nMove the iterator to the next item in hash table. It must be called also\nafter sht_iterator_start() to get the first item in the hash table.\nItems are returned as they are found in the hash table slot, starting\nwith the first slot.\n\nThe return code is false when there is no (more) item in the hash table.\n\nThe item name and value are accessible via variables: \\$shtitkey(iname)\nand \\$shtitval(iname).\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        sht_iterator_start(\"i1\", \"h1\");\n        while(sht_iterator_next(\"i1\")) {\n            xlog(\"h1[$shtitkey(i1)] is: $shtitval(i1)\\n\");\n        }\n        sht_iterator_end(\"i1\");\n    ...\n\n",
 "sht_iterator_rm": "### sht_iterator_rm(iname)\n\n module: htable\n\nRemove the current item in the iterator and move the iterator to the\nnext one.\n\nThe return code is 1 (true) if the item was removed and next item\nexists; -2 (false) if the item was removed and there is no next item\n(end of items); other negative value (false) can be returned on error\n(e.g., iterator or item not found).\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        sht_iterator_start(\"i1\", \"h1\");\n        while(sht_iterator_next(\"i1\")) {\n            while($shtitkey(i1) =~ \"xyz\" and sht_iterator_rm(\"i1\")) {\n                xdbg(\"item removed\\n\");\n            }\n        }\n        sht_iterator_end(\"i1\");\n    ...\n\n",
 "sht_iterator_sets": "### sht_iterator_sets(iname, sval)\n\n module: htable\n\nSet the value of the current item to the string in the sval.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        sht_iterator_start(\"i1\", \"h1\");\n        sht_iterator_next(\"i1\");\n        sht_iterator_sets(\"i1\", \"$ci\");\n        sht_iterator_end(\"i1\");\n    ...\n\n",
 "sht_iterator_seti": "### sht_iterator_seti(iname, ival)\n\n module: htable\n\nSet the value of the current item to the integer in the ival.\n\nThe parameters can be dynamic strings or integers with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        sht_iterator_start(\"i1\", \"h1\");\n        sht_iterator_next(\"i1\");\n        sht_iterator_seti(\"i1\", \"20\");\n        sht_iterator_end(\"i1\");\n    ...\n\n",
 "sht_iterator_setex": "### sht_iterator_setex(iname, exval)\n\n module: htable\n\nSet the expire of the current item to the integer in the exval.\n\nThe parameters can be dynamic strings or integers with variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n        sht_iterator_start(\"i1\", \"h1\");\n        sht_iterator_next(\"i1\");\n        sht_iterator_setex(\"i1\", \"120\");\n        sht_iterator_end(\"i1\");\n    ...\n\n",
 "sht_match_name": "### sht_match_name(htable, op, mval)\n\n module: htable\n\nReturn greater than 0 (true) if the htable has an item that matches the\nname against the mval parameter.\n\nThe op parameter can be:\n\n- *eq* - match the val parameter as string equal expression.\n\n- *ne* - match the val parameter as string not-equal expression.\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with' expression.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(sht_match_name(\"ha\", \"eq\", \"alice\")) {\n      ...\n    }\n    ...\n\n",
 "sht_has_name": "### sht_has_name(htable, op, mval)\n\n module: htable\n\nAlias for sht_match_name().\n\n",
 "sht_match_str_value": "### sht_match_str_value(htable, op, mval)\n\n module: htable\n\nReturn greater than 0 (true) if the htable has an item that matches the\nstring value against the mval parameter.\n\nThe op parameter can be:\n\n- *eq* - match the val parameter as string equal expression.\n\n- *ne* - match the val parameter as string not-equal expression.\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with' expression.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(sht_match_str_value(\"ha\", \"eq\", \"alice\")) {\n      ...\n    }\n    ...\n\n",
 "sht_has_str_value": "### sht_has_str_value(htable, op, mval)\n\n module: htable\n\nAlias for sht_match_str_value().\n\n",
 "dispatch_xhttp_pi": "### dispatch_xhttp_pi()\n\n module: xhttp_pi\n\nHandle the HTTP request and generate a response.\n\n    ...\n    tcp_accept_no_cl=yes\n    ...\n    loadmodule \"sl.so\"\n    loadmodule \"xhttp.so\"\n    loadmodule \"xhttp_pi.so\"\n    ...\n    modparam(\"xhttp_pi\", \"framework\", \"/usr/local/etc/kamailio/pi_framework.xml\")\n    ...\n    event_route[xhttp:request] {\n        $var(xhttp_root) = $(hu{s.substr,0,3});\n        if ($var(xhttp_root) == \"/pi\")\n            dispatch_xhttp_pi();\n        else\n            xhttp_reply(\"200\", \"OK\", \"text/html\",\n                    \"<html><body>Wrong URL $hu</body></html>\");\n    }\n    ...\n\n",
 "dispatch_rpc": "### dispatch_rpc()\n\n module: xmlrpc\n\nThis function processes an XMLRPC request, found in the body of the\nrequest.\n\nIt should be used only in a route specified using the `\"route\"` module\nparameter or if the request method is GET or POST (using it for other\nrequest methods will not have adverse side-effects, but it will probably\nnot work).\n\ndispatch_rpc() extracts the XML-RPC document from the body of the\nrequest to determine the name of the RPC method to be called and then it\nsearches through the list of all the RPC functions to find a function\nwith matching name. If such a function is found then dispatch_rpc() will\npass control to the function to handle the request.\n\n    #...\n    modparam(\"xmlrpc\", \"route\", \"XMLRPC\");\n    #...\n    route[XMLRPC]{\n        if search(\"^User-Agent:.*xmlrpclib\"))\n            set_reply_close();\n        set_reply_no_connect(); # optional\n        dispatch_rpc();\n    }\n            \n\n",
 "xmlrpc_reply": "### xmlrpc_reply(code, reason)\n\n module: xmlrpc\n\nThis function can be called from the config script to directly generate\nan XML-RPC reply.\n\n    #...\n    modparam(\"xmlrpc\", \"route\", \"XMLRPC\");\n    #...\n    route[XMLRPC]{\n        # allow XMLRPC requests only on TLS and only if the client\n        # certificate is valid\n        if (proto!=TLS){\n            xmlrpc_reply(\"400\", \"xmlrpc allowed only over TLS\");\n            return;\n        }\n        if (@tls.peer.verified!=\"\"){\n            xmlrpc_reply(\"400\", \"Unauthorized\");\n            return;\n        }\n        if search(\"^User-Agent:.*xmlrpclib\"))\n            set_reply_close();\n        set_reply_no_connect(); # optional\n        dispatch_rpc();\n    }\n            \n",
 "lua_dofile": "### lua_dofile(path)\n\n module: app_lua\n\nExecute the Lua script stored in 'path'. The parameter can be a string\nwith pseudo-variables evaluated at runtime.\n\n    ...\n    lua_dofile(\"/usr/local/etc/kamailio/lua/myscript.lua\");\n    ...\n\n",
 "lua_dostring": "### lua_dostring(script)\n\n module: app_lua\n\nExecute the Lua script stored in parameter. The parameter can be a\nstring with pseudo-variables.\n\n    ...\n    if(!lua_dostring(\"KSR.log([[err]], [[----------- Hello World from $fU\\n]])\"))\n    {\n        xdbg(\"SCRIPT: failed to execute lua script!\\n\");\n    }\n    ...\n\n",
 "lua_run": "### lua_run(func [, params])\n\n module: app_lua\n\nExecute the Lua function 'func' giving 'params' as parameters. There can\nbe up to 3 string parameters after 'func' (overall, max 4 params, first\nis the function). The function must exist in the Lua script loaded at\nstartup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n    ...\n    if(!lua_run(\"sr_append_fu_to_reply\")) {\n        xdbg(\"SCRIPT: failed to execute lua function!\\n\");\n    }\n    ...\n    lua_run(\"lua_func0\");\n    lua_run(\"lua_func1\", \"$rU\");\n    lua_run(\"lua_func2\", \"$rU\", \"2\");\n    lua_run(\"lua_func3\", \"$rU\", \"2\", \"$si\");\n    ...\n\n",
 "lua_runstring": "### lua_runstring(script)\n\n module: app_lua\n\nExecute the Lua script stored in parameter. The parameter can be a\nstring with pseudo-variables. The script is executed in Lua context\nspecific to loaded Lua files at startup.\n\n    ...\n    if(!lua_runstring(\"KSR.log([[err]], [[----------- Hello World from $fU\\n]])\"))\n    {\n        xdbg(\"SCRIPT: failed to execute lua script!\\n\");\n    }\n    ...\n\n",
 "pos_append": "### pos_append(idx, val)\n\n module: posops\n\nAppend the value val after the position idx in the SIP message buffer.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pos_append(\"100\", \"kamailio-$si\");\n    ...\n                    \n\n",
 "pos_insert": "### pos_insert(idx, val)\n\n module: posops\n\nInsert the value val at the position idx in the SIP message buffer.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pos_insert(\"100\", \"kamailio-$si\");\n    ...\n                    \n\n",
 "pos_rm": "### pos_rm(idx, len)\n\n module: posops\n\nRemove len characters starting at the position idx in the SIP message\nbuffer.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe idx can be a positive integer value or a variable holding a positive\ninteger.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pos_insert(\"100\", \"10\");\n    ...\n                    \n\n",
 "pos_set_char": "### pos_set_char(idx, val)\n\n module: posops\n\nSet the char at position index to first character in val.\n\nImportant: it changes the character directly in the SIP message buffer,\nthe update being immediately visible.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pos_set_char(\"100\", \"x\");\n    ...\n                    \n\n",
 "pos_headers_start": "### pos_headers_start()\n\n module: posops\n\nReturn the position in the message buffer where headers start.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(pos) = pos_headers_start();\n    ...\n                    \n\n",
 "pos_headers_end": "### pos_headers_end()\n\n module: posops\n\nReturn the position in the message buffer where headers end.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(pos) = pos_headers_end();\n    ...\n                    \n\n",
 "pos_body_start": "### pos_body_start()\n\n module: posops\n\nReturn the position in the message buffer where body starts.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(pos) = pos_body_start();\n    ...\n                    \n\n",
 "pos_body_end": "### pos_body_end()\n\n module: posops\n\nReturn the position in the message buffer where body ends.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(pos) = pos_body_end();\n    ...\n                    \n\n",
 "pos_find_str": "### pos_find_str(idx, val)\n\n module: posops\n\nReturn the position of the val in message buffer starting at idx. In\ncase of not finding it or error, the return code is negative. If val is\nat index 0, it returns the value specified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(idx) = pos_find_str(\"100\", \"kamailio\");\n    ...\n                    \n\n",
 "pos_findi_str": "### pos_findi_str(idx, val)\n\n module: posops\n\nReturn the position of the val (matching case insensitive) in message\nbuffer starting at idx. In case of not finding it or error, the return\ncode is negative. If val is at index 0, it returns the value specified\nby modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(idx) = pos_findi_str(\"100\", \"kamailio\");\n    ...\n                    \n\n",
 "pos_rfind_str": "### pos_rfind_str(idx, val)\n\n module: posops\n\nReturn the last position of the val in message buffer starting at idx\n(reverse search). In case of not finding it or error, the return code is\nnegative. If val is at index 0, it returns the value specified by\nmodparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(idx) = pos_rfind_str(\"100\", \"kamailio\");\n    ...\n                    \n\n",
 "pos_rfindi_str": "### pos_rfindi_str(idx, val)\n\n module: posops\n\nReturn the last position of the val (matching case insensitive) in\nmessage buffer starting at idx (reverse search). In case of not finding\nit or error, the return code is negative. If val is at index 0, it\nreturns the value specified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(idx) = pos_rfindi_str(\"100\", \"kamailio\");\n    ...\n                    \n\n",
 "pos_search": "### pos_search(idx, re)\n\n module: posops\n\nReturn the position that starts matching the regular expression re in\nmessage buffer starting at idx. In case of not finding it or error, the\nreturn code is negative. If val is at index 0, it returns the value\nspecified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe re can be a static regular expression string.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(idx) = pos_search(\"100\", \"[0-9]+\");\n    ...\n                    \n\n",
 "pos_rsearch": "### pos_rsearch(idx, re)\n\n module: posops\n\nReturn the position of last match that starts matching the regular\nexpression re in message buffer starting at idx. In case of not finding\nit or error, the return code is negative. If val is at index 0, it\nreturns the value specified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe re can be a static regular expression string.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(idx) = pos_rsearch(\"100\", \"[0-9]+\");\n    ...\n                    \n\n",
 "is_from_local": "### is_from_local()\n\n module: domain\n\nChecks based on domain table if host part of From header uri is one of\nthe local domains that the proxy is responsible for\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n    ...\n    if (is_from_local()) {\n        ...\n    };\n    ...\n            \n\n",
 "is_uri_host_local": "### is_uri_host_local()\n\n module: domain\n\nIf called from route or failure route block, checks based on domain\ntable if host part of Request-URI is one of the local domains that the\nproxy is responsible for. If called from branch route, the test is made\non host part of URI of first branch, which thus must have been appended\nto the transaction before is_uri_host_local() is called.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n    ...\n    if (is_uri_host_local()) {\n        ...\n    };\n    ...\n            \n\n",
 "is_domain_local": "### is_domain_local(domain)\n\n module: domain\n\nThis function checks if the domain contained in the parameter is local.\nThe parameter can be a static string or contain pseudo-variables.\n\nThis function is a generalized form of the is_from_local() and\nis_uri_host_local() functions, being able to completely replace them and\nalso extends them by allowing the domain to be taken from any of the\nabove mentioned sources. The following equivalences exist:\n\n- is_domain_local(\"\\$rd\") is same as is_uri_host_local()\n\n- is_domain_local(\"\\$fd\") is same as is_from_local()\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n    ...\n    if (is_domain_local(\"$rd\")) {\n        ...\n    }\n    if (is_domain_local(\"my.domain.com\")) {\n        ...\n    }\n    if (is_domain_local(\"$fd\")) {\n        ...\n    }\n    if (is_domain_local(\"$avp(some_avp_alias)\")) {\n        ...\n    }\n    if (is_domain_local(\"$avp(i:850)\")) {\n        ...\n    }\n    if (is_domain_local(\"$avp(s:some_avp)\")) {\n        ...\n    }\n    ...\n            \n\n",
 "kazoo_publish": "#### kazoo_publish(exchange, routing_key, json_payload [, amqp_headers])\n\n module: kazoo\n\nThe function publishes a json payload to rabbitmq. The routing_key\nparameter should be encoded. Optional AMQP-Headers are specified in the\nformat key1=value1;key2=value2\n\nThis function can be used from ANY ROUTE.\n\n    ...\n    $var(amqp_payload_request) = $_s({\"Event-Category\" : \"directory\", \"Event-Name\" : \"reg_success\", \"Contact\" : \"$(ct{s.escape.common}{s.replace,\\','}{s.replace,$$,})\", \"Call-ID\" : \"$ci\", \"Realm\" : \"$fd\", \"Username\" : \"$fU\", \"From-User\" : \"$fU\", \"From-Host\" : \"$fd\", \"To-User\" : \"$tU\", \"To-Host\" : \"$td\", \"User-Agent\" : \"$(ua{s.escape.common}{s.replace,\\','}{s.replace,$$,})\" });\n    $var(amqp_routing_key) = \"registration.success.\" + $(fd{kz.encode}) + \".\" + $fU;\n    kazoo_publish(\"callmgr\", $var(amqp_routing_key), $var(amqp_payload_request));\n    ...\n\n",
 "kazoo_query": "#### kazoo_query(exchange, routing_key, json_payload [, target_var] [, amqp_headers])\n\n module: kazoo\n\nThe function publishes a json payload to rabbitmq, waits for a\ncorrelated messageand puts the result in target_var. The routing_key\nparameter should be encoded. target_var is optional as the function also\nputs the result in pseudo-variable \\$kzR. Optional AMQP-Headers are\nspecified in the format key1=value1;key2=value2\n\nThis function can be used from ANY ROUTE.\n\n    ...\n    $var(amqp_payload_request) = \"{'Event-Category' : 'call_event' , 'Event-Name' : 'query_user_channels_req', 'Realm' : '\" + $fd + \"', 'Username' : '\" + $fU + \"', 'Active-Only' : false }\";\n    kazoo_encode(\"$ci\", \"$var(callid_encoded)\");\n    $var(amqp_routing_key) = \"call.status_req.$var(callid_encoded)\";\n    if(kazoo_query(\"callevt\", $var(amqp_routing_key), $var(amqp_payload_request), \"$var(amqp_result)\")) {\n       kazoo_json(\"$var(amqp_result)\", \"Channels[0].switch_url\", \"$du\");\n       if($du != $null) {\n           xlog(\"L_INFO\", \"$ci|log|user channels found redirecting call to $du\");\n           return;\n       }\n    }\n    ...\n\n",
 "kazoo_subscribe": "#### kazoo_subscribe(exchange, exchange_type, queue, routing_key)\n\n module: kazoo\n\nThe function subscribes to exchange/type on queue with routing_key. The\nrouting_key parameter should be encoded.\n\nThis function must be called from event_route\\[kazoo:mod-init\\].\n\n    ...\n    event_route[kazoo:mod-init]\n    {\n       kazoo_subscribe(\"dialoginfo\", \"direct\", \"BLF-QUEUE-MY_HOSTNAME\", \"BLF-MY_HOSTNAME\");\n    }\n\n    event_route[kazoo:consumer-event]\n    {\n        xlog(\"L_INFO\",\"Received json payload : $kzE\");\n    }\n    ...\n\n#### kazoo_subscribe(json_description)\n\n module: kazoo\n\nThe function takes additional parameters to the subscribe function.\n\n- exchange : str, required\n\n- type : str, required\n\n- queue : str, required\n\n- routing : str, required\n\n- auto_delete : int, default 1\n\n- durable : int, default 0\n\n- no_ack : int, default 1\n\n- wait_for_consumer_ack : int, default 0\n\n- event_key : str, no default\n\n- event_subkey : str, no default\n\nThis function must be called from event_route\\[kazoo:mod-init\\].\n\n    ...\n    event_route[kazoo:mod-init]\n    {\n        $var(payload) = \"{ 'exchange' : 'dialoginfo' , 'type' : 'direct', 'queue' : 'BLF-QUEUE-MY_HOSTNAME', 'routing' : 'BLF-MY_HOSTNAME', 'auto_delete' : 0, 'durable' : 1, 'no_ack' : 0, 'wait_for_consumer_ack' : 1 }\";\n        kazoo_subscribe(\"$var(payload)\");\n    }\n\n    event_route[kazoo:consumer-event]\n    {\n        xlog(\"L_INFO\",\"Received json payload : $kzE\");\n    }\n    ...\n\n",
 "kazoo_pua_publish": "#### kazoo_pua_publish(json_payload)\n\n module: kazoo\n\nThe function build presentity state from json_payload and updates\npresentity table.\n\nThis function can be used from ANY ROUTE.\n\n    ...\n    event_route[kazoo:consumer-event-presence-update]\n    {\n        xlog(\"L_INFO\", \"received $(kzE{kz.json,Event-Package}) update for $(kzE{kz.json,From})\");\n        kazoo_pua_publish($kzE);\n        pres_refresh_watchers(\"$(kzE{kz.json,From})\", \"$(kzE{kz.json,Event-Package})\", 1);\n    }\n    ...\n\n",
 "kazoo_encode": "#### kazoo_encode(to_encode, target_var)\n\n module: kazoo\n\nThe function encodes the 1st parameter for amqp and puts the result in\nthe 2nd parameter.\n\nThis function can be used from ANY ROUTE.\n\n    ...\n    kazoo_encode(\"$ci\", \"$var(callid_encoded)\");\n    $var(amqp_routing_key) = \"call.status_req.$var(callid_encoded)\";\n    ...\n\n",
 "kazoo_json": "#### kazoo_json(json_payload, field, target_var)\n\n module: kazoo\n\nThe function extracts the value from a json payload and puts the result\nin the 3rd parameter. It can use nested values for the query part.\n\nThis function can be used from ANY ROUTE.\n\n    ...\n    kazoo_json(\"$var(amqp_result)\", \"Channels[0].switch_url\", \"$du\");\n    if($du != $null) {\n      xlog(\"L_INFO\", \"$ci|log|user channels found redirecting call to $du\");\n      return;\n    }\n    ...\n\n",
 "cpl_run_script": "### cpl_run_script(type, mode[, uri])\n\n module: cplc\n\nStarts the execution of the CPL script. The user name is fetched from\nnew_uri or requested uri or from To header -in this order- (for incoming\nexecution) or from FROM header (for outgoing execution). Regarding the\nstateful/stateless message processing, the function is very flexible,\nbeing able to run in different modes (see below the\"mode\" parameter).\nNormally this function will end script execution. There is no guaranty\nthat the CPL script interpretation ended when Kamailio script ended also\n(for the same INVITE ;-)) - this can happen when the CPL script does a\nPROXY and the script interpretation pause after proxying and it will be\nresumed when some reply is received (this can happen in a different\nprocess of SER). If the function returns to script, the SIP server\nshould continue with the normal behavior as if no script existed. When\nsome error is returned, the function itself haven't sent any SIP error\nreply (this can be done from script).\n\nMeaning of the parameters is as follows:\n\n- *type* - which part of the script should be run; set it to \"incoming\"\n  for having the incoming part of script executed (when an INVITE is\n  received) or to \"outgoing\" for running the outgoing part of script\n  (when a user is generating an INVITE - call).\n\n- *mode* - sets the interpreter mode as stateless/stateful behavior. The\n  following modes are accepted:\n\n  - *IS_STATELESS* - the current INVITE has no transaction created yet.\n    All replies (redirection or deny) will be done is a stateless way.\n    The execution will switch to stateful only when proxy is done. So,\n    if the function returns, will be in stateless mode.\n\n  - *IS_STATEFUL* - the current INVITE has already a transaction\n    associated. All signaling operations (replies or proxy) will be done\n    in stateful way. So, if the function returns, will be in stateful\n    mode.\n\n  - *FORCE_STATEFUL* - the current INVITE has no transaction created\n    yet. All signaling operations will be done is a stateful way (on\n    signaling, the transaction will be created from within the\n    interpreter). So, if the function returns, will be in stateless\n    mode.\n\n  *HINT*: is_stateful is very difficult to manage from the routing\n  script (script processing can continue in stateful mode); is_stateless\n  is the fastest and less resources consumer (transaction is created\n  only if proxying is done), but there is minimal protection against\n  retransmissions (since replies are sent stateless); force_stateful is\n  a good compromise - all signaling is done stateful (retransmission\n  protection) and in the same time, if returning to script, it will be\n  in stateless mode (easy to continue the routing script execution)\n\n- *uri* - optional - provide the SIP URI to be used for loading the CPL\n  script, instead of taking it from R-URI or headers.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    cpl_run_script(\"incoming\",\"force_stateful\");\n    ...\n\n",
 "cpl_process_register": "### cpl_process_register()\n\n module: cplc\n\nThis function MUST be called only for REGISTER requests. It checks if\nthe current REGISTER request is related or not with CPL script\nupload/download/ remove. If it is, all the needed operation will be\ndone. For checking if the REGISTER is CPL related, the function looks\nfirst to \"Content-Type\" header. If it exists and has a the mime type set\nto \"application/cpl+xml\" means this is a CPL script upload/remove\noperation. The distinction between to case is made by looking at\n\"Content-Disposition\" header; id its value is \"script;action=store\",\nmeans it's an upload; if it's \"script;action=remove\", means it's a\nremove operation; other values are considered to be errors. If no\n\"Content-Type\" header is present, the function looks for \"Accept\" header\nand if it contains \"\\*\" or \"application/cpl-xml\" the request will be\nconsidered for downloading CPL scripts. The functions returns to script\nonly if the REGISTER is not related to CPL. In other case, the function\nwill send by itself the necessary replies (stateless - using sl),\nincluding for errors.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (method==\"REGISTER\") {\n        cpl_process_register();\n    }\n    ...\n\n",
 "cpl_process_register_norpl": "### cpl_process_register_norpl()\n\n module: cplc\n\nSame as \u201ccpl_process_register\u201d without internally generating the reply.\nAll information (script) is appended to the reply but without sending it\nout.\n\nMain purpose of this function is to allow integration between CPL and\nUserLocation services via same REGISTER messages.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (method==\"REGISTER\") {\n        cpl_process_register();\n        # continue with usrloc part\n        save(\"location\");\n    }\n    ...\n\n",
 "options_reply": "### options_reply()\n\n module: siputils\n\nThis function checks if the request method is OPTIONS and if the request\nURI does not contain a username. If both are true the request will be\nanswered stateless with \u201c200 OK\u201d and the capabilities from the modules\nparameters.\n\nIt sends \u201c500 Server Internal Error\u201d for some errors and returns false\nif it is called for a wrong request.\n\nThe check for the request method and the missing username is optional\nbecause it is also done by the function itself. But you should not call\nthis function outside the myself check because in this case the function\ncould answer OPTIONS requests which are sent to you as outbound proxy\nbut with another destination than your proxy (this check is currently\nmissing in the function).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (uri==myself) {\n        if ((method==OPTIONS) && (! uri=~\"sip:.*[@]+.*\")) {\n            options_reply();\n        }\n    }\n    ...\n\n",
 "is_user": "### is_user(username)\n\n module: siputils\n\nCheck if the username in credentials matches the given username.\n\nMeaning of the parameters is as follows:\n\n- *username* - Username string.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_user(\"john\")) {\n        ...\n    };\n    ...\n\n",
 "has_totag": "### has_totag()\n\n module: siputils\n\nCheck if To header field uri contains tag parameter.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (has_totag()) {\n        ...\n    };\n    ...\n\n",
 "uri_param": "### uri_param(param)\n\n module: siputils\n\nFind if Request URI has a given parameter with no value\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name to look for.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (uri_param(\"param1\")) {\n        ...\n    };\n    ...\n\n### uri_param(param, value)\n\n module: siputils\n\nFind if Request URI has a given parameter with matching value\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name to look for.\n\n- *value* - parameter value to match.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (uri_param(\"param1\",\"value1\")) {\n        ...\n    };\n    ...\n\n",
 "uri_param_any": "### uri_param_any(param)\n\n module: siputils\n\nFind if Request URI has a given parameter with or without value.\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name to look for.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (uri_param_any(\"param1\")) {\n        ...\n    }\n    ...\n\n",
 "add_uri_param": "### add_uri_param(param)\n\n module: siputils\n\nAdd to RURI a parameter (name=value);\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter to be appended in \u201cname=value\u201d format.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    add_uri_param(\"nat=yes\");\n    ...\n\n",
 "get_uri_param": "### get_uri_param(name, var)\n\n module: siputils\n\nGet the value of RURI parameter.\n\nMeaning of the parameters is as follows:\n\n- *name* - the name of R-URI parameter\n\n- *var* - the variable where to store the value of the parameter\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    get_uri_param(\"nat\", \"$var(nat)\");\n    ...\n\n",
 "uri_param_rm": "### uri_param_rm(param)\n\n module: siputils\n\nRemove parameter from Request URI.\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (uri_param_rm(\"param1\")) {\n        ...\n    }\n    ...\n\n",
 "tel2sip": "### tel2sip(uri, hostpart, result)\n\n module: siputils\n\nConverts URI in first param (pseudo variable or string) to SIP URI, if\nit is a tel URI. If conversion was done, writes resulting SIP URI to\nthird param (pseudo variable). Returns 1 if conversion succeeded, 2 if\nno conversion was needed, and -1 in case of error.\n\nThe conversion follows the rules in RFC 3261 section 19.1.6:\n\n- Visual separators ( \"-\", \".\", \"(\", \")\" ) are removed from tel URI\n  number before converting it to SIP URI userinfo.\n\n- tel URI parameters are downcased before appending them to SIP URI\n  userinfo\n\nThe SIP URI hostpart is taken from second param (pseudo variable or\nstring).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, or ONREPLY_ROUTE.\n\n    ...\n    # $ru: tel:+(34)-999-888-777\n    # $fu: sip:test@foo.com\n    tel2sip(\"$ru\", $fd\", \"$ru\");\n    # $ru:  sip:+34999888777@foo.com;user=phone\n\n    # $ru: tel:+12-(34)-56-78;Ext=200;ISUB=+123-456\n    # $fu: sip:test@foo.com\n    tel2sip(\"$ru\", $fd\", \"$ru\");\n    # $ru:  sip:+12345678;ext=200;isub=+123-456@foo.com;user=phone\n    ...\n\n",
 "is_e164": "### is_e164(pseudo-variable)\n\n module: siputils\n\nChecks if string value of pseudo variable argument is an E164 number.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE, and\nLOCAL_ROUTE.\n\n    ...\n    if (is_e164(\"$fU\")) {  # Check From header URI user part\n       ...\n    }\n    if (is_e164(\"$avp(i:705)\") {\n       # Check stgring value stored in avp i:705\n       ...\n    };\n    ...\n\n",
 "is_uri_user_e164": "### is_uri_user_e164(pseudo-variable)\n\n module: siputils\n\nChecks if userpart of URI stored in pseudo variable is E164 number.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_uri_user_e164(\"$fu\")) {  # Check From header URI user part\n       ...\n    }\n    if (is_uri_user_e164(\"$avp(i:705)\") {\n       # Check user part of URI stored in avp i:705\n       ...\n    };\n    ...\n\n",
 "is_uri": "### is_uri(pseudo-variable)\n\n module: siputils\n\nChecks if string value of pseudo variable argument is a valid uri.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_uri(\"$var(x)\")) {  # Check if variable contains a uri\n       ...\n    }\n    if (is_uri(\"$avp(i:705)\") {\n       # Check value stored in avp i:705\n       ...\n    };\n    ...\n\n",
 "is_tel_number": "### is_tel_number(tval)\n\n module: siputils\n\nChecks if the parameter value is a telephone number: starting with one\noptional +, followed by digits. The parameter can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_tel_number(\"$rU\")) {  # Test if R-URI user is telephone number\n       ...\n    }\n    if (is_tel_number(\"+24242424\")) {\n       ...\n    }\n    ...\n\n",
 "is_numeric": "### is_numeric(tval)\n\n module: siputils\n\nChecks if the parameter value consists solely of decimal digits. The\nparameter can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_numeric(\"$rU\")) {  # Test if R-URI user consists of decimal digits\n       ...\n    }\n    ...\n\n",
 "is_alphanum": "### is_alphanum(tval)\n\n module: siputils\n\nChecks if the parameter value consists solely of decimal digits or\nalphabetic ASCII characters. The parameter can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_alphanum(\"$rU\")) {\n       ...\n    }\n    ...\n\n",
 "is_alphanumex": "### is_alphanumex(tval, eset)\n\n module: siputils\n\nChecks if the value of parameter 'tval' consists solely of decimal\ndigits, alphabetic ASCII characters and the characters in the second\nparameter 'eset'. The parameters can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_alphanumex(\"$rU\", \"+.-_\")) {\n       ...\n    }\n    ...\n\n",
 "cmp_uri": "### cmp_uri(str1, str2)\n\n module: siputils\n\nThe function returns *true* if the two parameters matches as SIP URI.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(cmp_uri(\"$ru\", \"sip:kamailio@kamailio.org\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "cmp_aor": "### cmp_aor(str1, str2)\n\n module: siputils\n\nThe function returns *true* if the two parameters matches as AoR. The\nparameters have to be SIP URIs.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(cmp_aor(\"$rU@KaMaIlIo.org\", \"sip:kamailio@$fd\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "cmp_hdr_name": "### cmp_hdr_name(str1, str2)\n\n module: siputils\n\nThe function returns *true* (return code 1) if the two parameters\nmatches as header names.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(cmp_hdr_name(\"$var(hname)\", \"From\"))\n    {\n        # do interesting stuff here\n    }\n    ...\n\n",
 "append_rpid_hf": "### append_rpid_hf()\n\n module: siputils\n\nAppends to the message a Remote-Party-ID header that contains header\n'Remote-Party-ID: ' followed by the saved value of the SIP URI received\nfrom the database or radius server followed by the value of module\nparameter radius_rpid_suffix. The function does nothing if no saved SIP\nURI exists.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    append_rpid_hf();  # Append Remote-Party-ID header field\n    ...\n\n### append_rpid_hf(prefix, suffix)\n\n module: siputils\n\nThis function is the same as [ ](#siputils.f.append_rpid_hf). The only\ndifference is that it accepts two parameters--prefix and suffix to be\nadded to Remote-Party-ID header field. This function ignores rpid_prefix\nand rpid_suffix parameters, instead of that allows to set them in every\ncall.\n\nMeaning of the parameters is as follows:\n\n- *prefix* - Prefix of the Remote-Party-ID URI. The string will be added\n  at the beginning of the body of the header field, just before the URI.\n\n- *suffix* - Suffix of the Remote-Party-ID header field. The string will\n  be appended at the end of the header field. It can be used to set\n  various URI parameters, for example.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n    ...\n    # Append Remote-Party-ID header field\n    append_rpid_hf(\"\", \";party=calling;id-type=subscriber;screen=yes\");\n    ...\n\n",
 "is_rpid_user_e164": "### is_rpid_user_e164()\n\n module: siputils\n\nThe function checks if the SIP URI received from the database or radius\nserver and will potentially be used in Remote-Party-ID header field\ncontains an E164 number (+followed by up to 15 decimal digits) in its\nuser part. Check fails, if no such SIP URI exists (i.e. radius server or\ndatabase didn't provide this information).\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_rpid_user_e164()) {\n        # do something here\n    };\n    ...\n\n",
 "set_uri_user": "### set_uri_user(uri, user)\n\n module: siputils\n\nSets userpart of SIP URI stored in writable pseudo variable 'uri' to\nvalue of pseudo variable 'user'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(uri) = \"sip:user@host\";\n    $var(user) = \"new_user\";\n    set_uri_user(\"$var(uri)\", \"$var(user)\");\n    ...\n\n",
 "set_uri_host": "### set_uri_host(uri, host)\n\n module: siputils\n\nSets hostpart of SIP URI stored in writable pseudo variable 'uri' to\nvalue of pseudo variable 'host'.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    $var(uri) = \"sip:user@host\";\n    $var(host) = \"new_host\";\n    set_uri_host(\"$var(uri)\", \"$var(host)\");\n    ...\n\n",
 "is_request": "### is_request()\n\n module: siputils\n\nReturn true if the SIP message is a request.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_request()) {\n        ...\n    }\n    ...\n\n",
 "is_reply": "### is_reply()\n\n module: siputils\n\nReturn true if the SIP message is a reply.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_reply()) {\n        ...\n    }\n    ...\n\n",
 "is_gruu": "### is_gruu([uri])\n\n module: siputils\n\nThe function returns true if the uri is GRUU ('gr' parameter is\npresent): 1 - pub-gruu; 2 - temp-gruu.\n\nMeaning of the parameters is as follows:\n\n- *uri* - the SIP URI to check for GRUU parameter. It is optional, when\n  missing, the value of R-URI is used.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(is_gruu()) { ... }\n    ...\n\n",
 "is_supported": "### is_supported(option)\n\n module: siputils\n\nFunction returns true if given option is listed in Supported header(s)\n(if any) of the request. Currently the following options are known:\npath, 100rel, timer, eventlist, gruu, and outbound.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (is_supported(\"outbound\")) { ... }\n    ...\n\n",
 "is_first_hop": "### is_first_hop([mode])\n\n module: siputils\n\nThe function returns true if the proxy is first hop after the original\nsender based on a best effort estimation by checking Via and\nRecord-Route headers.\n\nFor incoming SIP requests, it means there is only one Via header.\n\nFor incoming SIP replies, if mode==0, it means that top Record-Route URI\nis 'myself' and source address is not matching local IP (to avoid\ndetecting in case of local loops). Therefore for mode==0 the detection\nis done only when Record-Route has an IP address in its URI (for a\ndomain, it returns -1/false). If mode==1, then the check of local IP is\nno longer done, only if top Record-Route is myself, returning true also\nif there is a domain, assuming that is expected no looping can happen\nbased on config rules.\n\nNote that it does not detect spirals, which can have the condition for\nreplies true also in the case of additional SIP reply reception.\n\nParameter mode is optional and can be an integer or a variable holding\nan integer. If not provided, the behaviour is like mode==0.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(is_first_hop()) { ... }\n    ...\n    if(is_first_hop(\"1\")) { ... }\n    ...\n\n",
 "sip_p_charging_vector": "### sip_p_charging_vector(flags)\n\n module: siputils\n\nManage the P-Charging-Vector header (RFC7315). The flags can be: 'r' -\nremove; 'g' - generate; 'f' - force (remove + generate).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sip_p_charging_vector(\"g\");\n    ...\n\n",
 "contact_param_encode": "### contact_param_encode(pname, saddr)\n\n module: siputils\n\nThis function encodes URI inside Contact headers by building a new URI\nfrom 'saddr' parameter and adding a parameter with the name 'pname'\ncontaining incoming URI encoded in Base64URL format.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the new URI parameter to hold the encoded incoming\n  URI.\n\n- *saddr* - local server address in SIP URI format.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    if (is_method(\"REGISTER\") and src_ip == 10.0.0.0/8) {\n        contact_param_encode(\"ksu\", \"sip:1.2.3.4:5060;transport=tcp\");\n    }\n    ...\n\n",
 "contact_param_decode": "### contact_param_decode(pname)\n\n module: siputils\n\nThis function decodes URI inside Contact headers by building a new URI\nfrom 'pname' parameter, decoding its value from Base64URL.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the incoming URI parameter holding the encoded URI\n  value.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    if (is_method(\"REGISTER\") and src_ip == 1.2.3.4) {\n        contact_param_decode(\"ksu\");\n    }\n    ...\n\n",
 "contact_param_decode_uri": "### contact_param_decode_uri(pname)\n\n module: siputils\n\nThis function decodes R-URI (request URI) by building a new R-URI from\n'pname' parameter, decoding its value from Base64URL.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the incoming URI parameter holding the encoded URI\n  value.\n\nThis function can be used from REQUEST_ROUTE.\n\n    ...\n    if (is_method(\"INVITE\") and src_ip == 1.2.3.4) {\n        contact_param_decode_ruri(\"ksu\");\n    }\n    ...\n\n",
 "contact_param_rm": "### contact_param_rm(pname)\n\n module: siputils\n\nThis function removes the parameter from the URIs inside the Contact\nheaders.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the URI parameter.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n    ...\n    if (is_method(\"REGISTER\") and src_ip == 1.2.3.4) {\n        contact_param_rm(\"myparam\");\n    }\n    ...\n\n",
 "hdr_date_check": "### hdr_date_check(tdiff)\n\n module: siputils\n\nReturns true if sip message has Date header and its value is lower than\n'NOW() - tdiff'.\n\nMeaning of the parameters is as follows:\n\n- *tdiff* - time difference in seconds, it can be a variable or static\n  integer value.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if (!hdr_date_check(\"10\")) {\n        sl_send_reply(\"403\", \"Outdated date\");\n        exit;\n    }\n    ...\n\n",
 "xcaps_put": "### xcaps_put(uri, path, doc)\n\n module: xcap_server\n\nHandle XCAP PUT command.\n\n    ...\n    event_route[xhttp:request] {\n        if($hu=~\"^/xcap-root/\")\n        {\n            # xcap ops\n            switch($rm) {\n                case \"PUT\":\n                    xcaps_put(\"sip:101@$Ri\", \"$hu\", \"$rb\");\n                    exit;\n                    break;\n            }\n        }\n    }\n    ...\n\n",
 "xcaps_get": "### xcaps_get(uri, path)\n\n module: xcap_server\n\nHandle XCAP GET command.\n\n    ...\n    event_route[xhttp:request] {\n        if($hu=~\"^/xcap-root/\")\n        {\n            # xcap ops\n            switch($rm) {\n                case \"GETT\":\n                    xcaps_get(\"sip:101@$Ri\", \"$hu\");\n                    exit;\n                    break;\n            }\n        }\n    }\n    ...\n\n",
 "xcaps_del": "### xcaps_del(uri, path)\n\n module: xcap_server\n\nHandle XCAP DELETE command.\n\n    ...\n    event_route[xhttp:request] {\n        if($hu=~\"^/xcap-root/\")\n        {\n            # xcap ops\n            switch($rm) {\n                case \"DELETE\":\n                    xcaps_del(\"sip:101@$Ri\", \"$hu\");\n                    exit;\n                    break;\n            }\n        }\n    }\n    ...\n\n",
 "auth_xkeys_add": "### auth_xkeys_add(hdr, kid, alg, data)\n\n module: auth_xkeys\n\nAdd a header computed with the first key in the group kid, hashing with\nalgorithm alg over the content of parameter data. The parameters can\ninclude variables.\n\nThe algorithm can be: sha256, sha384, sha512.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    auth_xkeys_add(\"X-My-Key\", \"abc\", \"sha256\", \"$Ri:$fu:$ru:$hdr(CSeq)\");\n    ...\n\n",
 "auth_xkeys_check": "### auth_xkeys_check(hdr, kid, alg, data)\n\n module: auth_xkeys\n\nCheck if the value of header hdr matches the value computed with the\nfirst key in the group kid, hashing with algorithm alg over the content\nof parameter data. The parameters can include variables.\n\nThe algorithm can be: sha256, sha384, sha512.\n\nNote that the header is not removed by the function, it is recommended\nto remove it if sending to untrusted destination.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    if(!auth_xkeys_check(\"X-My-Key\", \"abc\", \"sha256\", \"$si:$fu:$ru:$hdr(CSeq)\")) {\n        send_reply(\"403\", \"Forbidden\");\n        exit;\n    }\n    remove_hf(\"X-My-Key\");\n    ...\n",
 "diameter_request": "### diameter_request([peer], appid, commandcode, message)\n\n module: ims_diameter_server\n\nThis method will send a Diameter Request.\n\nMeaning of the parameters is as follows:\n\n- *peer* - send the diameter request directly to a diameter peer\n  \\[optional\\]. If this parameter is omitted, the default routing is\n  used (see CDP).\n\n- *appid* - Diameter-Application, e.g.:\n\n  Typical App-ID's are:\n\n  - 16777216 - Diameter Cx/Dx\n\n  - 16777217 - Diameter Sh\n\n  - 4 - Diameter Ro (Online Charging)\n\n  - ...\n\n- *commandcode* - Diameter-Command-Code, e.g.:\n\n  - 300 - Diameter Cx/Dx User-Assignment Request (UAR)\n\n  - 301 - Diameter Cx/Dx Server-Assignment Request (SAR)\n\n  - ...\n\n- *message* - the Diameter Message (as JSON), which should be sent.\n\nThis function can be used from any route.\n\n    ...\n    diameter_request(\"16777216\", \"300\", \"{ some json }\");\n    ...\n            \n\n",
 "diameter_request_async": "### diameter_request_async([peer], appid, commandcode, message)\n\n module: ims_diameter_server\n\nThis method will send a Diameter Request asynchronously. The Reply to\nthis request will be visible in the event-route \"diameter:response\".\n\nThe meaning of the parameters are identical to the diameter_request\nfunction.\n\nThis function is only available, if the diameter:response event-route is\ndefined.\n\n",
 "sqlang_dofile": "### sqlang_dofile(path)\n\n module: app_sqlang\n\nNote: not implemented yet.\n\nExecute the SQLang script stored in 'path'. The parameter can be a\nstring with pseudo-variables evaluated at runtime.\n\n    ...\n    sqlang_dofile(\"/usr/local/etc/kamailio/sqlang/myscript.sq\");\n    ...\n\n",
 "sqlang_dostring": "### sqlang_dostring(script)\n\n module: app_sqlang\n\nNote: not implemented yet.\n\nExecute the Squirrel script stored in parameter. The parameter can be a\nstring with pseudo-variables.\n\n    ...\n    if(!sqlang_dostring('KSR.dbg(\"test message\\n\")'))\n    {\n        xdbg(\"SCRIPT: failed to execute squirrel script!\\n\");\n    }\n    ...\n\n",
 "sqlang_run": "### sqlang_run(function [, params])\n\n module: app_sqlang\n\nExecute the Squirrel function 'func' giving params as parameters. There\ncan be up to 3 string parameters. The function must exist in the script\nloaded at startup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n    ...\n    if(!sqlang_run(\"sqlang_append_fu_to_reply\"))\n    {\n        xdbg(\"SCRIPT: failed to execute squirrel function!\\n\");\n    }\n    ...\n    sqlang_run(\"sqlang_funcx\", \"$rU\", \"2\");\n    ...\n\n",
 "sqlang_runstring": "### sqlang_runstring(script)\n\n module: app_sqlang\n\nNote: not implemented yet.\n\nExecute the SQLang script stored in parameter. The parameter can be a\nstring with pseudo-variables. The script is executed in JS context\nspecific to loaded JS files at startup.\n\n    ...\n    if(!sqlang_runstring('KSR.dbg(\"Hello World from $fU\\n\")'))\n    {\n        xdbg(\"failed to execute squirrel script!\\n\");\n    }\n    ...\n\n",
 "stirshaken_check_identity": "### stirshaken_check_identity()\n\n module: stirshaken\n\nCheck the validity of the Identity header by decoding PASSporT's\nsignature with a certificate referenced in its x5u header and\n(optionally) checking that certificate for being trusted by X509\ncertificate check with CA root certificates in vs_ca_dir (and optionally\nCRLs in vs_crl_dir). PASSporT's iat grant is also checked for being too\nfresh or expired against vs_identity_expire_s seconds. This function\nexecutes a call to a callback which may supply certificates from cache\n(see vs_cache_certificates param). If certificate needs to be downloaded\nthis call will block for a maximum of vs_connect_timeout_s seconds (see\nvs_connect_timeout_s param);\n\nThis function takes no parameters (only SIP message is passed\nimplicitly).\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    modparam(\"stirshaken\", \"vs_verify_x509_cert_path\", 1)\n    modparam(\"stirshaken\", \"vs_ca_dir\", \"/path/to/ca\")\n    modparam(\"stirshaken\", \"vs_cache_certificates\", 1)\n    modparam(\"stirshaken\", \"vs_cache_dir\", \"/path/to/cert_cache\")\n    modparam(\"stirshaken\", \"vs_cache_expire_s\", 100)\n\n    request_route {\n        ...\n            if (1 == stirshaken_check_identity()) {\n                xlog(\"Shaken Identity is OK\\n\");\n            } else {\n                xlog(\"Shaken Identity is invalid\\n\");\n            }\n        ...\n    }\n    ...\n\n",
 "stirshaken_check_identity_with_key": "### stirshaken_check_identity_with_key(keyPath)\n\n module: stirshaken\n\nCheck the validity of the Identity header by decoding PASSporT's\nsignature with a key read from the location provided. PASSporT's iat\ngrant is also checked for being too fresh or expired against\nvs_identity_expire_s seconds. This method does not involve HTTP(s)\ntranscations. This method does not execute a call to a callback\n(vs_cache_certificates param has no meaning for this method). WARNING:\nThis method only checks if SIP Identity Header was signed by a key\ncorresponding to specified public key. This method doesn't attempt to\nobtain certificate referenced in PASSporT (but PASSporT should be\nchecked with key corresponding to that certificate). Therefore it is\npossible that this check will be successful, while PASSporT is not valid\n(could be signed with key that doesn't match certificate referenced in\nx5u header). If you want a complete Shaken check or if you are not sure\nwhat you're doing, then you should execute w_stirshaken_check_identity()\ninstead (and configure Verification Service to perform X509 certificate\npath verification with stirshaken_vs_verify_x509_cert_path param set to\n1).\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n            if (1 == stirshaken_check_identity_with_key(\"/path/to/key\")) {\n                xlog(\"Shaken Identity is OK\\n\");\n            } else {\n                xlog(\"Shaken Identity is invalid\\n\");\n            }\n        ...\n    }\n    ...\n\n",
 "stirshaken_check_identity_with_cert": "### stirshaken_check_identity_with_cert(certPath)\n\n module: stirshaken\n\nSame as stirshaken_check_identity_with_key(keyPath) but the key is read\nfrom the certificate which is read from the location provided.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n            if (1 == stirshaken_check_identity_with_cert(\"/path/to/cert\")) {\n                xlog(\"Shaken Identity is OK\\n\");\n            } else {\n                xlog(\"Shaken Identity is invalid\\n\");\n            }\n        ...\n    }\n    ...\n\n",
 "stirshaken_add_identity": "### stirshaken_add_identity(x5u, attest, origtn_val, desttn_val, origid)\n\n module: stirshaken\n\nAdd SIP Identity Header to the call using default private key (see\nas_default_key param). Authenticate call with STIR-Shaken. If origID is\nempty, a UUID string is generated to fill the field. The origtn_val\nrepresents the origination telephone number; desttn_val, represents the\ndestination telephone number; x5u is the HTTP(s) URL referencing to the\npublic key that should be used to verify the signature; attest\nrepresents the attestation level (should be \"A\", \"B\" or \"C\").\n\nThe parameters can contain pseudo-variables. If origid is empty, an\nunique identifier will be generated with libuuid, e.g.\n\"3f31bd2b-9fc4-4084-b0b0-566506c46292\".\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n            if (1 == stirshaken_add_identity(\"https://sp.com/sp.pem\", \"B\", \"+44100\", \"+44200\", \"origid\")) {\n                xlog(\"Shaken authentication added (SIP Identity Header created)\\n\");\n            } else {\n                xlog(\"Failed\\n\");\n            }\n        ...\n    }\n    ...\n\nIf origid is empty, an unique identifier will be generated with libuuid,\ne.g. \"3f31bd2b-9fc4-4084-b0b0-566506c46292\".\n\n    ...\n    request_route {\n        ...\n            if (1 == stirshaken_add_identity(\"https://sp.com/sp.pem\", \"B\", \"+44100\", \"+44200\", \"\")) {\n                xlog(\"Shaken authentication added (SIP Identity Header created)\\n\");\n            } else {\n                xlog(\"Failed\\n\");\n            }\n        ...\n    }\n    ...\n\n",
 "stirshaken_add_identity_with_key": "### stirshaken_add_identity_with_key(x5u, attest, origtn_val, desttn_val, origid, keyPath)\n\n module: stirshaken\n\nSame as stirshaken_add_identity() but using the key read from the\nlocation provided as a last parameter.\n\nThe parameters can contain pseudo-variables. If origid is empty, an\nunique identifier will be generated with libuuid, e.g.\n\"3f31bd2b-9fc4-4084-b0b0-566506c46292\".\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    request_route {\n        ...\n            if (1 == stirshaken_add_identity_with_key(\"https://sp.com/sp.pem\", \"B\", \"+44100\", \"+44200\", uuid, \"/path/to/key\")) {\n                xlog(\"Shaken authentication added (SIP Identity Header created)\\n\");\n            } else {\n                xlog(\"Failed\\n\");\n            }\n        ...\n    }\n    ...\n\n",
 "t_cancel_branches": "### t_cancel_branches(which)\n\n module: tmx\n\nCancel branches of an active SIP transaction. The function can be called\nfor a SIP reply that will identify the current branch.\n\nParameter can be:.\n\n- *all* - cancel all branches.\n\n- *others* - cancel all branches but the current one.\n\n- *this* - cancel current branch.\n\nThis function can be used in ONREPLY_ROUTE.\n\n    ...\n    if (t_cancel_branches(\"all\")) {\n        xlog(\"cancelled all branches\\n\");\n    }\n    ...\n\n",
 "t_cancel_callid": "### t_cancel_callid(callid, cseq, flag [, rcode])\n\n module: tmx\n\nCancel first INVITE transaction identified by callid and cseq. It sets\nthe flag if the value is greater than zero\n\nParameters:.\n\n- *callid* - call-id value.\n\n- *cseq* - cseq number.\n\n- *flag* - index of the flag to set.\n\n- *rcode* - code to be added as cause attribute in Reason header for\n  generated CANCEL request. This parameter is optional.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    if (t_cancel_callid(\"123qaz\", \"5\", \"22\")) {\n        xlog(\"transaction cancelled\\n\");\n    }\n    ...\n    if (t_cancel_callid(\"123qaz\", \"5\", \"22\", \"200\")) {\n        xlog(\"transaction cancelled with [Reason: cause=200]\\n\");\n    }\n    ...\n\n",
 "t_reply_callid": "### t_reply_callid(callid, cseq, code, reason)\n\n module: tmx\n\nSend reply to first transaction identified by callid and cseq.\n\nParameters:.\n\n- *callid* - call-id value.\n\n- *cseq* - cseq number.\n\n- *code* - reply code.\n\n- *reason* - reply reason.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    if (t_reply_callid(\"123qaz\", \"5\", \"458\", \"Replied remotely\")) {\n        xlog(\"transaction replied\\n\");\n    }\n    ...\n\n",
 "t_flush_flags": "### t_flush_flags()\n\n module: tmx\n\nFlush the flags from current SIP message into the already created\ntransaction. It makes sense only in routing block if the transaction was\ncreated via t_newtran() and the flags have been altered since.\n\nIt is not needed to execute this function when using t_relay() (or\nsimilar tm relay functions, flags are synchronized automatically in that\ncase).\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    t_flush_flags();\n    ...\n\n",
 "t_flush_xflags": "### t_flush_xflags()\n\n module: tmx\n\nFlush the extended flags from current SIP message into the already\ncreated transaction. It makes sense only in routing block if the\ntransaction was created via t_newtran() and the extended flags have been\naltered since.\n\nIt is not needed to execute this function when using t_relay() (or\nsimilar tm relay functions, xflags are synchronized automatically in\nthat case).\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    t_flush_xflags();\n    ...\n\n",
 "t_is_failure_route": "### t_is_failure_route()\n\n module: tmx\n\nReturns true if the top-executed route block is failure_route.\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    failure_route[xyz] {\n        route(abc);\n    }\n\n    route[abc] {\n        if(t_is_failure_route()) { ... }\n    }\n    ...\n\n",
 "t_is_branch_route": "### t_is_branch_route()\n\n module: tmx\n\nReturns true if the top-executed route block is branch_route.\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    branch_route[xyz] {\n        route(abc);\n    }\n\n    route[abc] {\n        if(t_is_branch_route()) { ... }\n    }\n    ...\n\n",
 "t_is_reply_route": "### t_is_reply_route()\n\n module: tmx\n\nReturns true if the top-executed route block is reply_route.\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    reply_route[xyz] {\n        route(abc);\n    }\n\n    route[abc] {\n        if(t_is_reply_route()) { ... }\n    }\n    ...\n\n",
 "t_is_request_route": "### t_is_request_route()\n\n module: tmx\n\nReturns true if the top-executed route block is request_route.\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    request_route[xyz] {\n        route(abc);\n    }\n\n    route[abc] {\n        if(t_is_request_route()) { ... }\n    }\n    ...\n\n",
 "t_suspend": "### t_suspend()\n\n module: tmx\n\nSuspend the execution of SIP request in a transaction. If transaction\nwas not created yet, it is created by this function. Returns true in\ncase of success and internal transaction index and label are available\nvia \\$T(id_index) and \\$T(id_label).\n\nThis function can be used from ANY_ROUTE .\n\n    ...\n    if(t_suspend())\n    {\n        xlog(\"processing suspended in transaction [$T(id_index):$T(id_label)]\\n\");\n        exit;\n    }\n    ...\n\n",
 "t_continue": "### t_continue(tindex, tlabel, rtname)\n\n module: tmx\n\nContinue the execution of the transaction identified by tindex and\ntlabel with the actions defined in route\\[rtname\\].\n\nParameters:.\n\n- *tindex* - internal index of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *tlabel* - internal label of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *rtname* - the name of the route block to execute. Can be a static\n  string value or a dynamic string with pseudo-variables.\n\nImportant note: the route\\[rtname\\] is executed in the context of a\nfailure (same behaviour for functions as they were used in a\nfailure_route block).\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    t_continue('123', '456', 'MYROUTE');\n    ...\n    route[MYROUTE] {\n      xlog(\"executed by t continue\\n\");\n      ...\n    }\n    ...\n\n",
 "t_drop": "### t_drop([rcode])\n\n module: tmx\n\nDrops the transaction with response code (500 default).\n\nParameters:.\n\n- *rcode* - response code to set in uas status.\n\nThis function can be used in ANY_ROUTE.\n\n    ...\n    route[MYREQ]\n    {\n    ...\n        if (!t_newtran()) {\n            xlog(\"L_ERROR\", \"$ci|log|failed to create transaction\\n\");\n            drop;\n        }\n\n        t_on_failure(\"TR_ERROR\");\n        t_on_reply(\"TR_OK\");\n        t_relay();\n    }\n\n    failure_route[TR_ERROR]\n    {\n        xlog(\"L_INFO\", \"$ci|log|failed $T_reply_code $T_reply_reason\\n\");\n        t_drop();\n    }\n\n    onreply_route[TR_OK]\n    {\n       xlog(\"L_INFO\", \"$ci|log|checking transaction result\\n\");\n       if(status=~\"60[0-9]\") {\n          t_drop();\n       }\n    ...\n    }\n    ...\n\n",
 "t_reuse_branch": "### t_reuse_branch()\n\n module: tmx\n\nCreates new \"main\" branch by making copy of branch-failure branch.\nCurrently the following branch attributes are copied from branch-failure\nbranch: request-uri, ruid, path, instance, and branch flags.\n\nThis function can be used from tm:branch-failure event_route.\n\n    ...\n    event_route [tm:branch-failure:contact] {\n        t_reuse_branch();\n        setbflag(10);\n        t_relay();\n        exit;\n    }\n    ...\n\n",
 "t_precheck_trans": "### t_precheck_trans()\n\n module: tmx\n\nCheck if current processed message is handled by other process. This\nfunction is useful to catch retransmissions before transaction is\ncreated. The function returns true if the request is handled by another\nprocess.\n\nNote that ACK and CANCEL requests are not tracked by this function, the\nreturn code being false for them.\n\nThis function can be used from REQUEST_ROUTE .\n\n    ...\n        # handle retransmissions\n        if(t_precheck_trans()) {\n            t_check_trans();\n            exit;\n        }\n        t_check_trans();\n    ...\n\n",
 "do_routing": "### do_routing([groupID])\n\n module: drouting\n\nFunction to trigger routing of the message according to the rules in the\ndatabase table and the configured parameters.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\nThe module can take one optional parameter: the routing group the caller\nbelongs to - this may be a static int value or a variable holding an\nint. If none specified, the function will automatically try to query the\ndr_group table to get the group id associated with the user in From URI.\n\n    ...\n    do_routing();\n    ...\n    do_routing(\"0\");\n    ...\n    do_routing(\"$avp(i:10)\");\n\n",
 "next_routing": "### next_routing()\n\n module: drouting\n\nThe function takes the next available destination (set by do_routing, as\nalternative destinations) and push it into RURI. Note that the function\njust sets the RURI (nothing more).\n\nIf a new RURI is set, the used destination is removed from the pending\nset of alternative destinations.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\nThe function returns true only if a new RURI was set. False is returned\nis no other alternative destinations are found or in case of internal\nprocessing error.\n\n    ...\n    if (next_routing()) {\n        t_relay();\n        exit;\n    }\n    ...\n\n",
 "use_next_gw": "### use_next_gw()\n\n module: drouting\n\nSame as next_routing().\n\n",
 "goes_to_gw": "### goes_to_gw([type])\n\n module: drouting\n\nFunction returns true if the destination of the current request\n(destination URI or Request URI) points (as IP) to one of the gateways.\nThere is no DNS lookups done if the domain part of the URI is not an IP.\n\nThis function does not change anything in the message.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE and\nONREPLY_ROUTE.\n\nThe function can take two optional parameters:\n\n- type\n  \\- GW/destination type to be checked\n\n<!-- -->\n\n    ...\n    if (goes_to_gw(\"1\")) {\n        sl_send_reply(\"403\",\"Forbidden\");\n        exit;\n    }\n    ...\n\n",
 "is_from_gw": "### is_from_gw([ type, [flag] ])\n\n module: drouting\n\nThe function checks if the sender of the message is a gateway from a\ngroup in drouting rules.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE and\nONREPLY_ROUTE.\n\nThe function can take two parameters:\n\n- type\n  (mandatory) - GW/destination type to be checked\n- flags\n  (optional) - if message is a request and the GW has a STRIP defined,\n  then apply it if GW is source.\n\n<!-- -->\n\n    ...\n    if (is_from_gw(\"1\") {\n    }\n    ...\n    if (is_from_gw(\"3\",\"1\") {\n    }\n    ...\n\n",
 "rand_event": "### rand_event()\n\n module: cfgutils\n\nReturn true or false, depending on a random value and a probability\nvalue.\n\n    ...\n    if (rand_event()) {\n      append_to_reply(\"Retry-After: 120\\n\");\n      sl_send_reply(\"503\", \"Try later\");\n      exit;\n    };\n    # normal message processing follows\n    ...\n\n",
 "rand_set_prob": "### rand_set_prob(probability)\n\n module: cfgutils\n\nSet the \u201cprobability\u201d of the decision.\n\n\u201cprobability\u201d can have a value from the range 0..100.\n\n    ...\n    rand_set_prob(\"4\");\n    ...\n\n",
 "rand_reset_prob": "### rand_reset_prob()\n\n module: cfgutils\n\nReset the probability back to the initial value.\n\n    ...\n    rand_reset_prob();\n    ...\n\n",
 "rand_get_prob": "### rand_get_prob()\n\n module: cfgutils\n\nReturn the current probability setting, e.g. for logging purposes.\n\n    ...\n    rand_get_prob();\n    ...\n\n",
 "sleep": "### sleep(time)\n\n module: cfgutils\n\nWaits \"time\" seconds.\n\nMeaning of the parameters is as follows:\n\n- *time* - Time to wait in seconds. It can be an integer or a variable\n  holding an integer.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    sleep(\"1\");\n    ...\n                \n\n",
 "usleep": "### usleep(time)\n\n module: cfgutils\n\nWaits \"time\" micro-seconds.\n\nMeaning of the parameters is as follows:\n\n- *time* - Time to wait in micro-seconds (1/1000000 of a second). It can\n  be an integer or a variable holding an integer.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    # wait 5 milliseconds\n    usleep(\"5000\");\n    ...\n                \n\n",
 "abort": "### abort()\n\n module: cfgutils\n\nDebugging function that aborts the server. Depending on the\nconfiguration of the server a core dump will be created.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    abort();\n    ...\n                \n\n",
 "pkg_status": "### pkg_status()\n\n module: cfgutils\n\nDebugging function that dumps the status for the private (PKG) memory.\nThis information is logged to the default log facility, depending on the\ngeneral log level and the memlog setting. You need to compile the server\nwith activated memory debugging to get detailed informations.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    pkg_status();\n    ...\n                \n\n",
 "pkg_summary": "### pkg_summary()\n\n module: cfgutils\n\nDebugging function that dumps the summary for the private (PKG) memory\nusage. This information is logged to the default log facility, depending\non the general log level and the memlog setting. You need to compile the\nserver with activated memory debugging to get detailed informations.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    pkg_summary();\n    ...\n                \n\n",
 "shm_status": "### shm_status()\n\n module: cfgutils\n\nDebugging function that dumps the status for the shared (SHM) memory.\nThis information is logged to the default log facility, depending on the\ngeneral log level and the memlog setting. You need to compile the server\nwith activated memory debugging to get detailed informations.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n    ...\n    shm_status();\n    ...\n                \n\n",
 "shm_summary": "### shm_summary()\n\n module: cfgutils\n\nDebugging function that dumps the summary for the shared (SHM) memory\nusage. This information is logged to the default log facility, depending\non the general log level and the memlog setting. You need to compile the\nserver with activated memory debugging to get detailed informations.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    shm_summary();\n    ...\n                \n\n",
 "reset_gflag": "### reset_gflag(flag)\n\n module: cfgutils\n\nReset the bit at the position \u201cflag\u201d in global flags.\n\n\u201cflag\u201d can have a value in the range of 0..31.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n    ...\n    reset_gflag(\"4\");\n    ...\n\n",
 "is_gflag": "### is_gflag(flag)\n\n module: cfgutils\n\nCheck if bit at the position \u201cflag\u201d in global flags is set.\n\n\u201cflag\u201d can have a value in the range of 0..31.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n    ...\n    if(is_gflag(\"4\"))\n    {\n        log(\"global flag 4 is set\\n\");\n    } else {\n        log(\"global flag 4 is not set\\n\");\n    };\n    ...\n\n",
 "lock": "### lock(key)\n\n module: cfgutils\n\nLock the key. Can be used to synchronize operations in config file, a\nhash id is computed over the key and appropriate lock is set in the lock\narray controlled by parameter \"lock_set_size\". Do not use lock() after\nanother lock() unless you are sure the keys hit different array entries.\n\n\u201ckey\u201d can be static string or string with PVs.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n    ...\n    lock(\"$rU\");\n    ...\n\n",
 "trylock": "### trylock(key)\n\n module: cfgutils\n\nTry to lock the key. If the lock can not be obtained (possibly already\nlocked), the function returns an error and script execution continues.\n\n\u201ckey\u201d can be static string or string with PVs.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n    ...\n    if (trylock(\"$rU\")) {\n        xlog(\"L_INFO\", \"Doing some cool stuff\\n\");\n        unlock(\"$rU\");\n    }\n    ...\n\n",
 "unlock": "### unlock(key)\n\n module: cfgutils\n\nUnlock the key.\n\n\u201ckey\u201d can be static string or string with PVs.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n    ...\n    unlock(\"$rU\");\n    ...\n\n",
 "check_route_exists": "### check_route_exists(route)\n\n module: cfgutils\n\nCheck if a route block exists. It returns true (1) on found and false on\nnot found or error.\n\nParameters:\n\n\u201cname\u201d of a route block in the config file, like \u201croute\\[FROGJUMP\\]\u201d\n\nThis function can be used from any route. You can only check for\nroute\\[\\] blocks, not reply, event or other routes.\n\n    ...\n    if(check_route_exists(\"JUMP\") {\n        $var(jumping_frogs) = 1;\n    };\n    ...\n\n",
 "route_if_exists": "### route_if_exists(route)\n\n module: cfgutils\n\nExecute a routing block only if it is defined. If it's not defined,\nsilently move to the next action in the configuration script.\n\nIt returns the code of last action in the route block, if that exists,\nor false if the route doesn't exists or was an error executing it.\n\nParameters:\n\n\u201cname\u201d of a route block in the config file, like \u201croute\\[FROGJUMP\\]\u201d\n\nThis function can be used from any route. You can only execute it for\nroute\\[\\] blocks, not reply, event or other routes.\n\n    ...\n    if(route_if_exists(\"JUMP\")) {\n        exit;\n    }\n    ...\n\n",
 "core_hash": "### core_hash(string1, string2, size)\n\n module: cfgutils\n\nExported function that enables the core_hash() function to be used from\nthe configuration file.\n\nThis is a quick and simple hash function and it is not cryptographically\nsecure. This function should not be used for any security related\npurposes.\n\nParameters:\n\n- \u201cstring1\u201d first string to hash\n\n- \u201cstring2\u201d (optional) second string to hash (set to \"\" if not needed)\n\n- \u201csize\u201d size of the hash space (used as a power of 2)\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    core_hash(\"$ci\", \"\", 4);\n    ...\n\n",
 "ipsec_create": "### ipsec_create(domain)\n\n module: ims_ipsec_pcscf\n\nThis function creates IPSec SA and Policy based on the parameters sent\nin Security-Client header in the REGISTER message. It's called when OK\nis received. The function also adds Security-Server header to the\nREGISTER.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n  *flags* - bitwise flag: 0x01 - if set - delete unused tunnels before\n  every registration. This is an optional parameter, default value - 0.\n\n<!-- -->\n\n    ...\n    ipsec_create(\"location\");\n    # or\n    ipsec_create(\"location\", \"1\");\n    ...\n            \n\n",
 "ipsec_forward": "### ipsec_forward(domain, flags)\n\n module: ims_ipsec_pcscf\n\nThe function processes redirects outgoing message via the IPSec tunnel\ninitiated with ipsec_create().\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n  *flags* - bitwise flag:\n\n  - *0x01* (1) - set force socket for request messages. Useful for ipsec\n    and TCP.\n\n  - *0x02* (2) - reverse search for a contact in the memory. Useful when\n    contact alias is disabled.\n\n  - *0x04* (4) - use destination URI for IPSec tunnel search. Useful for\n    routing requests within dialog.\n\n  - *0x08* (8) - use new R-URI for IPSec tunnel search.\n\n  - *0x10* (16) - do not look for alias parameter to set received\n    details.\n\n  - *0x20* (32) - do not reset the destination URI.\n\n  - *0x40* (64) - use user equipment client port as target for TCP\n    requests.\n\n  - *0x80* (128) - set transport parameter in the new dst uri for TCP\n    requests.\n\n  This is an optional parameter, default value - 0.\n\n<!-- -->\n\n    ...\n    ipsec_forward(\"location\");\n    # or\n    ipsec_forward(\"location\", \"1\");\n    ...\n            \n\n",
 "ipsec_destroy": "### ipsec_destroy(domain)\n\n module: ims_ipsec_pcscf\n\nThe function destroys IPSec tunnel, created with ipsec_create.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n<!-- -->\n\n    ...\n    ipsec_destroy(\"location\");\n    ...\n            \n",
 "sworker_active": "### sworker_active()\n\n module: sworker\n\nReturn 1 (true) if the processing happens in an async process, or -1\n(false) if the processing is happening in a SIP receiving process.\n\nThis function can be used from REQUEST_ROUTE\\|CORE_REPLY_ROUTE.\n\n    ...\n    request_route {\n        ...\n        if(sworker_active()) {\n        }\n        ...\n    }\n    ...\n\n",
 "swork_task": "### swork_task(gname)\n\n module: sworker\n\nDelegate the processing of SIP message to a group of async workers. The\nfunction is restricted to be used inside\nevent_route\\[core:pre-routing\\].\n\nThe parameter gname provides the name of the group workers, it can\ncontain pseudo-variables.\n\nThe function returns 1 (true) in case the task is delegated. After that,\n'drop' must be used so processing of the message does not continue to\nrequest_route or reply_route in the same process, it is going to be done\nby the delegated group of workers. It returns -1 (false) in case there\nwas a problem delegating the processing.\n\nThis function can be used from REQUEST_ROUTE\\|CORE_REPLY_ROUTE.\n\n    ...\n    event_route[core:pre-routing] {\n        if(sworker_task(\"default\")) {\n            xinfo(\"===== delegate processing [$Tf] [$si:$sp]\\n\");\n            drop;\n        }\n        xinfo(\"===== processing continues [$Tf] [$si:$sp]\\n\");\n        ...\n    }\n    ...\n",
 "cr_user_carrier": "### cr_user_carrier(user, domain, dstvar)\n\n module: carrierroute\n\nThis function loads the carrier and stores it in a config variable. It\ncannot be used in the config file mode, as it needs a mapping of the\ngiven user to a certain carrier. The is drived from a database entry\nbelonging to the user parameter. This mapping must be available in the\ntable that is specified in the \u201csubscriber_table\u201d variable. This data is\nnot cached in memory, that means for every execution of this function a\ndatabase query will be done.\n\nMeaning of the parameters is as follows:\n\n- *user* - Name of the user for the carrier tree lookup. Additional to a\n  string any pseudo-variable could be used as input.\n\n- *domain* - Name of the routing domain to be used. Additional to a\n  string any pseudo-variable could be used as input.\n\n- *dstvar* - Name of the writable config variable (e.g., an AVP) where\n  to store the carrier id.\n\n",
 "cr_route": "### cr_route(carrier, domain, prefix_matching, rewrite_user, hash_source, descavp)\n\n module: carrierroute\n\nThis function searches for the longest match for the user given in\nprefix_matching with the given domain in the given carrier tree. The\nRequest URI is rewritten using rewrite_user and the given hash source\nand algorithm. Returns -1 if there is no data found or an empty rewrite\nhost on the longest match is found. On success, it also stores the\ncarrier description in the given AVP (if present). This is useful if you\nneed some additional informations that belongs to each gw, like the\ndestination uri, force socket or any arbitrary info.\n\nDepending on the value of the avoid_failed_destinations module\nparameter, the function pays special attention to the failurerouting\ncases, so that any destination that has failed to provide a successful\nresponse will not be reused in a subsequent call of this function. This\nsituation can appear when different route domains contain a set of\ncommon gateways.\n\nThis function is only usable with rewrite_user and prefix_matching\ncontaining a valid string. This string needs to be numerical if the\nmatch_mode parameter is set to 10. It uses the standard CRC32 algorithm\nto calculate the hash values.\n\nIf flags and masks values are specified in the routing rule, they will\nbe compared by this function to the message flags. Specify a flag and\nmask value of \u201c0\u201d to match to all possible message flags (this is the\ndefault value). If flags and mask are not zero, and no match to the\nmessage flags is possible, no routing will be done. The calculation of\nthe hash and the load-balancing is done after the flags matching.\n\nMeaning of the parameters is as follows:\n\n- *carrier* - The routing tree to be used. It must be string containing\n  either carrier id (nummeric) or carrier name (arbitrary string). It\n  also accepts any pseudo-variable as input.\n\n- *domain* - Name of the routing domain to be used. it must be string\n  containing either domain id (nummeric) or domain name (arbitrary\n  string). It also accepts any pseudo-variable as input.\n\n- *prefix_matching* - User name to be used for prefix matching in the\n  routing tree. It also accepts any pseudo-variable as input\n\n- *rewrite_user* - The user name to be used for applying the rewriting\n  rule. Usually this is the user part of the request URI. It also\n  accepts any pseudo-variable as input\n\n- *hash_source* - The hash values of the destination set, it must be a\n  contiguous range starting at 1, limited by the configuration parameter\n  \u201cmax_targets\u201d. Possible values for hash_source are: \u201ccall_id\u201d,\n  \u201cfrom_uri\u201d, \u201cfrom_user\u201d, \u201cto_uri\u201d, \u201cto_user\u201d and \u201crand\u201d.\n\n- *decsavp* - AVP where to store the description. This parameter is\n  optional.\n\n",
 "cr_nofallback_route": "### cr_nofallback_route(carrier, domain, prefix_matching, rewrite_user, hash_source, descavp)\n\n module: carrierroute\n\nThis function searches for the longest match for the user given in\nprefix_matching with the given domain in the given carrier tree. The\nRequest URI is rewritten using rewrite_user and the given hash source\nand algorithm. Returns -1 if there is no data found or an empty rewrite\nhost on the longest match is found. On success it also stores the\ncarrier description in the given AVP (if present). This is useful if you\nneed some additional informations that belongs to each gw, like the\ndestination uri, force socket or any arbitrary info.\n\nThis function is only usable with rewrite_user and prefix_matching\ncontaining a valid string. This string needs to be numerical if the\nmatch_mode parameter is set to 10.\n\nIt uses the standard CRC32 algorithm to calculate the hash values. In\ncontrast to the normal *cr_route* function, the backup rules of (now\nobsolete) cr_prime_route is used. This means none of the configured\nprobabilities will be used, only a fixed hash distribution is used. This\nmakes sense to distribute incoming register requests e.g. to a bunch of\nregistrar servers. If one of the hash targets is not available and\nbackup rule is configured, the function will return -1.\n\nMeaning of the parameters is as follows:\n\n- *carrier* - The routing tree to be used. It must be string containing\n  either carrier id (nummeric) or carrier name (arbitrary string). It\n  also accepts any pseudo-variable as input.\n\n- *domain* - Name of the routing domain to be used. it must be string\n  containing either domain id (nummeric) or domain name (arbitrary\n  string). It also accepts any pseudo-variable as input\n\n- *prefix_matching* - User name to be used for prefix matching in the\n  routing tree. It also accepts any pseudo-variable as input\n\n- *rewrite_user* - The user name to be used for applying the rewriting\n  rule. Usually this is the user part of the request URI. It also\n  accepts any pseudo-variable as input\n\n- *hash_source* - The hash values of the destination set, it must be a\n  contiguous range starting at 1, limited by the configuration parameter\n  \u201cmax_targets\u201d. Possible values for hash_source are: \u201ccall_id\u201d,\n  \u201cfrom_uri\u201d, \u201cfrom_user\u201d, \u201cto_uri\u201d, \u201cto_user\u201d and \u201crand\u201d.\n\n- *decsavp* - AVP where to store the description. This parameter is\n  optional.\n\n",
 "cr_next_domain": "### cr_next_domain(carrier, domain, prefix_matching, host, reply_code, dstavp)\n\n module: carrierroute\n\nThis function searches for the longest match for the user given in\nprefix_matching with the given domain in the given carrier failure tree.\nIt tries to find a next domain matching the given host, reply_code and\nthe message flags. The matching is done in this order: \u201chost\u201d then\n\u201creply_code\u201d and then \u201cflags\u201d. The more wildcards in reply_code and the\nmore bits used in flags, the lower the priority will be. Returns -1, if\nthere is no data found or if the next_domain on the longest match is\nempty. Otherwise the next domain is stored in the given variable.\n\nThis function is only usable if rewrite_user and prefix_matching\ncontains a valid string. This string must be numerical if the match_mode\nparameter is set to 10.\n\nMeaning of the parameters is as follows:\n\n- *carrier* - The routing tree to be used. It must be string containing\n  either carrier id (nummeric) or carrier name (arbitrary string). It\n  also accepts any pseudo-variable as input.\n\n- *domain* - Name of the routing domain to be used. it must be string\n  containing either domain id (nummeric) or domain name (arbitrary\n  string). It also accepts any pseudo-variable as input.\n\n- *prefix_matching* - User name to be used for prefix matching in the\n  routing tree. It also accepts any pseudo-variable as input.\n\n- *host* - The host name to be used for failure route rule matching.\n  Usually this is the last tried routing destination stored in an avp by\n  cr_route. It also accepts any pseudo-variable as input\n\n- *reply_code* - The reply code to be used for failure route rule\n  matching. It also accepts any pseudo-variable as input\n\n- *dstavp* - Name of the AVP where to store the next routing domain.\n\n",
 "acc_log_request": "### acc_log_request(comment)\n\n module: acc\n\n`acc_request` reports on a request, for example, it can be used to\nreport on missed calls to off-line users who are replied 404 - Not\nFound. To avoid multiple reports on UDP request retransmission, you\nwould need to embed the action in stateful processing.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The string can contain any number\n  of pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    acc_log_request(\"Some comment\");\n    $var(code) = 404;\n    $avp(reason) = \"Not found\";\n    acc_log_request(\"$var(code) Error: $avp(reason)\");\n    ...\n\n",
 "acc_db_request": "### acc_db_request(comment, table)\n\n module: acc\n\nLike `acc_log_request`, `acc_db_request` reports on a request. The\nreport is sent to database at \u201cdb_url\u201d, in the table referred to in the\nsecond action parameter.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The string can contain any number\n  of pseudo-variables.\n\n- *table* - Database table to be used. It can contain config variables\n  that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    acc_db_request(\"Some comment\", \"SomeTable\");\n    acc_db_request(\"Some comment\", \"acc_$time(year)_$time(mon)\");\n    acc_db_request(\"$var(code) Error: $avp(reason)\", \"SomeTable\");\n    ...\n\n",
 "acc_request": "### acc_request(comment, table)\n\n module: acc\n\nWrapper around `acc_log_request` and `acc_db_request` functions, writing\nthe accounting record to LOG and DATABASE backends. If \u201cdb_url\u201d\nparameter is not set, the acc record is written only to LOG backend.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be used for generating the SIP response code\n  and text fields, if in the format \u201cCODE TEXT\u201d. The CODE should be a\n  valid SIP response code (100..699). The TEXT can be one or many words.\n  If CODE is missing, then 0 is used. The parameter can contain\n  pseudo-variables.\n\n- *table* - Database table to be used. It can contain config variables\n  that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\n    ...\n    acc_request(\"100 Received\", \"acc\");\n    acc_request(\"100 Received\", \"acc_$time(year)_$time(mon)\");\n    acc_db_request(\"$var(code) $avp(reason)\", \"acc\");\n    ...\n\n"
}