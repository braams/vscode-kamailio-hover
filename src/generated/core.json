{
 "parameters": {
  "advertised_address": "### advertised_address\n\nIt can be an IP address or string and represents the address advertised\nin Via header. If empty or not set (default value) the socket address\nfrom where the request will be sent is used.\n\n```\nWARNING:\n- don't set it unless you know what you are doing (e.g. nat traversal)\n- you can set anything here, no check is made (e.g. foo.bar will be accepted even if foo.bar doesn't exist)\n```\n\nExample of usage:\n\n```c\nadvertised_address=\"\u200b1.2.3.4\"\u200b\nadvertised_address=\"kamailio.org\"\n```\n\nNote: this option may be deprecated and removed in the near future, it\nis recommended to set **advertise** option for **listen** parameter.\n",
  "advertised_port": "### advertised_port\n\nThe port advertised in Via header. If empty or not set (default value)\nthe port from where the message will be sent is used. Same warnings as\nfor 'advertised_address'.\n\nExample of usage:\n\n```c\nadvertised_port=5080\n```\n\nNote: this option may be deprecated and removed in the near future, it\nis recommended to set **advertise** option for **listen** parameter.\n",
  "alias": "### alias\n\n**Alias name:** **domain**\n\nParameter to set alias hostnames for the server. It can be set many\ntimes, each value being added in a list to match the hostname when\n'myself' is checked.\n\nIt is necessary to include the port (the port value used in the \"port=\"\nor \"listen=\" defintions) in the alias definition otherwise the\nloose_route() function will not work as expected for local forwards.\nEven if you do not use 'myself' explicitly (for example if you use the\ndomain module), it is often necessary to set the alias as these aliases\nare used by the loose_routing function and might be needed to handle\nrequests with pre-loaded route set correctly.\n\nExample of usage:\n\n```c\nalias=other.domain.com:5060\nalias=another.domain.com:5060\n\ndomain=new.domain.com:5060\n```\n\nNote: the hostname has to be enclosed in between quotes if it has\nreserved tokens such as **forward**, **drop** ... or operators such as\n**-** (minus) ...\n",
  "async_workers": "### async_workers\n\nSpecify how many child processes (workers) to create for asynchronous\nexecution in the group \"default\". These are processes that can receive\ntasks from various components (e.g, modules such as async, acc, sqlops)\nand execute them locally, which is different process than the task\nsender.\n\nDefault: 0 (asynchronous framework is disabled).\n\nExample:\n\n```c\nasync_workers=4\n```\n",
  "async_nonblock": "### async_nonblock\n\nSet the non-block mode for the internal sockets used by default group of\nasync workers.\n\nDefault: `0`\n\nExample:\n\n```c\nasync_nonblock=1\n```\n",
  "async_usleep": "### async_usleep\n\nSet the number of microseconds to sleep before trying to receive next\ntask (can be useful when async_nonblock=1).\n\nDefault: `0`\n\nExample:\n\n```c\nasync_usleep=100\n```\n",
  "async_workers_group": "### async_workers_group\n\nDefine groups of asynchronous worker processes.\n\nPrototype:\n\n```c\nasync_workers_group=\"name=X;workers=N;nonblock=[0|1];usleep=M\"\n```\n\nThe attributes are:\n\n- **name** - the group name (used by functions such as\n  **sworker_task(name)**)\n- **workers** - the number of processes to create for this group\n- **nonblock** - set or not set the non-block flag for internal\n  communication socket\n- **usleep** - the number of microseconds to sleep before trying to\n  receive next task (can be useful if nonblock=1)\n\nDefault: \"\".\n\nExample:\n\n```c\nasync_workers_group=\"name=reg;workers=4;nonblock=0;usleep=0\"\n```\n\nIf the **name** is default, then it overwrites the value set by\n**async_workers**.\n\nSee also **event_route[core:pre-routing]** and **sworker** module.\n",
  "auto_aliases": "### auto_aliases\n\n**Alias name:** **auto_domains**\n\nKamailio by default discovers all IPv4 addresses on all interfaces and\ndoes a reverse DNS lookup on these addresses to find host names.\nDiscovered host names are added to aliases list, matching the **myself**\ncondition. To disable host names auto-discovery, turn off auto_aliases.\n\nExample:\n\n```c\nauto_aliases=no\n\nauto_domains=no\n```\n",
  "auto_bind_ipv6": "### auto_bind_ipv6\n\nWhen turned on, Kamailio will automatically bind to all IPv6 addresses\n(much like the default behaviour for IPv4). Default is 0.\n\nExample:\n\n```c\nauto_bind_ipv6=1\n```\n",
  "bind_ipv6_link_local": "### bind_ipv6_link_local\n\nIf set to 1, try to bind also IPv6 link local addresses by discovering\nthe scope of the interface. This apply for UDP socket for now, to be\nadded for the other protocols. Default is 0.\n\nExample:\n\n```c\nbind_ipv6_link_local=1\n```\n",
  "check_via": "### check_via\n\nCheck if the address in top most via of replies is local. Default value\nis 0 (check disabled).\n\nExample of usage:\n\n```c\ncheck_via=1\n```\n",
  "children": "### children\n\nNumber of children to fork for the UDP interfaces (one set for each\ninterface - ip:port). Default value is 8. For example if you configure\nthe proxy to listen on 3 UDP ports, it will create 3xchildren processes\nwhich handle the incoming UDP messages.\n\nFor configuration of the TCP/TLS worker threads see the option\n\"tcp_children\".\n\nExample of usage:\n\n```c\nchildren=16\n```\n",
  "chroot": "### chroot\n\nThe value must be a valid path in the system. If set, Kamailio will\nchroot (change root directory) to its value.\n\nExample of usage:\n\n```c\nchroot=/other/fakeroot\n```\n",
  "corelog": "### corelog\n\nSet the debug level used to print some log messages from core, which\nmight become annoying and don't represent critical errors. For example,\nsuch case is failure to parse incoming traffic from the network as SIP\nmessage, due to someone sending invalid content.\n\nDefault value is `-1` (`L_ERR`).\n\nExample of usage:\n\n```c\ncorelog=1\n```\n",
  "debug": "### debug\n\nSet the debug level. Higher values make Kamailio to print more debug\nmessages. Log messages are usually sent to syslog, except if logging to\nstderr was activated (see <#log_stderror> parameter).\n\nThe following log levels are defined:\n\n```c\nL_ALERT     -5\nL_BUG       -4\nL_CRIT2     -3\nL_CRIT      -2\nL_ERR       -1\nL_WARN       0\nL_NOTICE     1\nL_INFO       2\nL_DBG        3\n```\n\nA log message will be logged if its log-level is lower than the defined\ndebug level. Log messages are either produced by the the code, or\nmanually in the configuration script using log() or xlog() functions.\nFor a production server you usually use a log value between -1 and 2.\n\nDefault value: `L_WARN` (`debug=0`)\n\nExamples of usage:\n\n- debug=3: print all log messages. This is only useful for debugging\n  of problems. Note: this produces a lot of data and therefore should\n  not be used on production servers (on a busy server this can easily\n  fill up your hard disk with log messages)\n- debug=0: This will only log warning, errors and more critical\n  messages.\n- debug=-6: This will disable all log messages.\n\nValue of 'debug' parameter can also be obtained and set dynamically using the\n'debug' Core MI function or the RPC function, e.g.:\n\n```bash\nkamcmd cfg.get core debug\nkamcmd cfg.set_now_int core debug 2\nkamcmd cfg.set_now_int core debug -- -1\n```\n\nNote: There is a difference in log-levels between Kamailio 3.x and\nKamailio<=1.5: Up to Kamailio 1.5 the log level started with 4, whereas\nin Kamailio>=3 the log level starts with 3. Thus, if you were using\ndebug=3 in older Kamailio, now use debug=2.\n\nFor configuration of logging of the memory manager see the parameters\n<#memlog> and <#memdbg>.\n\nFurther information can also be found at:\n\n- <https://www.kamailio.org/wiki/tutorials/3.2.x/syslog>\n",
  "description": "### description\n\n**Alias name:** **descr desc**\n",
  "disable_core_dump": "### disable_core_dump\n\nCan be 'yes' or 'no'. By default core dump limits are set to unlimited\nor a high enough value. Set this config variable to 'yes' to disable\ncore dump-ing (will set core limits to 0).\n\nDefault value is `no`.\n\nExample of usage:\n\n```c\ndisable_core_dump=yes\n```\n",
  "disable_tls": "### disable_tls\n\n**Alias name:** **tls_disable**\n\nGlobal parameter to disable TLS support in the SIP server. Default value\nis 'yes'.\n\nNote: Make sure to load the \"tls\" module to get tls functionality.\n\nExample of usage:\n\n```c\ndisable_tls=yes\n```\n\nIn Kamailio TLS is implemented as a module. Thus, the TLS configuration\nis done as module configuration. For more details see the README of the\nTLS module: <http://kamailio.org/docs/modules/devel/modules/tls.html>\n",
  "enable_tls": "### enable_tls\n\n**Alias name:** **tls_enable**\n\nReverse Meaning of the disable_tls parameter. See disable_tls parameter.\n\n```c\nenable_tls=yes # enable tls support in core\n```\n",
  "exit_timeout": "### exit_timeout\n\n**Alias name:** **ser_kill_timeout**\n\nHow much time Kamailio will wait for all the shutdown procedures to\ncomplete. If this time is exceeded, all the remaining processes are\nimmediately killed and Kamailio exits immediately (it might also\ngenerate a core dump if the cleanup part takes too long).\n\nDefault: 60 s. Use 0 to disable.\n\n```c\nexit_timeout = seconds\n```\n",
  "flags": "### flags\n\nSIP message (transaction) flags can have string names. The *name* for\nflags cannot be used for **branch** or **script flags**(*)\n\n```c\n...\nflags\n  FLAG_ONE   : 1,\n  FLAG_TWO   : 2;\n...\n```\n\n- NOTE: The named flags feature was propagated from the source code merge\n  back in 2008 and is not extensively tested. The recommended way of\n  defining flags is using [#!define](core.md#define) (which\n  is also valid for branch/script flags):\n\n```c\n#!define FLAG_NAME FLAG_BIT\n```\n",
  "force_rport": "### force_rport\n\nyes/no: Similar to the force_rport() function, but activates symmetric\nresponse routing globally.\n",
  "fork": "### fork\n\nIf set to 'yes' the proxy will fork and run in daemon mode - one process\nwill be created for each network interface the proxy listens to and for\neach protocol (TCP/UDP), multiplied with the value of 'children'\nparameter.\n\nWhen set to 'no', the proxy will stay bound to the terminal and runs as\nsingle process. First interface is used for listening to. This is\nequivalent to setting the server option \"-F\".\n\nDefault value is 'yes'.\n\nExample of usage:\n\n```c\nfork=no\n```\n",
  "fork_delay": "### fork_delay\n\nNumber of usecs to wait before forking a process.\n\nDefault is 0 (don't wait).\n\nExample of usage:\n\n```c\nfork_delay=5000\n```\n",
  "group": "### group\n\n**Alias name:** **gid**\n\nThe group id to run Kamailio.\n\nExample of usage:\n\n```c\ngroup=\"kamailio\"\n```\n",
  "http_reply_parse": "### http_reply_parse\n\nAlias: http_reply_hack\n\nWhen enabled, Kamailio can parse HTTP replies, but does so by treating\nthem as SIP replies. When not enabled HTTP replies cannot be parsed.\nThis was previously a compile-time option, now it is run-time.\n\nDefault value is 'no'.\n\nExample of usage:\n\n```c\nhttp_reply_parse=yes\n```\n",
  "ip_free_bind": "### ip_free_bind\n\nAlias: ipfreebind, ip_nonlocal_bind\n\nControl if Kamailio should attempt to bind to non local ip. This option\nis the per-socket equivalent of the system **ip_nonlocal_bind**.\n\nDefault is 0 (do not bind to non local ip).\n\nExample of usage:\n\n```c\n  ip_free_bind = 1\n```\n",
  "ipv6_hex_style": "### ipv6_hex_style\n\nCan be set to `a`, `A` or `c` to specify if locally computed string\nrepresentation of IPv6 addresses should be expanded lowercase, expanded\nuppercase or compacted lowercase hexa digits.\n\nDefault is `c` (compacted lower hexa digits, conforming better with RFC\n5952).\n\n`A` is preserving the behaviour before this global parameter was\nintroduced, while `a` enables the ability to follow some of the\nrecommendations of RFC 5952, section 4.3.\n\nExample of usage:\n\n```c\n  ipv6_hex_style = \"a\"\n```\n",
  "kemi": "### kemi.pre_routing_callback\n\nSet the name of callback function in the KEMI script to be executed as\nthe equivalent of `event_route[core:pre-routing]` block (from the\nnative configuration file).\n\nDefault value: `none`\n\nSet it to empty string or `none` to skip execution of this callback\nfunction.\n\nExample:\n\n```c\nkemi.pre_routing_callback=\"ksr_pre_routing\"\n```\n",
  "latency_cfg_log": "### latency_cfg_log\n\nIf set to a log level less or equal than debug parameter, a log message\nwith the duration in microseconds of executing request route or reply\nroute is printed to syslog.\n\nDefault value is `3` (`L_DBG`).\n\nExample:\n\n```c\nlatency_cfg_log=2\n```\n",
  "latency_limit_action": "### latency_limit_action\n\nLimit of latency in us (micro-seconds) for config actions. If a config\naction executed by cfg interpreter takes longer than its value, a\nmessage is printed in the logs, showing config path, line and action\nname when it is a module function, as well as internal action id.\n\nDefault value is `0` (disabled).\n\n```c\nlatency_limit_action=`500`\n```\n",
  "latency_limit_db": "### latency_limit_db\n\nLimit of latency in us (micro-seconds) for db operations. If a db\noperation executed via DB API v1 takes longer that its value, a message\nis printed in the logs, showing the first 50 characters of the db query.\n\nDefault value is `0` (disabled).\n\n```c\nlatency_limit_db=`500`\n```\n",
  "latency_log": "### latency_log\n\nLog level to print the messages related to latency.\n\nDefault value is `-1` (`L_ERR`).\n\n```c\nlatency_log=3\n```\n",
  "listen": "### listen\n\nSet the network addresses the SIP server should listen to. It can be an\n`IP address`, `hostname` or `network interface id` or combination of\n`protocol:address:port` (e.g., `udp:10.10.10.10:5060`). This parameter can\nbe set multiple times in same configuration file, the server is listening\non all addresses specified.\n\nExample of usage:\n\n```c\n    listen=10.10.10.10\n    listen=eth1:5062\n    listen=udp:10.10.10.10:5064\n```\n\nIf you omit this directive then the SIP server will listen on all network\ninterfaces. On start the SIP server reports all the interfaces that it\nis listening on. Even if you specify only UDP interfaces here, the\nserver will start the TCP engine too. If you don't want this, you need\nto disable the TCP support completely with the core parameter\n`disable_tcp`.\n\nIf you specify IPv6 addresses, you should put them into square brackets,\ne.g.:\n\n```c\n    listen=udp:[2a02:1850:1:1::18]:5060\n```\n\nYou can specify an advertise address (like `ip:port`) per listening socket\n\n- it will be used to build the SIP headers such as Via and Record-Route:\n\n```c\n    listen=udp:10.10.10.10:5060 advertise 11.11.11.11:5060\n```\n\nThe advertise address must be in the format `address:port`, the protocol is\ntaken from the bind socket. The advertise address is a convenient\nalternative to `advertised_address` / `advertised_port` config parameters or\n`set_advertised_address()` / `set_advertised_port()` config functions.\n\nA typical use case for advertise address is when running SIP server\nbehind a NAT/Firewall, when the local IP address (to be used for bind)\nis different than the public IP address (to be used for advertising).\n\nA unique name can be set for sockets to simplify the selection of the\nsocket for sending out. For example, the rr and path modules can use the\nsocket name to advertise it in header URI parameter and use it as a\nshortcut to select the corresponding socket for routing subsequent\nrequests.\n\nThe name has to be provided as a string enclosed in between quotes after\nthe `name` keyword.\n\n```c\n    listen=udp:10.0.0.10:5060 name \"s1\"\n    listen=udp:10.10.10.10:5060 advertise 11.11.11.11:5060 name \"s2\"\n    listen=udp:10.10.10.20:5060 advertise \"mysipdomain.com\" name \"s3\"\n    listen=udp:10.10.10.30:5060 advertise \"mysipdomain.com\" name \"s4\"\n    ...\n    $fsn = \"s4\";\n    t_relay();\n```\n\nNote that there is no internal check for uniqueness of the socket names,\nthe admin has to ensure it in order to be sure the desired socket is\nselected, otherwise the first socket with a matching name is used.\n\nAs of 5.6, there is now a `virtual` keyword which can be added to\nthe end of each listen directive. This can be used in combination with\nany other keyword, but must be added at the end of the line.\n\n```c\n    listen=udp:10.1.1.1:5060 virtual\n    listen=udp:10.0.0.10:5060 name \"s1\" virtual\n    listen=udp:10.10.10.10:5060 advertise 11.11.11.11:5060 virtual\n    listen=udp:10.10.10.20:5060 advertise \"mysipdomain.com\" name \"s3\" virtual\n```\n\nThe `virtual` keyword is meant for use in situations where you have\na floating/virtual IP address on your system that may not always be\nactive on the system. It is particularly useful for active/active\nvirtual IP situations, where otherwise things like usrloc PATH support\ncan break due to incorrect `check_self` results.\n\nThis identifier will change the behaviour of how `myself`, `is_myself()`\nor `check_self` matches against traffic destined to this IP address. By\ndefault, Kamailio always considers traffic destined to a listen IP as\n`local` regardless of if the IP is currently locally active. With this\nflag set, Kamailio will do an extra check to make sure the IP is\ncurrently a local IP address before considering the traffic as local.\n\nThis means that if Kamailio is listening on an IP that is not currently\nlocal, it will recognise that, and can relay the traffic to another\nKamailio node as needed, instead of thinking it always needs to handle\nthe traffic.\n",
  "loadmodule": "### loadmodule\n\nLoads a module for later usage in the configuration script. The module\nis searched in the path specified by `loadpath` (or `mpath`).\n\nPrototypes:\n\n- `loadmodule &quot;modulepath&quot;`\n- `loadmodule(&quot;modulepath&quot;)`\n- `loadmodule(&quot;modulepath&quot;, &quot;opts&quot;)`\n\nIf `modulepath` is only `modulename` or `modulename.so`, then Kamailio will\ntry to search also for `modulename/modulename.so`, very useful when\nusing directly the version compiled in the source tree.\n\nThe `opts` parameter is a list of characters that can specify loading options.\nThey can be:\n\n- `g` (or `G`) - open the module shared object file with `RTLD_GLOBAL` set,\n  which can be used for modules related to external scripting languages to avoid\n  reloading.\n\nExample of usage:\n\n```c\n    loadpath \"/usr/local/lib/kamailio/:usr/local/lib/kamailio/modules/\"\n\n    loadmodule \"/usr/local/lib/kamailio/modules/db_mysql.so\"\n    loadmodule \"modules/usrloc.so\"\n    loadmodule \"tm\"\n    loadmodule \"dialplan.so\"\n    loadmodule(\"app_lua.so\", \"g\")\n```\n",
  "loadmodulex": "### loadmodulex\n\nSimilar to `loadmodule` with the ability to evaluate variables in its\nparameter.\n",
  "loadpath": "### loadpath\n\n**Alias name:** `mpath`\n\nSet the module search path. `loadpath` takes a list of directories\nseparated by `:`. The list is searched in-order. For each directory `d`,\n`$d/${module_name}.so` and `$d/${module_name}/${module_name}.so` are tried.\n\nThis can be used to simplify the loadmodule parameter and can include\nmany paths separated by colon. First module found is used.\n\nExample of usage:\n\n```c\n    loadpath \"/usr/local/lib/kamailio/modules:/usr/local/lib/kamailio/mymodules\"\n\n    loadmodule \"mysql\"\n    loadmodule \"uri\"\n    loadmodule \"uri_db\"\n    loadmodule \"sl\"\n    loadmodule \"tm\"\n```\n\nThe proxy tries to find the modules in a smart way, e.g: `loadmodule &quot;uri&quot;`\ntries to find `uri.so` in the loadpath, but also `uri/uri.so`.\n",
  "local_rport": "### local_rport\n\nSimilar to **add_local_rport()** function, but done in a global scope,\nso the function does not have to be executed for each request.\n\nDefault: off\n\nExample:\n\n```c\nlocal_rport = on\n```\n",
  "log_engine_data": "### log_engine_data\n\nSet specific data required by the log engine. See also the\n**log_engine_type**.\n\n```c\nlog_engine_type=\"udp\"\nlog_engine_data=\"127.0.0.1:9\"\n```\n",
  "log_engine_type": "### log_engine_type\n\nSpecify what logging engine to be used and its initialization data. A\nlogging engine is implemented as a module. Supported values are a matter\nof the module.\n\nFor example, see the readme of **log_custom** module for more details.\n\n```c\nlog_engine_type=\"udp\"\nlog_engine_data=\"127.0.0.1:9\"\n```\n",
  "log_facility": "### log_facility\n\nIf Kamailio logs to syslog, you can control the facility for logging.\nVery useful when you want to divert all Kamailio logs to a different log\nfile. See the man page syslog(3) for more details.\n\nFor more see:\n\n- <https://www.kamailio.org/dokuwiki/doku.php/tutorials:debug-syslog-messages>\n\nDefault value is LOG_DAEMON.\n\nExample of usage:\n\n```c\nlog_facility=LOG_LOCAL0\n```\n",
  "log_name": "### log_name\n\nAllows to configure a log_name prefix which will be used when printing\nto syslog -- it is also known as syslog tag, and the default value is\nthe application name or full path that printed the log message. This is\nuseful to filter log messages when running many instances of Kamailio on\nsame server.\n\n```c\nlog_name=\"kamailio-proxy-5080\"\n```\n",
  "log_prefix": "### log_prefix\n\nSpecify the text to be prefixed to the log messages printed by Kamailio\nwhile processing a SIP message (that is, when executing route blocks).\nIt can contain script variables that are evaluated at runtime. See\n<#log_prefix_mode> about when/how evaluation is done.\n\nIf a log message is printed from a part of the code executed out of\nrouting blocks actions (e.g., can be timer, evapi worker process, ...),\nthere is no log prefix set, because this one requires a valid SIP\nmessage structure to work with.\n\nExample - prefix with message type (1 - request, 2 - response), CSeq and\nCall-ID:\n\n```c\nlog_prefix=\"{$mt $hdr(CSeq) $ci} \"\n```\n",
  "log_prefix_mode": "### log_prefix_mode\n\nControl if [log prefix](#log_prefix) is re-evaluated.\n\nIf set to 0 (default), then log prefix is evaluated when the sip message\nis received and then reused (recommended if the **log_prefix** has only\nvariables that have same value for same message). This is the current\nbehaviour of **log_prefix** evaluation.\n\nIf set to 1, then the log prefix is evaluated before/after each config\naction (needs to be set when the **log_prefix** has variables that are\ndifferent based on the context of config execution, e.g., $cfg(line)).\n\nExample:\n\n```c\nlog_prefix_mode=1\n```\n",
  "log_stderror": "### log_stderror\n\nWith this parameter you can make Kamailio to write log and debug\nmessages to standard error. Possible values are:\n\n- `yes` - write the messages to standard error\n- `no` - write the messages to syslog\n\nDefault value is `no`.\n\nFor more see:\n\n- <https://www.kamailio.org/dokuwiki/doku.php/tutorials:debug-syslog-messages>\n\nExample of usage:\n\n```c\nlog_stderror=yes\n```\n",
  "cfgengine": "### cfgengine\n\nSet the config interpreter engine for execution of the routing logic\ninside the configuration file. Default is the native interpreter.\n\nExample of usage:\n\n```c\ncfgengine=\"name\"\ncfgengine \"name\"\n```\n\nIf name is `native` or `default`, it expects to have in native config\ninterpreter for routing logic.\n\nThe name can be the identifier of an embedded language interpreter, such\nas `lua` which is registered by the `app_lua` module:\n\n```c\ncfgengine \"lua\"\n```\n",
  "maxbuffer": "### maxbuffer\n\nThe size in bytes multiplied by 2 not to be exceeded during the auto-probing\nprocedure of discovering and increasing the maximum OS buffer size for receiving\nUDP messages (socket option SO_RCVBUF). Default value is 262144.\n\nExample of usage:\n\n```c\nmaxbuffer=65536\n```\n\nNote: it is not the size of the internal SIP message receive buffer.\n",
  "maxsndbuffer": "### maxsndbuffer\n\nThe size in bytes multiplied by 2 not to be exceeded during the auto-probing\nprocedure of discovering and increasing the maximum OS buffer size for sending\nUDP messages (socket option SO_SNDBUF). Default value is 262144.\n\nExample of usage:\n\n```c\nmaxsndbuffer=65536\n```\n",
  "max_branches": "### max_branches\n\nThe maximum number of outgoing branches for each SIP request. It has\nimpact on the size of destination set created in core (e.g., via\nappend_branch()) as well as the serial and parallel forking done via tm\nmodule. It replaces the old defined constant MAX_BRANCHES.\n\nThe value has to be at least 1 and the upper limit is 30.\n\nDefault value: 12\n\nExample of usage:\n\n```c\nmax_branches=16\n```\n",
  "max_recursive_level": "### max_recursive_level\n\nThe parameters set the value of maximum recursive calls to blocks of\nactions, such as sub-routes or chained IF-ELSE (for the ELSE branches).\nDefault is 256.\n\nExample of usage:\n\n```c\nmax_recursive_level=500\n```\n",
  "max_while_loops": "### max_while_loops\n\nThe parameters set the value of maximum loops that can be done within a\n\"while\". Comes as a protection to avoid infinite loops in config file\nexecution. Default is 100. Setting to 0 disables the protection (you\nwill still get a warning when you start Kamailio if you do something\nlike while(1) {...}).\n\nExample of usage:\n\n```c\nmax_while_loops=200\n```\n",
  "mcast": "### mcast\n\nThis parameter can be used to set the interface that should join the\nmulticast group. This is useful if you want to **listen** on a multicast\naddress and don't want to depend on the kernel routing table for\nchoosing an interface.\n\nThe parameter is reset after each **listen** parameter, so you can join\nthe right multicast group on each interface without having to modify\nkernel routing beforehand.\n\nExample of usage:\n\n```c\nmcast=\"eth1\"\nlisten=udp:224.0.1.75:5060\n```\n",
  "mcast_loopback": "### mcast_loopback\n\nIt can be 'yes' or 'no'. If set to 'yes', multicast datagram are sent\nover loopback. Default value is 'no'.\n\nExample of usage:\n\n```c\nmcast_loopback=yes\n```\n",
  "mcast_ttl": "### mcast_ttl\n\nSet the value for multicast ttl. Default value is OS specific (usually\n1).\n\nExample of usage:\n\n```c\nmcast_ttl=32\n```\n",
  "memdbg": "### memdbg\n\n**Alias name:** `mem_dbg`\n\nThis parameter specifies on which log level the memory debugger messages\nwill be logged. If memdbg is active, every request (alloc, free) to the\nmemory manager will be logged. (Note: if compile option NO_DEBUG is\nspecified, there will never be logging from the memory manager).\n\nDefault value: L_DBG (memdbg=3)\n\nFor example, memdbg=2 means that memory debugging is activated if the\ndebug level is 2 or higher.\n\n```c\ndebug=3    # no memory debugging as debug level\nmemdbg=4   # is lower than memdbg\n\ndebug=3    # memory debugging is active as the debug level\nmemdbg=2   # is higher or equal memdbg\n```\n\nPlease see also <#memlog> and <#debug>.\n",
  "memlog": "### memlog\n\n**Alias name:** `mem_log`\n\nThis parameter specifies on which log level the memory statistics will\nbe logged. If memlog is active, Kamailio will log memory statistics on\nshutdown (or if requested via signal SIGUSR1). This can be useful for\ndebugging of memory leaks.\n\nDefault value: L_DBG (memlog=3)\n\nFor example, memlog=2 means that memory statistics dumping is activated\nif the debug level is 2 or higher.\n\n```c\ndebug=3    # no memory statistics as debug level\nmemlog=4   # is lower than memlog\n\ndebug=3    # dumping of memory statistics is active as the\nmemlog=2   # debug level is higher or equal memlog\n```\n\nPlease see also <#memdbg> and <#debug>.\n",
  "mem_add_size": "### mem_add_size\n\nSize in bytes to be added for each chunk allocated by the internal `qm` (quick malloc) memory manager.\nIt could be useful in cases when external libraries initialized to use `qm` expose issues of buffer\noverflow.\n\nIt can be set via config reload framework.\n\nDefault is 0.\n\n```c\nmem_add_size=4\n```\n",
  "mem_join": "### mem_join\n\nIf set to 1, memory manager (e.g., q_malloc) does join of free fragments.\nIt is effective if MEM_JOIN_FREE compile option is defined.\n\nIt can be set via config reload framework.\n\nDefault is 1 (enabled).\n\n```c\nmem_join=1\n```\n\nTo change its value at runtime, **kamcmd** needs to be used and the\nmodules **ctl** and **cfg_rpc** loaded. Enabling it can be done with:\n\n```bash\nkamctl rpc cfg.set_now_int core mem_join 1\n```\n\nTo disable, set its value to 0.\n",
  "mem_safety": "### mem_safety\n\nIf set to `1`, memory free operation does not call `abort()` for double\nfreeing a pointer or freeing an invalid address. The server still prints\nthe alerting log messages. If set to 0, the SIP server stops by calling\n`abort()` to generate a core file.\n\nIt can be set via config reload framework.\n\nDefault is `1` (enabled).\n\n```c\nmem_safety=0\n```\n",
  "mem_status_mode": "### mem_status_mode\n\nIf set to `1`, memory status dump for `qm` allocator will print details\nabout used fragments. If set to `0`, the dump contains only free\nfragments. It can be set at runtime via cfg param framework (e.g., via\n`kamcmd`).\n\nDefault is `0`.\n\n```c\nmem_status_mode=1\n```\n",
  "mem_summary": "### mem_summary\n\nParameter to control printing of memory debugging information displayed\non `exit` or `SIGUSR1`. The value can be composed by following flags:\n\n- `1` - dump all the pkg used blocks (status)\n- `2` - dump all the shm used blocks (status)\n- `4` - summary of pkg used blocks\n- `8` - summary of shm used blocks\n- `16` - short status\n\nIf set to `0`, nothing is printed.\n\nDefault value: `12`\n\nExample:\n\n```c\nmem_summary=15\n```\n",
  "mhomed": "### mhomed\n\nSet the server to try to locate outbound interface on multihomed host.\nThis parameter affects the selection of the outgoing socket for\nforwarding requests. By default is off (0) - it is rather time\nconsuming. When deactivated, the incoming socket will be used or the\nfirst one for a different protocol, disregarding the destination\nlocation. When activated, Kamailio will select a socket that can reach\nthe destination (to be able to connect to the remote address). (Kamailio\nopens a UDP socket to the destination, then it retrieves the local IP\nwhich was assigned by the operating system to the new UDP socket. Then\nthis socket will be closed and the retrieved IP address will be used as\nIP address in the Via/Record-Route headers)\n\nExample of usage:\n\n```c\nmhomed=1\n```\n",
  "mlock_pages": "### mlock_pages\n\nLocks all Kamailio pages into memory making it unswappable (in general\none doesn't want his SIP proxy swapped out :-))\n\n```c\nmlock_pages = yes |no (default no)\n```\n",
  "modinit_delay": "### modinit_delay\n\nNumber of microseconds to wait after initializing a module - useful to\ncope with systems where are rate limits on new connections to database\nor other systems.\n\nDefault value is 0 (no wait).\n\n```c\nmodinit_delay=100000\n```\n",
  "modparam": "### modparam\n\nThe modparam command will be used to set the options (parameters) for the loaded\nmodules.\n\nPrototypes:\n\n```c\nmodparam(\"modname\", \"paramname\", intval)\nmodparam(\"modname\", \"paramname\", \"strval\")\n```\n\nThe first pameter is the name of the module or a list of module names separated\nby `|` (pipe). Actually, the `modname` is enclosed in beteen `^(` and `)$` and\nmatched with the names of the loaded modules using POSIX regexp operation. For example,\nwhen `auth` is given, then the module name is matched with `^(auth)$`; when\n`acc|auth` is given, then the module name is matched with `^(acc|auth)$`. While\nusing only `|` between the names of the modules is recommended for clarity, any\nvalue that can construct a valid regular expression can be used. Note also that\n`modparam` throws error only when no module name is matched and no parameter is\nset. If the list of modules in `modname` includes a wrong name, Kamailio starts.\nFor example setting `modname` to `msilo|notamodule` does not result in a startup\nerror if `msilo` module is loaded. Be also careful with expressions than can\nmatch more module names than wanted, for example setting `modname` to `a|b` can\nresult in matching all module names that include either `a` or `b`.\n\nThe second parameter of `modparam` is the name of the module parameter.\n\nThe third parameter of `modparam` has to be either an interger or a string value,\na matter of what the module parameter expects, as documented in the README of the\nmodule.\n\nExample:\n\n```c\nmodparam(\"usrloc\", \"db_mode\", 2)\nmodparam(\"usrloc\", \"nat_bflag\", 6)\nmodparam(\"auth_db|msilo|usrloc\", \"db_url\",\n    \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n```\n\nSee the documenation of the respective module to find out the available\noptions.\n",
  "modparamx": "### modparamx\n\nSimilar to **modparam**, with ability to evaluate the variables in its\nparameters.\n",
  "msg_recv_max_size": "### msg_recv_max_size\n\nSet the maximum size in bytes of a SIP message to be accepted by Kamailio.\n\nDefault: `32767` (`2^15 - 1`)\n\nExample:\n\n```c\nmsg_recv_max_size = 10000\n```\n",
  "onsend_route_reply": "### onsend_route_reply\n\nIf set to 1 (yes, on), onsend_route block is executed for received\nreplies that are sent out. Default is 0.\n\n```c\nonsend_route_reply=yes\n```\n",
  "open_files_limit": "### open_files_limit\n\nIf set and bigger than the current open file limit, Kamailio will try to\nincrease its open file limit to this number. Note: Kamailio must be\nstarted as root to be able to increase a limit past the hard limit\n(which, for open files, is `1024` on most systems). \"Files\" include\nnetwork sockets, so you need one for every concurrent session\n(especially if you use connection-oriented transports, like TCP/TLS).\n\nExample of usage:\n\n```c\nopen_files_limit=2048\n```\n",
  "phone2tel": "### phone2tel\n\nBy enabling this feature, Kamailio internally treats SIP URIs with\nuser=phone parameter as TEL URIs. If you do not want this behavior, you\nhave to turn it off.\n\nDefault value: `1` (enabled)\n\n```c\nphone2tel = 0\n```\n",
  "pmtu_discovery": "### pmtu_discovery\n\nIf set to 1, the don't-fragment (DF) bit will be set in outbound IP\npackets, but no fragmentation from the kernel will be done for IPv4\nand IPv6. This means that packets might be dropped and it is up to\nthe user to reduce the packet size and try again.\n\nIf set to 2, the kernel will will fragment a packet if needed\naccording to the path MTU, or will set the don't-fragment flag\notherwise. For IPv6 the kernel will fragment a packet if needed\naccording to the path MTU. The kernel keeps track of the path MTU\nper destination host.\n\nThe default is 0, do not set the don't-fragment bit or fragment\npackets for IPv4 and IPv6.\n\n```c\npmtu_discovery = 0 | 1 | 2 (default 0)\n```\n",
  "port": "### port\n\nThe port the SIP server listens to. The default value for it is 5060.\n\nExample of usage:\n\n```c\nport=5080\n```\n",
  "pv_buffer_size": "### pv_buffer_size\n\nThe size in bytes of internal buffer to print dynamic strings with\npseudo-variables inside. The default value is 8192 (8kB). Please keep in\nmind that for xlog messages, there is a dedicated module parameter to\nset the internal buffer size.\n\nExample of usage:\n\n```c\npv_buffer_size=2048\n```\n",
  "pv_buffer_slots": "### pv_buffer_slots\n\nThe number of internal buffer slots to print dynamic strings with\npseudo-variables inside. The default value is 10.\n\nExample of usage:\n\n```c\npv_buffer_slots=12\n```\n",
  "pv_cache_limit": "### pv_cache_limit\n\nThe limit how many pv declarations in the cache after which an action is\ntaken. Default value is 2048.\n\n```c\npv_cache_limit=1024\n```\n",
  "pv_cache_action": "### pv_cache_action\n\nSpecify what action to be done when the size of pv cache is exceeded. If\n`0`, print a warning log message when the limit is exceeded. If `1`,\nwarning log messages is printed and the cache systems tries to drop a\n`$sht(...)` declaration. Default is `0`.\n\n```\npv_cache_action=1\n```\n",
  "rpc_exec_delta": "### rpc_exec_delta\n\nSpecify the time interval (in seconds) required to wait before executing again\nan RPC command exported with the flag `RPC_EXEC_DELTA`. Practically it enables\nan execution rate limit for such command. The rate limiting is per RPC command.\n\nSuch RPC commands can be those related to reload of data records or config options\nfrom backends such as database or hard drive. For them, executing the RPC command\ntoo ofter can result in compromizing the internal structures (e.g., previous reload\nof data was not finished when next reload is triggered).\n\nDefault value: `0` (no rate limiting)\n\nExample:\n\n```c\nrpc_exec_delta=5\n```\n",
  "rundir": "### rundir\n\nAlias: run_dir\n\nSet the folder for creating runtime files such as MI fifo or CTL\nunixsocket.\n\nDefault: `/var/run/kamailio`\n\nExample of usage:\n\n```c\nrundir=\"/tmp\"\n```\n",
  "received_route_mode": "### received_route_mode\n\nEnable or disable the execution of `event_route[core:msg-received]`\nrouting block or its corresponding Kemi callback.\n\nDefault value: `0` (disabled)\n\nExample of usage:\n\n```c\nreceived_route_mode=1\n```\n",
  "reply_to_via": "### reply_to_via\n\nIf it is set to 1, any local reply is sent to the IP address advertised\nin top most Via of the request instead of the IP address from which the\nrequest was received. Default value is 0 (off).\n\nExample of usage:\n\n```c\nreply_to_via=0\n```\n",
  "route_locks_size": "### route_locks_size\n\nSet the number of mutex locks to be used for synchronizing the execution\nof config script for messages sharing the same `Call-Id`. In other words,\nenables Kamailio to execute the config script sequentially for the\nrequests and replies received within the same dialog -- a new message\nreceived within the same dialog waits until the previous one is routed\nout.\n\nFor smaller impact on parallel processing, its value it should be at\nleast twice the number of Kamailio processes (all children processes).\n\nExample:\n\n```c\nroute_locks_size = 256\n```\n\nNote that ordering of the SIP messages can still be changed by network\ntransmission (quite likely for UDP, especially on long distance paths)\nor CPU allocation for processes when executing pre-config and\npost-config tasks (very low chance, but not to be ruled out completely).\n",
  "server_id": "### server_id\n\nA configurable unique server id that can be used to discriminate server\ninstances within a cluster of servers when all other information, such\nas IP addresses are the same.\n\n```c\n  server_id = number\n```\n",
  "server_header": "### server_header\n\nSet the value of Server header for replies generated by Kamailio. It\nmust contain the header name, but not the ending `CRLF`.\n\nExample of usage:\n\n```c\nserver_header=\"Server: My Super SIP Server\"\n```\n",
  "server_signature": "### server_signature\n\nThis parameter controls the \"Server\" header in any locally generated\nmessage.\n\nExample of usage:\n\n```c\nserver_signature=no\n```\n\nIf it is enabled (default=yes) a header is generated as in the following\nexample:\n\n```c\nServer: Kamailio (<version> (<arch>/<os>))\n```\n",
  "shm_force_alloc": "### shm_force_alloc\n\nTries to pre-fault all the shared memory, before starting. When \"on\",\nstart time will increase, but combined with mlock_pages will guarantee\nKamailio will get all its memory from the beginning (no more kswapd slow\ndowns)\n\n```c\nshm_force_alloc = yes | no (default no)\n```\n",
  "shm_mem_size": "### shm_mem_size\n\nSet shared memory size (in Mb).\n\n```c\nshm_mem_size = 64 (default 64)\n```\n",
  "sip_parser_log": "### sip_parser_log\n\nLog level for printing debug messages for some of the SIP parsing\nerrors.\n\nDefault: `0` (`L_WARN`)\n\n```c\nsip_parser_log = 1\n```\n",
  "sip_parser_mode": "### sip_parser_mode\n\nControl sip parser behaviour.\n\nIf set to `1`, the parser is more strict in accepting messages that have\ninvalid headers (e.g., duplicate To or From). It can make the system\nsafer, but loses the flexibility to be able to fix invalid messages with\nconfig operations.\n\nIf set to `0`, the parser is less strict on checking validity of headers.\n\nDefault: `1`\n\n```c\nsip_parser_mode = 0\n```\n",
  "sip_warning": "### sip_warning (noisy feedback)\n\nCan be `0` or `1`. If set to `1` (default value is `0`) a 'Warning' header is\nadded to each reply generated by Kamailio. The header contains several\ndetails that help troubleshooting using the network traffic dumps, but\nmight reveal details of your network infrastructure and internal SIP\nrouting.\n\nExample of usage:\n\n```c\nsip_warning=0\n```\n",
  "socket": "### socket\n\nSpecify an address to listen (bind) to, a simplified alternative to `listen`\nparamter that allows specifying the attributes using a structure style.\n\nPrototype:\n\n```c\nsocket = {\n    attr1 = value1;\n    ...\n    attrN = valueN;\n}\n```\n\nThe attributes are:\n\n- `bind` - the address to listen on in format `[proto:]address[:port]`\n- `advertise` - the address to advertise in SIP headers in format `address[:port]`\n- `name` - name of the socket to be referenced in configuration file\n- `virtual` - set to `yes/no` to indicate if the IP has to be considered virtual or not\n\nThe attribute `bind` is mandatory and has to provide at list the address to listen on.\n\nExample:\n\n```c\nsocket = {\n    bind = udp:10.10.10.10:5060;\n    advertise = 11.11.11.11:5060;\n    name = \"s0\";\n    virtual = yes;\n}\n```\n\nThe above is the equivalent of:\n\n```c\nlisten=udp:10.10.10.10:5060 advertise 11.11.11.11:5060 name \"s0\" virtual\n```\n",
  "socket_workers": "### socket_workers\n\nNumber of workers to process SIP traffic per listen socket - typical use\nis before a **listen** global parameter.\n\n- when used before **listen** on UDP or SCTP socket, it overwrites\n  **children** or **sctp_children** value for that socket.\n- when used before **listen** on TCP or TLS socket, it adds extra tcp\n  workers, these handling traffic only on that socket.\n\nThe value of **socket_workers** is reset with next **listen** socket\ndefinition that is added, thus use it for each **listen** socket where\nyou want custom number of workers.\n\nIf this parameter is not used at all, the values for **children**,\n**tcp_children** and **sctp_children** are used as usually.\n\nExample for udp sockets:\n\n```c\nchildren=4\nsocket_workers=2\nlisten=udp:127.0.0.1:5080\nlisten=udp:127.0.0.1:5070\nlisten=udp:127.0.0.1:5060\n```\n\n- it will start 2 workers to handle traffic on udp:127.0.0.1:5080\n  and 4 for each of udp:127.0.0.1:5070 and udp:127.0.0.1:5060. In\n  total there are 10 worker processes\n\nExample for tcp sockets:\n\n```c\nchildren=4\nsocket_workers=2\nlisten=tcp:127.0.0.1:5080\nlisten=tcp:127.0.0.1:5070\nlisten=tcp:127.0.0.1:5060\n```\n\n- it will start 2 workers to handle traffic on tcp:127.0.0.1:5080 and\n  4 to handle traffic on both tcp:127.0.0.1:5070 and\n  tcp:127.0.0.1:5060. In total there are 6 worker processes\n",
  "sql_buffer_size": "### sql_buffer_size\n\nThe size in bytes of the SQL buffer created for data base queries. For\ndatabase drivers that use the core db_query library, this will be\nmaximum size object that can be written or read from a database. Default\nvalue is 65535.\n\nExample of usage:\n\n```c\nsql_buffer_size=131070\n```\n",
  "statistics": "### statistics\n\nKamailio has built-in support for statistics counter. This means, these\ncounters can be increased, decreased, read and cleared. The statistics\ncounter are defined either by the core (e.g. tcp counters), by modules\n(e.g. 2xx_transactions by \"tmx\" module) or by the script writer using\nthe \"statistics\" module.\n\nThe statistics counters are read/updated either automatically by\nKamailio internally (e.g. tcp counters), by the script writer via the\nmodule functions of the \"statistics\" module, by the script writer using\nthe `$stat()` pseudo variable (read-only), or via MI commands.\n\nFollowing are some examples how to access statistics variables:\n\n**script**:\n\n```c\nmodparam(\"statistics\", \"variable\", \"NOTIFY\")\n\n(if method == \"NOTIFY\") {\n    update_stat(\"NOTIFY\", \"+1\");\n}\n\nxlog(\"Number of received NOTIFYs: $stat(NOTIFY)\");\n```\n\n**RPC**:\n\n```bash\n# get counter value\nkamctl rpc stats.get_statistics NOTIFY\n# set counter to zero\nkamctl rpc stats.reset_statistics NOTIFY\n# get counter value and then set it to zero\nkamctl rpc stats.clear_statistics NOTIFY\n\n# or use the kamcmd tool\nkamcmd stats.get_statistics 1xx_replies\n```\n",
  "stats_name_separator": "### stats_name_separator\n\nSpecify the character used as a separator for the internal statistics'\nnames. Default value is `_`.\n\nExample of usage:\n\n```c\nstats_name_separator = \"-\"\n```\n",
  "tos": "### tos\n\nThe TOS (Type Of Service) to be used for the sent IP packages (both TCP\nand UDP).\n\nExample of usage:\n\n```c\ntos=IPTOS_LOWDELAY\ntos=0x10\ntos=IPTOS_RELIABILITY\n```\n",
  "udp_mtu": "### udp_mtu\n\nFallback to another protocol (`udp_mtu_try_proto` must be set also either\nglobally or per packet) if the constructed request size is greater than\nudp_mtu.\n\nRFC 3261 specified size: `1300`. Default: `0` (off).\n\n```c\nudp_mtu = number\n```\n",
  "udp_mtu_try_proto": "### udp_mtu_try_proto\n\nIf `udp_mtu != 0` and udp forwarded request size (after adding all the\n\"local\" headers) `&gt; udp_mtu`, use this protocol instead of udp. Only the\nVia header will be updated (e.g. The Record-Route will be the one built\nfor udp).\n\n**Warning:** Although RFC3261 mandates automatic transport protocol\nchanging, enabling this feature can lead to problems with clients which\ndo not support other protocols or are behind a firewall or NAT. Use this\nonly when you know what you do!\n\nSee also `udp_mtu_try_proto(proto)` function.\n\nDefault: `UDP` (`off`). Recommended: `TCP`.\n\n```c\nudp_mtu_try_proto = TCP|TLS|SCTP|UDP\n```\n",
  "uri_host_extra_chars": "### uri_host_extra_chars\n\nSpecify additional chars that should be allowed in the host part of URI.\n\n```c\nuri_host_extra_chars = \"_\"\n```\n",
  "user": "### user\n\n**Alias name:** **uid**\n\nThe user id to run Kamailio (Kamailio will suid to it).\n\nExample of usage:\n\n```c\n    user=\"kamailio\"\n```\n",
  "user_agent_header": "### user_agent_header\n\nSet the value of User-Agent header for requests generated by Kamailio.\nIt must contain header name as well, but not the ending CRLF.\n\n```c\nuser_agent_header=\"User-Agent: My Super SIP Server\"\n```\n",
  "verbose_startup": "### verbose_startup\n\nControl if printing routing tree and udp probing buffer debug messages\nshould be printed at startup.\n\nDefault is 0 (don't print); set to 1 to get those debug messages.\n\nExample of usage:\n\n```c\n   verbose_startup=1\n```\n",
  "version_table": "### version_table\n\nSet the name of the table holding the table version. Useful if the proxy\nis sharing a database within a project and during upgrades. Default\nvalue is \"version\".\n\nExample of usage:\n\n```c\n   version_table=\"version44\"\n```\n",
  "wait_worker1_mode": "### wait_worker1_mode\n\nEnable waiting for child SIP worker one to complete initialization, then\ncreate the other child worker processes.\n\nDefault: 0 (do not wait for child worker one to complete\ninitialization).\n\nExample:\n\n```c\nwait_worker1_mode = 1\n```\n",
  "wait_worker1_time": "### wait_worker1_time\n\nHow long to wait for child worker one to complete the initialization. In\nmicro-seconds.\n\nDefault: 4000000 (micro-seconds = 4 seconds).\n\nExample:\n\n```c\nwait_worker1_time = 1000000\n```\n",
  "wait_worker1_usleep": "### wait_worker1_usleep\n\nWaiting for child worker one to complete the initialization is done in\na loop, which loop waits until wait_worker1_time passes.  This parameter\nspecifies how long after each iteration of that loop to wait in micro-seconds.\n\nDefault: 100000 (micro-seconds = 0.1 seconds).\n\nExample:\n\n```c\nwait_worker1_usleep = 50000\n```\n",
  "workdir": "### workdir\n\n**Alias name:** **wdir**\n\nThe working directory used by Kamailio at runtime. You might find it\nuseful when it comes to generating core files :)\n\nExample of usage:\n\n```c\nwdir=\"/usr/local/kamailio\"\n# or\nwdir=/usr/kamwd\n```\n",
  "xavp_via_params": "### xavp_via_params\n\nSet the name of the XAVP of which subfields will be added as local `Via`\n-header parameters.\n\nIf not set, `XAVP` to `Via` header parameter manipulation is not applied\n(default behaviour).\n\nIf set, local `Via` header gets additional parameters from defined `XAVP`.\nCore flag `FL_ADD_XAVP_VIA_PARAMS` needs to be set\u00b9.\n\nExample:\n\n```c\nxavp_via_params=\"via\"\n```\n\n`[1]` See function `via_add_xavp_params()` from \"corex\" module.\n",
  "xavp_via_fields": "### xavp_via_fields\n\nSet the name of xavp from where to take Via header field: address and\nport. Use them to build local Via header.\n\nExample:\n\n```c\nxavp_via_fields=\"customvia\"\n\nrequest_route {\n  ...\n  $xavp(customvia=>address) = \"1.2.3.4\";\n  $xavp(customvia[0]=>port) = \"5080\";  # must be string\n  via_use_xavp_fields(\"1\");\n  t_relay();\n}\n```\n\nSee function `via_use_xavp_fields()` from \"corex\" module.\n",
  "xavp_via_reply_params": "### xavp_via_reply_params\n\nSet the name of the XAVP of which subfields will be added as header parameters to the top `Via` of the replies sent out.\n\nIf not set, `XAVP` to `Via` header parameter manipulation is not applied\n(default behaviour).\n\nIf set, top `Via` header of the to-be-sent reply gets additional parameters from defined `XAVP`.\nCore flag `FL_ADD_XAVP_VIA_REPLY PARAMS` needs to be set\u00b9.\n\nExample:\n\n```c\nxavp_via_reply_params=\"viarpl\"\n```\n\n`[1]` See function `via_reply_vadd_xavp_params()` from \"corex\" module.\n",
  "dns": "### dns\n\nThis parameter controls if the SIP server will try doing a DNS lookup on\nthe address in the Via header of a received sip request to decide if\nadding a `received=src_ip` parameter to the Via is necessary. Note that\nVias containing DNS names (instead of IPs) should have `received=` added,\nso turning dns to yes is not recommended.\n\nDefault is `no`.\n",
  "rev_dns": "### rev_dns\n\n**Alias name:** **dns_rev_via**\n\nThis parameter controls if the SIP server will try doing a reverse DNS\nlookup on the source IP of a sip request to decide if adding a\n`received=src_ip` parameter to the Via is necessary (if the Via\ncontains a DNS name instead of an IP address, the result of the reverse\ndns on the source IP will be compared with the DNS name in the Via). See\nalso dns (the effect is cumulative, both can be turned on and in that\ncase if the DNS lookup test fails the reverse DNS test will be tried).\nNote that Vias containing DNS names (instead of IPs) should have\n`received=` added, so turning rev_dns to yes is not recommended.\n\nDefault is `no`.\n",
  "dns_cache_del_nonexp": "### dns_cache_del_nonexp\n\n**Alias name:** **dns_cache_delete_nonexpired**\n\n```c\ndns_cache_del_nonexp = yes | no (default: no)\n```\n\n```\n  allow deletion of non-expired records from the cache when there is no more space\n  left for new ones. The last-recently used entries are deleted first.\n```\n",
  "dns_cache_rec_pref": "### dns_cache_rec_pref\n\n```c\ndns_cache_rec_pref = number (default 0)\n```\n\n```\n  dns cache record preference, determines how new DNS records are stored internally in relation to existing entries.\n  Possible values:\n    0 - do not check duplicates\n    1 - prefer old records\n    2 - prefer new records\n    3 - prefer records with longer lifetime\n```\n",
  "dns_cache_flags": "### dns_cache_flags\n\n```c\ndns_cache_flags = number (default 0)\n```\n\n```\n  dns cache specific resolver flags, used for overriding the default behaviour (low level).\n  Possible values:\n    1 - ipv4 only: only DNS A requests are performed, even if Kamailio also listens on ipv6 addresses.\n    2 - ipv6 only: only DNS AAAA requests are performed. Ignored if dns_try_ipv6 is off or Kamailio\n        doesn't listen on any ipv6 address.\n    4 - prefer ipv6: try first to resolve a host name to an ipv6 address (DNS AAAA request) and only\n        if this fails try an ipv4 address (DNS A request). By default the ipv4 addresses are preferred.\n```\n",
  "dns_cache_gc_interval": "### dns_cache_gc_interval\n\nInterval in seconds after which the dns cache is garbage collected\n(default: 120 s)\n\n```c\ndns_cache_gc_interval = number\n```\n",
  "dns_cache_init": "### dns_cache_init\n\nIf off, the dns cache is not initialized at startup and cannot be\nenabled at runtime, this saves some memory.\n\n```c\ndns_cache_init = on | off (default on)\n```\n",
  "dns_cache_max_ttl": "### dns_cache_max_ttl\n\n```c\ndns_cache_max_ttl = time in seconds (default MAXINT)\n```\n",
  "dns_cache_mem": "### dns_cache_mem\n\nMaximum memory used for the dns cache in KB (default 500 K)\n\n```c\ndns_cache_mem = number\n```\n",
  "dns_cache_min_ttl": "### dns_cache_min_ttl\n\n```c\ndns_cache_min_ttl = time in seconds (default 0)\n```\n",
  "dns_cache_negative_ttl": "### dns_cache_negative_ttl\n\nTells how long to keep negative DNS responses in cache. If set to 0,\ndisables caching of negative responses. Default is 60 (seconds).\n",
  "dns_naptr_ignore_rfc": "### dns_naptr_ignore_rfc\n\nIf the DNS lookup should ignore the remote side's protocol preferences,\nas indicated by the Order field in the NAPTR records and mandated by RFC\n2915.\n\n```c\ndns_naptr_ignore_rfc = yes | no (default yes)\n```\n",
  "dns_retr_no": "### dns_retr_no\n\nNumber of dns retransmissions before giving up. Default value is system\nspecific, depends also on the '/etc/resolv.conf' content (usually 4).\n\nExample of usage:\n\n```c\ndns_retr_no=3\n```\n",
  "dns_retr_time": "### dns_retr_time\n\nTime in seconds before retrying a dns request. Default value is system\nspecific, depends also on the '/etc/resolv.conf' content (usually 5s).\n\nExample of usage:\n\n```c\ndns_retr_time=3\n```\n",
  "dns_search_full_match": "### dns_search_full_match\n\nWhen name was resolved using dns search list, check the domain added in\nthe answer matches with one from the search list (small performance hit,\nbut more safe)\n\n```c\ndns_search_full_match = yes | no (default yes)\n```\n",
  "dns_servers_no": "### dns_servers_no\n\nHow many dns servers from the ones defined in '/etc/resolv.conf' will be\nused. Default value is to use all of them.\n\nExample of usage:\n\n```c\ndns_servers_no=2\n```\n",
  "dns_srv_lb": "### dns_srv_lb\n\n**Alias name:** **dns_srv_loadbalancing**\n\nEnable dns srv weight based load balancing (see doc/tutorials/dns.txt)\n\n```c\ndns_srv_lb = yes | no (default no)\n```\n",
  "dns_try_ipv6": "### dns_try_ipv6\n\nCan be 'yes' or 'no'. If it is set to 'yes' and a DNS lookup fails, it\nwill retry it for ipv6 (AAAA record). Default value is 'no'.\n\nNote: If dns_try_ipv6 is off, no hostname resolving that would result in\nan ipv6 address would succeed - it doesn't matter if an actual DNS\nlookup is to be performed or the host is already an ip address. Thus, if\nthe proxy should forward requests to IPv6 targets, this option must be\nturned on!\n\nExample of usage:\n\n```c\ndns_try_ipv6=yes\n```\n",
  "dns_try_naptr": "### dns_try_naptr\n\nEnable NAPTR support according to RFC 3263 (see doc/tutorials/dns.txt\nfor more info)\n\n```c\ndns_try_naptr = yes | no (default no)\n```\n",
  "dns_sctp_pref": "### dns_sctp_pref, dns_tcp_pref, dns_tls_pref, dns_udp_pref\n\n**Alias name:** **dns_sctp_preference, dns_tcp_preference,\ndns_tls_preference, dns_udp_preference**\n\nSet preference for each protocol when doing naptr lookups. By default\ndns_udp_pref=30, dns_tcp_pref=20, dns_tls_pref=10 and dns_sctp_pref=20.\nTo use the remote site preferences set all dns_*_pref to the same\npositive value (e.g. dns_udp_pref=1, dns_tcp_pref=1, dns_tls_pref=1,\ndns_sctp_pref=1). To completely ignore NAPTR records for a specific\nprotocol, set the corresponding protocol preference to -1 (or any other\nnegative number). (see doc/tutorials/dns.txt for more info)\n\n```c\ndns_{udp,tcp,tls,sctp}_pref = number\n```\n",
  "dns_use_search_list": "### dns_use_search_list\n\nCan be 'yes' or 'no'. If set to 'no', the search list in\n'/etc/resolv.conf' will be ignored (=> fewer lookups => gives up\nfaster). Default value is 'yes'.\n\nHINT: even if you don't have a search list defined, setting this option\nto 'no' will still be \"faster\", because an empty search list is in fact\nsearch \"\" (so even if the search list is empty/missing there will still\nbe 2 dns queries, eg. foo+'.' and foo+\"\"+'.')\n\nExample of usage:\n\n```c\ndns_use_search_list=no\n```\n",
  "use_dns_cache": "### use_dns_cache\n\n**Alias name:** **dns_use_cache**\n\nTells if DNS responses are cached - this means that the internal DNS\nresolver (instead of the system's stub resolver) will be used. If set to\n\"off\", disables caching of DNS responses and, as side effect, DNS\nfailover. Default is \"on\". Settings can be changed also during runtime\n(switch from internal to system resolver and back).\n",
  "use_dns_failover": "### use_dns_failover\n\n**Alias name:** **dns_use_failover**\n\n```c\nuse_dns_failover = on | off (default off)\n```\n\nIf `on` and sending a request fails (due to not being allowed from an `onsend_route`,\nsend failure, blocklisted destination or, when using tm, invite timeout), and the\ndestination resolves to multiple ip addresses and/or multiple `SRV` records, the send\nwill be re-tried using the next ip/record. In `tm` case, a new branch will be\ncreated for each new send attempt.\n",
  "disable_tcp": "### disable_tcp\n\nGlobal parameter to disable TCP support in the SIP server. Default value\nis `no`.\n\nExample of usage:\n\n```c\ndisable_tcp=yes\n```\n",
  "tcp_accept_aliases": "### tcp_accept_aliases\n\nIf a message received over a tcp connection has \"alias\" in its via a new\ntcp alias port will be created for the connection the message came from\n(the alias port will be set to the via one).\n\nBased on `draft-ietf-sip-connect-reuse-00.txt`, but using only the port\n(host aliases are dangerous, involve extra DNS lookups and the need for\nthem is questionable)\n\nSee `force_tcp_alias` for more details.\n\nNote: For NAT traversal of TCP clients it is better to not use\ntcp_accept_aliases but just use nathelper module and\n`fix_nated_[contact|register]()` functions.\n\nDefault is `no` (`off`)\n\n```c\ntcp_accept_aliases= yes|no\n```\n",
  "tcp_accept_haproxy": "### tcp_accept_haproxy\n\nEnable the internal TCP stack to expect a PROXY-protocol-formatted\nheader as the first message of the connection. Both the human-readable\n(v1) and binary-encoded (v2) variants of the protocol are supported.\nThis option is typically useful if you are behind a TCP load-balancer,\nsuch as HAProxy or an AWS' ELB, and allows the load-balancer to provide\nconnection information regarding the upstream client. This enables the\nuse of IP-based ACLs, even behind a load-balancer.\n\nPlease note that enabling this option will reject any inbound TCP\nconnection that does not conform to the PROXY-protocol spec.\n\nFor reference - the PROXY protocol:\n\n- <https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>\n\nDefault value is **no**.\n\n```c\ntcp_accept_haproxy=yes\n```\n",
  "tcp_accept_hep3": "### tcp_accept_hep3\n\nEnable internal TCP receiving stack to accept HEP3 packets. This option\nhas to be set to **yes** on a Kamailio instance acting as Homer\nSIPCapture server that is supposed to receive HEP3 packets over TCP/TLS.\n\nDefault value is **no**.\n\n```c\ntcp_accept_hep3=yes\n```\n",
  "tcp_accept_iplimit": "### tcp_accept_iplimit\n\nSet limit for accepted connections from the same IP address.\n\nDefault: `1024`.\n\n```c\ntcp_accept_iplimit=32\n```\n\nIt can be set to `0` (or a negative value) to disable this limit.\n",
  "tcp_accept_no_cl": "### tcp_accept_no_cl\n\nControl whether to throw or not error when there is no Content-Length\nheader for requests received over TCP. It is required to be set to\n**yes** for XCAP traffic sent over HTTP/1.1 which does not use\nContent-Length header, but splits large bodies in many chunks. The\nmodule **sanity** can be used then to restrict this permission to HTTP\ntraffic only, testing in route block in order to stay RFC3261 compliant\nabout this mandatory header for SIP requests over TCP.\n\nDefault value is **no**.\n\n```c\ntcp_accept_no_cl=yes\n```\n",
  "tcp_accept_unique": "### tcp_accept_unique\n\nIf set to `1`, reject duplicate connections coming from same source IP and\nport.\n\nDefault set to `0`.\n\n```c\ntcp_accept_unique = 1\n```\n",
  "tcp_async": "### tcp_async\n\n**Alias name:** **tcp_buf_write**\n\nIf enabled, all the tcp writes that would block / wait for connect to\nfinish, will be queued and attempted latter (see also `tcp_conn_wq_max`\nand `tcp_wq_max`).\n\n**Note:** It also applies for TLS.\n\n```c\ntcp_async = yes | no (default yes)\n```\n",
  "tcp_check_timer": "### tcp_check_timer\n\nSet the check interval (in seconds) for tcp connections. It is used to check\nif there was any data received on new connections or if the receiving of SIP\nmessages takes too long. See also `tcp_msg_data_timeout` and `tcp_msg_read_timeout`.\n\nDefault half of `tcp_msg_data_timeout` or `tcp_msg_read_timeout` value depending on\nwhich one is smaller and not zero or 0 if both are zero\n\n```c\ntcp_check_timer=5\n```\n",
  "tcp_children": "### tcp_children\n\nNumber of children processes to be created for reading from TCP\nconnections. If no value is explicitly set, the same number of TCP\nchildren as UDP children (see \"children\" parameter) will be used.\n\nExample of usage:\n\n```c\ntcp_children=4\n```\n",
  "tcp_clone_rcvbuf": "### tcp_clone_rcvbuf\n\nControl if the received buffer should be cloned from the TCP stream,\nneeded by functions working inside the SIP message buffer (such as\nmsg_apply_changes()).\n\nDefault is `0` (don't clone), set it to `1` for cloning.\n\nExample of usage:\n\n```c\ntcp_clone_rcvbuf=1\n```\n",
  "tcp_connection_lifetime": "### tcp_connection_lifetime\n\nLifetime in seconds for TCP sessions. TCP sessions which are inactive\nfor longer than **tcp_connection_lifetime** will be closed by Kamailio.\nDefault value is defined is `120`. Setting this value to 0 will close the\nTCP connection pretty quick.\n\nNote: As many SIP clients are behind NAT/Firewalls, the SIP proxy should\nnot close the TCP connection as it is not capable of opening a new one.\n\nExample of usage:\n\n```c\ntcp_connection_lifetime=3605\n```\n",
  "tcp_connection_match": "### tcp_connection_match\n\nIf set to `1`, try to be more strict in matching outbound TCP connections,\nattempting to lookup first the connection using also local port, not\nonly the local IP and remote IP+port.\n\nDefault is `0`.\n\n```c\ntcp_connection_match=1\n```\n",
  "tcp_connect_timeout": "### tcp_connect_timeout\n\nTime in seconds before an ongoing attempt to establish a new TCP\nconnection will be aborted. Lower this value for faster detection of TCP\nconnection problems. The default value is 10s.\n\nExample of usage:\n\n```c\ntcp_connect_timeout=5\n```\n",
  "tcp_conn_wq_max": "### tcp_conn_wq_max\n\nMaximum bytes queued for write allowed per connection. Attempting to\nqueue more bytes would result in an error and in the connection being\nclosed (too slow). If tcp_buf_write is not enabled, it has no effect.\n\n```c\ntcp_conn_wq_max = bytes (default 32 K)\n```\n",
  "tcp_crlf_ping": "### tcp_crlf_ping\n\nEnable SIP outbound TCP keep-alive using PING-PONG (CRLFCRLF - CRLF).\n\n```c\ntcp_crlf_ping = yes | no default: yes\n```\n",
  "tcp_defer_accept": "### tcp_defer_accept\n\nTcp accepts will be delayed until some data is received (improves\nperformance on proxies with lots of opened tcp connections). See linux\n`tcp(7)` `TCP_DEFER_ACCEPT` or freebsd `ACCF_DATA(0)`. For now linux and\nfreebsd only.\n\nWARNING: the linux `TCP_DEFER_ACCEPT` is buggy (`&lt;=2.6.23`) and doesn't\nwork exactly as expected (if no data is received it will retransmit syn\nacks for `~ 190 s`, irrespective of the set timeout and then it will\nsilently drop the connection without sending a RST or FIN). Try to use\nit together with tcp_syncnt (this way the number of retrans. SYNACKs can\nbe limited => the timeout can be controlled in some way).\n\nOn FreeBSD:\n\n```c\ntcp_defer_accept =  yes | no (default no)\n```\n\nOn Linux:\n\n```c\ntcp_defer_accept =  number of seconds before timeout (default disabled)\n```\n",
  "tcp_delayed_ack": "### tcp_delayed_ack\n\nInitial ACK for opened connections will be delayed and sent with the\nfirst data segment (see linux tcp(7) TCP_QUICKACK). For now linux only.\n\n```c\ntcp_delayed_ack  = yes | no (default yes when supported)\n```\n",
  "tcp_fd_cache": "### tcp_fd_cache\n\nIf enabled FDs used for sending will be cached inside the process\ncalling tcp_send (performance increase for sending over tcp at the cost\nof slightly slower connection closing and extra FDs kept open)\n\n```c\ntcp_fd_cache = yes | no (default yes)\n```\n",
  "tcp_keepalive": "### tcp_keepalive\n\nEnables keepalive for tcp (sets SO_KEEPALIVE socket option)\n\n```c\ntcp_keepalive = yes | no (default yes)\n```\n",
  "tcp_keepcnt": "### tcp_keepcnt\n\nNumber of keepalives sent before dropping the connection (TCP_KEEPCNT\nsocket option). Linux only.\n\n```c\ntcp_keepcnt = number (not set by default)\n```\n",
  "tcp_keepidle": "### tcp_keepidle\n\nTime before starting to send keepalives, if the connection is idle\n(TCP_KEEPIDLE socket option). Linux only.\n\n```c\ntcp_keepidle  = seconds (not set by default)\n```\n",
  "tcp_keepintvl": "### tcp_keepintvl\n\nTime interval between keepalive probes, when the previous probe failed\n(TCP_KEEPINTVL socket option). Linux only.\n\n```c\ntcp_keepintvl = seconds (not set by default)\n```\n",
  "tcp_linger2": "### tcp_linger2\n\nLifetime of orphaned sockets in FIN_WAIT2 state (overrides\ntcp_fin_timeout on, see linux tcp(7) TCP_LINGER2). Linux only.\n\n```c\ntcp_linger2 = seconds (not set by default)\n```\n",
  "tcp_max_connections": "### tcp_max_connections\n\nMaximum number of tcp connections (if the number is exceeded no new tcp\nconnections will be accepted). Default is defined in tcp_init.h: #define\nDEFAULT_TCP_MAX_CONNECTIONS 2048\n\nExample of usage:\n\n```c\ntcp_max_connections=4096\n```\n",
  "tcp_msg_data_timeout": "### tcp_msg_data_timeout\n\nDuration in seconds for how long to wait till data is received on a new tcp\nconnection. Default 20.\n\n```c\ntcp_msg_data_timeout=10\n```\n",
  "tcp_msg_read_timeout": "### tcp_msg_read_timeout\n\nDuration in seconds for how long to wait till data is received on a new tcp\nconnection. Default 20.\n\n```c\ntcp_msg_read_timeout=10\n```\n",
  "tcp_no_connect": "### tcp_no_connect\n\nStop outgoing TCP connects (also stops TLS) by setting tcp_no_connect to\nyes.\n\nYou can do this any time, even even if Kamailio is already started (in\nthis case using the command \"kamcmd cfg.set_now_int tcp no_connect 1\").\n",
  "tcp_poll_method": "### tcp_poll_method\n\nPoll method used (by default the best one for the current OS is\nselected). For available types see io_wait.c and poll_types.h: none,\npoll, epoll_lt, epoll_et, sigio_rt, select, kqueue, /dev/poll\n\nExample of usage:\n\n```c\ntcp_poll_method=select\n```\n",
  "tcp_rd_buf_size": "### tcp_rd_buf_size\n\nBuffer size used for tcp reads. A high buffer size increases performance\non server with few connections and lot of traffic on them, but also\nincreases memory consumption (so for lots of connection is better to use\na low value). Note also that this value limits the maximum message size\n(SIP, HTTP) that can be received over tcp.\n\nThe value is internally limited to 16MByte, for higher values recompile\nKamailio with higher limit in tcp_options.c (search for \"rd_buf_size\"\nand 16777216). Further, you may need to increase the private memory, and\nif you process the message stateful you may also have to increase the\nshared memory.\n\nDefault: 4096, can be changed at runtime.\n\n```c\ntcp_rd_buf_size=65536\n```\n",
  "tcp_reuse_port": "### tcp_reuse_port\n\nAllows reuse of TCP ports. This means, for example, that the same TCP\nports on which Kamailio is listening on, can be used as source ports of\nnew TCP connections when acting as an UAC. Kamailio must have been\ncompiled in a system implementing SO_REUSEPORT (Linux > 3.9.0, FreeBSD,\nOpenBSD, NetBSD, MacOSX). This parameter takes effect only if also the\nsystem on which Kamailio is running on supports SO_REUSEPORT.\n\n```c\ntcp_reuse_port = yes (default no)\n```\n",
  "tcp_script_mode": "### tcp_script_mode\n\nSpecify if connection should be closed (set to CONN_ERROR) if processing\nthe received message results in error (that can also be due to negative\nreturn code from a configuration script main route block). If set to 1,\nthe processing continues with the connection open.\n\nDefault `0` (close connection)\n\n```c\ntcp_script_mode = 1\n```\n",
  "tcp_send_timeout": "### tcp_send_timeout\n\nTime in seconds after a TCP connection will be closed if it is not\navailable for writing in this interval (and Kamailio wants to send\nsomething on it). Lower this value for faster detection of broken TCP\nconnections. The default value is 10s.\n\nExample of usage:\n\n```c\ntcp_send_timeout=3\n```\n",
  "tcp_source_ipv4": "### tcp_source_ipv4, tcp_source_ipv6\n\nSet the source IP for all outbound TCP connections. If setting of the IP\nfails, the TCP connection will use the default IP address.\n\n```c\ntcp_source_ipv4 = IPv4 address\ntcp_source_ipv6 = IPv6 address\n```\n",
  "tcp_syncnt": "### tcp_syncnt\n\nNumber of SYN retransmissions before aborting a connect attempt (see\nlinux tcp(7) TCP_SYNCNT). Linux only.\n\n```c\ntcp_syncnt = number of syn retr. (default not set)\n```\n",
  "tcp_wait_data": "### tcp_wait_data\n\nSpecify how long to wait (in milliseconds) to wait for data on tcp\nconnections in certain cases. Now applies when reading on tcp connection\nfor haproxy protocol.\n\nDefault: `5000ms` (`5secs`)\n\n```c\ntcp_wait_data = 10000\n```\n",
  "tcp_wq_blk_size": "### tcp_wq_blk_size\n\nBlock size used for tcp async writes. It should be big enough to hold a\nfew datagrams. If it's smaller than a datagram (in fact a tcp write())\nsize, it will be rounded up. It has no influenced on the number of\ndatagrams queued (for that see tcp_conn_wq_max or tcp_wq_max). It has\nmostly debugging and testing value (can be ignored).\n\nDefault: `2100` (`~ 2 INVITEs`), can be changed at runtime.\n",
  "tcp_wq_max": "### tcp_wq_max\n\nMaximum bytes queued for write allowed globally. It has no effect if\ntcp_buf_write is not enabled.\n\n```c\ntcp_wq_max = bytes (default 10 Mb)\n```\n",
  "tls_port_no": "### tls_port_no\n\nThe port the SIP server listens to for TLS connections.\n\nDefault value is `5061`.\n\nExample of usage:\n\n```c\ntls_port_no=6061\n```\n",
  "tls_max_connections": "### tls_max_connections\n\nMaximum number of ls connections (if the number is exceeded no new ls\nconnections will be accepted). It cannot exceed tcp_max_connections.\n\nDefault value is `2048`.\n\nExample of usage:\n\n```c\ntls_max_connections=4096\n```\n",
  "disable_sctp": "### disable_sctp\n\nGlobal parameter to disable SCTP support in the SIP server. See also\n`enable_sctp`.\n\nDefault value is `auto`.\n\nExample of usage:\n\n```c\ndisable_sctp=yes\n```\n",
  "enable_sctp": "### enable_sctp\n\n```c\nenable_sctp = 0/1/2  - SCTP disabled (0)/ SCTP enabled (1)/auto (2),\n                        default auto (2)\n```\n",
  "sctp_children": "### sctp_children\n\nsctp children no (similar to udp children)\n\n```c\nsctp_children = number\n```\n",
  "sctp_socket_rcvbuf": "### sctp_socket_rcvbuf\n\nSize for the sctp socket receive buffer\n\n**Alias name:** **sctp_socket_receive_buffer**\n\n```c\nsctp_socket_rcvbuf = number\n```\n",
  "sctp_socket_sndbuf": "### sctp_socket_sndbuf\n\nSize for the sctp socket send buffer\n\n**Alias name:** **sctp_socket_send_buffer**\n\n```c\nsctp_socket_sndbuf = number\n```\n",
  "sctp_autoclose": "### sctp_autoclose\n\nNumber of seconds before autoclosing an idle association (default: `180`\ns). Can be changed at runtime, but it will affect only new associations.\nE.g.:\n\n```shell\nkamcmd cfg.seti sctp autoclose 120\n```\n\n```c\nsctp_autoclose = seconds\n```\n",
  "sctp_send_ttl": "### sctp_send_ttl\n\nNumber of milliseconds before an unsent message/chunk is dropped\n(default: `32000` ms or `32` s). Can be changed at runtime, e.g.:\n\n```shell\nkamcmd cfg.seti sctp send_ttl 180000\n```\n\n```c\nsctp_send_ttl = milliseconds - n\n```\n",
  "sctp_send_retries": "### sctp_send_retries\n\nHow many times to attempt re-sending a message on a re-opened\nassociation, if the sctp stack did give up sending it (it's not related\nto sctp protocol level retransmission). Useful to improve reliability\nwith peers that reboot/restart or fail over to another machine.\n\nWARNING: use with care and low values (e.g. 1-3) to avoid \"multiplying\"\ntraffic to unresponding hosts (default: 0). Can be changed at runtime.\n\n```c\nsctp_send_retries = 1\n```\n",
  "sctp_assoc_tracking": "### sctp_assoc_tracking\n\nControls whether or not sctp associations are tracked inside Kamailio.\nTurning it off would result in less memory being used and slightly\nbetter performance, but it will also disable some other features that\ndepend on it (e.g. `sctp_assoc_reuse`). Default: yes.\n\nCan be changed at runtime (\"kamcmd sctp assoc_tracking 0\"), but changes\nwill be allowed only if all the other features that depend on it are\nturned off (for example it can be turned off only if first\n`sctp_assoc_reuse` was turned off).\n\nNote: turning `sctp_assoc_tracking` on/off will delete all the tracking\ninformation for all the currently tracked associations and might\nintroduce a small temporary delay in the sctp processing if lots of\nassociations were tracked.\n\nConfig options depending on `sctp_assoc_tracking` being on:\n`sctp_assoc_reuse`.\n\n```c\nsctp_assoc_tracking = yes/no\n```\n",
  "sctp_assoc_reuse": "### sctp_assoc_reuse\n\nControls sctp association reuse. For now only association reuse for\nreplies is affected by it. Default: `yes`. Depends on `sctp_assoc_tracking`\nbeing on.\n\nNote that even if turned off, if the port in via corresponds to the\nsource port of the association the request was sent on or if rport is\nturned on (`force_rport()` or via containing a rport option), the\nassociation will be automatically reused by the sctp stack. Can be\nchanged at runtime (sctp assoc_reuse), but it can be turned on only if\n`sctp_assoc_tracking` is on.\n\n```c\nsctp_assoc_reuse = yes/no\n```\n",
  "sctp_max_assocs": "### sctp_max_assocs\n\nMaximum number of allowed open sctp associations. -1 means maximum\nallowed by the OS. Default: -1. Can be changed at runtime (e.g.:\n`kamcmd cfg.seti sctp max_assocs 10`). When the maximum associations\nnumber is exceeded and a new associations is opened by a remote host,\nthe association will be immediately closed. However it is possible that\nsome SIP packets get through (especially if they are sent early, as part\nof the 4-way handshake).\n\nWhen Kamailio tries to open a new association and the max_assocs is\nexceeded the exact behaviour depends on whether or not\n`sctp_assoc_tracking` is on. If on, the send triggering the active open\nwill gracefully fail, before actually opening the new association and no\npacket will be sent. However if `sctp_assoc_tracking` is off, the\nassociation will first be opened and then immediately closed. In general\nthis means that the initial sip packet will be sent (as part of the\n4-way handshake).\n\n```c\nsctp_max_assocs = number\n```\n",
  "sctp_srto_initial": "### sctp_srto_initial\n\nInitial value of the retr. timeout, used in RTO calculations (default:\nOS specific).\n\nCan be changed at runtime (sctp `srto_initial`) but it will affect only\nnew associations.\n\n```c\nsctp_srto_initial = milliseconds\n```\n",
  "sctp_srto_max": "### sctp_srto_max\n\nMaximum value of the retransmission timeout (RTO) (default: OS\nspecific).\n\nWARNING: values lower than the sctp `sack_delay` will cause lots of\nretransmissions and connection instability (see sctp_srto_min for more\ndetails).\n\nCan be changed at runtime (sctp `srto_max`) but it will affect only new\nassociations.\n\n```c\nsctp_srto_max = milliseconds\n```\n",
  "sctp_srto_min": "### sctp_srto_min\n\nMinimum value of the retransmission timeout (RTO) (default: OS\nspecific).\n\nWARNING: values lower than the sctp `sack_delay` of any peer might cause\nretransmissions and possible interoperability problems. According to the\nstandard the `sack_delay` should be between 200 and 500 ms, so avoid\ntrying values lower than 500 ms unless you control all the possible sctp\npeers and you do make sure their `sack_delay` is higher or their sack_freq\nis 1.\n\nCan be changed at runtime (sctp `srto_min`) but it will affect only new\nassociations.\n\n```c\nsctp_srto_min = milliseconds\n```\n",
  "sctp_asocmaxrxt": "### sctp_asocmaxrxt\n\nMaximum retransmissions attempts per association (default: OS specific).\nIt should be set to `sctp_pathmaxrxt` `*` no. of expected paths.\n\nCan be changed at runtime (sctp asocmaxrxt) but it will affect only new\nassociations.\n\n```c\nsctp_asocmaxrxt   = number\n```\n",
  "sctp_init_max_attempts": "### sctp_init_max_attempts\n\nMaximum INIT retransmission attempts (default: OS specific).\n\nCan be changed at runtime (sctp init_max_attempts).\n\n```c\nsctp_init_max_attempts = number\n```\n",
  "sctp_init_max_timeo": "### sctp_init_max_timeo\n\nMaximum INIT retransmission timeout (RTO max for INIT). Default: OS\nspecific.\n\nCan be changed at runtime (sctp init_max_timeo).\n\n```c\nsctp_init_max_timeo = milliseconds\n```\n",
  "sctp_hbinterval": "### sctp_hbinterval\n\nsctp heartbeat interval. Setting it to -1 will disable the heartbeats.\nDefault: OS specific.\n\nCan be changed at runtime (sctp hbinterval) but it will affect only new\nassociations.\n\n```c\nsctp_hbinterval = milliseconds\n```\n",
  "sctp_pathmaxrxt": "### sctp_pathmaxrxt\n\nMaximum retransmission attempts per path (see also sctp_asocmaxrxt).\nDefault: OS specific.\n\nCan be changed at runtime (sctp pathmaxrxt) but it will affect only new\nassociations.\n\n```c\nsctp_pathmaxrxt = number\n```\n",
  "sctp_sack_delay": "### sctp_sack_delay\n\nDelay until an ACK is generated after receiving a packet. Default: OS\nspecific.\n\nWARNING: a value higher than srto_min can cause a lot of retransmissions\n(and strange problems). A value higher than srto_max will result in very\nhigh connections instability. According to the standard the `sack_delay`\nvalue should be between 200 and 500 ms.\n\nCan be changed at runtime (sctp `sack_delay`) but it will affect only new\nassociations.\n\n```c\nsctp_sack_delay = milliseconds\n```\n",
  "sctp_sack_freq": "### sctp_sack_freq\n\nNumber of packets received before an ACK is sent (without waiting for\nthe `sack_delay` to expire). Default: OS specific.\n\nNote: on linux with `lksctp` up to and including 1.0.9 is not possible to\nset this value (having it in the config will produce a warning on\nstartup).\n\nCan be changed at runtime (sctp `sack_freq`) but it will affect only new\nassociations.\n\n```c\nsctp_sack_freq = number\n```\n",
  "sctp_max_burst": "### sctp_max_burst\n\nMaximum burst of packets that can be emitted by an association. Default:\nOS specific.\n\nCan be changed at runtime (sctp `max_burst`) but it will affect only new\nassociations.\n\n```c\nsctp_max_burst = number\n```\n",
  "udp4_raw": "### udp4_raw\n\nEnables raw socket support for sending UDP IPv4 datagrams (40-50%\nperformance increase on linux multi-cpu).\n\nPossible values: `0` - disabled (default), `1` - enabled, `-1` auto.\n\nIn \"auto\" mode it will be enabled if possible (sr started as root or\nwith `CAP_NET_RAW`). `udp4_raw` can be used on Linux and FreeBSD. For other\nBSDs and Darwin one must compile with `-DUSE_RAW_SOCKS`. On Linux one\nshould also set `udp4_raw_mtu` if the MTU on any network interface that\ncould be used for sending is smaller than `1500`.\n\nThe parameter can be set at runtime as long as sr was started with\nenough privileges (`core.udp4_raw`).\n\n```c\nudp4_raw = on\n```\n",
  "udp4_raw_mtu": "### udp4_raw_mtu\n\nMTU value used for UDP IPv4 packets when udp4_raw is enabled. It should\nbe set to the minimum MTU of all the network interfaces that could be\nused for sending. The default value is 1500. Note that on BSDs it does\nnot need to be set (if set it will be ignored, the proper MTU will be\nused automatically by the kernel). On Linux it should be set.\n\nThe parameter can be set at runtime (`core.udp4_raw_mtu`).\n`\n",
  "udp4_raw_ttl": "### udp4_raw_ttl\n\nTTL value used for UDP IPv4 packets when udp4_raw is enabled. By default\nit is set to auto mode (`-1`), meaning that the same TTL will be used as\nfor normal UDP sockets.\n\nThe parameter can be set at runtime (`core.udp4_raw_ttl`).\n",
  "dst_blocklist_expire": "### dst_blocklist_expire\n\n**Alias name:** **dst_blocklist_ttl**\n\nHow much time a blocklisted destination will be kept in the blocklist\n(w/o any update).\n\n```c\ndst_blocklist_expire = time in s (default 60 s)\n```\n",
  "dst_blocklist_gc_interval": "### dst_blocklist_gc_interval\n\nHow often the garbage collection will run (eliminating old, expired\nentries).\n\n```c\ndst_blocklist_gc_interval = time in s (default 60 s)\n```\n",
  "dst_blocklist_init": "### dst_blocklist_init\n\nIf off, the blocklist is not initialized at startup and cannot be\nenabled at runtime, this saves some memory.\n\n```c\ndst_blocklist_init = on | off (default on)\n```\n",
  "dst_blocklist_mem": "### dst_blocklist_mem\n\nMaximum shared memory amount used for keeping the blocklisted\ndestinations.\n\n```c\ndst_blocklist_mem = size in Kb (default 250 Kb)\n```\n",
  "use_dst_blocklist": "### use_dst_blocklist\n\nEnable the destination blocklist: Each failed send attempt will cause\nthe destination to be added to the blocklist. Before any send, this\nblocklist will be checked and if a match is found, the send is no longer\nattempted (an error is returned immediately).\n\nNote: using the blocklist incurs a small performance penalty.\n\nSee also `doc/dst_blocklist.txt`.\n\n```c\nuse_dst_blocklist = on | off (default off)\n```\n",
  "real_time": "### real_time\n\nSets real time priority for all the Kamailio processes, or the timers\n(bitmask).\n\n```\n   Possible values:   0  - off\n                      1  - the \"fast\" timer\n                      2  - the \"slow\" timer\n                      4  - all processes, except the timers\n```\n\nExample: `real_time= 7` => everything switched to real time priority.\n\n```c\nreal_time = <int> (flags) (default off)\n```\n",
  "rt_policy": "### rt_policy\n\nReal time scheduling policy, `0 = SCHED_OTHER`, `1= SCHED_RR` and\n`2=SCHED_FIFO`\n\n```c\nrt_policy= <0..3> (default 0)\n```\n",
  "rt_prio": "### rt_prio\n\nReal time priority used for everything except the timers, if `real_time`\nis enabled.\n\n```c\nrt_prio = <int> (default 0)\n```\n",
  "rt_timer1_policy": "### rt_timer1_policy\n\n**Alias name:** **rt_ftimer_policy**\n\nLike `rt_policy` but for the \"fast\" timer.\n\n```c\nrt_timer1_policy=<0..3> (default 0)\n```\n",
  "rt_timer1_prio": "### rt_timer1_prio\n\n**Alias name:** **rt_fast_timer_prio, rt_ftimer_prio**\n\nLike `rt_prio` but for the \"fast\" timer process (if `real_time &amp; 1`).\n\n```c\nrt_timer1_prio=<int> (default 0)\n```\n",
  "rt_timer2_policy": "### rt_timer2_policy\n\n**Alias name:** **rt_stimer_policy**\n\nLike `rt_policy` but for the \"slow\" timer.\n\n```c\nrt_timer2_policy=<0..3> (default 0)\n```\n",
  "rt_timer2_prio": "### rt_timer2_prio\n\n**Alias name:** **rt_stimer_prio**\n\nLike `rt_prio` but for the \"slow\" timer.\n\n```c\nrt_timer2_prio=<int> (default 0)\n```\n"
 },
 "functions": {
  "add_local_rport": "### add_local_rport\n\nAdd **rport** parameter to local generated Via header -- see RFC3581. In\neffect for forwarded SIP requests.\n\nExample of usage:\n\n```c\nadd_local_rport();\n```\n",
  "avpflags": "### avpflags\n",
  "break": "### break\n\n'break' statement can be used to end a 'case' block in a 'switch'\nstatement or exit from a 'while' statement.\n",
  "drop": "### drop\n\nStop the execution of the configuration script and alter the implicit\naction which is done afterwards.\n\nIf the function is called in a 'branch_route' then the branch is\ndiscarded (implicit action for 'branch_route' is to forward the\nrequest).\n\nIf the function is called in the default 'onreply_route' then you can\ndrop any response. If the function is called in a named 'onreply_route'\n(transaction stateful) then any provisional reply is discarded.\n(Implicit action for 'onreply_route' is to send the reply upstream\naccording to Via header.)\n\nExample of usage:\n\n```c\nonreply_route {\n    if(status==\"200\") {\n        drop(); # this works\n    }\n}\n\nonreply_route[FOOBAR] {\n    if(status==\"200\") {\n        drop(); # this is ignored\n    }\n}\n```\n",
  "exit": "### exit\n\nStop the execution of the configuration script -- it has the same\nbehaviour as return(0). It does not affect the implicit action to be\ntaken after script execution.\n\n```c\nrequest_route {\n    if (route(ABC)) {\n    xlog(\"L_NOTICE\",\"method $rm is INVITE\\n\");\n    } else {\n    xlog(\"L_NOTICE\",\"method is $rm\\n\");\n    }\n}\n\nroute[ABC] {\n    if (is_method(\"INVITE\")) {\n    return(1);\n    } else if (is_method(\"REGISTER\")) {\n    return(-1);\n    } else if (is_method(\"MESSAGE\")) {\n    sl_send_reply(\"403\",\"IM not allowed\");\n    exit;\n    }\n}\n```\n",
  "error": "### error\n\n```c\nerror(\"p1\", \"p2\");\n```\n\nNot properly implemented yet - prints a log messages with the two string parameters.\n",
  "exec": "### exec\n\nBasic implementation of executing an external application with C `system()`\nfunction. Look also at the functions exported by `exec` module.\n\n```c\nexec(\"/path/to/app\");\n```\n",
  "force_rport": "### force_rport\n\nThe `force_rport()` adds the rport parameter to the first Via header of the\nreceived message. Thus, Kamailio will add the received port to the top\nmost Via header in the SIP message, even if the client does not indicate\nsupport for rport. This enables subsequent SIP messages to return to the\nproper port later on in a SIP transaction.\n\nThis is useful for NAT traversal, to enforce symmetric response\nsignaling.\n\nThe rport parameter is defined in RFC 3581.\n\nNote: there is also a force_rport parameter which changes the global\nbehavior of the SIP proxy.\n\nExample of usage:\n\n```c\nforce_rport();\n```\n",
  "add_rport": "### add_rport\n\nAlias for force_rport();\n",
  "force_send_socket": "### force_send_socket\n\nForce to send the message from the specified socket (it **must** be one\nof the sockets specified with the `listen` directive). If the protocol\ndoesn't match (e.g. UDP message \"forced\" to a TCP socket) the closest\nsocket of the same protocol is used.\n\nThis function does not support pseudo-variables, use the `set_send_socket()`\nfunction from the corex module instead.\n\nExample of usage:\n\n```c\nforce_send_socket(10.10.10.10:5060);\nforce_send_socket(udp:10.10.10.10:5060);\n```\n",
  "force_tcp_alias": "### force_tcp_alias\n\n**Alias name:** **add_tcp_alias**\n\n`force_tcp_alias(port)`\n\nadds a tcp port alias for the current connection (if tcp). Useful if you\nwant to send all the traffic to port_alias through the same connection\nthis request came from (it could help for firewall or nat traversal).\nWith no parameters adds the port from the message via as the alias. When\nthe \"aliased\" connection is closed (e.g. it's idle for too much time),\nall the port aliases are removed.\n",
  "forward": "### forward\n\nForward in stateless mode the SIP request to destination address set in `$du`\nor `$ru`.\n\nExample of usage:\n\n```c\n$du = \"sip:10.0.0.10:5060;transport=tcp\";\nforward();\n```\n",
  "isavpflagset": "### isavpflagset\n",
  "isflagset": "### isflagset\n\nTest if a flag is set for current processed message (if the flag value\nis 1). The value of the parameter can be in range of 0..31.\n\nFor more see:\n\n- [Kamailio - Flag Operations](../../tutorials/kamailio-flag-operations.md)\n\nExample of usage:\n\n```c\nif(isflagset(3)) {\n    log(\"flag 3 is set\\n\");\n};\n```\n\nKamailio also supports named flags. They have to be declared at the\nbeginning of the config file with:\n\n```\n flags  flag1_name[:position],  flag2_name ...\n```\n\nExample:\n\n```c\nflags test, a:1, b:2 ;\nrequest_route {\n    setflag(test);\n    if (isflagset(a)){ # equiv. to isflagset(1)\n        ....\n    }\n    resetflag(b);  # equiv. to resetflag(2)\n```\n",
  "is_int": "### is_int\n\nChecks if a pseudo variable argument contains integer value.\n\n```c\nif(is_int(\"$avp(foobar)\")) {\n    log(\"foobar contains an integer\\n\");\n}\n```\n",
  "log": "### log\n\nWrite text message to standard error terminal or syslog. You can specify\nthe log level (the integer id) as first parameter.\n\nThe parameters are static values. If you want dynamic parameters with\nvariables, look at `xlog` module.\n\nFor more see:\n\n- <https://www.kamailio.org/dokuwiki/doku.php/tutorials:debug-syslog-messages>\n\nExample of usage:\n\n```c\nlog(\"just some text message\\n\");\nlog(1, \"another text message\\n\");\n```\n",
  "prefix": "### prefix\n\nAdd the string parameter in front of username in R-URI.\n\nExample of usage:\n\n```c\nprefix(\"00\");\n```\n",
  "resetavpflag": "### resetavpflag\n",
  "resetflag": "### resetflag\n",
  "return": "### return\n\nThe return() function allows you to return any integer value from a\ncalled route() block. You can test the value returned by a route using\n`$retcode` variable (which is same as `$rc` or `$?`).\n\n`return(0)` is same as [`exit()`](#exit);\n\nIn logical evaluation expressions:\n\n- Negative is FALSE\n- Positive is TRUE\n\nIf no value is specified, or a route reaches its end without executing a\nreturn statement, it returns 1. If return is used in the top level route\nis equivalent with exit `[val]`.\n\nExample usage:\n\n```c\nrequest_route {\n    if (route(RET)) {\n    xlog(\"L_NOTICE\",\"method $rm is INVITE\\n\");\n    } else {\n    xlog(\"L_NOTICE\",\"method $rm is REGISTER\\n\");\n    };\n}\n\nroute[RET] {\n    if (is_method(\"INVITE\")) {\n    return(1);\n    } else if (is_method(\"REGISTER\")) {\n    return(-1);\n    } else {\n    return(0);\n    };\n}\n```\n\nIMPORTANT: do not compare route block or module function execution in a condition\nwith the value of the return code. Next example is showing a wrong use:\n\n```c\nrequest_route {\n    if (route(RET) == -2) {\n    xinfo(\"return is -2\\n\");\n    } else {\n    xinfo(\"return is not -2\\n\"); ### THIS IS GOING TO BE EXECUTED\n    }\n}\n\nroute[RET] {\n    return -2;\n}\n```\n\nSee also the FAQ for how the function return code is evaluated:\n\n- [Frequently Asked Questions](../tutorials/../../tutorials/faq/main.md#how-is-the-function-return-code-evaluated)\n\nNote: starting with version `5.7.0-dev`, this behaviour can be changed with\n`return_mode` global parameter.\n",
  "return_mode": "### return_mode\n\nControl the return code evaluation mode:\n\n- 0 (default) - evaluation is like so far (negative is false, positive is true)\n- 1 - propagate return value and evaluation has to be done with `&gt;0` or `&lt;0`, otherwise\n  `value!=0` is evaluated to true no matter is negative or positive\n",
  "revert_uri": "### revert_uri\n\nSet the R-URI to the value of the R-URI as it was when the request was\nreceived by server (undo all changes of R-URI).\n\nExample of usage:\n\n```\n  revert_uri();\n```\n",
  "rewritehostport": "### rewritehostport\n\n**Alias name:** **sethostport, sethp**\n\nRewrite the domain part and port of the R-URI with the value of\nfunction's parameter. Other parts of the R-URI like username and URI\nparameters remain unchanged.\n\nExample of usage:\n\n```\n  rewritehostport(\"1.2.3.4:5080\");\n```\n",
  "rewritehostporttrans": "### rewritehostporttrans\n\n**Alias name:** **sethostporttrans, sethpt**\n\nRewrite the domain part and port of the R-URI with the value of\nfunction's parameter. Also allows to specify the transport parameter.\nOther parts of the R-URI like username and URI parameters remain\nunchanged.\n\nExample of usage:\n\n```\n  rewritehostporttrans(\"1.2.3.4:5080\");\n```\n",
  "rewritehost": "### rewritehost\n\n**Alias name:** **sethost, seth**\n\nRewrite the domain part of the R-URI with the value of function's\nparameter. Other parts of the R-URI like username, port and URI\nparameters remain unchanged.\n\nExample of usage:\n\n```\n  rewritehost(\"1.2.3.4\");\n```\n",
  "rewriteport": "### rewriteport\n\n**Alias name:** **setport, setp**\n\nRewrites/sets the port part of the R-URI with the value of function's\nparameter.\n\nExample of usage:\n\n```\n  rewriteport(\"5070\");\n```\n",
  "rewriteuri": "### rewriteuri\n\n**Alias name:** **seturi**\n\nRewrite the request URI.\n\nExample of usage:\n\n```\n  rewriteuri(\"sip:test@kamailio.org\");\n```\n",
  "rewriteuserpass": "### rewriteuserpass\n\n**Alias name:** **setuserpass, setup**\n\nRewrite the password part of the R-URI with the value of function's\nparameter.\n\nExample of usage:\n\n```\n  rewriteuserpass(\"my_secret_passwd\");\n```\n",
  "rewriteuser": "### rewriteuser\n\n**Alias name:** **setuser, setu**\n\nRewrite the user part of the R-URI with the value of function's\nparameter.\n\nExample of usage:\n\n```\n  rewriteuser(\"newuser\");\n```\n",
  "route": "### route\n\nExecute route block given in parameter. Parameter may be name of the\nblock or a string valued expression.\n\nExamples of usage:\n\n```\n  route(REGISTER_REQUEST);\n  route(@received.proto + \"_proto_\" + $var(route_set));\n```\n",
  "selval": "### selval\n\nSelect a value based on conditional expression.\n\nPrototype:\n\n```c\nselval(evalexpr, valexp1, valexpr2)\n```\n\nThis is a core statement that return the 2nd parameter if the 1st\nparameter is evaluated to true, or 3rd parameter if the 1st parameter is\nevaluated to false. It can be considered a core function that is\nequivalent of ternary condition/operator\n\nExample:\n\n```c\n$var(x) = selval($Ts mod 2, \"true/\" + $ru, \"false/\" + $rd);\n```\n\nThe first parameter is a conditional expression, like those used for IF,\nthe 2nd and 3rd parameters can be expressions like those used in the\nright side of assignments.\n",
  "set_advertised_address": "### set_advertised_address\n\nSame as `advertised_address` but it affects only the current message. It\nhas priority if `advertised_address` is also set.\n\nExample of usage:\n\n```\n  set_advertised_address(\"kamailio.org\");\n```\n",
  "set_advertised_port": "### set_advertised_port\n\nSame as `advertised_port` but it affects only the current message. It\nhas priority over `advertised_port`.\n\nExample of usage:\n\n```\n  set_advertised_port(5080);\n```\n",
  "set_forward_no_connect": "### set_forward_no_connect\n\nThe message will be forwarded only if there is already an existing\nconnection to the destination. It applies only to connection oriented\nprotocols like TCP and TLS (TODO: SCTP), for UDP it will be ignored. The\nbehavior depends in which route block the function is called:\n\n- normal request route: affects stateless forwards and tm. For tm it\n  affects all the branches and the possible retransmissions (in fact\n  there are no retransmission for TCP/TLS).\n\n<!-- -->\n\n\n- `onreply_route[0]` (stateless): equivalent to `set_reply_*()` (it's\n  better to use `set_reply_*` though)\n\n<!-- -->\n\n\n- `onreply_route[!=0]` (tm): ignored\n\n<!-- -->\n\n\n- branch_route: affects the current branch only (all messages sent on\n  this branch, like possible retransmissions and CANCELs).\n\n<!-- -->\n\n\n- onsend_route: like branch route\n\nExample of usage:\n\n```\n  route {\n    ...\n    if (lookup()) {\n      //requests to local users. They are usually behind NAT so it does not make sense to try\n      //to establish a new TCP connection\n      set_forward_no_connect();\n      t_relay();\n    }\n    ...\n  }\n```\n",
  "set_forward_close": "### set_forward_close\n\nTry to close the connection (the one on which the message is sent out)\nafter forwarding the current message. Can be used in same route blocks\nas `set_forward_no_connect()`.\n\nNote: Use with care as you might not receive the replies anymore as the\nconnection is closed.\n",
  "set_reply_no_connect": "### set_reply_no_connect\n\nLike `set_forward_no_connect()`, but for replies to the current message\n(local generated replies and replies forwarded by tm). The behavior\ndepends in which route block the function is called:\n\n- normal request route: affects all replies sent back on the\n  transaction (either local or forwarded) and all local stateless\n  replies (`sl_reply()`).\n\n<!-- -->\n\n\n- `onreply_route`: affects the current reply (so the send_flags set in\n  the `onreply_route` will be used if the reply for which they were set\n  is the winning final reply or it's a provisional reply that is\n  forwarded)\n\n<!-- -->\n\n\n- branch_route: ignored.\n\n<!-- -->\n\n\n- onsend_route: ignored\n\nExample of usage:\n\n```\n  route[4] {\n    //requests from local users. There are usually behind NAT so it does not make sense to try\n    //to establish a new TCP connection for the replies\n    set_reply_no_connect();\n    // do authentication and call routing\n    ...\n  }\n```\n",
  "set_reply_close": "### set_reply_close\n\nLike `set_reply_no_connect`, but closes the TCP connection after sending.\nCan be used in same route blocks as `set_reply_no_connect`.\n\nExample of usage:\n\n```\n  route {\n    ...\n    if (...caller-is-not-registered...) {\n      // reject unregistered client\n      // if request was received via TCP/TLS close the connection, as\n      // this may trigger re-registration of the client.\n      set_reply_close();\n      sl_send_reply(\"403\",\"REGISTER first\");\n      exit;\n    }\n    ...\n  }\n```\n",
  "setavpflag": "### setavpflag\n",
  "setflag": "### setflag\n\nSet a flag for current processed message. The value of the parameter can\nbe in range of 0..31. The flags are used to mark the message for special\nprocessing (e.g., accounting) or to keep some state (e.g., message\nauthenticated).\n\nFor more see:\n\n- [Kamailio - Flag Operations](../../tutorials/kamailio-flag-operations.md)\n\nExample of usage:\n\n```\n  setflag(3);\n```\n",
  "strip": "### strip\n\nStrip the first N-th characters from username of R-URI (N is the value\nof the parameter).\n\nExample of usage:\n\n```\n  strip(3);\n```\n",
  "strip_tail": "### strip_tail\n\nStrip the last N-th characters from username of R-URI (N is the value of\nthe parameter).\n\nExample of usage:\n\n```\nstrip_tail(3);\n```\n",
  "udp_mtu_try_proto": "### udp_mtu_try_proto(proto)\n\n- proto - `TCP|TLS|SCTP|UDP` - like `udp_mtu_try_proto` global\n  parameter but works on a per packet basis and not globally.\n\nExample:\n\n```\nif($rd==\"10.10.10.10\")\n    udp_mtu_try_proto(SCTP);\n```\n",
  "userphone": "### userphone\n\nAdd \"user=phone\" parameter to R-URI.\n"
 },
 "keywords": {
  "af": "### af\n\nThe address family of the received SIP message. It is INET if the\nmessage was received over IPv4 or INET6 if the message was received over\nIPv6.\n\nExampe of usage:\n\n```c\n    if (af==INET6) {\n        log(\"Message received over IPv6 link\\n\");\n    }\n```\n",
  "dst_ip": "### dst_ip\n\nThe IP of the local interface where the SIP message was received. When\nthe proxy listens on many network interfaces, makes possible to detect\nwhich was the one that received the packet.\n\nExample of usage:\n\n```c\n   if(dst_ip==127.0.0.1) {\n      log(\"message received on loopback interface\\n\");\n   };\n```\n",
  "dst_port": "### dst_port\n\nThe local port where the SIP packet was received. When Kamailio is\nlistening on many ports, it is useful to learn which was the one that\nreceived the SIP packet.\n\nExample of usage:\n\n```c\n   if(dst_port==5061)\n   {\n       log(\"message was received on port 5061\\n\");\n   };\n```\n",
  "from_uri": "### from_uri\n\nThis script variable is a reference to the URI of 'From' header. It can\nbe used to test 'From'- header URI value.\n\nExample of usage:\n\n```c\n    if(is_method(\"INVITE\") && from_uri=~\".*@kamailio.org\")\n    {\n        log(\"the caller is from kamailio.org\\n\");\n    };\n```\n",
  "method": "### method\n\nThe variable is a reference to the SIP method of the message.\n\nExample of usage:\n\n```c\n    if(method==\"REGISTER\")\n    {\n       log(\"this SIP request is a REGISTER message\\n\");\n    };\n```\n",
  "msg": "### msg:len\n\nThe variable is a reference to the size of the message. It can be used\nin 'if' constructs to test message's size.\n\nExample of usage:\n\n```c\n    if(msg:len>2048)\n    {\n        sl_send_reply(\"413\", \"message too large\");\n        exit;\n    };\n```\n\n.\n",
  "proto": "### proto\n\nThis variable can be used to test the transport protocol of the SIP\nmessage.\n\nExample of usage:\n\n```c\n    if(proto==UDP)\n    {\n        log(\"SIP message received over UDP\\n\");\n    };\n```\n",
  "status": "### status\n\nIf used in onreply_route, this variable is a referece to the status code\nof the reply. If it used in a standard route block, the variable is a\nreference to the status of the last reply sent out for the current\nrequest.\n\nExample of usage:\n\n```c\n    if(status==\"200\")\n    {\n        log(\"this is a 200 OK reply\\n\");\n    };\n```\n",
  "snd_af": "### snd_af\n",
  "snd_ip": "### snd_ip\n",
  "snd_port": "### snd_port\n",
  "snd_proto": "### snd_proto\n",
  "src_ip": "### src_ip\n\nReference to source IP address of the SIP message.\n\nExample of usage:\n\n```c\n    if(src_ip==127.0.0.1)\n    {\n        log(\"the message was sent from localhost!\\n\");\n    };\n```\n",
  "src_port": "### src_port\n\nReference to source port of the SIP message (from which port the message\nwas sent by previous hop).\n\nExample of usage:\n\n```c\n    if(src_port==5061)\n    {\n        log(\"message sent from port 5061\\n\");\n    }\n```\n",
  "to_ip": "### to_ip\n",
  "to_port": "### to_port\n",
  "to_uri": "### to_uri\n\nThis variable can be used to test the value of URI from To header.\n\nExample of usage:\n\n```c\n  if(to_uri=~\"sip:.+@kamailio.org\")\n  {\n      log(\"this is a request for kamailio.org users\\n\");\n  };\n```\n",
  "uri": "### uri\n\nThis variable can be used to test the value of the request URI.\n\nExample of usage:\n\n```c\n    if(uri=~\"sip:.+@kamailio.org\")\n    {\n        log(\"this is a request for kamailio.org users\\n\");\n    };\n```\n",
  "INET": "### INET\n\nVariant: `IPv4`\n\nThis keyword can be used to test whether the SIP packet was received\nover an IPv4 connection.\n\nExample of usage:\n\n```c\n    if (af==INET) {\n        log(\"the SIP message was received over IPv4\\n\");\n    }\n```\n",
  "INET6": "### INET6\n\nVariant: `IPv6`\n\nThis keyword can be used to test whether the SIP packet was received\nover an IPv6 connection.\n\nExample of usage:\n\n```c\n  if(af==INET6)\n  {\n      log(\"the SIP message was received over IPv6\\n\");\n  };\n```\n",
  "SCTP": "### SCTP\n\nThis keyword can be used to test the value of 'proto' and check whether\nthe SIP packet was received over SCTP or not.\n\nExample of usage:\n\n```c\n  if(proto==SCTP)\n  {\n      log(\"the SIP message was received over SCTP\\n\");\n  };\n```\n",
  "TCP": "### TCP\n\nThis keyword can be used to test the value of 'proto' and check whether\nthe SIP packet was received over TCP or not.\n\nExample of usage:\n\n```c\n  if(proto==TCP)\n  {\n      log(\"the SIP message was received over TCP\\n\");\n  };\n```\n",
  "TLS": "### TLS\n\nThis keyword can be used to test the value of 'proto' and check whether\nthe SIP packet was received over TLS or not.\n\nExample of usage:\n\n```c\n  if(proto==TLS)\n  {\n      log(\"the SIP message was received over TLS\\n\");\n  };\n```\n",
  "UDP": "### UDP\n\nThis keyword can be used to test the value of 'proto' and check whether\nthe SIP packet was received over UDP or not.\n\nExample of usage:\n\n```c\n  if(proto==UDP)\n  {\n      log(\"the SIP message was received over UDP\\n\");\n  };\n```\n",
  "WS": "### WS\n\nThis keyword can be used to test the value of 'proto' and check whether\nthe SIP packet was received over WS or not.\n\nExample of usage:\n\n```c\n  if(proto==WS)\n  {\n      log(\"the SIP message was received over WS\\n\");\n  };\n```\n",
  "WSS": "### WSS\n\nThis keyword can be used to test the value of 'proto' and check whether\nthe SIP packet was received over WSS or not.\n\nExample of usage:\n\n```c\n  if(proto==WSS)\n  {\n      log(\"the SIP message was received over WSS\\n\");\n  };\n```\n",
  "max_len": "### max_len\n\nNote: This command was removed.\n",
  "myself": "### myself\n\nThis is a reference to the list of local IP addresses, hostnames and\naliases that has been set in the Kamailio configuration file. This lists\ncontain the domains served by Kamailio.\n\nThe variable can be used to test if the host part of an URI is in the\nlist. The usefulness of this test is to select the messages that has to\nbe processed locally or has to be forwarded to another server.\n\nSee \"alias\" to add hostnames, IP addresses and aliases to the list.\n\nExample of usage:\n\n```c\n    if(uri==myself) {\n        log(\"the request is for local processing\\n\");\n    };\n```\n\nNote: You can also use the is_myself() function.\n",
  "request_route": "### request_route\n\nRequest routing block - is executed for each SIP request.\n\nIt contains a set of actions to be executed for SIP requests received\nfrom the network. It is the equivalent of `main()` function for\nhandling the SIP requests.\n\n\ud83d\udd25**IMPORTANT**: For backward compatibility reasons, the main request\n`route` block can be identified by `route{...}` or\n`route[0]{...}`'.\n\nThe implicit action after execution of the main route block is to drop\nthe SIP request. To send a reply or forward the request, explicit\nactions (e.g., sl_send_reply(), forward(), t_relay()) must be called\ninside the route block.\n\nExample of usage:\n\n```c\n    request_route {\n         if(is_method(\"OPTIONS\")) {\n            # send reply for each options request\n            sl_send_reply(\"200\", \"ok\");\n            exit();\n         }\n         route(FWD);\n    }\n    route[FWD] {\n         # forward according to uri\n         forward();\n    }\n```\n",
  "route": "### route\n\nThis block is used to define 'sub-routes' - group of actions that can be\nexecuted from another routing block. Originally targeted as being\nexecuted from 'request_route', it can be executed now from all the other\nblocks. Be sure you put there the actions valid for the root routing\nblock executing the sub-route.\n\nThe definition of the sub-route block follows the general rules, with a\nname in between square brackets and actions between curly braces. A\nsub-route can return an integer value back to the routing block that\nexecuted it. The return code can be retrieved via $rc variables.\n\nEvaluation of the return of a subroute is done with following rules:\n\n- negative value is evaluated as false\n- 0 - is interpreted as **exit**\n- positive value is evaluated as true\n\n```c\nrequest_route {\n  if(route(POSITIVE)) {\n    xlog(\"return number is positive\\n\");\n  }\n  if( ! route(NEGATIVE)) {\n    xlog(\"return number is negative\\n\");\n  }\n  if( route(ZERO)) {\n    xlog(\"this log message does not appear\\n\");\n  }\n}\n\nroute[POSITIVE] {\n  return 10;\n}\n\nroute[NEGATIVE] {\n  return -8;\n}\n\nroute[ZERO] {\n  return 0;\n}\n```\n\nA sub-route can execute another sub-route. There is a limit to the\nnumber of recursive levels, avoiding ending up in infinite loops -- see\n**max_recursive_level** global parameter.\n\nThe sub-route blocks allow to make the configuration file modular,\nsimplifying the logic and helping to avoid duplication of actions.\n",
  "branch_route": "### branch_route\n\nRequest's branch routing block. It contains a set of actions to be taken\nfor each branch of a SIP request. It is executed only by TM module after\nit was armed via `t_on_branch(&quot;branch_route_index&quot;)`.\n\nExample of usage:\n\n```c\n    request_route {\n        lookup(\"location\");\n        t_on_branch(\"OUT\");\n        if(!t_relay()) {\n            sl_send_reply(\"500\", \"relaying failed\");\n        }\n    }\n    branch_route[OUT] {\n        if(uri=~\"10\\.10\\.10\\.10\") {\n            # discard branches that go to 10.10.10.10\n            drop();\n        }\n    }\n```\n",
  "failure_route": "### failure_route\n\nFailed transaction routing block. It contains a set of actions to be\ntaken each transaction that received only negative replies (`&gt;=300`) for\nall branches. The `failure_route` is executed only by TM module after it\nwas armed via `t_on_failure(&quot;failure_route_index&quot;)`.\n\nNote that in `failure_route` is processed the request that initiated the\ntransaction, not the reply .\n\nExample of usage:\n\n```c\n    request_route {\n        lookup(\"location\");\n        t_on_failure(\"TOVOICEMAIL\");\n        if(!t_relay()) {\n            sl_send_reply(\"500\", \"relaying failed\");\n        }\n    }\n    failure_route[TOVOICEMAIL] {\n        if(is_method(\"INVITE\")) {\n             # call failed - relay to voice mail\n             t_relay_to_udp(\"voicemail.server.com\",\"5060\");\n        }\n    }\n```\n",
  "reply_route": "### reply_route\n\nMain SIP response (reply) handling block - it contains a set of actions\nto be executed for SIP replies. It is executed for all replies received\nfrom the network.\n\nIt does not have a name and it is executed by the core, before any other\nmodule handling the SIP reply. It is triggered only by SIP replies\nreceived on the network.\n\nThere is no network route that can be enforced for a SIP reply - it is\nsent based on Via header, according to SIP RFC3261 - therefore no\ndedicated actions for forwarding the reply must be used in this block.\n\nThis routing block is optional, if missing, the SIP reply is sent to the\naddress in 2nd Via header.\n\nOne can decide to drop a SIP reply by using **drop** action.\n\nExample:\n\n```c\nreply_route {\n  if(status==\"128\") {\n    drop;\n  }\n}\n```\n\n\ud83d\udd25**IMPORTANT**: Note: for backward compatibility reasons, the main `reply`\nrouting block can be also identified by `onreply_route {...}` or\n`onreply_route[0] {...}`.\n",
  "onreply_route": "### onreply_route\n\nSIP reply routing block executed by **tm** module. It contains a set of\nactions to be taken for SIP replies in the context of an active\ntransaction.\n\nThe `onreply_route` must be armed for the SIP requests whose replies\nshould be processed within it, via `t_on_reply`(\"`onreply_route_index`\").\n\nCore 'reply_route' block is executed before a possible **tm**\n'onreply_route' block.\n\n```c\n  request_route {\n      lookup(\"location\");\n      t_on_reply(\"LOGRPL\");\n      if(!t_relay()) {\n          sl_send_reply(\"500\", \"relaying failed\");\n      }\n  }\n\n  reply_route {\n      if(!t_check_trans()) {\n          drop;\n      }\n  }\n\n  onreply_route[LOGRPL] {\n      if(status=~\"1[0-9][0-9]\") {\n           log(\"provisional response\\n\");\n      }\n  }\n```\n",
  "onsend_route": "### onsend_route\n\nThe route is executed in when a SIP request is sent out. Only a limited\nnumber of commands are allowed (`drop`, `if` + all the checks, msg flag\nmanipulations, `send()`, `log()`, `textops::search()`).\n\nIn this route the final destination of the message is available and can\nbe checked (with `snd_ip`, `snd_port`, `to_ip`, `to_port`, `snd_proto`, `snd_af`).\n\nThis route is executed only when forwarding requests - it is not\nexecuted for replies, retransmissions, or locally generated messages\n(e.g. via fifo uac).\n\nExample:\n\n```c\n  onsend_route {\n    if(to_ip==1.2.3.4 && !isflagset(12)){\n      log(1, \"message blocked\\n\");\n      drop;\n    }\n  }\n```\n\n- snd_ip, snd_port - behave like src_ip/src_port, but contain the\n  ip/port Kamailio will use to send the message\n- to_ip, to_port - like above, but contain the ip/port the message\n  will be sent to (not to be confused with dst_ip/dst_port, which are\n  the destination of the original received request: Kamailio's ip and\n  port on which the message was received)\n- snd_proto, snd_af - behave like proto/af but contain the\n  protocol/address family that Kamailio will use to send the message\n- msg:len - when used in an onsend_route, msg:len will contain the\n  length of the message on the wire (after all the changes in the\n  script are applied, Vias are added a.s.o) and not the lentgh of the\n  original message.\n",
  "event_route": "### event_route\n\nGeneric type of route executed when specific events happen.\n\nPrototype: `event_route[groupid:eventid]`\n\n- groupid - should be the name of the module that triggers the event\n- eventid - some meaningful short text describing the event\n"
 },
 "pseudovariables": {
  "$$": "### $$ - Pseudo-variable marker\n\n`$$` - represents the character `$`\n",
  "$_s": "### $_s(format) - Evaluate dynamic format\n\n**$_s(format)** - returns the string after evaluating all\npseudo-variables in format\n\n```\n    $var(x) = \"sip:\" + $rU + \"@\" + $fd;\n\n    # is equivalent of:\n\n    $var(x) = $_s(sip:$rU@$fd);\n```\n",
  "ai": "### $ai - URI in P-Asserted-Identity header\n\n**$ai** - reference to URI in request's P-Asserted-Identity header (see\nRFC 3325)\n",
  "adu": "### $adu - Auth Digest URI\n\n**$adu** - URI from Authorization or Proxy-Authorization header. This\nURI is used when calculating the HTTP Digest Response.\n",
  "aa": "### $aa - Auth algorithm\n\n**$aa** - algorithm from Authorization or Proxy-Authorization header.\n",
  "ar": "### $ar - Auth realm\n\n**$ar** - realm from Authorization or Proxy-Authorization header\n",
  "au": "### $au - Auth username user\n\n**$au** - user part of username from Authorization or\nProxy-Authorization header\n",
  "ad": "### $ad - Auth username domain\n\n**$ad** - domain part of username from Authorization or\nProxy-Authorization header\n",
  "aU": "### $aU - Auth whole username\n\n**$aU** - whole username from Authorization or Proxy-Authorization\nheader\n",
  "Au": "### $Au - Acc username and realm/domain\n\n**$Au** - username for accounting purposes. It's a selective pseudo\nvariable (inherited from acc module). It returns the auth username and\nrealm ($au@$ar) if it exists or From URI ($fu) otherwise.\n",
  "AU": "### $AU - Acc username\n\n**$AU** - username for accounting purposes. It's a selective pseudo\nvariable (inherited from acc module). It returns the auth username ($au)\nif it exists or From user ($fU) otherwise.\n",
  "branch": "### $branch(name) - Branch attributes\n\n**$branch(name)** - reference to attribute 'name' of a branch\n\nThis pseudo variable gives you access to the \"additional branches\" only,\nnot to the \"main branch\". E.g. if there are 3 clients registered for the\nsame AoR, after lookup() you will have one contact in the \"main branch\"\nand two \"additional branches\". Using $branch() you can access the\nadditional branches, the main branch can be accessed using $ru and $du.\n(Note: In branch_routes there is no distinction between the main and the\nadditional branches - the branch_route will be called once for each one\nof them.)\n\nThe 'name' can be:\n\n- uri - return uri of the branch\n- dst_uri - return destination uri (next hop address)\n- path - return the path vector for the branch\n- q - return the q value of the branch as integer `0..100` (representing `q * 100`)\n- send_socket - return the socket to be used to send the branch\n- count - return the number of the branches\n- flags - return the branch flags value\n- ruid - return the ruid of the branch (Record internal Unique ID from\n  usrloc)\n\nThe PV can take an index to access a specific branch:\n$(branch(name)[index])\n\nExample:\n\n```c\n$var(i)=0;\nwhile($var(i)<$branch(count))\n{\n   xlog(\"$(branch(uri)[$var(i)])\\n\");\n   $var(i) = $var(i) + 1;\n}\n```\n\nStarting with 3.1.0, you can assign value per attribute. Index can be\nused to update a specific branch:\n\n```c\n$(branch(attr)[index]) = value;\n```\n\nIf index is missing, first branch is used. If index is -1 the last\nbranch is used.\n\nAssigning $null to uri attribute will drop the branch, for the rest of\nattributes will just set the value to null.\n\n```c\n$(branch(uri)[2]) = \"sip:test@kamailio.org;transport=sctp\";\n```\n",
  "br": "### $br - Request's first branch\n\n**$br** - reference to request's first branch\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file (will add a new branch).\n",
  "bR": "### $bR - Request's all branches\n\n**$bR** - reference to request's all branches\n",
  "bf": "### $bf - Branch flags\n\n**$bf** - reference to branch flags of branch 0 (RURI) - decimal output\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "bF": "### $bF - Branch flags\n\n**$bF** - reference to branch flags of branch 0 (RURI) - hexa output\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "bs": "### $bs - Body size\n\n**$bs** - body size\n",
  "ci": "### $ci - Call-Id\n\n**$ci** - reference to the value of call-id header\n",
  "cl": "### $cl - Content-Length\n\n**$cl** - reference to the value of content-length header\n",
  "cnt": "### $cnt(pv) - Count number of pvs\n\n**$cnt(avp)** - return the number of avps\n\n```c\nxlog(\"$$avp(x) found $cnt($avp(x)) times\\n\");\n```\n\n**$cnt(xavp)** - return the number of xavps\n\n```\n * $cnt($xavp(key[*])) : number of XAVPs \"key\".\n * $cnt($xavp(key[n]=>sub[*])) : number of children \"sub\" in XAVP \"key[n]\".\n * $cnt($xavp(key[*]=>sub[*])) : total number of children \"sub\" in all XAVPs \"key\".\n\n * $cnt($xavp(key[n])) : 1 or 0 (if this index exists or not).\n * $cnt($xavp(key[-n])) : same but with reverse indexing (-1 is the last index).\n\n * $cnt($xavp(key[*]=>sub[n])) : number of children \"sub[n]\" that exist in all XAPVs \"key\".\n\n * $cnt($xavp(key)) is the same as $cnt($xavp(key[*])).\n * $cnt($xavp(key=>sub)) is the same as $cnt($xavp(key[*]=>sub[*]))\n```\n",
  "conid": "### $conid - TCP Connection ID\n\n**$conid** - The TCP connection ID of the connection the current message\narrived on for TCP, TLS, WS, and WSS. Set to $null for SCTP and UDP.\n",
  "cs": "### $cs - CSeq Number\n\n**$cs** - reference to the sequence number in the CSeq header. The\nmethod in the CSeq header is identical to the request method, thus use\n$rm to get the method (works also for responses).\n",
  "csb": "### $csb - CSeq Header Body\n\n**$csb** - reference to the CSeq header body (number method).\n",
  "ct": "### $ct - Contact header\n\n**$ct** - reference to the value of contact header\n",
  "cT": "### $cT - Content-Type\n\n**$cT** - reference to the value of content-type header\n",
  "dd": "### $dd - Domain of destination URI\n\n**$dd** - reference to domain of destination uri (without port)\n",
  "def": "### $def(name) - Defined Value\n\n**$def(name)** - return a defined value.\n\nExample:\n\n```c\n#!define ABC xyz\n\nxlog(\"FLT_ACC: $def(ABC)\\n\");\n```\n",
  "defn": "### $defn(name) - Defined Value As Number\n\n**$defn(name)** - return a defined value as a signed integer.\n\nExample:\n\n```c\n#!define FLT_ACC 1\n\nxlog(\"FLT_ACC: $defn(FLT_ACC)\\n\");\n```\n",
  "di": "### $di - Diversion header URI\n\n**$di** - reference to Diversion header URI\n",
  "dip": "### $dip - Diversion \"privacy\" parameter\n\n**$dip** - reference to Diversion header \"privacy\" parameter value\n",
  "dir": "### $dir - Diversion \"reason\" parameter\n\n**$dir** - reference to Diversion header \"reason\" parameter value\n",
  "dic": "### $dic - Diversion \"counter\" parameter\n\n**$dic** - reference to Diversion header \"counter\" parameter value\n",
  "dp": "### $dp - Port of destination URI\n\n**$dp** - reference to port of destination uri\n",
  "dP": "### $dP - Transport protocol of destination URI\n\n**$dP** - reference to transport protocol of destination uri\n",
  "ds": "### $ds - Destination set\n\n**$ds** - reference to destination set\n",
  "du": "### $du - Destination URI\n\n**$du** - reference to destination uri\n\nIf loose_route() returns TRUE a destination uri is set according to the\nfirst Route header. $du is also set if lookup() function of 'registrar'\nmodule finds contact(s) behind NAT or if you use the path functionality.\nThe function handle_ruri_alias() from the nathelper module will also set\nit. You can set $du to any SIP URI.\n\n```\n sip:kamailio.org\n sip:pbx123.kamailio.org;transport=udp\n sip:[2001:DB8::33:2]:5980;transport=tls\n```\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\nTo reset $du:\n\n```\n$du = $null;\n```\n",
  "fd": "### $fd - From URI domain\n\n**$fd** - reference to domain in URI of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n",
  "fn": "### $fn - From display name\n\n**$fn** - reference to display name of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n",
  "fs": "### $fs - Forced Send Socket\n\n**$fs** - reference to the forced send socket for the SIP message (if\nany) in the form \"proto:ip:port\". It is the socket from where Kamailio\nis going to send out the message.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file). Transport proto can be omitted when assigning\nvalue, in which case it is taken from destination URI of the\nmessage.\n\nExample:\n\n```c\nlisten=udp:1.2.3.4:5060\n...\n$fs = \"udp:1.2.3.4:5060\";\n```\n",
  "fsn": "### $fsn - Forced Send Socket Name\n\n**$fsn** - reference to the name of the forced send socket for the SIP\nmessage. The name can be assigned to this variable to select a send\nsocket via its name.\n\n```c\nlisten=udp:1.2.3.4:5060 name \"s1\"\n...\n$fsn = \"s1\";\n...\n$fs = \"udp:1.2.3.4:5060\";\nxdbg(\"name for forced send socket: $fsn\\n\");\n```\n",
  "ft": "### $ft - From tag\n\n**$ft** - reference to tag parameter of 'From' header\n",
  "fti": "### $fti - Initial From tag\n\n**$fti** - reference to tag parameter of 'From' header as it was in the\ninitial request (e.g., initial INVITE).\n\nThe value From tag in the initial request can be in the To tag, if the\nrequest within the dialog is sent by the callee. This variable detects\nwho sent the request within the dialog and returns the proper value that\nwas in the From tag of the request initiating the dialog.\n\nIt is exported by **rr** module and has to be used after loose_route().\nThe append_fromtag parameter is required to be set to 1 in order to have\nthis variable returning the right value.\n",
  "fu": "### $fu - From URI\n\n**$fu** - reference to URI of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\nNote that changing the From: header may break backwards compatibility\nwith SIP 1.0 devices.\n",
  "fU": "### $fU - From URI username\n\n**$fU** - reference to username in URI of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\nNote that changing the From: header may break backwards compatibility\nwith SIP 1.0 devices.\n",
  "fUl": "### $fUl - From URI Username Length\n\n**$fUl** - length of the username in the From URI\n",
  "mb": "### $mb - SIP message buffer\n\n**$mb** - reference to SIP message buffer\n",
  "mbu": "### $mbu - updated SIP message buffer\n\n**$mbu** - reference to updated SIP message buffer, after applying\nchanges\n",
  "mf": "### $mf - Flags\n\n**$mf** - reference to message/transaction flags set for current SIP\nrequest\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "mF": "### $mF - Flags in hexadecimal\n\n**$mF** -reference to message/transaction flags set for current SIP\nrequest in hexa-decimal\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "mi": "### $mi - SIP message id\n\n**$mi** - reference to SIP message id\n",
  "ml": "### $ml - SIP message length\n\n**$ml** - reference to SIP message length\n",
  "mt": "### $mt - SIP Message Type\n\n**$mt** - returns 1 if the sip message is a request, returns 2 if the\nsip message is a reply\n",
  "od": "### $od - Domain original R-URI\n\n**$od** - reference to domain in request's original R-URI\n",
  "op": "### $op - Port in original R-URI\n\n**$op** - reference to port of original R-URI\n",
  "oP": "### $oP - Protocol of original R-URI\n\n**$oP** - reference to transport protocol of original R-URI\n",
  "ou": "### $ou - Original R-URI\n\n**$ou** - reference to request's original URI\n",
  "oU": "### $oU - Username in original R-URI\n\n**$oU** - reference to username in request's original URI\n",
  "oUl": "### $oUl - Original R-URI Username Length\n\n**$oUl** - the length of the username in the original R-URI\n",
  "pd": "### $pd - Domain in P-Preferred-Identity header URI\n\n**$pd** - reference to domain in request's P-Preferred-Identity header\nURI (see RFC 3325)\n",
  "pn": "### $pn - Display Name in P-Preferred-Identity header\n\n**$pn** - reference to Display Name in request's P-Preferred-Identity\nheader (see RFC 3325)\n",
  "pp": "### $pp - Process id\n\n**$pp** - reference to process id (pid)\n",
  "pr": "### $pr or $proto - Protocol of received message\n\n**$pr** or **$proto** - protocol of received message (udp, tcp, tls,\nsctp, ws, wss)\n",
  "prid": "### $prid - protocol id\n\n**$prid** - internal protocol id\n\n- 0 - NONE\n- 1 - UDP\n- 2 - TCP\n- 3 - TLS\n- 4 - SCTP\n- 5 - WS\n- 6 - WSS\n- 7 - OTHER\n",
  "pU": "### $pU - User in P-Preferred-Identity header URI\n\n**$pU** - reference to user in request's P-Preferred-Identity header URI\n(see RFC 3325)\n",
  "pu": "### $pu - URI in P-Preferred-Identity header\n\n**$pu** - reference to URI in request's P-Preferred-Identity header (see\nRFC 3325)\n",
  "rb": "### $rb - Body of request/reply\n\n**$rb** - reference to message body\n",
  "rc": "### $rc - Returned code\n\n**$rc** - reference to returned code by last invoked function\n\n**$retcode** - same as **$rc**\n\nNote that the value of $rc is overwritten by each new function call.\n\nExample of use:\n\n```c\n    lookup(\"location\");\n    $var(rc) = $rc;\n    if ($var(rc) < 0) {\n        t_newtran();\n        switch ($var(rc)) {\n            case -1:\n            case -3:\n                send_reply(\"404\", \"Not Found\");\n                exit;\n            case -2:\n                send_reply(\"405\", \"Method Not Allowed\");\n                exit;\n        }\n    }\n\n```\n",
  "rd": "### $rd - Domain in R-URI\n\n**$rd** - reference to domain in request's URI (without port) or to the\nNamespace Specific String of a URN (see RFC 2141)\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "rdir": "### $rdir(key) - Request Direction\n\n**$rdir(key)** - get the direction of the request within dialog.\n\nThe direction is 'downstream' if sent by the caller and 'upstream' if\nsent by callee.\n\nThe key can be:\n\n- id - the returned value is an integer: 1 - for direction downstream,\n  2 - for direction upstream\n- name - the returned value is a string: 'downstream' or 'upstream'\n\nExample:\n\n```c\nif($rdir(name)==\"upstream\") {\n  xlog(\"request was sent by callee\\n\");\n}\n```\n\nThe variable is exported by **rr** module and append_fromtag parameter\nmust be enabled. The variable has to be used after loose_route()\nfunction.\n",
  "re": "### $re - Remote-Party-ID header URI\n\n**$re** - reference to Remote-Party-ID header URI\n",
  "rm": "### $rm - SIP method\n\n**$rm** - reference to request's method. Works also for replies (by\nusing the CSeq header)\n",
  "rmid": "### $rmid - SIP Method ID\n\n**$rmid** - returns internal integer representation of SIP method type\n",
  "route_uri": "### $route_uri - URI in first Route header\n\n**$route_uri** - returns the string with URI field in the first Route\nheader\n",
  "rp": "### $rp - Port in R-URI\n\n**$rp** - reference to port of R-URI\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "rP": "### $rP - Protocol of R-URI\n\n**$rP** - reference to transport protocol of R-URI\n",
  "rr": "### $rr - SIP reply reason phrase\n\n**$rr** - reference to reply's reason phrase (the text after reply code)\n",
  "rs": "### $rs - SIP reply code\n\n**$rs** - reference to reply's status (status-code, response-code,\nreply-code)\n",
  "rt": "### $rt - Refer-to URI\n\n**$rt** - reference to URI of refer-to header\n",
  "ru": "### $ru - Request URI\n\n**$ru** - reference to request's URI (address in the first line of a SIP\nrequest)\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "rU": "### $rU - Username in R-URI\n\n**$rU** - reference to username in request's URI or to the Namespace\nIdentifier of a URN (see RFC 2141)\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "rUl": "### $rUl - R-URI Username Length\n\n**$rUl** - the length of the username in R-URI\n",
  "rv": "### $rv - SIP message version\n\n**$rv** - reference to SIP message (reply or request) version\n",
  "ruid": "### $ruid - Record internal Unique ID\n\n**$ruid** - the Record internal Unique ID for the location record\nselected by calling registrar:lookup()\n",
  "rz": "### $rz - URI Scheme of R-URI\n\n**$rz** - returns R-URI scheme, possible values: sip, sips, tel, tels\nand urn, R-URI scheme parsing error should be reflected by value: none\n",
  "RAi": "### $RAi - Received advertised IP address\n\n**$RAi** - reference to advertised IP address of the interface where the\nrequest has been received, or $Ri if no advertised address.\n",
  "RAp": "### $RAp - Received advertised port\n\n**$RAp** - reference to advertised port where the request has been\nreceived, or $Rp if no advertised port.\n",
  "Ri": "### $Ri - Received IP address\n\n**$Ri** - reference to IP address of the interface where the request has\nbeen received\n",
  "Rp": "### $Rp - Received port\n\n**$Rp** - reference to the port where the message was received\n",
  "Rn": "### $Rn - Received socket name\n\n**$Rn** - reference to the name of the socket where the message was\nreceived\n",
  "RAu": "### $RAu - Advertised socket URI\n\n**$RAu** - local socket where the SIP messages was received in URI\nformat, without transport parameter for UDP, using advertised address\nwhen available.\n",
  "RAut": "### $RAut - Advertised socket URI\n\n**$RAut** - local socket where the SIP messages was received in URI\nformat, always with transport parameter, using advertised address when\navailable.\n",
  "Ru": "### $Ru - Received socket URI\n\n**$Ru** - local socket where the SIP messages was received in URI\nformat, without transport parameter for UDP.\n",
  "Rut": "### $Rut - Received socket URI\n\n**$Rut** - local socket where the SIP messages was received in URI\nformat, always with transport parameter.\n",
  "sas": "### $sas - Source address in socket format\n\n**$sas** - get source address in socket format (proto:address:port).\n",
  "sbranch": "### $sbranch(attr) - Static Branch\n\n**$sbranch(attr)** - class of variables allowing to manage the values of\nattributes for static branch. The static branch is internal structure\nthat is used by the functions sbranch_push_ruri() and sbranch_append()\nfrom **pv** module, enabling more flexibility in updating the R-URI\n(first) branch attributes as well as extra branches (e.g., for parallel\nforking).\n\nThe **attr** can be any of the supported values for **$branch(attr)**\nclass of variables -- see above for proper details.\n\nExample of usage:\n\n```c\nsbranch_reset();\n$sbranch(uri) = \"sip:127.0.0.1:5080\";\n$sbranch(dst_uri) =  \"sip:127.0.0.1:5090\";\n$sbranch(path) =  \"sip:127.0.0.1:5090, sip:127.0.0.1:5094\";\n$sbranch(send_socket) =  \"udp:127.0.0.1:5060\";\nsbranch_set_ruri();\n```\n",
  "sf": "### $sf - Script flags\n\n**$sf** - reference to script flags - decimal output\n",
  "sF": "### $sF - Script flags\n\n**$sF** - reference to script flags - hexa output\n",
  "si": "### $si - Source IP address\n\n**$si** - reference to IP source address of the message - see also $siz\n",
  "sid": "### $sid - Server ID\n\n**$sid** - the value for server id (server_id parameter)\n",
  "siz": "### $siz - Source IP address\n\n**$siz** - reference to IP source address of the message, with enclosing\nsquare brackets for IPv6\n",
  "sp": "### $sp - Source port\n\n**$sp** - reference to the source port of the message\n",
  "stat": "### $stat(name) - Statistics\n\n**$stat(name)** - return the value of statistic item specified by 'name'\n",
  "su": "### $su - Source address as URI\n\n**$su** - returns the representation of source address (ip, port, proto)\nas SIP URI. If the proto is UDP, then it is not added (being the default\ntransport protocol).\n\nIts value looks like:\n\n```\n\"sip:ip:port\" -- if proto is UDP\n\"sip:ip:port;transport=proto\"  -- if proto is not UDP\n```\n\nNote that WS and WSS are both represented by transport=ws, conforming\nwith the IETF RFC for SIP over WebSocket.\n",
  "sut": "### $sut - Source address as full URI\n\n**$sut** - returns the representation of source address (ip, port,\nproto) as full SIP URI. The proto UDP is added also as transport\nparameter.\n\nIts value looks like:\n\n```\n\"sip:ip:port;transport=proto\"\n```\n",
  "td": "### $td - To URI Domain\n\n**$td** - reference to domain in URI of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n",
  "tn": "### $tn - To display name\n\n**$tn** - reference to display name of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n",
  "tt": "### $tt - To tag\n\n**$tt** - reference to tag parameter of 'To' header\n",
  "tti": "### $tti - Initial To tag\n\n**$tti** - reference to tag parameter of 'To' header as it was in the\nSIP response to the initial request (e.g., 200ok to the initial INVITE).\n\nThe value To tag in the initial transaction can be in the From tag, if\nthe request within the dialog is sent by the callee. This variable\ndetects who sent the request within the dialog and returns the proper\nvalue that was in the To tag of the transaction initiating the dialog.\n\nIt is exported by **rr** module and has to be used after loose_route().\nThe append_fromtag parameter is required to be set to 1 in order to have\nthis variable returning the right value.\n",
  "tu": "### $tu - To URI\n\n**$tu** - reference to URI of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n",
  "tU": "### $tU - To URI Username\n\n**$tU** - reference to username in URI of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n",
  "tUl": "### $tUl - To URI Username Length\n\n**$tUl** - the length of the username in To URI\n",
  "Tb": "### $Tb - Startup timestamp\n\n**$Tb** - reference to unix timestamp of the time at which kamailio was\nstarted (boot time)\n",
  "Tf": "### $Tf - String formatted time - cached\n\n**$Tf** - reference string formatted time\n\nNote: the system time is retrieved only once for each processed SIP\nmessage. Subsequent calls of $Tf for same SIP message will return same\nvalue.\n",
  "TF": "### $TF - String formatted time - current\n\n**$TF** - reference string formatted time\n\nNote: the system time is computed for each call of $TF. Subsequent calls\nof $TF for same SIP message may return different values.\n",
  "Ts": "### $Ts - Unix time stamp - cached\n\n**$Ts** - reference to unix time stamp\n\nNote: the system time is retrieved only once for each processed SIP\nmessage. Subsequent calls of $Ts for same SIP message will return same\nvalue.\n",
  "TS": "### $TS - Unix time stamp - current\n\n**$TS** - reference to unix time stamp\n\nNote: the system time is computed for each call of $TS. Subsequent calls\nof $TS for same SIP message may return different values.\n",
  "ua": "### $ua - User agent header\n\n**$ua** - reference to user agent header field\n",
  "version": "### $version() - version\n\n**$version(num)** - version as number\n\n**$version(full)** - full version string \"name version\narchitecture/platform\"\n\n**$version(hash)** - TBA\n",
  "env": "## $env(NAME) - environment variables\n\n**$env(NAME)** - value of the environment variable named NAME\n\nExample:\n\n```c\nxdbg(\"PATH environment variable:  $env(PATH)\\n\");\n```\n",
  "avp": "## $avp(id) - AVPs\n\n**$avp(id)** - the value of the AVP identified by 'id'.\n\n**$(avp(id)[N])** - represents the value of N-th AVP identified by\n'id'.\n\nThe 'id' can be:\n\n- \"[(s|i):]name\" - name is the id of an AVP; 's' and 'i' specifies\n  if the id is string or integer. If missing, it is considered to be\n  string.\n- \"name\" - the name is an AVP alias, or if the alias is not found, it\n  is a string name\n- pseudo variable - if value of pv is integer, id is integer, if\n  string, id is string\n\n$(avp(id)[0]) can be written in shorter form as $avp(id) and\n$avp(s:name) as $avp(name).\n\nAVPs are special variables that are attached to SIP transactions. It is\na list of pairs (name,value). Before the transaction is created, the AVP\nlist is attached to SIP request. Note that the AVP list works like a\nstack, last added value is retrieved first, and there can be many values\nfor same AVP name, an assignment to the same AVP name does not overwrite\nold value, it will add the new value in the list.\n\nTo delete the first AVP with name 'id' you have to assign to it '$null':\n\n```c\n$avp(id) = $null;\n```\n\nTo delete all the AVP with name 'id' you have to assign $null to the\nindex '*':\n\n```c\n$(avp(id)[*]) = $null;\n```\n\nTo overwrite the value of the AVP with name 'id' you have to assign the\nnew value to the index '*':\n\n```c\n$(avp(id)[*]) = newvalue;\n```\n\nThe value of an AVP can be integer or string. To assign a value as\nstring, it has to be enclosed in double quotes. To assign the value as\ninteger, it has to be a valid number given without quotes.\n\nExample of usage:\n\n```c\n$avp(x) = 1;  # assign of integer value\n$avp(x) = 2;\n$avp(y) = \"abc\"; # assign of string value\nif($(avp(x)[1])==1) {\n  ...\n}\n$(avp(x)[1]) = $null;\n```\n\nIt is R/W variable (you can assign values to it directly in\nconfiguration file).\n",
  "expires": "## $expires(key) - Expires Values\n\nReturn the min and max of expires value for current SIP message. Contact\nheaders are checked with higher priority, if no expires parameter there,\nthen Expires header is used\n\nIf none is found, $null is returned.\n\nPossible 'key' values:\n\n- $expires(min) - the minimum value for expires\n- $expires(max) - the maximum value for expires\n\nWhen there is only one expires value, then min and max return the same.\n\nExample of usage:\n\n```c\nif($expires(max)!=$null) {\n    xlog(\"max expires value is: $expires(max)\\n\");\n}\n```\n",
  "xavp": "## $xavp(id) - XAVPs\n\n**xavp** - eXtended AVPs - are variables that can store multiple values,\nwhich can also be grouped in a structure-like fashion. Their value can\nbe a string, an integer number or a list of named values (child values).\n\nThey work like a stack, similar to AVPs, and are attached to SIP\ntransactions and automatically destroyed when the transaction is\nfinished.\n\nEach xavp has a string name and can contain a string, an integer or a\nlist of named values. The structure name (or root list name) and the\nvalue name (or field name, or child value name) are separated by => like\n$xavp(root=>field) where \"root\" is the name of the structure and \"field\"\nis the name of the (child) value.\n\nTo assign a single value use:\n\n```c\n$xavp(root)=\"string value\";\n$xavp(root)=intnumber;\n```\n\nTo assign a named value use:\n\n```c\n$xavp(root=>field)=\"string value\";\n$xavp(root=>field)=intnumber;\n```\n\nLike avps, xavp act like a stack. To refer to an existing value, use an\nindex. The newest xavp has index zero [0].\n\n```c\n$xavp(root[0]=>field)=12;\n```\n\nIf you assign a value without an index, a new xavp is allocated and the\nold one is pushed up the stack, becoming index [1]. Old index [1]\nbecomes [2] etc.\n\n```c\n# new item (person => [(lastname = \"Smith\")])\n$xavp(person=>lastname)=\"Smith\";\n\n# add new item (person => [(lastname = \"Doe\")])\n$xavp(person=>lastname)=\"Doe\";\n\n# add another named value to the last example item\n#   (person => [(firstname=\"John\"), (lastname = \"Doe\")])\n$xavp(person[0]=>firstname)=\"John\";\n\n# add another named value to first example item\n#   (person => [(firstname=\"Alice\"), (lastname = \"Smith\")])\nxavp(person[1]=>firstname)=\"Alice\";\n```\n\nAnother example:\n\n```c\n# create new (the first) root xavp with a named value of string type\n$xavp(sf=>uri)=\"sip:10.10.10.10\";\n\n# add named values (child values)\n$xavp(sf[0]=>fr_timer)=10;\n$xavp(sf[0]=>fr_inv_timer)=15;\n$xavp(sf[0]=>headers)=\"X-CustomerID: 1234\\r\\n\";\n\n# create new (the second) root xavp with a named value of string type, moving previous one to sf[1]\n$xavp(sf=>uri)=\"sip:10.10.10.11\";\n# add named values (child values)\n$xavp(sf[0]=>fr_timer)=20;\n$xavp(sf[0]=>fr_inv_timer)=35;\n\n# create new (the third) xavp with a named value of string type, moving previous one to sf[1] and the other one to sf[2]\n$xavp(sf=>uri)=\"sip:10.10.10.12\";\n# add named values (child values)\n$xavp(sf[0]=>fr_timer)=10;\n$xavp(sf[0]=>fr_inv_timer)=15;\n$xavp(sf[0]=>headers)=\"X-CustomerID: pw45\\r\\n\";\n```\n\nxavps are read and write variables.\n",
  "xavu": "## $xavu(id) - XAVUs\n\nSimilar to XAVPs, but with single value items, therefore there are no\nindexes in the naming format. XAVUs are also stored in transaction\ncontext and destroyed when the transaction is terminated.\n\nExamples:\n\n```c\n$xavu(x) = 123; # <- set the value\n$xavu(x) = 234; # <- update to the value, not adding to a list like for xavps\n$xavu(x) = $null; # <- delete the xavu\n$xavu(a=>b) = \"xyz\"; # <- two level naming supported\n```\n",
  "xavi": "## $xavi(id) - XAVIs\n\nSimilar to XAVPs, but with key names are case insensitive. XAVIs are\nalso stored in transaction context and destroyed when the transaction is\nterminated.\n\nExamples:\n\n```c\n$xavi(WhatEver=>FoO) = 123; # <- set the value\n# $xavi(whatever[0]=>foo) == 123\n```\n",
  "hdr": "## $hdr(name) - Headers\n\n**$hdr(name)** - represents the body of first header field identified by\n'name'\n\n**$(hdr(name)[N])** - represents the body of the N-th header field\nidentified by 'name'.\n\nIf [N] is omitted then the body of the first header is printed. The\nbody of first header is returned when N=0, for the second N=1, a.s.o. In\ncase of a comma-separated multi-body headers, it returns all the bodies,\ncomma-separated. To print the last header of that type, use -1, or other\nnegative values to count from the end. No white spaces are allowed\ninside the specifier (before }, before or after {, [, ] symbols). When\nN='*', all headers of that type are printed.\n\nIf name is *, then any header name is matched, e.g., $hdr(*) is body\nof first header, $(hdr(*)[-1]) is body of last header.\n\nThe module should identify compact header names. It is recommended to\nuse dedicated specifiers for headers (e.g., $ua for user agent header),\nif they are available -- they are faster.\n\nExample of usage:\n\n```c\nif($hdr(From)=~\"kamailio\\.org\") {\n...\n}\n```\n\n\ud83d\udd25**IMPORTANT**: It is read-only variable. You can remove or add headers\nusing functions from textops module.\n",
  "hfl": "## $hfl(name) - Header Field With List Of Bodies\n\nSimilar to **$hdr(name)**, but for some of the standard headers that can\nhave many bodies serialized in the same header field (i.e., comma\nseparated list of bodies in same header field) is able to return the\nindividual body values.\n\nImplemented for:\n\n- Contact\n- Record-Route\n- Route\n- Via\n- Diversion\n- P-Asserted-Identity\n- P-Preferred-Identity\n\nFor the rest of the headers works like **$hdr(name)**.\n\n**$hfl(name)** - represents the first body of first header field\nidentified by 'name'.\n\n**$(hfl(name)[N])** - represents the body of the N-th header field\nidentified by 'name'.\n\nExample of usage:\n\n```c\nif($(hfl(Via)[1])=~\"TLS\") {\n...\n}\n```\n",
  "hdrc": "## $hdrc(name) - Number of Headers\n\n**$hdrc(name)** - get the number of headers with the respective name\n\nExample of usage:\n\n```c\nif($hdrc(Via) == 2) {\n...\n}\n```\n",
  "hflc": "## $hflc(name) - Number of Header Bodies\n\nSimilar to **$hdrc(name)**, but for some of the standard headers that\ncan have many bodies serialized in the same header field (i.e., comma\nseparated list of bodies in same header field) is able to count the\nnumber of individual bodies.\n\nImplemented for:\n\n- Record-Route\n- Route\n- Via\n- Diversion\n- P-Asserted-Identity\n- P-Preferred-Identity\n\nFor the rest of the headers works like **$hdrc(name)**.\n\nExample of usage:\n\n```c\nif($hflc(Via)==3) {\n...\n}\n```\n",
  "var": "## $var(name) - Private memory variables (zero)\n\n**$var(name)** - refers to variables that can be used in configuration\nscript, having integer or string value. This kind of variables are\nfaster than AVPs, being referenced directly to memory location.\n\nExample of usage:\n\n```c\n$var(a) = 2; #-- sets the value of variable 'a' to integer '2'\n$var(a) = \"2\"; #-- sets the value of variable 'a' to string '2'\n$var(a) = \"sip:\" + $au + \"@\" + $fd; #-- compose a value from authentication username and From URI domain\n$var(a) = 3 + (7&(~2));\n\nif( $var(a) & 4 ) {\n  xlog(\"var a has third bit set\\n\");\n}\n```\n\n**Note:** Setting a variable to $null is actually initializing the value\nto integer '0'. This type of script variables doesn't have $null value.\n\n```c\n$var(x) = $null;\n\nif($var(x)==0) { # this is true\n  ...\n}\n```\n\n**Note:** A script variable persists over the Kamailio process in which\nit was initialized, so be sure of giving it a new value before reading\nit or you'll get the value assigned in any other previous message\nprocessed by the same Kamailio process (pid).\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n**pv** module can be used to initialize the script variables.\n",
  "vz": "## $vz(name) - Private memory variables (zero)\n\nSame as $var(name) -- added to pair with $vn(name).\n",
  "vn": "## $vn(name) - Private memory variables (null)\n\nSimilar to $var(name) and able to hold $null (which is the default\nvalue). The value is kept in private memory (pkg) and it is persistent\nacross SIP message processing, within the space of each Kamailio\nprocess.\n\nExample of usage:\n\n```c\n$vn(x) = 1;\n$vn(x) = \"abc\";\n$vn(x) = $null;\n\nif($vn(x) == $null) { ... }\n```\n",
  "shv": "## $shv(name) - Shared memory variables\n\n**$shv(name)** - it is a class of pseudo-variables stored in shared\nmemory. The value of $shv(name) is visible across all Kamailio\nprocesses. Each \u201cshv\u201d has single value and it is initialised to integer\n0. You can use \u201cshvset\u201d parameter of **pv module** to initialize the\nshared variable. The module exports a set of RPC functions to get/set\nthe value of shared variables.\n\nExample - shv(name) pseudo-variable usage:\n\n```\n...\nmodparam(\"pv\", \"shvset\", \"debug=i:1\")\n...\nif ($shv(debug) == 1) {\n    xlog(\"request: $rm from $fu to $ru\\n\");\n}\n...\n```\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n",
  "dsv": "## $dsv(key) - Dispatcher variables\n\nReturn attributes related to dispatcher module.\n\nThe key can be:\n\n- code - the SIP response code that caused the execution of\n  event_route 'dispatcher:dst-up' or 'dispatcher:dst-down', if\n  available\n- reason - the SIP response reason that caused the execution of\n  event_route 'dispatcher:dst-up' or 'dispatcher:dst-down', if\n  available\n- flags - flags set internally when executing event_route\n  'dispatcher:dst-up' or 'dispatcher:dst-down'\n",
  "dsg": "## $dsg(key) - Dispatcher group attributes\n\nReturn attributes related to dispatcher group that is set via\n`ds_dsg_fetch()`.\n\nThe key can be:\n\n- `count` - the number of records (destination addresses) in the group\n- `active`- the number of active destinations in the group\n- `pactive`- the percent of active destinations in the group\n- `inactive` - the number of inactive destination in the group\n- `pinactive` - the percent of inactive destination in the group\n",
  "time": "## $time(name) - Broken-down time\n\n**$time(name)** - the PV provides access to broken-down time attributes\nin the local timezone.\n\nThe 'name' can be:\n\n- sec - return seconds (int 0-59)\n- min - return minutes (int 0-59)\n- hour - return hours (int 0-23)\n- mday - return the day of month (int 0-59)\n- mon - return the month (int 1-12)\n- year - return the year (int, e.g., 2008)\n- wday - return the day of week (int, 1=Sunday - 7=Saturday)\n- yday - return the day of year (int, 1-366)\n- isdst - return daylight saving time status (int, 0 - DST off, >0 DST\n  on)\n\nExample - time(name) pseudo-variable usage:\n\n```c\n...\nif ($time(year) == 2008) {\n    xlog(\"request: $rm from $fu to $ru in year 2008\\n\");\n}\n...\n```\n",
  "utime": "## $utime(name) - Broken-down time\n\n**$utime(name)** - the PV provides access to broken-down time attributes\nin UTC.\n\nSee **$time(name)** above for the possible attributes\n",
  "timef": "## $timef(format) - Strftime Formatted Time\n\n**$timef(format)** - return current time as formatted by strftime\n'format'. See 'man strftime' to see the available time attribute\nspecifiers.\n\nExample:\n\n```c\nxlog(\"Today is $timef(%m/%d/%y)\\n\");\n```\n",
  "utimef": "## $utimef(format) - Strftime Formatted UTC Time\n\n**$utimef(format)** - return current time in UTC as formatted by\nstrftime 'format'. See 'man strftime' to see the available time\nattribute specifiers.\n\nExample:\n\n```c\nxlog(\"The time is $utimef(%m/%d/%y %H:%M:%S)\\n\");\n```\n",
  "ccp": "## $ccp(key) - Config Custom Parameters\n\nGet the value for global custom parameters:\n\n- [Custom Global parameters](core.md#custom-global-parameters)\n\nExample:\n\n```c\ngv.sval = \"hello\" desc \"hello var\"\ngv.ival = 10 desc \"ten var\"\n\nrequest_route {\n    xinfo(\"global vars: $ccp(gv.sval) :: $ccp(gv.ival)\\n\");\n}\n```\n",
  "sel": "## $sel(name) - Selects\n\n**$sel(name)** - return the value of **select** specified by name.\n**select** refers a class of config variables introduced by SER 2.0,\nallowing to select and return parts of sip messages and not only.\n\nList of available selects:\n\n- [Selects](selects.md)\n\nExample:\n\n```c\nif($sel(via[1].host)==\"10.10.10.10\")\n{\n  ...\n}\n```\n",
  "rcv": "### $rcv(key)\n\nAttributes of received data. The variables must be used inside\n**event_route[core:msg-received]** routing block.\n\nThe key can be:\n\n- buf - received message\n- len - lenght of received message\n- srcip - source ip\n- rcvip - local ip where it was received\n- scrport - source port\n- rcvport - local port where it was received\n- proto - protocol as int id\n- sproto - protocol as string\n- af - address family\n\nExample of usage:\n\n```c\nevent_route[core:msg-received] {\n  xlog(\"rcv on $rcv(af)/$rcv(proto): ($rcv(len)) [$rcv(buf)] from [$rcv(srcip):$rcv(srcport)] to [$rcv(rcvip):$rcv(rcvport)]\\n\");\n}\n```\n",
  "rpl": "## $rpl(key)\n\nAttributes of the SIP reply processed at that moment. The variables must\nbe used during SIP reply processing, otherwise it returns $null.\n\nThe key can be:\n\n- duri - SIP URI corresponding to the address where the SIP reply is\n  going to be sent based on 2nd via\n- dhost - host part of duri\n- dport - port part of duri\n- dproto - proto part of duri\n- dprotoid - proto id of duri\n- cntvia - the number of Via header bodies\n\nExample of usage:\n\n```c\nreply_route{\n  xinfo(\"reply to be sent to: $rpl(duri)\\n\");\n}\n```\n",
  "msgbuf": "## $msgbuf(index)\n\nGet or set the character in the message buffer at the position index.\n\nThe index has to be a positive integer or a variable holding such value.\n\nNote that the variable returns a clone of the character stored in a\nstatic buffer, copy it to another variable if you want to compare with\nanother $msgbuf(index).\n\nThe update is done directly and immediately in the message buffer -- use\nit with care!\n\nExample of usage:\n\n```c\nif ($msgbuf(20)==\"V\") {\n    $msgbuf(20) = \"v\";\n}\n```\n",
  "hfitname": "### $hfitname(iname)\n\nThe header name of the header field iterator.\n\nExample:\n\n```c\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        xlog(\"hdr[$hfitname(i1)] is: $hfitbody(i1)\\n\");\n    }\n    hf_iterator_end(\"i1\");\n```\n",
  "hfitbody": "### $hfitbody(iname)\n\nThe header body of the header field iterator.\n\nExample:\n\n```c\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        xlog(\"hdr[$hfitname(i1)] is: $hfitbody(i1)\\n\");\n    }\n    hf_iterator_end(\"i1\");\n```\n",
  "blitval": "### $blitval(iname)\n\nThe value of the body line iterator.\n\nExample:\n\n```c\n    bl_iterator_start(\"b1\");\n    while(bl_iterator_next(\"b1\")) {\n        xlog(\"body line: $blitval(b1)\");\n    }\n    bl_iterator_end(\"b1\");\n```\n",
  "sndfrom": "### $sndfrom(name)\n\n**$snd(name)** - return attributes of the address from where the request\nis going to be sent (local socket).\n\n**$sndfrom(name)** - return attributes of the address from where the\nrequest is going to be sent (local socket, same as $snd(name)).\n\nThe name can have same values as for $sndto(...).\n",
  "sndto": "### $sndto(name)\n\n**$sndto(name)** - return attributes of the address to where the request\nis going to be sent (remote socket).\n\nThey are available in **onsend_route**. The name can be:\n\n- ip - IP address of destination\n- af - address family to be used to send (numeric)\n- port - port of destination address\n- proto - transport protocol to be used to send (numeric - UDP=1,\n  TCP=2, TLS=3, SCTP=4, WS=5, WSS=6)\n- sproto - transport protocol to be used to send (string)\n- buf - entire send buffer as string\n- len - length of outgoing packet (length of above buf)\n\nExample:\n\n```c\nonsend_route {\n  if($snd(ip)==\"10.10.10.10\")\n  {\n    ...\n  }\n}\n```\n",
  "sipdump": "### $sipdump(name)\n\n**$sipdump(name)** - return attributes of the message handled in the\nevent_route[sipdump:msg].\n\nThe name can be:\n\n- tag - the tag of processing (rcv or snd)\n- buf - entire message buffer as string\n- len - length of the message (length of above buf)\n- af - address family\n- src_ip - source IP address as string\n- dst_ip - destination IP address as string\n- src_port - port of source address as number\n- dst_port - port of source address as number\n- proto - transport protocol\n\nExample:\n\n```c\nevent_route[sipdump:msg] {\n  if($sipdump(len) > 1024) {\n    ...\n  }\n}\n```\n",
  "siptrace": "### $siptrace(name)\n\n**$siptrace(name)** - return attributes of the message handled in the\nevent_route[siptrace:msg].\n\nThe name can be:\n\n- src_addr - source socket address (proto:ip:port)\n- dst_addr - destination socket address (proto:ip:port)\n- src_host - source host, for IPv6 host contains `[]`\n- dst_host - destination host, for IPv6 host contains `[]`\n- src_hostip - source host, for IPv6 host do not contains `[]`\n- dst_hostip - destination host, for IPv6 host do not contains\n  `[]`\n- src_port - source port\n- dst_port - destination port\n- src_proto - source proto\n- dst_proto - destination proto\n\nExample:\n\n```c\nevent_route[siptrace:msg]\n{\n    if (allow_address(\"1\", \"$siptrace(src_hostip)\", \"0\")) {\n        return;\n\n    }\n    if (compare_ips($siptrace(src_host), \"[2001:DB8::1]\")) {\n        return;\n    }\n}\n```\n",
  "BM_time_diff": "### $BM_time_diff\n\n$BM_time_diff - the time difference elapsed between calls of\nbm_start_timer(name) and bm_log_timer(name). The value is 0 if no\nbm_log_timer() was called.\n",
  "dlg": "### $dlg(attr)\n\nReturn the attribute of the current processed dialog.\n\n\ud83d\udd25**IMPORTANT**: It is R/O variable.\n\nThe 'attr' can be:\n\n- h_id - hash id\n- h_entry - hash entry\n- ref - reference count\n- state - state of dialog\n- to_rs - To route set\n- from_rs - From route set\n- dflags - dialog internal flags\n- sflags - dialog script flags\n- callid - sip call id\n- to_uri - To uri\n- to_tag - To tag\n- from_uri - From uri\n- from_tag - From tag\n- toroute - timeout route\n- lifetime - timeout inteval\n- start_ts - start timestamp\n- to_cseq - To CSeq\n- from_cseq - From CSeq\n- to_contact - To contact address\n- from_contact - From contact address\n- to_bindaddr - To bind address\n- from_bindaddr - From bind address\n",
  "dlg_ctx": "### $dlg_ctx(attr)\n\nReturn the attribute of the context for current processed dialog.\n\n\ud83d\udd25**IMPORTANT**: Some of the attributes are R/W variables.\n\nThe 'attr' can be:\n\n- set - returns 1 if the dialog for current context is set, 0\n  otherwise\n- flags - get/set dialog flags\n- timeout_route - get/set route name to be executed on timeout\n- timeout_route_id - get internal id for the route to be executed on\n  timeout\n- timeout_bye - set to 1 if BYE has to be sent when dialog lifetime\n  elapses\n- timeout - set the dialog lifetime (in seconds)\n- on - get/set an integer value associated with the context (cfg\n  usage)\n- dir - get direction of the request for the dialog of the current\n  context (0 - unknown, 1 - downstream, 2 - upstream)\n",
  "dlg_var": "### $dlg_var(key)\n\nStore and retrieve custom variable for current processed dialog.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable.\n\nThe 'key' can be any string.\n",
  "erl_atom": "### $erl_atom(name)\n\n*$erl_atom(name)* pseudo variable allows create analog to Erlang atom\ndata type. Erlang atom is a literal, a constant with name. Formatted\noutput pseudo variable atom could be enclosed in single quotes (') if it\ndoes not begin with a lower-case letter or if it contains other\ncharacters than alphanumeric characters, underscore (_), or @.\n\nExample:\n\n```c\n$erl_atom(A) = \"node@host.tld\";\n\nxlogl(\"L_DEBUG\",\"$$erl_atom(A): $erl_atom(A=>format)\\n\");\n```\n",
  "erl_list": "### $erl_list(name)\n\nCompound data type with a variable number of terms. Formally, a list is\neither the empty list [] or consists of one or more elements.\n\nExample:\n\n```c\n$erl_atom(E) = \"example\";\n$erl_list(L) = \"list\";\n$erl_list(L) = \"of\";\n$erl_list(L) = $erl_atom(E);\n\nxlogl(\"L_DEBUG\",\"length(L): $erl_list(L=>length), format(L): $erl_list(L=>format)\\n\");\n\n# empty list\n$erl_tuple(E[*]) = $null;\n```\n",
  "erl_tuple": "### $erl_tuple(name)\n\nFrom the Erlang point of view the tuple compound data type with a fixed\nnumber of terms. The module implementation of tuple has the same\nbehavior as the list.\n\nExample:\n\n```c\n$erl_atom(e) = \"error\";\n\n$erl_tuple(T) = \"badrpc\";\n$erl_tuple(T) = $erl_atom(e);\n\nxlogl(\"L_DEBUG\",\"length(T): $erl_tuple(T=>length), format(T): $erl_tuple(T=>format)\\n\");\n```\n",
  "erl_pid": "### $erl_pid(name)\n\nHolds Eralng process identifier. Provides access to Erlang PID value and\ncould be used in send message.\n",
  "erl_ref": "### $erl_ref(name)\n\nHolds Erlang reference. Provides access to reference value and could be\nused in send message.\n",
  "erl_xbuff": "### $erl_xbuff(name)\n\nGeneric pseudo variable to acts as other pseudo variables exported from\nErlang module.\n",
  "evapi": "### $evapi(conidx)\n\ninternal connection index\n",
  "sht": "### $sht(htable=>key)\n\nAccess hash table entries.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file. Hash table entry can be deleted by assigning value\n$null to it. Value of a non-existing hash table entry is $null.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter.\n\nThe \u201ckey\u201d can be:\n\n- static string - set of characters without pseudo-variables\n\n- dynamic string - set of characters that include pseudo-variables.\n  The pseudo-variables will be evaluated at runtime.\n\n  ...\n  modparam(\"htable\", \"htable\", \"a=>size=4;\")\n  ...\n  $sht(a=>$au) = 1;\n  $sht(a=>$ru) = $fu;\n  ...\n",
  "shtex": "### $shtex(htable=>key)\n\nAccess hash table entry expire value. Value represents the seconds until\nthe htable entry will expire and be deleted from htable.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter\nand have auto-expire greater than 0.\n\nThe \u201ckey\u201d can be:\n\n- static string - set of characters without pseudo-variables\n\n- dynamic string - set of characters that include pseudo-variables.\n  The pseudo-variables will be evaluated at runtime.\n\n  ...\n  modparam(\"htable\", \"htable\", \"a=>size=4;autoexpire=120;\")\n  ...\n  $sht(a=>$au) = 1;\n  $shtex(a=>$au) = 10;\n  ...\n",
  "shtcn": "### $shtcn(htable=>exp)\n\nCount items matching the name by regexp.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter.\n\nThe **exp** can be:\n\n- reqexp - match by regular expression 'regexp'\n- ~~regexp - match by regular expression 'regexp'\n- ~%prefix - match by right prefix\n- %~prefix - match by left prefix\n- ==value - match by string value\n- eqvalue - match by integer value\n- * * - (two asterisks next to each other) - count all items\n\nThe **exp** can contain pseudo-variables.\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=4;\")\n...\n$sht(a=>abc) = 1;\n$shtex(a=>ade) = 10;\nxlog(\"$shtcn(a=>a.*)\");\n...\n```\n",
  "shtcv": "### $shtcv(htable=>exp)\n\nCount items matching the value by regexp.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter.\n\nThe **exp** must follow same rules as for **$shtcn(...)**.\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=4;\")\n...\n$sht(a=>abc) = \"xyz\";\n$shtex(a=>ade) = \"xwt\";\nxlog(\"$shtcv(a=>x.*)\");\n...\n```\n",
  "shtinc": "### $shtinc(htable=>key)\n\nAtomic increment of the value for the hash table item.\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=4;\")\n...\n$sht(a=>$au) = 1;\nxlog(\"==== $shtinc(a=>$au)\\n\");\n...\n```\n",
  "shtdec": "### $shtdec(htable=>key)\n\nAtomic decrement of the value for the hash table item.\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=4;\")\n...\n$sht(a=>$au) = 1;\nxlog(\"==== $shtdec(a=>$au)\\n\");\n...\n```\n",
  "shtitkey": "### $shtitkey(iname)\n\nThe key at the current position in the iterator.\n",
  "shtitval": "### $shtitval(iname)\n\nThe value at the current position in the iterator.\n\nExample:\n\n```c\n    sht_iterator_start(\"i1\", \"h1\");\n    while(sht_iterator_next(\"i1\")) {\n        xlog(\"h1[$shtitkey(i1)] is: $shtitval(i1)\\n\");\n    }\n    sht_iterator_end(\"i1\");\n```\n",
  "shtrecord": "### $shtrecord(id)\n\nGet the key or the value of expired item inside the\nevent_route[htable:expired:_table_name_].\n\nThe id can be:\n\n- key\n- value\n\nExample:\n\n```c\nevent_route[htable:expired:h1] {\n  xlog(\"expired item ($shtrecord(key),$shtrecord(value))\\n\");\n}\n```\n",
  "mct": "### $mct(key=>expiry)\n\nUsing this alternative format, the default expiry may be overidden by\nincluding a custom value at time of assignment.\n\n```\n...\n$mct(test=>30) = 1; # set expire time to 30 seconds\nxlog(\"stored value is $mct(test)\");\n# sleep 30 seconds\nxlog(\"stored value is $mct(test)\"); # will return <null>\n...\n```\n",
  "mcinc": "### $mcinc(key)\n\nDo an atomic increment operation on the value stored in memcached. You\nneed to add a value previously.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201ckey\u201d can be:\n\n- static string - set of characters without pseudo-variables\n\n- dynamic string - set of characters that include pseudo-variables.\n  The pseudo-variables will be evaluated at runtime.\n\n  ...\n  $mct(cnt) = 1;\n  $mcinc(cnt) = 2; # increment by 2\n  xlog(\"counter is now $mct(cnt)\");\n  ...\n",
  "mcdec": "### $mcdec(key)\n\nDo an atomic decrement operation on the value stored in memcached. You\nneed to add a value previously.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201ckey\u201d can be:\n\n- static string - set of characters without pseudo-variables\n\n- dynamic string - set of characters that include pseudo-variables.\n  The pseudo-variables will be evaluated at runtime.\n\n  ...\n  $mct(cnt) = 10;\n  $mcdec(cnt) = 2; # decrement by 2\n  xlog(\"counter is now $mct(cnt)\");\n  ...\n",
  "http_req_id": "### $http_req_id\n\nThe $http_req_id read-only variable can be used in REQUEST_ROUTE to\nretrive the unique identifier for a query after sending it or in the\nHTTP callback route to retrive the id of the query the reply belongs to.\nUseful mainly in non-transactional context.\n",
  "http_req": "### $http_req(key)\n\nThe $http_req(key) write-only variable can be used to set custom\nparameters before sending a HTTP query.\n\n**key** can be one of:\n\n- all: if set to $null, resets all the parameters to their default\n  value (the ones defined in modparam)\n\n- hdr: sets/modifies/removes a HTTP header. N.B.: setting this\n  variable multiple times will add several headers to the query.\n\n- body: sets/modifies/removes the request body\n\n- method: sets the HTTP method: either \"GET\", \"POST\", \"PUT\" or\n  \"DELETE\" (these are the supported methods). (Note: if the method is\n  not set, curl will use GET, or POST if a body is specified)\n\n- timeout: sets the HTTP timeout. (Note, this timeout should be\n  normally less than tm.fr_timer timeout, because transaction timeout\n  has a higher priority over HTTP timeout)\n\n- tls_client_cert: sets the client certificate to use\n\n- tls_client_key: sets the client certificate key to use\n\n- tls_ca_path: sets the CA certificate path to use\n\n- authmethod: Sets the preferred authentication mode for HTTP/HTTPS\n  requests. The value is a bitmap and multiple methods can be used.\n  Note that in this case, the CURL library will make an extra request\n  to discover server-supported authentication methods. You may want to\n  use a specific value. Valid values are:\n\n  - 1 - BASIC authentication\n  - 2 - HTTP Digest authentication\n  - 4 - GSS-Negotiate authentication\n  - 8 - NTLM authentication\n  - 16 - HTTP Digest with IE flavour.\n  - (Default value is 3 - BASIC and Digest authentication.)\n\n- username: sets the username to use for authenticated requests\n\n- password: sets the password to use for authenticated requests\n\n- suspend: if set to 0 it doesn't suspend the current transaction before performing the query\n\n- tcp_keepalive: enable TCP keepalive\n\n- tcp_ka_idle: set TCP keepalive idle time wait\n\n- tcp_ka_interval: set TCP keepalive interval\n",
  "http_ok": "#### $http_ok\n\n1 if cURL executed the request successfully, 0 otherwise (check\n$http_err for details).\n",
  "http_err": "#### $http_err\n\ncURL error string if an error occurred, $null otherwise.\n",
  "http_rs": "#### $http_rs\n\nHTTP status.\n",
  "http_rr": "#### $http_rr\n\nHTTP reason phrase.\n",
  "http_hdr": "#### $http_hdr(Name)\n\nValue of the Name header (the $(http_hdr(Name)[N]) syntax can also be\nused, check the SIP $hdr() PV documentation for details).\n",
  "http_mb": "#### $http_mb and $http_ml\n\nHTTP response buffer (including headers) and length.\n",
  "http_rb": "#### $http_rb and $http_bs\n\nHTTP response body and body length,\n",
  "xml": "### $xml(name=>spec)\n\n- name - id to refer the documet\n- spec - specifier:\n  - doc - set/get the document as text\n  - xpath:xpath-expression - evaluate xpath expression\n\nExample:\n\n```\n$xml(x=>doc) = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><a><b>test</b></a>';\nxlog(\"content of node b: $xml(x=>xpath:/a/b/text())\\n\");\n$xml(x=>xpath:/a/b) = \"1234\";\n```\n",
  "T_branch_idx": "### $T_branch_idx\n\n- the index (starting with 0 for the first branch) of the branch for\n  which is executed the branch_route[].\n- in failure_route[] block, the value is the number of completed\n  branches added to the number of new new branches\n- in request_route block, the value is number of created branches\n- in onreply_route[], the value is the index of the branch receiving\n  the reply\n- if used outside of transaction processing, the value is '-1'\n",
  "T_reply_ruid": "### $T_reply_ruid\n\n- the ruid stored in the current branch of the transaction. The ruid\n  is stored in a branch from the details in a contact binding. In an\n  event_route[tm:branch-failure] block, this is the ruid of the\n  branch that sent a failure reply. In a failure_route[] block, this\n  is the ruid of the winning failure response.\n",
  "T_reply_code": "### $T_reply_code\n\n- the code of the reply, as follows: in request_route will be the last\n  stateful sent reply; in reply_route will be the current processed\n  reply; in failure_route will be the negative winning reply. In case\n  of no-reply or error, '0' value is returned\n",
  "T_req": "### $T_req(pv)\n\n- can be used in reply routes or inside the modules to get access to\n  attributes of the request belonging to same transaction as the reply\n\n  route {\n  t_on_reply(\"1\");\n  t_relay();\n  }\n\n  onreply_route[1] {\n  xlog(\"Request SRCIP:PORT = $T_req($si):$T_req($sp)\\n\");\n  }\n",
  "T_rpl": "### $T_rpl(pv)\n\n- can be used in failure routes or inside the modules to get access to\n  attributes of the winning reply belonging to same transaction as the\n  request\n\n  route {\n  t_on_failure(\"1\");\n  t_relay();\n  }\n\n  failure_route[1] {\n  xlog(\"Reply SRCIP:PORT = $T_rpl($si):$T_rpl($sp)\\n\");\n  }\n",
  "T_inv": "### $T_inv(pv)\n\n- can be used in request routes or inside the modules to get access to\n  attributes of the INVITE request while processing a CANCEL.\n\n  route {\n  if(is_method(\"CANCEL\"))\n  {\n  if($T_inv($mf) & 1 )\n  {\n  # first flag is set in the INVITE transaction\n  }\n  }\n  }\n",
  "T": "### $T(name)\n\n- pseudo-variable class to access TM attributes\n\nThe **name** can be:\n\n- id_index - return the internal index of current transaction or $null\n  if no transaction is found\n- id_label - return the internal label of current transaction or $null\n  if no transaction is found\n- id_index_n - return the internal index of current transaction, if no\n  transaction exists yet, create it\n- id_label_n - return the internal label of current transaction, if no\n  transaction exists yet, create it\n- reply_code - reply code (alias to $T_reply_code)\n- reply_reason - reply reason\n- reply_last - last received reply code\n- branch_index - branch index (alias to $T_branch_idx)\n- ruid - return the internal location ruid field for current branch\n- reply_type - 1 if it is a local generated reply, 0 - if no reply for\n  transaction or it is a received reply\n\nNote: the pair (id_index,id_label) uniquely identifies a transaction.\n",
  "T_branch": "### $T_branch(name)\n\n- pseudo-variable class to access TM branch attributes\n\nThe **name** can be:\n\n- flags - Flags of the branch. In an event_route[tm:branch-failure]\n  block, this is the flags of the branch that sent a failure reply. In\n  a failure_route[] block, this is the flags of the winning failure\n  response.\n- uri - the R-URI of the branch. Can be used in onreply_route[id] -\n  reply route blocks executed by tm module. For other routing blocks\n  handling requests, the R-URI is returned by $ru\n",
  "uac_req": "### $uac_req(key)\n\n- used to build the input for uac_send_req() function of UAC module\n\nThe key can be:\n\n- method - SIP method\n- ruri - request URI\n- furi - From URI\n- turi - To URI\n- ouri - Outbound proxy URI\n- hdrs - SIP Headers\n- body - Body\n- flags - flags for processing\n  - 1 - the password is provided in HA1 format\n- auser - authentication username\n- apasswd - authentication password\n- sock - local socket to be used for sending (proto:address:port)\n- callid - SIP-Call-ID of the generated request (by default, a call-id\n  is generated)\n- all - alias useful to reset all fields - $uac_req(all) = $null;\n- evroute - it has to be set to 1 in order to execute\n  event_route[uac:reply] when reply is received\n- evcode - reply code for the request sent with uac_req_send(),\n  available inside event_route[uac:reply]\n- evtype - is 1 if the reply was received via network, 2 if the reply\n  was locally generated (e.g., retransmission timeout), available\n  inside event_route[uac:reply]\n- evparam - generic data buffer associated with the request that can\n  be set before sending it and retrieved when executing the event\n  route. It has a size of 128 characters.\n\n```c\n$uac_req(method)=\"OPTIONS\";\n$uac_req(ruri)=\"sip:kamailio.org\";\n$uac_req(furi)=\"sip:kamailio.org\";\n$uac_req(turi)=\"sip:kamailio.org\";\n$uac_req(evroute) = 1;\nuac_req_send();\n...\nevent_route[uac:reply] {\n  xlog(\"request sent to $uac_req(ruri) completed with code: $uac_req(evcode)\\n\");\n}\n```\n",
  "rr_count": "### $rr_count\n\n- Number of Record Routes in received SIP request or reply.\n",
  "rr_top_count": "### $rr_top_count\n\n- If topmost Record Route in received SIP request or reply is a double\n  Record Route, value of $rr_top_count is 2. If it a single Record\n  Route, value of $rr_top_count is 1. If there is no Record Route(s),\n  value of $rr_top_count is 0.\n",
  "mqk": "### $mqk(q)\n\n- return the key of fetched item from queue q\n",
  "mqv": "### $mqv(q)\n\n- return the value of fetched item from queue q\n\n```c\n...\nmq_add(\"myq\", \"$rU\", \"call from $fU at $Tf\");\n...\nwhile(mq_fetch(\"myq\"))\n{\n   xlog(\"$mqk(myq) - $mqv(myq)\\n\");\n}\n...\n```\n",
  "TV": "### $TV(name)\n\nSeconds and microseconds taken from struct timeval. The time at that\nmoment is represented by **seconds.microseconds**.\n\n- $TV(s) - seconds (cached at first call per sip message)\n- $TV(u) - microseconds (cached at first call per sip message)\n- $TV(sn) - seconds (not cached, taken at that moment)\n- $TV(un) - microseconds (corresponding to the moment $TV(sn) is\n  retrieved)\n- $TV(Sn) - string representation seconds.microseconds (not cached,\n  taken at that moment)\n- $TV(Sm) - string representation of an always increasing monotonic\n  counter. Note that even if is based on clock, it starts from an\n  unspecified point in time, so should really be treated as an\n  opaque counter.\n",
  "nh": "### $nh(key)\n\nReturn attributes of next hop for the SIP messages. For SIP requests,\nthe address is taken from dst_uri, if set, if not from new r-uri or\noriginal r-uri. For SIP replies, the attributes are taken from 2nd Via\nheader (username is always $null for SIP replies).\n\n- $nh(u) - uri (lower case u)\n- $nh(U) - username (upper case u)\n- $nh(d) - domain\n- $nh(p) - port (lower case p)\n- $nh(P) - transport protocol (upper case p)\n",
  "redis": "### $redis(res=>key)\n\nAccess the attributes of the Redis response.\n\nThe key can be:\n\n- type - type of the reply (as in hiredis.h)\n- value - the value returned by REDIS server;\n- info - in case of error from REDIS, it will contain an info message.\n\nIf reply type is an array (as in hiredis.h), there are other keys\navailable:\n\n- size - returns number of elements in the array.\n\n- type[n] - returns the type of the nth element in the array. type -\n  returns array type.\n\n- value[n] - returns value of the nth element. value - returns null\n  for an array. You need to get each element by index.\n\nIn case one of the members of the array is also an array (for example\ncalling SMEMBERS in a MULTI/EXEC transaction), the members of the array\ncan be accessed by adding any of the above keys, after a value[n] key.\nThe first value[n] references the element in the first array, while\nthe next key references an element of the referenced array.\n\nExample:\n\n```\nredis_cmd(\"srvN\", \"GET foo\", \"r\");\nxlog(\"===== result type: $redis(r=>type) * value: $redis(r=>value)\\n\");\n```\n",
  "redisd": "### $redisd(key)\n\nReturn the corresponding value for various defines from hiredis library.\n\nThe key can be:\n\n- rpl_str - return REDIS_REPLY_STRING\n- rpl_arr - return REDIS_REPLY_ARRAY\n- rpl_int - return REDIS_REPLY_INTEGER\n- rpl_nil - return REDIS_REPLY_NIL\n- rpl_sts - return REDIS_REPLY_STATUS\n- rpl_err - return REDIS_REPLY_ERROR\n\n$redisd(rpl_XYZ) can be compared with $redis(r=>type).\n\nExample:\n\n```\nredis_cmd(\"srvN\", \"GET foo\", \"r\");\nif ($redis(r=>type) == $redisd(rpl_int)) {\n}\n```\n",
  "gip": "### $gip(pvc=>key)\n\nVariables exported by GeoIP module, returning geo-location attributes.\nThe attributes are populated upon calling function **geoip_match(ipaddr,\npvc)**.\n\n**pvc** (container id) is second parameter of geoip_match(..) and\n**key** can be:\n\n- cc - country code\n- tz - time zone\n- zip - postal code\n- lat - latitude\n- lon - longitude\n- dma - dma code\n- ips - ip start\n- ipe - ip end\n- city - city\n- area - area code\n- regc - region\n- regn - region name\n- metro - metro code\n- contc - continent code\n\nYou can call several time **geoip_match(ipaddr, pvc)** with different ip\naddress and containers in your config, to compare, for example,\nattributes of source and destination of a call.\n\n```c\ngeoip_match(\"$si\", \"src\");\ngeoip_match(\"$nh(d)\", \"dst\");\n\nif($gip(src=>cc)==$gip(dst=>cc))\n{\n    # source and destination from same country\n}\n\n```\n",
  "gip2": "### $gip2(pvc=>key)\n\nVariables exported by GeoIP2 module, returning geo-location attributes.\nThe attributes are populated upon calling function\n**geoip_match2(ipaddr, pvc)**.\n\n**pvc** (container id) is second parameter of geoip_match2(..) and\n**key** can be:\n\n- cc - country code\n- tz - time zone\n- zip - postal code\n- lat - latitude\n- lon - longitude\n- dma - dma code\n- ips - ip start\n- ipe - ip end\n- city - city\n- area - area code\n- regc - region\n- regn - region name\n- metro - metro code\n- contc - continent code\n\nYou can call several time **geoip_match(ipaddr, pvc)** with different ip\naddress and containers in your config, to compare, for example,\nattributes of source and destination of a call.\n\n```c\ngeoip_match2(\"$si\", \"src\");\ngeoip_match2(\"$nh(d)\", \"dst\");\n\nif($gip2(src=>cc)==$gip2(dst=>cc))\n{\n    # source and destination from same country\n}\n\n```\n",
  "tls": "### $tls(key)\n\nVariables related to TLS communication and certificates.\n\nThe **key** can be:\n\n- **m_issuer_line** - return local (my) certificate issuer line\n- **p_issuer_line** - return remote (peer) certificate issuer line\n- **m_subject_line** - return local (my) certificate subject line\n- **p_subject_line** - return remote (peer) certificate subject line\n\nExample:\n\n```c\nif(proto==TLS) {\n    xinfo(\"local certificate subject: $tls(m_subject_line)\\n\");\n}\n```\n",
  "tls_version": "### $tls_version\n\nThe TLS/SSL version which is used on the TLS connection from which the\nmessage was received. String type.\n",
  "tls_description": "### $tls_description\n\nThe TLS/SSL description of the TLS connection from which the message was\nreceived. String type.\n",
  "tls_cipher_info": "### $tls_cipher_info\n\nThe TLS/SSL cipher which is used on the TLS connection from which the\nmessage was received. String type.\n",
  "tls_cipher_bits": "### $tls_cipher_bits\n\nThe number of cipher bits which are used on the TLS connection from\nwhich the message was received. String and Integer type.\n",
  "tls_peer_version": "### $tls_peer_version\n\nThe version of the certificate. String type.\n",
  "tls_my_version": "### $tls_my_version\n\nThe version of the certificate. String type.\n",
  "tls_peer_serial": "### $tls_peer_serial\n\nThe serial number of the certificate. String and Integer type.\n",
  "tls_my_serial": "### $tls_my_serial\n\nThe serial number of the certificate. String and Integer type.\n",
  "tls_peer_subject": "### $tls_peer_subject\n\nASCII dump of the fields in the subject section of the certificate.\nString type. Example:\n\n```\n  /C=AT/ST=Vienna/L=Vienna/O=enum.at/CN=enum.at\n```\n",
  "tls_peer_issuer": "### $tls_peer_issuer\n\nASCII dump of the fields in the issuer section of the certificate.\nString type.\n",
  "tls_my_subject": "### $tls_my_subject\n\nASCII dump of the fields in the subject section of the certificate.\nString type.\n",
  "tls_my_issuer": "### $tls_my_issuer\n\nASCII dump of the fields in the issuer section of the certificate.\nString type.\n",
  "tls_peer_subject_cn": "### $tls_peer_subject_cn\n\ncommonName in the subject section of the certificate. String type.\n",
  "tls_peer_issuer_cn": "### $tls_peer_issuer_cn\n\ncommonName in the issuer section of the certificate. String type.\n",
  "tls_my_subject_cn": "### $tls_my_subject_cn\n\ncommonName in the subject section of the certificate. String type.\n",
  "tls_my_issuer_cn": "### $tls_my_issuer_cn\n\ncommonName in the issuer section of the certificate. String type.\n",
  "tls_peer_subject_locality": "### $tls_peer_subject_locality\n\nlocalityName in the subject section of the certificate. String type.\n",
  "tls_peer_issuer_locality": "### $tls_peer_issuer_locality\n\nlocalityName in the issuer section of the certificate. String type.\n",
  "tls_my_subject_locality": "### $tls_my_subject_locality\n\nlocalityName in the subject section of the certificate. String type.\n",
  "tls_my_issuer_locality": "### $tls_my_issuer_locality\n\nlocalityName in the issuer section of the certificate. String type.\n",
  "tls_peer_subject_country": "### $tls_peer_subject_country\n\ncountryName in the subject section of the certificate. String type.\n",
  "tls_peer_issuer_country": "### $tls_peer_issuer_country\n\ncountryName in the issuer section of the certificate. String type.\n",
  "tls_my_subject_country": "### $tls_my_subject_country\n\ncountryName in the subject section of the certificate. String type.\n",
  "tls_my_issuer_country": "### $tls_my_issuer_country\n\ncountryName in the issuer section of the certificate. String type.\n",
  "tls_peer_subject_state": "### $tls_peer_subject_state\n\nstateOrProvinceName in the subject section of the certificate. String\ntype.\n",
  "tls_peer_issuer_state": "### $tls_peer_issuer_state\n\nstateOrProvinceName in the issuer section of the certificate. String\ntype.\n",
  "tls_my_subject_state": "### $tls_my_subject_state\n\nstateOrProvinceName in the subject section of the certificate. String\ntype.\n",
  "tls_my_issuer_state": "### $tls_my_issuer_state\n\nstateOrProvinceName in the issuer section of the certificate. String\ntype.\n",
  "tls_peer_subject_organization": "### $tls_peer_subject_organization\n\norganizationName in the subject section of the certificate. String type.\n",
  "tls_peer_issuer_organization": "### $tls_peer_issuer_organization\n\norganizationName in the issuer section of the certificate. String type.\n",
  "tls_my_subject_organization": "### $tls_my_subject_organization\n\norganizationName in the subject section of the certificate. String type.\n",
  "tls_my_issuer_organization": "### $tls_my_issuer_organization\n\norganizationName in the issuer section of the certificate. String type.\n",
  "tls_peer_subject_unit": "### $tls_peer_subject_unit\n\norganizationalUnitName in the subject section of the certificate. String\ntype.\n",
  "tls_peer_subject_uid": "### $tls_peer_subject_uid\n\nUID in the subject section of the certificate. String type.\n",
  "tls_peer_issuer_unit": "### $tls_peer_issuer_unit\n\norganizationalUnitName in the issuer section of the certificate. String\ntype.\n",
  "tls_my_subject_unit": "### $tls_my_subject_unit\n\norganizationalUnitName in the subject section of the certificate. String\ntype.\n",
  "tls_my_subject_uid": "### $tls_my_subject_uid\n\nUID in the subject section of the certificate. String type.\n",
  "tls_my_issuer_unit": "### $tls_my_issuer_unit\n\norganizationalUnitName in the issuer section of the certificate. String\ntype.\n",
  "tls_peer_san_email": "### $tls_peer_san_email\n\nemail address in the \"subject alternative name\" extension. String type.\n",
  "tls_my_san_email": "### $tls_my_san_email\n\nemail address in the \"subject alternative name\" extension. String type.\n",
  "tls_peer_san_hostname": "### $tls_peer_san_hostname\n\nhostname (DNS) in the \"subject alternative name\" extension. String type.\n",
  "tls_my_san_hostname": "### $tls_my_san_hostname\n\nhostname (DNS) in the \"subject alternative name\" extension. String type.\n",
  "tls_peer_san_uri": "### $tls_peer_san_uri\n\nURI in the \"subject alternative name\" extension. String type.\n",
  "tls_my_san_uri": "### $tls_my_san_uri\n\nURI in the \"subject alternative name\" extension. String type.\n",
  "tls_peer_san_ip": "### $tls_peer_san_ip\n\nip address in the \"subject alternative name\" extension. String type.\n",
  "tls_my_san_ip": "### $tls_my_san_ip\n\nip address in the \"subject alternative name\" extension. String type.\n",
  "tls_peer_verified": "### $tls_peer_verified\n\nReturns 1 if the peer's certificate was successfully verified. Otherwise\nit returns 0. String and Integer type.\n",
  "tls_peer_revoked": "### $tls_peer_revoked\n\nReturns 1 if the peer's certificate was revoked. Otherwise it returns 0.\nString and Integer type.\n",
  "tls_peer_expired": "### $tls_peer_expired\n\nReturns 1 if the peer's certificate is expired. Otherwise it returns 0.\nString and Integer type.\n",
  "tls_peer_selfsigned": "### $tls_peer_selfsigned\n\nReturns 1 if the peer's certificate is selfsigned. Otherwise it returns\n0. String and Integer type.\n",
  "tls_peer_notBefore": "### $tls_peer_notBefore\n\nReturns the notBefore validity date of the peer's certificate. String\ntype.\n",
  "tls_peer_notAfter": "### $tls_peer_notAfter\n\nReturns the notAfter validity date of the peer's certificate. String\ntype.\n",
  "tls_peer_server_name": "### $tls_peer_server_name\n\nThe SNI server name of the peer\n",
  "tls_peer_raw_cert": "### $tls_peer_raw_cert\n\nThe raw PEM-encoded client certificate. String type.\n",
  "tls_my_raw_cert": "### $tls_my_raw_cert\n\nThe raw PEM-encoded client certificate. String type.\n",
  "tls_peer_urlencoded_cert": "### $tls_peer_urlencoded_cert\n\nThe PEM-encoded client certificate, urlencoded. String type.\n",
  "tls_my_urlencoded_cert": "### $tls_my_urlencoded_cert\n\nThe PEM-encoded client certificate, urlencoded. String type.\n",
  "msg": "### $msg(attr)\n\nReturn attributes of SIP message:\n\n- $msg(len) - sip message length\n- $msg(buf) - sip message buffer\n- $msg(body) - sip message body\n- $msg(body_len) - sip message body length\n- $msg(hdrs) - sip message headers (surrounding white space and EoL\n  chars trimmed)\n- $msg(fline) - sip message first line (surrounding white space and\n  EoL chars trimmed)\n- $msg(fpart) - sip message first line and the headers\n- $msg(lpart) - sip message headers and the body\n",
  "pos": "### $pos(key)\n\nGet attributes after a function of the module is executed.\n\nThe key can be:\n\n- ret - the return code on success or -1\n- idx - position inside message buffer, for find/search it is the\n  start of matching\n- len - the length of matching string for search functions\n",
  "hu": "### $hu\n\n- URL of http request.\n",
  "msrp": "### $msrp(conid)\n\nThe internal integer id for TCP/TLS connection.\n",
  "sipt": "### $sipt(generic_number)\n\nReturns the value (Address signal) of the Generic Number for the IAM\nmessage. Returns -1 if there is a parsing error or if the Generic Number\nis not present.\n",
  "cfg": "## $cfg(key) - Config File Attributes\n\nAttributes related to configuration file.\n\nThe key can be:\n\n- line - return the current line in config\n- name - return the name of current config file\n- file - return the name of current config file\n- route - return the name of routing block\n\nExample:\n\n```c\nsend_reply(\"404\", \"Not found at line $cfg(line)\");\n```\n",
  "dns": "## $dns(pvid=>key) - DNS Query Result\n\nThis variable stores the DNS result details after a call of\ndns_query(hostname, pvid) function from ipops module.\n\n- pvid can be any string\n- key can be:\n  - count - number of addresses\n  - ipv4 - set to 1 if at least one ipv4 address (otherwise 0)\n  - ipv6 - set to 1 if at least one ipv6 address (otherwise 0)\n  - addr[index] - the address as string from position index in the\n    list (0 based indexing)\n  - type[index] - the type of address from position index in the\n    list (0 based indexing), the value is 4 for ipv4 and 6 for ipv6\n\nThe index can be an integer or a variable with integer value. First\naddress has the index 0. If negative value, the returned address is\ncounted from the end of the list, -1 being the last address. If no index\nis provided, then the first address is returned.\n\n```c\nif(dns_query(\"test.com\", \"xyz\"))\n{\n    xlog(\" number of addresses: $dns(xyz=>count)\\n\");\n    xlog(\" ipv4 address found: $dns(xyz=>ipv4)\\n\");\n    xlog(\" ipv6 address found: $dns(xyz=>ipv6)\\n\");\n    $var(i) = 0;\n    while($var(i)&lt;$dns(xyz=>count)) {\n        xlog(\" #[$var(i)] type ($dns(xyz=>type[$var(i)]))\"\n             \" addr [$dns(xyz=>addr[$var(i)])]\\n\");\n        $var(i) = $var(i) + 1;\n    }\n}\n```\n",
  "HN": "## $HN(key) - Hostname details\n\nGive local hostname details (implemented by ipops module).\n\nThe key can be:\n\n- n - the hostname\n- f - the fullname\n- d - the domain\n- i - the ip address\n\n```c\nxlog(\"local hostanme is $HN(n)\\n\");\n```\n",
  "RANDOM": "## $RANDOM - Random number\n\nReturns a random value from the [0 - 2^31) range.\n(Part of the cfgutils module)\n\n```c\nif (rand_event()) {\n  $avp(i:10) = ($RANDOM / 16777216); # 2^24\n  if ($avp(i:10) < 10) {\n     $avp(i:10) = 10;\n  }\n  append_to_reply(\"Retry-After: $avp(i:10)\\n\");\n  sl_send_reply(\"503\", \"Try later\");\n  exit;\n};\n# normal message processing follows\n```\n",
  "jsonrpl": "### $jsonrpl(key) - JSONRPC Reply\n\nThis variable gives access to JSONRPC reply after executing\njsonrpc_exec(...) in kamailio.cfg.\n\nThe key can be:\n\n- code - code for the JSONRPC response\n- text - text of the code for the JSONRPC response\n- body - the body of the JSONRPC response\n",
  "lsock": "## $lsock(expr)\n\nGet attributes for listen sockets (from corex module).\n\nThe **expr** is an expression specifying what to match and return, the\nformat is:\n\n```\nmatchid/value/field\n```\n\nThe **expr** can contain variables that are evaluated before parsing the\nexpression.\n\nThe **matchid** can be:\n\n- n - match on name\n- l - match on listen address\n\nThe **value** specifies what to match with.\n\nThe **field** can be (only first character matches):\n\n- name - return name\n- listen - return the listen address\n- advertise - return the advertise address\n- index - return the index in the list of all sockets\n\nExample:\n\n```\nlisten=udp:127.0.0.1:5060 advertise 127.0.0.1:5090 name \"s0\"\n...\nxinfo(\"$lsock(n/s0/listen)\\n\");\nxinfo(\"$lsock(l/udp:127.0.0.1:5060/name)\\n\");\n$var(s0) = \"n/s0/listen\";\nxinfo(\"$lsock($var(s0))\\n\");\n```\n",
  "evr": "### $evr(key)\n\nevrexec attributes:\n\n- $evr(data) - processing data\n- $evr(srcip) - source ip\n- $evr(srcport) - sourceport as string\n- $evr(srcportno) - source port as number\n",
  "subs": "### $subs(key) - Subscription Attributes\n\nThis variable gives access to attributes of the current subscription.\nThe variable has to be used after executing *handle_subscription()* in\norder to provide accurate values.\n\nThe key can be:\n\n- uri - subscription URI. Useful in particular for subscriptions\n  within the dialog, when the request URI in SUBSCRIBE is the Contact\n  address from the initial subscription.\n",
  "ulc": "### $ulc(profile=>attr) - Registered Contact Attributes\n\nAccess the attributes of contact addresses stored in 'profile'.\n\nIt must be used after a call of \u201creg_fetch_contacts()\u201d.\n",
  "hep": "### $hep(key) - HEP Packet Attributes\n\nThe key refers to HEP packet header values:\n\n- version - HEP version\n- src_ip - source IP address\n- dst_ip - destination IP address\n- 0x000 - HEP attribute 0x000\n- 0x999 - HEP attribute 0x999\n",
  "sruid": "## $sruid - Unique ID\n\n- $sruid - return unique ID generated internally Kamailio\n",
  "ltt": "## $ltt(key) - Local To-Tag\n\n$ltt(key) - return local generated To-tag when Kamailio sends a reply\n\n- $ltt(s) - the to-tag used in stateless replies\n- $ltt(t) - the to-tag used in transaction stateful replies\n  (transaction has to be created at that time, eg., by t_newtran() or\n  in a branch/failure route, otherwise it returns $null)\n- $ltt(x) - $ltt(t) if the transaction was created already, otherwise\n  $ltt(s)\n",
  "via0": "## $via0(attr) - Via[0] Attributes\n\n$via0(attr) - attributes of first Via header.\n\nThe attr can be:\n\n- host - host part (string)\n- port - port (number)\n- proto - protocol - transport part (string)\n- protoid - protocol id (integer id)\n- branch - branch parameter\n- rport - rport parameter value (string)\n- received - received parameter value (string)\n- i - i parameter value (string)\n- params - all parameters\n- oc - 0 if the oc parameter is not present; 1 if present but no value; 2 if present with value\n- ocval - value of oc parameter\n- ocalgo - the value of oc-algo parameter\n- ocvalidity - the value of oc-validity parameter\n- ocseq - the value of oc-seq parameter\n",
  "via1": "## $via1(attr) - Second Via Attributes\n\n$via1(attr) - attributes of second Via header. The attr can be the same\nas for $via0(attr).\n",
  "viaZ": "## $viaZ(attr) - Last Via Attributes\n\n$viaZ(attr) - attributes of last Via header. The attr can be the same as\nfor $via0(attr).\n",
  "C": "## $C(xy) - Foreground and background colors\n\n$C(xy) - reference to an escape sequence. \u201cx\u201d represents the foreground\ncolor and \u201cy\u201d represents the background color.\n\nColors could be:\n\n- x : default color of the terminal\n- s : Black\n- r : Red\n- g : Green\n- y : Yellow\n- b : Blue\n- p : Purple\n- c : Cyan\n- w : White\n",
  "K": "## $K(key) - Kamailio Constants\n\n$K(key) - return the numeric values corresponding to Kamailio\nconfiguration constants.\n\nThe key can be:\n\n- IPv4 - return AF_INET\n- IPv6 - return AF_INET6\n- UDP - return PROTO_UDP\n- TCP - return PROTO_TCP\n- TLS - return PROTO_TLS\n- SCTP - return PROTO_SCTP\n- WS - return PROTO_WS\n- WSS - return PROTO_WSS\n\n```c\nxinfo(\"proto UDP numeric id: $K(UDP)\\n\");\n```\n"
 },
 "transformations": {
  "s.len": "Return strlen of PV value\n\n```\n$var(x) = \"abc\";\nif($(var(x){s.len}) == 3)\n{\n   ...\n}\n```\n",
  "s.int": "Return integer value of a string-represented number\n\n```\n$var(x) = \"1234\";\nif($(var(x){s.int})==1234) {\n  ...\n}\n```\n",
  "s.md5": "Return md5 over PV value\n\n```\nxlog(\"md5 over From username: $(fU{s.md5})\");\n```\n",
  "s.sha256": "Return sha 256 over PV value\n\n```\nxlog(\"sha 256 over From username: $(fU{s.sha256})\");\n```\n",
  "s.sha384": "Return sha 384 over PV value\n\n```\nxlog(\"sha 384 over From username: $(fU{s.sha384})\");\n```\n",
  "s.sha512": "Return sha 512 over PV value\n\n```\nxlog(\"sha 512 over From username: $(fU{s.sha512})\");\n```\n",
  "s.substr": "Return substring starting at offset having size of 'length'. If offset\nis negative, then it is counted from the end of PV value, -1 being the\nlast char. In case of positive value, 0 is first char. Length must be\npositive, in case of 0, substring to the end of PV value is returned.\noffset and length can be PV as well.\n\nExample:\n\n```\n$var(x) = \"abcd\";\n$(var(x){s.substr,1,0}); => \"bcd\"\n```\n",
  "s.select": "Return a field from PV value. The field is selected based on separator\nand index. The separator must be a character used to identify the\nfields. Index must be an integer value or a PV. If index is negative, the\ncount of fields starts from end of PV value, -1 being last field. If\nindex is positive, 0 is the first field.\n\nExample:\n\n```\n$var(x) = \"12,34,56\";\n$(var(x){s.select,1,,}) => \"34\" ;\n\n$var(x) = \"12,34,56\";\n$(var(x){s.select,-2,,}) => \"34\"\n```\n",
  "s.encode.7bit": "Return encoding in 7Bit of PV value\n",
  "s.decode.7bit": "Return decoding of PV value in 7Bit\n",
  "s.encode.hexa": "Return encoding in hexa of PV value\n",
  "s.decode.hexa": "Return decoding from hexa of PV value\n",
  "s.encode.base58": "Return base58 encoding of PV value.\n\nThe set of base58 digits is:\n\n```\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n```\n",
  "s.decode.base58": "Return base58 decoding of PV value.\n",
  "s.encode.base64": "Return base64 encoding of PV value\n",
  "s.decode.base64": "Decode base64 encoded PV and return value\n",
  "s.encode.base64t": "Return base64 encoding of PV value without trailing padding\ncharacters('=').\n",
  "s.decode.base64t": "Decode base64 encoded PV, handling missing trailing padding characters,\nand return value.\n",
  "s.encode.base64url": "Return base64-url encoding of PV value\n",
  "s.decode.base64url": "Decode base64-url encoded PV and return value\n",
  "s.encode.base64urlt": "Return base64-url encoding of PV value without trailing padding\ncharacters('=').\n",
  "s.decode.base64urlt": "Decode base64-url encoded PV, handling missing trailing padding\ncharacters, and return value.\n",
  "s.escape.common": "Return escaped string of PV value. Characters escaped are ', \", \\ and\n0. Useful when doing DB queries (care should be taken for non Latin\ncharacter set).\n",
  "s.unescape.common": "Return unescaped string of PV value. Reverse of above transformation.\n",
  "s.escape.user": "Return escaped string of PV value, changing to '%hexa' the characters\nthat are not allowed in user part of SIP URI following RFC requirements.\n",
  "s.unescape.user": "Return unescaped string of PV value, changing '%hexa' to character code.\nReverse of above transformation.\n",
  "s.escape.param": "Return escaped string of PV value, changing to '%hexa' the characters\nthat are not allowed in the param part of SIP URI following RFC\nrequirements.\n",
  "s.unescape.param": "Return unescaped string of PV value, changing '%hexa' to character code.\nReverse of above transformation.\n",
  "s.escape.csv": "Escapes a string to use as a CSV field, as specified in RFC4180:\n\n```\n * enclose string in double quotes\n * escape double quotes with a second double quote\n```\n\nExample:\n\n```c\n$var(x) = 'foo,bar\"baz';\n$(var(x){s.escape.csv}); # contains '\"foo,bar\"\"baz\"'\n```\n",
  "s.numeric": "Removes all non-numeric parts of string.\n\nExample:\n\n```\n$var(x) = \"(040)1234/567-89\";\n$(var(x){s.numeric}) => \"040123456789\" ;\n```\n",
  "s.tolower": "Return string with lower case ASCII letters.\n",
  "s.toupper": "Return string with upper case ASCII letters.\n",
  "s.strip": "Return string after removing starting 'len' characters. Parameter 'len'\ncan be positive integer or pseudo-variable holding a positive integer.\n\nExample:\n\n```c\n$var(x) = \"1234\";\n$var(y) = $(var(x){s.strip,2}); # resulted value is \"34\"\n```\n",
  "s.striptail": "Return string after removing ending 'len' characters. Parameter 'len'\ncan be positive integer or pseudo-variable holding a positive integer.\n",
  "s.prefixes": "Return series of comma separated prefixes of the pv. Parameter 'len' is\noptional and will limit the maximum prefix length.\n\nExample:\n\n```c\n$var(x) = \"123456\";\n$(var(x){s.prefixes}) => 1,12,123,1234,12345,123456\n$(var(x){s.prefixes,4} => 1,12,123,1234\n```\n",
  "s.prefixes.quoted": "Return series of comma separated quoted prefixes of the pv. Parameter\n'len' is optional and will limit the maximum prefix length.\n\nExample:\n\n```c\n$var(x) = \"123456\";\n$(var(x){s.prefixes.quoted} => '1','12','123','1234','12345','123456'\n$(var(x){s.prefixes.quoted,4} => '1','12','123','1234'\n```\n",
  "s.replace": "Replace all occurrences of **match** with **repl**. The parameters can\nbe pseudo-variables.\n\nExample:\n\n```c\n$var(x) = \"abababa\";\n$(var(x){s.replace,a,c} => \"cbcbcbc\"\n```\n",
  "s.ftime": "Format the epoch in the pv according to the parameter. The parameter has\nto be strftime formatting string.\n\n```c\n$(TS{s.ftime,%Y-%m-%d %H:%M:%S})\n```\n",
  "s.trim": "Remove left and right whitespaces (' ', '\\t', '\\r', '\\n') around PV\nvalue.\n\n```c\n$(var(x){s.trim})\n```\n",
  "s.rtrim": "Remove right whitespaces (' ', '\\t', '\\r', '\\n') around PV value.\n\n```c\n$(var(x){s.rtrim})\n```\n",
  "s.ltrim": "Remove left whitespaces (' ', '\\t', '\\r', '\\n') around PV value.\n\n```c\n$(var(x){s.ltrim})\n```\n",
  "s.rm": "Remove occurrences of 'match' from PV. 'match' can be static string or\nvariable.\n\n```c\n$(var(x){s.rm,test})\n```\n",
  "s.rmws": "Remove occurrences of whitespace characters (' ', '\\t, '\\r', '\\n').\n\n```c\n$(var(x){s.rmws})\n```\n",
  "s.corehash": "Return the hash id computed with Kamailio's core hashing function. The\nparameter n is optional, it has to be a number of a pv holding a number.\nIf n is provided, the value returned is **(hashid)&(n-1)**. If n is\npower of two, the result is the modulo operation between hashid and n\n(hash id % n).\n\nNote: the value is returned as string.\n\n```c\n$(var(x){s.corehash})\n```\n",
  "s.unquote": "Return the value without surrounding single (') or double quotes (\").\n\n```c\n$var(x) = \"\\\"alice\\\"\";\n$var(alice) = $(var(x){s.unquote});\n```\n",
  "s.unbracket": "Return the value without surrounding (), [], {} or <>.\n\n```c\n$var(x) = \"<sip:alice@test.sip>\";\n$var(uri) = $(var(x){s.unbracket});\n```\n",
  "s.count": "Count how many times c appears in the pv value.\n\n```c\n\"abababa\"{s.count,a}\n# will return 4\n```\n",
  "s.after": "Return the part of the string after the character **x** searched from\nthe start of the value. If the character **x** is not found, it returns\nempty string.\n\n```c\n\"abcdef\"{s.after,c}\n# will return \"def\"\n```\n",
  "s.rafter": "Return the part of the string after the character **x** searched from\nthe end of the value. If the character **x** is not found, it returns\nempty string.\n\n```c\n\"abcdefcgh\"{s.rafter,c}\n# will return \"gh\"\n```\n",
  "s.before": "Return the part of the string before the character **x** searched from\nthe start of the value. If the character **x** is not found, it returns\nthe entire input string.\n\n```c\n\"abcdef\"{s.before,c}\n# will return \"ab\"\n```\n",
  "s.rbefore": "Return the part of the string before the character **x** searched from\nthe end of the value. If the character **x** is not found, it returns\nthe entire input string.\n\n```c\n\"abcdefcgh\"{s.rbefore,c}\n# will return \"abcdef\"\n```\n",
  "s.fmtlines": "Format the value in lines of n characters, adding m spaces to the start\nof each new line (not to first line). Each line is ended with \"\\r\\n\"\napart of last line.\n\n```c\n\"abcdefgh\"{s.fmtlines,4,2}\n```\n",
  "s.fmtlinet": "Format the value in lines of n characters, adding m tabs to the start of\neach new line (not to first line). Each line is ended with \"\\r\\n\"\napart of last line.\n\n```c\n\"abcdefgh\"{s.fmtlinet,4,2}\n```\n",
  "s.urlencode.param": "Encode the value for URL param format.\n",
  "s.urldecode.param": "Decode the value from URL param format.\n",
  "uri.user": "Return the user part\n",
  "uri.host": "(same as **{uri.domain}**)\n\nReturn the domain part\n",
  "uri.passwd": "Return the password\n",
  "uri.port": "Return the port\n",
  "uri.params": "Return the URI parameters in a string\n",
  "uri.param": "Return the value of parameter with name 'name'\n",
  "uri.headers": "Return URI headers\n",
  "uri.transport": "Return the value of transport parameter\n",
  "uri.ttl": "Return the value of ttl parameter\n",
  "uri.uparam": "Return the value of user parameter\n",
  "uri.maddr": "Return the value of maddr parameter\n",
  "uri.method": "Return the value of method parameter\n",
  "uri.lr": "Return the value of lr parameter\n",
  "uri.r2": "Return the value of r2 parameter\n",
  "uri.scheme": "Return the string value of URI scheme.\n",
  "uri.tosocket": "Return the string value corresponding to socket address matching proto,\naddress and port from the URI. In other words, converts from a format\nlike **<sip:address:port;transport=proto>** to **proto:address:port**.\n\nExample:\n\n```\n\"sip:test@127.0.0.1:5060;transport=udp\"{uri.tosocket} => \"udp:127.0.0.1:5060\"\n```\n",
  "uri.duri": "Return the destination URI for routing, keeping only schema, host, port\nand transport parameter. If port and transport are not in the original\nvalue, they are also not in the returned value.\n\nExample:\n\n```c\n$var(ouri) = \"sip:alice@server.com:5060;nat=yes;transport=tcp;line=xyz\";\n$var(duri) = $(var(ouri){uri.duri}); # => \"sip:server.com:5060;transport=tcp\"\n```\n",
  "uri.saor": "Return the SIP AoR, keeping only schema, user and host. If user is not\nin the original value, it is also not in the returned value.\n\nExample:\n\n```c\n$var(ouri) = \"sip:alice@server.com:5060;nat=yes;transport=tcp;line=xyz\";\n$var(suri) = $(var(ouri){uri.saor}); # => \"sip:alice@server.com\"\n```\n",
  "uri.suri": "Return the simple URI for routing, keeping only schema, user, host, port\nand transport parameter. If user, port and transport are not in the\noriginal value, they are also not in the returned value.\n\nExample:\n\n```c\n$var(ouri) = \"sip:alice@server.com:5060;nat=yes;transport=tcp;line=xyz\";\n$var(suri) = $(var(ouri){uri.suri}); # => \"sip:alice@server.com:5060;transport=tcp\"\n```\n",
  "param.value": "Return the value of parameter 'name'\n\nExample:\n\n```\n\"a=1;b=2;c=3\"{param.value,c} = \"3\"\n```\n\n'name' can be a pseudo-variable\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n",
  "param.in": "Return 1 if the parameter 'name' is found in parameters list, 0 if not\nfound.\n\nExample:\n\n```\n\"a=1;b=2;c=3\"{param.in,c} = 1\n```\n\n'name' can be a pseudo-variable\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n",
  "param.valueat": "Return the value of parameter at position given by 'index' (0-based\nindex)\n\nExample:\n\n```\n\"a=1;b=2;c=3\"{param.valueat,1} = \"2\"\n```\n\n'index' can be a pseudo-variable\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n",
  "param.name": "Return the name of parameter at position 'index'.\n\nExample:\n\n```\n\"a=1;b=2;c=3\"{param.name,1} = \"b\"\n```\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n",
  "param.count": "Return the number of parameters in the list.\n\nExample:\n\n```\n\"a=1;b=2;c=3\"{param.count} = 3\n```\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n",
  "nameaddr.name": "Return the value of display name\n\nExample:\n\n```\n'\"test\" <sip:test@kamailio.net>' {nameaddr.name} = \"test\"\n```\n",
  "nameaddr.uri": "Return the value of URI\n\nExample:\n\n```\n'\"test\" <sip:test@kamailio.net>' {nameaddr.uri} = sip:test@kamailio.net\n```\n",
  "nameaddr.len": "Return the length of the entire name-addr part from the value.\n",
  "tobody.uri": "* return URI from To body\n",
  "tobody.display": "* return Display name from To body\n",
  "tobody.tag": "* return Tag parameter from To body\n",
  "tobody.user": "* return URI User from To body\n",
  "tobody.host": "* return URI Host from To body\n",
  "tobody.params": "* return parameters part from To body\n",
  "line.count": "Return the number of lines.\n\nExample:\n\n```c\n$(var(x){line.count})\n```\n",
  "line.at": "Return the line at position 'pos'. The index start from 0. Negative\nposition can be used to count from last line (which is -1). The pos can\nbe also a variable holding the index value.\n\nExample:\n\n```c\n$(var(x){line.at,2})\n```\n",
  "line.sw": "Return the line starting with **match**.\n\nExample:\n\n```c\n$(var(x){line.sw,mytext})\n```\n",
  "msrpuri.user": "User part of a MSRP URI.\n",
  "msrpuri.host": "Host part of a MSRP URI.\n",
  "msrpuri.port": "Port part of a MSRP URI.\n",
  "msrpuri.session": "Session ID part of a MSRP URI.\n",
  "msrpuri.proto": "Transport layer part of a MSRP URI.\n",
  "msrpuri.params": "Parameters part of a MSRP URI.\n",
  "msrpuri.userinfo": "User-Info part of a MSRP URI. This is the same as user part, when there\nare no user parameters or password fields. Otherwise, it include the\nwhole part after scheme and before '@' in front of host.\n",
  "re.subst": "Perform POSIX regex substitutions on string value pseudo-variables.\n\n```c\n# Assign Request-URI user to PV\n$var(user) = $(ru{re.subst,/^sip:(.*)@(.*)/\\1/});\n```\n\n```c\n# Assign Request-URI user to PV, where every 'A' has been replaced by 'a'\n$var(user) = $(rU{re.subst,/A/a/g});\n```\n\nThe prototype is:\n\n```c\n{re.subst,/match_expression/replacement_expression/flags}\n```\n\n- match_expression - Posix regular expression\n- replacement_expression - substitution expression with back\n  references to matched tokes: \\1, \\2, ..., \\9\n- flags:\n  - i - match ignore case\n  - s - match within multi-lines strings\n  - g - replace all matches\n",
  "sql.val": "This transformation outputs valid SQL values for various PV values:\n\n- <null> values are output as NULL\n- integers are output as integers\n- everything else is output as quoted and escaped string\n\n```c\n    $var(null) = $null;\n    $avp(null) = $null;\n    $avp(str) = \"String with \\ illegal \\\\characters\";\n    $avp(nr) = 12345;\n    $avp(strnr) = \"12345\";\n\n    xlog(\"$$rm = $rm = $(rm{sql.val})\");\n    xlog(\"$$var(null) = $var(null) = $(var(null){sql.val})\");\n    xlog(\"$$avp(null) = $avp(null) = $(avp(null){sql.val})\");\n    xlog(\"$$avp(str) = $avp(str) = $(avp(str){sql.val})\");\n    xlog(\"$$avp(nr) = $avp(nr) = $(avp(nr){sql.val})\");\n    xlog(\"$$avp(strnr) = $avp(strnr) = $(avp(strnr){sql.val})\");\n\n  Output:\n    $rm = ACK = 'ACK'\n    $var(null) = 0 = 0\n    $avp(null) = <null> = NULL\n    $avp(str) = String with \\ illegal \\characters = 'String with \\\\ illegal \\\\characters'\n    $avp(nr) = 12345 = 12345\n    $avp(strnr) = 12345 = '12345'\n```\n",
  "sql.val.int": "Like sql.val, but output number 0 for null values.\n",
  "sql.val.str": "Like sql.val, but output string '' for null values.\n",
  "url.path": "Path part of an HTTP URL.\n\nFor example,\n\n```\n# When the first line of HTTP request is\n# \"GET /path/to/file/?this=is&the=querystring\"\n\n$(hu{url.path}) => \"/path/to/file/\"\n```\n",
  "url.querystring": "Query string part of an HTTP URL. For example,\n\n```\n# When the first line of HTTP request is\n# \"GET /path/to/file/?this=is&the=querystring\"\n\n$(hu{url.querystring}) => \"this=is&the=querystring\"\n```\n",
  "json.parse": "You can use the transformation to extract values from the json\nstructured pseudo-variables\n\n```\n$var(Custom-Data) = $(rb{json.parse,Custom-Data});\n```\n",
  "sock.host": "Return the host part.\n",
  "sock.port": "Return the port part.\n",
  "sock.proto": "Return the proto part.\n",
  "sock.touri": "Return the socket address converted to SIP URI:\n**<sip:host:port;transport=proto>**.\n",
  "urialias.encode": "Encode SIP URI to alias value.\n\n```c\n\"sip:127.0.0.1:5060;transport=udp\"{urialias.encode} => \"127.0.0.1~5060~1\"\n```\n",
  "urialias.decode": "Decode from alias value to SIP URI.\n\n```c\n\"127.0.0.1~5060~1\"{urialias.decode} => \"sip:127.0.0.1:5060;transport=udp\"\n```\n",
  "val.json": "If value is $null, return empty string; if value is string, then it is\nescaped for use as json value (without surrounding quotes.\n\n```c\n$var(x) = '\"name\" <sip:name@a.com>';\n$(var(x){val.json}) => \\\"name\\\" <sip:name@a.com>\n```\n",
  "val.n0": "Return integer 0 for values that are $null.\n\n```c\n$sht(a=>x) = $null;\n$(sht(a=>x){val.n0}) => 0\n```\n",
  "val.ne": "Return empty string for values that are $null.\n\n```c\n$sht(a=>x) = $null;\n# $(sht(a=>x){val.ne});\n```\n",
  "val.jsonqe": "If value is $null, return quoted empty string; if value is string, then\nit is escaped for use as json value already with surrounding quotes; if\nthe value is int, then it is preserved as it is.\n\n```c\n$var(x) = '\"name\" <sip:name@a.com>';\n$(var(x){val.jsonqe}) => \"\\\"name\\\" <sip:name@a.com>\"\n```\n"
 }
}