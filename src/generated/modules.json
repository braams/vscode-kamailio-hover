{
 "acc": {
  "overview": "ACC module is used to account transactions information to different\nbackends like syslog and SQL. With the separate module \u201cacc_radius\u201d\nsupport for radius is enabled.\n\nThere is some very early support of the Diameter protocol in the\n\u201cacc_diameter\u201d module, but is not up to date with the current Diameter\nprotocols. If you need Diameter support, please use the ims_charging\nmodule.\n\nTo account a transaction and to choose which set of backends to be used,\nthe script writer just has to set some flags (see the module parameters\nsection for flag definitions [Parameters](#acc.i.params)). If the\naccounting flag for a specific backend is set, the acc module will then\nreport on completed transaction. A typical usage of the module takes no\nacc-specific script command -- the functionality binds invisibly through\ntransaction processing. Script writers just need to mark the transaction\nfor accounting with proper setflag. Even so, the module allows the\nscript writer to force accounting in special cases via some script\nfunctions.\n\nThe accounting module will log by default a fixed set of attributes for\nthe transaction - if you customize your accounting by adding more\ninformation to be logged, please see the next chapter about extra\naccounting - [Extra accounting](#acc.i.extra-accounting).\n\nThe fixed minimal accounting information is:\n\n- Request Method name\n\n- From header TAG parameter\n\n- To header TAG parameter\n\n- Call-Id\n\n- 3-digit Status code from final reply\n\n- Reason phrase from final reply\n\n- Time stamp when transaction was completed\n\nIf a value is not present in request, the empty string is accounted\ninstead.\n\nNote that:\n\n- A single INVITE may produce multiple accounting reports -- that's due\n  to SIP forking feature.\n\n- All flags related to accounting need to be set in request processing\n  route - only the \"missed-call\" flag may be toggled from other types of\n  routes.\n\n- If a UA fails in middle of conversation, a proxy will never find out\n  about it. In general, a better practice is to account from an\n  end-device (such as PSTN gateway), which best knows about call status\n  (including media status and PSTN status in case of the gateway).\n  However, CDR-based logging has the option to log existing information\n  from expired dialogs (the dlg_vars in cdr_extra) Please see\n  cdr_expired_dlg_enable parameter - [\n  (integer)](#acc.p.cdr_expired_dlg_enable).\n\nThe SQL backend support is compiled in the module.\n",
  "parameters": {
   "early_media": "### `early_media` (integer)\n\nShould be early media (any provisional reply with body) accounted too ?\n\nDefault value is 0 (no).\n\n```\n...\nmodparam(\"acc\", \"early_media\", 1)\n...\n```\n",
   "failed_transaction_flag": "### `failed_transaction_flag` (integer)\n\nPer transaction flag which says if the transaction should be accounted\nalso in case of failure (SIP status code >= 300). This flag triggers\naccounting when the whole transaction fails (on the server side).\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc\", \"failed_transaction_flag\", 4)\n...\n```\n",
   "failed_filter": "### `failed_filter` (string)\n\nA string of failure response codes from 300 to 999 separated by commas.\nFailed transaction will not be accounted if its response code is in the\nlist even when failed_transaction_flag is set.\n\nDefault value is not-set (failure filtering is off).\n\n```\n...\nmodparam(\"acc\", \"failed_filter\", \"404,407\")\n...\n```\n",
   "report_ack": "### `report_ack` (integer)\n\nShall acc attempt to account e2e ACKs too ? Note that this is really\nonly an attempt, as e2e ACKs may take a different path (unless RR\nenabled) and mismatch original INVITE (e2e ACKs are a separate\ntransaction). The flag for accounting has to be set for each ACK as\nwell.\n\nDefault value is 0 (no).\n\n```\n...\nmodparam(\"acc\", \"report_ack\", 1)\n...\n```\n",
   "report_cancels": "### `report_cancels` (integer)\n\nBy default, CANCEL reporting is disabled -- most accounting applications\nwants to see INVITE's cancellation status. Turn on if you explicitly\nwant to account CANCEL transactions.\n\nDefault value is 0 (no).\n\n```\n...\nmodparam(\"acc\", \"report_cancels\", 1)\n...\n```\n",
   "detect_direction": "### `detect_direction` (integer)\n\nControls the direction detection for sequential requests. If enabled\n(non zero value), for sequential requests with upstream direction (from\ncallee to caller), the FROM and TO will be swapped (the direction will\nbe preserved as in the original request).\n\nIt affects all values related to TO and FROM headers (body, URI,\nusername, domain, TAG).\n\nDefault value is 0 (disabled).\n\n```\n...\nmodparam(\"acc\", \"detect_direction\", 1)\n...\n```\n",
   "acc_prepare_flag": "### `acc_prepare_flag` (integer)\n\nPer transaction flag which says if the transaction may be accounted\nlater, with flags set in TM module specific routes (e.g., like\nfailure_route). If this flag is not set and acc or missed_call flag are\nnot set either in request route block, there is no way to mark the\nrequest for transaction later unless you set acc_prepare_always. If\neither acc or missed_call flags are set in request route block, there is\nno need to set this flag.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc\", \"acc_prepare_flag\", 5)\n...\n```\n",
   "acc_prepare_always": "### `acc_prepare_always` (integer)\n\nPrepare all request even if acc_prepare_flag is not set to mark the\nrequest for transaction later.\n\nDefault value is not-set (previous behaviour).\n\n```\n...\nmodparam(\"acc\", \"acc_prepare_always\", 1)\n...\n```\n",
   "acc_extra_nullable": "### `acc_extra_nullable` (integer)\n\nIf set to 1, the database acc extra fields are set to NULL if the\ncorresponding script variable is not defined or has $null value. If set\nto 0, the value is saved as empty string (the existing behavior).\n\nDatabase columns may need to be altered to DROP NOT NULL constraints and\nDROP DEFAULT values in order to accept NULL values.\n\nDefault value is 0.\n\n```\n...\nmodparam(\"acc\", \"acc_extra_nullable\", 1)\n...\n```\n",
   "multi_leg_info": "### `multi_leg_info` (string)\n\nDefines the AVP set to be used in per-call-leg accounting. See [Multi\nCall-Legs accounting](#acc.i.multi-call-legs) for a detailed description\nof the Multi Call-Legs accounting.\n\nIf empty, the multi-leg accounting support will be disabled.\n\nDefault value is 0 (disabled).\n\n```\n...\n# for syslog-based accounting, use any text you want to be printed\nmodparam(\"acc\", \"multi_leg_info\",\n    \"text1=$avp(src);text2=$avp(dst)\")\n# for mysql-based accounting, use the names of the columns\nmodparam(\"acc\", \"multi_leg_info\",\n    \"leg_src=$avp(src);leg_dst=$avp(dst)\")\n# for DIAMETER-based accounting, use the DIAMETER AVP ID (as integer)\nmodparam(\"acc\", \"multi_leg_info\",\n    \"2345=$avp(src);2346=$avp(dst)\")\n...\n```\n",
   "log_flag": "### `log_flag` (integer)\n\nRequest flag which needs to be set to account a transaction via syslog.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc\", \"log_flag\", 2)\n...\n```\n",
   "log_missed_flag": "### `log_missed_flag` (integer)\n\nRequest flag which needs to be set to account missed calls via syslog.\nThis can be used to e.g. account failures during the call setup phase\nfrom the callee (client) side, for example if you do forking to several\ndestinations.\n\nKeep in mind that this flag is reset after branch completion. Therefore\nit is necessary to set it again e.g. in a failure_route if you do serial\nforking and want to log all attempts.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc\", \"log_missed_flag\", 3)\n...\n```\n",
   "log_level": "### `log_level` (integer)\n\nLog level at which accounting messages are issued to syslog.\n\nDefault value is 1 (L_NOTICE).\n\n```\n...\nmodparam(\"acc\", \"log_level\", 2)   # Set log_level to 2 (L_INFO)\n...\n```\n",
   "log_facility": "### `log_facility` (string)\n\nLog facility to which accounting messages are issued to syslog. This\nallows to easily separate the accounting specific logging from the other\nlog messages.\n\nDefault value is LOG_DAEMON.\n\n```\n...\nmodparam(\"acc\", \"log_facility\", \"LOG_DAEMON\")\n...\n```\n",
   "log_extra": "### `log_extra` (string)\n\nExtra values to be logged. See section [Extra\naccounting](#acc.i.extra-accounting) for more details.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc\", \"log_extra\", \"ua=$hdr(User-Agent);uuid=$avp(i:123)\")\n...\n```\n",
   "db_flag": "### `db_flag` (integer)\n\nRequest flag which needs to be set to account a transaction -- database\nspecific.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc\", \"db_flag\", 2)\n...\n```\n",
   "db_missed_flag": "### `db_missed_flag` (integer)\n\nRequest flag which needs to be set to account missed calls via database.\nThis can be used to e.g. account failures during the call setup phase\nfrom the callee (client) side, for example if you do forking to several\ndestinations.\n\nKeep in mind that this flag is reset after branch completion. Therefore\nit is necessary to set it again e.g. in a failure_route if you do serial\nforking and want to log all attempts.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc\", \"db_missed_flag\", 3)\n...\n```\n",
   "db_table_acc": "### `db_table_acc` (string)\n\nTable name of accounting successful calls -- database specific. It can\ncontain config variables that will be evaluated at runtime.\n\nDefault value is \u201cacc\u201d\n\n```\n...\nmodparam(\"acc\", \"db_table_acc\", \"myacc_table\")\nmodparam(\"acc\", \"db_table_acc\", \"acc_$time(year)_$time(mon)\")\n...\n```\n",
   "db_table_missed_calls": "### `db_table_missed_calls` (string)\n\nTable name for accounting missed calls -- database specific. It can\ncontain config variables that will be evaluated at runtime.\n\nDefault value is \u201cmissed_calls\u201d\n\n```\n...\nmodparam(\"acc\", \"db_table_missed_calls\", \"myMC_table\")\n...\n```\n",
   "db_url": "### `db_url` (string)\n\nSQL address -- database specific. If it is set to NULL or empty string,\nthe SQL support is disabled.\n\nDefault value is \u201cNULL\u201d (SQL disabled).\n\n```\n...\nmodparam(\"acc\", \"db_url\", \"mysql://user:password@localhost/kamailio\")\n...\n```\n",
   "acc_method_column": "### `acc_method_column` (string)\n\nColumn name in accounting table to store the request's method name as\nstring.\n\nDefault value is \u201cmethod\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_method_column\", \"method\")\n...\n```\n",
   "acc_from_tag_column": "### `acc_from_tag_column` (string)\n\nColumn name in accounting table to store the From header TAG parameter.\n\nDefault value is \u201cfrom_tag\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_from_tag_column\", \"from_tag\")\n...\n```\n",
   "acc_to_tag_column": "### `acc_to_tag_column` (string)\n\nColumn name in accounting table to store the To header TAG parameter.\n\nDefault value is \u201cto_tag\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_to_tag_column\", \"to_tag\")\n...\n```\n",
   "acc_callid_column": "### `acc_callid_column` (string)\n\nColumn name in accounting table to store the request's Callid value.\n\nDefault value is \u201ccallid\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_callid_column\", \"callid\")\n...\n```\n",
   "acc_sip_code_column": "### `acc_sip_code_column` (string)\n\nColumn name in accounting table to store the final reply's numeric code\nvalue in string format.\n\nDefault value is \u201csip_code\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_sip_code_column\", \"sip_code\")\n...\n```\n",
   "acc_sip_reason_column": "### `acc_sip_reason_column` (string)\n\nColumn name in accounting table to store the final reply's reason phrase\nvalue.\n\nDefault value is \u201csip_reason\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_sip_reason_column\", \"sip_reason\")\n...\n```\n",
   "acc_time_column": "### `acc_time_column` (string)\n\nColumn name in accounting table to store the time stamp of the\ntransaction completion in date-time format.\n\nDefault value is \u201ctime\u201d.\n\n```\n...\nmodparam(\"acc\", \"acc_time_column\", \"time\")\n...\n```\n",
   "db_extra": "### `db_extra` (string)\n\nExtra values to be logged into database - DB specific. See section\n[Extra accounting](#acc.i.extra-accounting) for more details.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc\", \"db_extra\", \"ct=$hdr(Content-type); email=$avp(s:email)\")\n...\n```\n",
   "db_insert_mode": "### `db_insert_mode` (integer)\n\nIf set to 1, use INSERT DELAYED to add records to accounting tables when\nthe DB driver has support for it. If no INSERT DELAYED support is\noffered by DB driver, then standard INSERT is used. Beware that MySQL\nInnoDB engine doesn't support INSERT DELAYED, thus be sure the acc\ntables are defined with different type (e.g., MyISAM).\n\nIf set to 2, async insert is used if the db driver module has support\nfor it and if async_workers core parameter value is greater than 0. If\nnot, then standard INSERT is used.\n\nDefault value is 0 (no INSERT DELAYED nor async insert).\n\n```\n...\nmodparam(\"acc\", \"db_insert_mode\", 1)\n...\n```\n",
   "cdr_enable": "### `cdr_enable` (integer)\n\nEnable CDR reporting - one record per call reported to \"acc_cdrs\" table,\nrelying on dialog module.\n\nThe value can be:\n\n- 0 - off (default).\n\n- 1 - on.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"acc\", \"cdr_enable\", 1)\n...\n```\n",
   "cdr_skip": "### `cdr_skip` (string)\n\nSkip cdr generation for dialogs with this dlg_var set.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc\", \"cdr_skip\", \"nocdr\")\n...\n```\n",
   "cdr_expired_dlg_enable": "### `cdr_expired_dlg_enable` (integer)\n\nShould CDR-based logging be enabled in case of expired dialogs?\n\n- 0 - off (default).\n\n- 1 - on.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"acc\", \"cdr_expired_dlg_enable\", 1)\n...\n```\n",
   "cdr_start_on_confirmed": "### `cdr_start_on_confirmed` (integer)\n\nShould the start time be taken from the time when the dialog is created,\nor when the dialog is confirmed?\n\n- 0 - use time of dialog creation (default).\n\n- 1 - use time of dialog confirmation.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"acc\", \"cdr_start_on_confirmed\", 1)\n...\n```\n",
   "cdr_facility": "### `cdr_facility` (integer)\n\nLog facility to which CDR messages are issued to syslog. This allows to\neasily separate CDR-specific logging from the other log messages.\n\nDefault value is LOG_DAEMON.\n\n```\n...\nmodparam(\"acc\", \"cdr_facility\", \"LOG_DAEMON\")\n...\n```\n",
   "cdr_extra": "### `cdr_extra` (string)\n\nSet of pseudo-variables defining custom CDR fields. See [CDR\nExtra](#acc.i.cdr-extra) for more details.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc\", \"cdr_extra\", \"c1=$dlg_var(caller);c2=$dlg_var(callee)\"\n...\n```\n",
   "cdr_extra_nullable": "### `cdr_extra_nullable` (integer)\n\nShould custom CDR fields be saved as NULL?\n\nIf set to 0, custom CDR fields not defined in config operation (or set\nto $null) will be saved as empty string. If set to 1, custom CDR fields\nnot defined in config operation (or set to $null) will be saved as\nNULL.\n\nDatabase columns may need to be altered to DROP NOT NULL constraints and\nDROP DEFAULT values in order to accept NULL values.\n\nDefault value is 0.\n\n```\n...\nmodparam(\"acc\", \"cdr_extra_nullable\", 1)\n...\n```\n",
   "cdr_start_id": "### `cdr_start_id` (string)\n\nModifying the id which is used to store the start time.\n\nDefault value is 'start_time'\n\n```\n...\nmodparam(\"acc\", \"cdr_start_id\", \"start\")\n...\n```\n",
   "cdr_end_id": "### `cdr_end_id` (string)\n\nModifying the id which is used to store the end time.\n\nDefault value is 'end_time'\n\n```\n...\nmodparam(\"acc\", \"cdr_end_id\", \"end\")\n...\n```\n",
   "cdr_duration_id": "### `cdr_duration_id` (string)\n\nModify the id which is used to store the duration.\n\nDefault value is 'duration'\n\n```\n...\nmodparam(\"acc\", \"cdr_duration_id\", \"d\")\n...\n```\n",
   "cdr_log_enable": "### `cdr_log_enable` (int)\n\nControl if CDR-based accounting should be written to syslog.\n\n0 - off. 1 - on (default).\n\n```\n...\nmodparam(\"acc\", \"cdr_log_enable\", 0)\n...\n```\n",
   "cdrs_table": "### `cdrs_table` (str)\n\nName of db table to store dialog-based CDRs.\n\nDefault value is \"\" (no db storage for dialog-based CDRs).\n\n```\n...\nmodparam(\"acc\", \"cdrs_table\", \"acc_cdrs\")\n...\n```\n",
   "time_mode": "### `time_mode` (int)\n\nStore additional value related to the time of event.\n\nValues can be:\n\n- *0* - (default), save only unix timestamp for syslog and datetime for\n  database.\n\n- *1* - save seconds in time_attr and microseconds in time_exten.\n\n- *2* - save seconds.milliseconds in time_attr.\n\n- *3* - save formatted time according to time_format parameter, using\n  the output of localtime(). Used for cdr entries too.\n\n- *4* - save formatted time according to time_format parameter, using\n  the output of gmtime(). Used for cdr entries too.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"acc\", \"time_mode\", 1)\n...\n```\n",
   "time_attr": "### `time_attr` (str)\n\nName of the syslog attribute or database column where to store\nadditional value related to the time of event.\n\nFor db accounting, the column has to be of different types, depending on\ntime_mode value. When time_mode is:\n\n- *1* - time_attr column has to be int.\n\n- *2* - time_attr column has to be double.\n\n- *3* - time_attr column has to be varchar(128).\n\n- *4* - time_attr column has to be varchar(128).\n\nFor time_mode=1, this attribute is not written in syslog, because time\nvalue is already unix timestamp, but in db accounting time value is\ndatetime and requires a function to get the timestamp.\n\n```\n...\nmodparam(\"acc\", \"time_attr\", \"seconds\")\n...\n```\n",
   "time_exten": "### `time_exten` (str)\n\nName of the syslog attribute or database column where to store extended\nvalue related to the time of event.\n\nIt is used now only for time_mode=1 and database column has to be int:\n\n```\n...\nmodparam(\"acc\", \"time_exten\", \"microsecs\")\n...\n```\n",
   "time_format": "### `time_format` (str)\n\nSpecify the format to print the time for time_mode 3 or 4.\n\nDefault value is %Y-%m-%d %H:%M:%S\".\n\n```\n...\nmodparam(\"acc\", \"time_format\", \"%Y/%m/%d %H:%M:%S\")\n...\n```\n",
   "reason_from_hf": "### `reason_from_hf` (int)\n\nTells where to take sip_reason from. If value is 0, sip_reason is taken\nfrom status line. Otherwise, sip_reason is taken from Reason header\nfield(s) if present. Currently only the first Reason header is used.\n\nDefault value is 0.\n\n```\n...\nmodparam(\"acc\", \"reason_from_hf\", 1)\n...\n```\n",
   "clone_msg": "### `clone_msg` (int)\n\nIf set to 1, request structure from transaction is cloned temporarily in\nthe callback to get acc attributes. It is required if you account values\nfrom SIP headers to avoid concurrent access to the shared memory\ntransaction structure, specially when accounting 1xx events. If set to\n0, it uses directly the shared memory structure, be sure you store all\nneeded attributes in AVPs/XAVPs inside request route.\n\nDefault value is 1.\n\n```\n...\nmodparam(\"acc\", \"clone_msg\", 0)\n...\n```\n",
   "cdr_on_failed": "### `cdr_on_failed` (int)\n\nIf set to 1, the module stores the CDR for a failed dialog (calls not\nanswered). If set to 0, those records are not stored, only those for\nanswered calls.\n\nDefault value is 1.\n\n```\n...\nmodparam(\"acc\", \"cdr_on_failed\", 0)\n...\n```\n",
   "acc_extra_size": "### `acc_extra_size` (int)\n\nSet the maximum number of extra attributes that can be stored in the\naccounting record (event accounting record). It is related to log_extra\nand db_extra module parameters.\n\nDefault value is 64.\n\n```\n...\nmodparam(\"acc\", \"acc_extra_size\", 100)\n...\n```\n",
   "cdr_extra_size": "### `cdr_extra_size` (int)\n\nSet the maximum number of extra attributes that can be stored in the\ncall data record (cdr by dialog module). It is related to cdr_extra\nmodule parameter.\n\nDefault value is 64.\n\n```\n...\nmodparam(\"acc\", \"cdr_extra_size\", 100)\n...\n```\n"
  },
  "functions": {
   "acc_log_request": "### `acc_log_request(comment)`\n\n`acc_request` reports on a request, for example, it can be used to\nreport on missed calls to off-line users who are replied 404 - Not\nFound. To avoid multiple reports on UDP request retransmission, you\nwould need to embed the action in stateful processing.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The string can contain any number\n  of pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nacc_log_request(\"Some comment\");\n$var(code) = 404;\n$avp(reason) = \"Not found\";\nacc_log_request(\"$var(code) Error: $avp(reason)\");\n...\n```\n",
   "acc_db_request": "### `acc_db_request(comment, table)`\n\nLike `acc_log_request`, `acc_db_request` reports on a request. The\nreport is sent to database at \u201cdb_url\u201d, in the table referred to in the\nsecond action parameter.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The string can contain any number\n  of pseudo-variables.\n\n- *table* - Database table to be used. It can contain config variables\n  that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nacc_db_request(\"Some comment\", \"SomeTable\");\nacc_db_request(\"Some comment\", \"acc_$time(year)_$time(mon)\");\nacc_db_request(\"$var(code) Error: $avp(reason)\", \"SomeTable\");\n...\n```\n",
   "acc_request": "### `acc_request(comment, table)`\n\nWrapper around `acc_log_request` and `acc_db_request` functions, writing\nthe accounting record to LOG and DATABASE backends. If \u201cdb_url\u201d\nparameter is not set, the acc record is written only to LOG backend.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be used for generating the SIP response code\n  and text fields, if in the format \u201cCODE TEXT\u201d. The CODE should be a\n  valid SIP response code (100..699). The TEXT can be one or many words.\n  If CODE is missing, then 0 is used. The parameter can contain\n  pseudo-variables.\n\n- *table* - Database table to be used. It can contain config variables\n  that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nacc_request(\"100 Received\", \"acc\");\nacc_request(\"100 Received\", \"acc_$time(year)_$time(mon)\");\nacc_db_request(\"$var(code) $avp(reason)\", \"acc\");\n...\n```\n"
  }
 },
 "acc_diameter": {
  "overview": "ACC_DIAMETER module is used to account transactions information to a\nDIAMETER server. Read also the documentation for 'acc' module.\n\nNOTE: This was developed based on some very early version of the\nDiameter protocol, and has not been really tested for many years. It is\nvery likely to be deleted in upcoming releases. If you want to revive\nthis module, you are welcome, be sure you do proper testing before using\nin production -- it also may need to be updated first to match the\nexported API by 'acc' module.\n\nNOTE: diameter support was developed for DISC (DIameter Server Client\nproject at http://developer.berlios.de/projects/disc/). This project\nseems to be no longer maintained and DIAMETER specifications were\nupdated in the meantime. Thus, the DIAMETER part in the module is\nobsolete and needs rework to be usable with opendiameter or other\nDIAMETER servers.\n\nIMPORTANT: If you need Diameter accounting, consider to use the\nims_charging module, it is up to date and used in IMS/VoLTE deployments.\n",
  "parameters": {
   "diameter_flag": "### `diameter_flag` (integer)\n\nRequest flag which needs to be set to account a transaction -- DIAMETER\nspecific.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_diameter\", \"diameter_flag\", 2)\n...\n```\n",
   "diameter_missed_flag": "### `diameter_missed_flag` (integer)\n\nRequest flag which needs to be set to account missed calls -- DIAMETER\nspecific.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_diameter\", \"diameter_missed_flag\", 3)\n...\n```\n",
   "diameter_client_host": "### `diameter_client_host` (string)\n\nHostname of the machine where the DIAMETER Client is running -- DIAMETER\nspecific.\n\nDefault value is \u201clocalhost\u201d.\n\n```\n...\nmodparam(\"acc_diameter\", \"diameter_client_host\", \"3a_server.net\")\n...\n```\n",
   "diameter_client_port": "### `diameter_client_port` (int)\n\nPort number where the Diameter Client is listening -- DIAMETER specific.\n\nDefault value is 3000.\n\n```\n...\nmodparam(\"acc_diameter\", \"diameter_client_port\", 3000)\n...\n```\n",
   "diameter_extra": "### `diameter_extra` (string)\n\nExtra values to be logged via DIAMETER - DIAMETER specific. See section\nthe section about extra accounting in 'acc' module for more details.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc_diameter\", \"diameter_extra\", \"7846=$hdr(Content-type);7847=$avp(s:email)\")\n...\n```\n"
  },
  "functions": {
   "acc_diam_request": "### `acc_diam_request(comment)`\n\nLike `acc_log_request`, `acc_diam_request` reports on a request. It\nreports to the configured Diameter server.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The string can contain any number\n  of pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nacc_diam_request(\"Some comment\");\nacc_diam_request(\"$var(code) Error: $avp(reason)\");\n...\n```\n"
  }
 },
 "acc_json": {
  "overview": "ACC_JSON module is used to account transaction information in a JSON\ndictionary. It binds to ACC module API and uses the same accounting\nmechanisms as for other backends.\n\nIt can output the JSON dictionary to MQUEUE or SYSLOG (even if Kamailio\nis not using syslog)\n",
  "parameters": {
   "acc_flag": "### `acc_flag` (integer)\n\nRequest flag which needs to be set to account a transaction in acc_json.\nSee acc_output_mqueue and acc_output_syslog\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_json\", \"acc_flag\", 2)\n...\n        \n```\n",
   "acc_missed_flag": "### `acc_missed_flag` (integer)\n\nRequest flag which needs to be set to account missed calls in acc_json.\nSee acc_output_mqueue and acc_output_syslog\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_json\", \"acc_missed_flag\", 3)\n...\n```\n",
   "acc_extra": "### `acc_extra` (string)\n\nExtra values to be added to the json dictionary.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc_json\", \"acc_extra\", \"via=$hdr(Via[*]); email=$avp(s:email)\")\n...\n```\n",
   "acc_json_pre_encoded_prefix": "### `acc_json_pre_encoded_prefix` (string)\n\nPrefix to identify values that will be considered to be already json\nencoded.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc_json\", \"acc_extra\", \"json_data=$avp(json_data);\")\nmodparam(\"acc_json\", \"acc_json_pre_encoded_prefix\", \"json_\")\n...\n$avp(json_data) = '{\"b\":2, \"c\":3}';\n...\n```\n",
   "acc_time_mode": "### `acc_time_mode` (integer)\n\nStore additional value related to the time of event.\n\nValues can be:\n\n- *0* - (default), save only unix timestamp for syslog and datetime for\n  database.\n\n- *1* - save seconds in time_attr and microseconds in time_exten.\n\n- *2* - save seconds.milliseconds in time_attr.\n\n- *3* - save formatted time according to time_format parameter, using\n  the output of localtime(). Used for cdr entries too.\n\n- *4* - save formatted time according to time_format parameter, using\n  the output of gmtime(). Used for cdr entries too.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"acc_json\", \"acc_time_mode\", 1)\n...\n        \n```\n",
   "acc_time_format": "### `acc_time_format` (str)\n\nSpecify the format to print the time for time_mode 3 or 4.\n\nDefault value is %Y-%m-%d %H:%M:%S\".\n\n```\n...\nmodparam(\"acc_json\", \"acc_time_format\", \"%Y/%m/%d %H:%M:%S\")\n...\n```\n",
   "acc_output_mqueue": "### `acc_output_mqueue` (integer)\n\nRequires the mqueue module. The acc module will queue json acc events in\nthe specified mqueue. Using a rtimer module exec you can access the\nqueue and process them.\n\nYou can also fetch the acc events using mqueue.fetch over JSON-RPC.\n\nDefault value is not-set mqueue will not be required.\n\n```\n...\n# example using json_mqueue/http_client to publish to NSQD\nmax_while_loops=100000\nmodparam(\"mqueue\", \"mqueue\", \"name=acc_events;size=100000\")\nmodparam(\"acc_json\", \"acc_output_mqueue\", \"acc_events\")\nmodparam(\"acc_json\", \"acc_flag\", 2)\nmodparam(\"acc_json\", \"acc_extra\", \"caller_ip_port=$avp(caller_ip_port);\")\nmodparam(\"rtimer\", \"timer\", \"name=nsqt;interval=1;mode=1;\")\nmodparam(\"rtimer\", \"exec\", \"timer=nsqt;route=RUN_CDR_PUBLISH\")\nmodparam(\"http_client\", \"keep_connections\", 1)\nmodparam(\"http_client\", \"httpcon\", \"nsqd=>http://localhost:4151/pub?topic=acc\")\n\nroute[RUN_ACC_PUBLISH] {\n   $var(count) = 0;\n   while (mq_fetch(\"acc_events\")) {\n      $var(q_size) = mq_size(\"acc_events\");\n      $var(count) = $var(count) + 1;\n      xinfo(\"[RUN_ACC_PUBLISH][$var(q_size)][$var(count)][$mqk(acc_events)][$mqv(acc_events)]\\n\");\n      $var(res) = http_connect_raw(\"nsqd\", \"\", \"application/json\", $mqv(acc_events), \"$var(nsq_res)\");\n      if ($var(res) < 0) {\n         xerr(\"[RUN_ACC_PUBLISH][$var(res)] http_connect_raw: timeout or error !\\n\");\n         mq_add(\"acc_events\", \"acc_key\", \"$mqv(acc_events)\");\n      } else if ($var(res) < 200 || $var(res) > 299) {\n         xerr(\"[RUN_ACC_PUBLISH][$var(res)] http unexpected response code !\\n\");\n         mq_add(\"acc_dead_letter_queue\", \"acc_key\", \"$mqv(acc_events)\");\n         return;\n      }\n   }\n   if ($var(count) > 0 ) {\n      xinfo(\"[RUN_CDR_PUBLISH]done count[$var(count)]\\n\");\n   }\n}\n...\n```\n",
   "acc_output_syslog": "### `acc_output_syslog` (integer)\n\nControl if the output of acc json should be sent to syslog. This is not\ndependent on Kamailio global logging settings, we can use syslog even if\nKamailio is not daemonized and/or logging is done to sdtout stderr.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_json\", \"acc_output_syslog\", 1)\nmodparam(\"acc_json\", \"acc_log_level\", 2)\nmodparam(\"acc_json\", \"acc_log_facility\", \"LOG_DAEMON\")\n...\n```\n",
   "acc_log_facility": "### `acc_log_facility` (integer)\n\nLog facility to which accounting messages are issued to syslog. This\nallows to easily separate the accounting specific logging from the other\nlog messages.\n\nDefault value is LOG_DAEMON.\n\n```\n...\nmodparam(\"acc_json\", \"acc_log_facility\", \"LOG_LOCAL0\")\n\n# modify you syslog/rsyslog config\n# /etc/rsyslog.d/default.conf\n# remove local0 from default log file\n# *.*;local0,auth,authpriv.none /var/log/syslog\n# add local0 to another log file\n# local0.*                      /var/log/json_acc.log\n...\n```\n",
   "acc_log_level": "### `acc_log_level` (integer)\n\nLog level at which accounting messages are issued to syslog.\n\nDefault value is 1 (L_NOTICE).\n\n```\n...\nmodparam(\"acc_json\", \"acc_log_level\", 2) # Set acc_log_level to 2 (L_INFO)\n...\n```\n",
   "cdr_enable": "### `cdr_enable` (int)\n\nEnable CDR reporting - one record per call is reported, relying on\ndialog module.\n\nThe value can be:\n\n- 0 - off (default).\n\n  1 - on.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"acc_json\", \"cdr_enable\", 1)\n...\n```\n",
   "cdr_extra": "### `cdr_extra` (str)\n\nSet of pseudo-variables defining custom CDR fields.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc_json\", \"cdr_extra\", \"ci=$dlg_var(call_id);ft=$dlg_var(from_tag)\")\n...\n```\n",
   "cdr_pre_encoded_prefix": "### `cdr_pre_encoded_prefix` (string)\n\nPrefix to identify values that will be considered to be already json\nencoded.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc_json\", \"cdr_extra\", \"json_data=$avp(json_data);\")\nmodparam(\"acc_json\", \"cdr_pre_encoded_prefix\", \"json_\")\n...\n$avp(json_data) = '{\"b\":2, \"c\":3}';\n...\n```\n",
   "cdr_expired_dlg_enable": "### `cdr_expired_dlg_enable` (str)\n\nShould CDR-based logging be enabled in case of expired dialogs?\n\n0 - off (default). 1 - on.\n\n```\n...\nmodparam(\"acc_json\", \"cdr_expired_dlg_enable\", 1)\n...\n```\n",
   "cdr_output_mqueue": "### `cdr_output_mqueue` (integer)\n\nRequires the mqueue module. The acc module will queue json cdr events in\nthe specified mqueue. Using a rtimer module exec you can access the\nqueue and process them.\n\nYou can also fetch the cdr events using mqueue.fetch over JSON-RPC.\n\nDefault value is not-set mqueue will not be required.\n\n```\n...\n# example using json_mqueue/http_client to publish to NSQD\nmodparam(\"mqueue\", \"mqueue\", \"name=cdr_events;size=100000\")\nmodparam(\"acc_json\", \"cdr_enable\", 1)\nmodparam(\"acc_json\", \"cdr_output_mqueue\", \"cdr_events\")\nmodparam(\"acc_json\", \"cdr_extra\", \"ci=$dlg_var(call_id)\")\nmodparam(\"rtimer\", \"timer\", \"name=nsqt;interval=1;mode=1;\")\nmodparam(\"rtimer\", \"exec\", \"timer=nsqt;route=RUN_CDR_PUBLISH\")\nmodparam(\"http_client\", \"keep_connections\", 1)\nmodparam(\"http_client\", \"httpcon\", \"nsqd=>http://localhost:4151/pub?topic=acc\")\n\nroute[RUN_CDR_PUBLISH] {\n   $var(count) = 0;\n   while (mq_fetch(\"cdr_events\")) {\n      $var(q_size) = mq_size(\"cdr_events\");\n      $var(count) = $var(count) + 1;\n      xinfo(\"[RUN_CDR_PUBLISH][$var(q_size)][$var(count)][$mqk(cdr_events)][$mqv(cdr_events)]\\n\");\n      $var(res) = http_connect_raw(\"nsqd\", \"\", \"application/json\", $mqv(cdr_events), \"$var(nsq_res)\");\n      if ($var(res) < 0) {\n         xerr(\"[RUN_CDR_PUBLISH][$var(res)] http_connect_raw: timeout or error !\\n\");\n         mq_add(\"cdr_events\", \"cdr_key\", \"$mqv(cdr_events)\");\n      } else if ($var(res) < 200 || $var(res) > 299) {\n         xerr(\"[RUN_CDR_PUBLISH][$var(res)] http unexpected response code !\\n\");\n         mq_add(\"cdr_dead_letter_queue\", \"cdr_key\", \"$mqv(cdr_events)\");\n         return;\n      }\n   }\n   if ($var(count) > 0 ) {\n      xinfo(\"[RUN_CDR_PUBLISH]done count[$var(count)]\\n\");\n   }\n}\n...\n```\n",
   "cdr_output_syslog": "### `cdr_output_syslog` (integer)\n\nThe acc module will log json cdr events to syslog.\n",
   "cdr_log_facility": "### `cdr_log_facility` (integer)\n\nLog facility to which accounting messages are issued to syslog. This\nallows to easily separate the accounting specific logging from the other\nlog messages.\n\nDefault value is LOG_DAEMON.\n\n```\n...\nmodparam(\"acc_json\", \"cdr_log_facility\", \"LOG_LOCAL0\")\n\n# modify you syslog/rsyslog config\n# /etc/rsyslog.d/default.conf\n# remove local0 from default log file\n# *.*;local0,auth,authpriv.none /var/log/syslog\n# add local0 to another log file\n# local0.*                      /var/log/json_cdr.log\n...\n```\n",
   "cdr_log_level": "### `cdr_log_level` (integer)\n\nLog level at which accounting messages are issued to syslog.\n\nDefault value is 1 (L_NOTICE).\n\n```\n...\nmodparam(\"acc_json\", \"cdr_log_level\", 2) # Set cdr_log_level to 2 (L_INFO)\n...\n```\n"
  },
  "functions": {}
 },
 "acc_radius": {
  "overview": "ACC_RADIUS module is used to account transaction information to RADIUS\nserver. It binds to ACC module API and uses the same accounting\nmechanisms as for other backends.\n\nTherefore you need this module just to send accounting data to a RADIUS\nserver - for more documentation regarding accounting, see the ACC\nreadme.\n",
  "parameters": {
   "radius_config": "### `radius_config` (string)\n\n*This parameter is radius specific.* Path to radius client configuration\nfile, set the referred config file correctly and specify there address\nof server, shared secret (should equal that in\n/usr/local/etc/raddb/clients for freeRadius servers) and dictionary, see\netc for an example of config file and dictionary.\n\nIf the parameter is set to empty string, the RADIUS accounting support\nwill be disabled (even if compiled).\n\nDefault value is \u201cNULL\u201d.\n\n```\n...\nmodparam(\"acc_radius\", \"radius_config\", \"/etc/radiusclient/radiusclient.conf\")\n...\n```\n",
   "radius_flag": "### `radius_flag` (integer)\n\nRequest flag which needs to be set to account a transaction -- RADIUS\nspecific.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_radius\", \"radius_flag\", 2)\n...\n```\n",
   "radius_missed_flag": "### `radius_missed_flag` (integer)\n\nRequest flag which needs to be set to account missed calls -- RADIUS\nspecific.\n\nDefault value is not-set (no flag).\n\n```\n...\nmodparam(\"acc_radius\", \"radius_missed_flag\", 3)\n...\n```\n",
   "service_type": "### `service_type` (integer)\n\nRadius service type used for accounting.\n\nDefault value is 15 (SIP).\n\n```\n...\nmodparam(\"acc_radius\", \"service_type\", 16)\n...\n```\n",
   "radius_extra": "### `radius_extra` (string)\n\nExtra values to be logged via RADIUS - RADIUS specific.\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"acc_radius\", \"radius_extra\", \"via=$hdr(Via[*]); email=$avp(s:email)\")\n...\n```\n",
   "rad_time_mode": "### `rad_time_mode`(integer)\n\nRadius Event-Timestamp for accounting.\n\nValues can be:\n\n- *0* - (default), format is only unix timestamp for Event-Timestamp\n  (For example: 1445590624)\n\n- *1* - format is unix timestamp with microseconds in Addition, it needs\n  to change Event-Timestamp attribute type in dictionary to string both\n  radius server and client (For example: 1445590624.377372)\n\nDefault value is 0 (Unix timestamp).\n\n```\n...\nmodparam(\"acc_radius\", \"rad_time_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "acc_rad_request": "### `acc_rad_request(comment)`\n\nLike `acc_log_request` of acc module, `acc_rad_request` reports on a SIP\nrequest event. It reports to radius server as configured in\n\u201cradius_config\u201d.\n\nMeaning of the parameters is as follows:\n\n- *comment* - Comment to be appended. The first token can be a SIP\n  response code that it is wanted to be interpreted as event type (e.g.,\n  using 200 means the transaction is considered successfully responded).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nacc_rad_request(\"Some comment\");\n...\n# write record as when the transaction was responded with a 200 code\nacc_rad_request(\"200 From Config\");\n...\n```\n"
  }
 },
 "alias_db": {
  "overview": "The ALIAS_DB module can be used as an alternative for user aliases via\nusrloc. The main feature is that it does not store all adjacent data as\nfor user location and always uses the database for search (no memory\ncaching). A common use case is to provide additional user aliases, i.e.\nto supplement the registration in the location database. Users are this\nway on a proxy reachable with several request URIs.\n\nAs the module uses no memory caching the lookup is a bit slower but the\ndata provisioning is easier. With very fast databases like MySQL the\nspeed penalty can be lowered. Also, the search can be performed on\ndifferent tables in the same script.\n",
  "parameters": {
   "db_url": "### `db_url` (str)\n\nDatabase URL.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "user_column": "### `user_column` (str)\n\nName of the column storing username.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"user_column\", \"susername\")\n...\n```\n",
   "domain_column": "### `domain_column` (str)\n\nName of the column storing user's domain.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"domain_column\", \"sdomain\")\n...\n```\n",
   "alias_user_column": "### `alias_user_column` (str)\n\nName of the column storing alias username.\n\n*Default value is \u201calias_username\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"alias_user_column\", \"auser\")\n...\n```\n",
   "alias_domain_column": "### `alias_domain_column` (str)\n\nName of the column storing alias domain.\n\n*Default value is \u201calias_domain\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"alias_domain_column\", \"adomain\")\n...\n```\n",
   "use_domain": "### `use_domain` (int)\n\nSpecifies whether to use or not the domain from R-URI when searching for\nalias. If set to 0, the domain from R-URI is not used, if set to 1 the\ndomain from R-URI is used.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"use_domain\", 1)\n...\n```\n",
   "domain_prefix": "### `domain_prefix` (str)\n\nSpecifies the prefix to be stripped from the domain in R-URI before\ndoing the search.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"alias_db\", \"domain_prefix\", \"sip.\")\n...\n```\n",
   "append_branches": "### `append_branches` (int)\n\nIf the alias resolves to many SIP IDs, the first is replacing the R-URI,\nthe rest are added as branches.\n\n*Default value is \u201c0\u201d (0 - don't add branches; 1 - add branches).*\n\n```\n...\nmodparam(\"alias_db\", \"append_branches\", 1)\n...\n```\n"
  },
  "functions": {
   "alias_db_lookup": "### `alias_db_lookup(table_name[, flags])`\n\nThe function takes the R-URI and search to see whether it is an alias or\nnot. If it is an alias for a local user, the R-URI is replaced with\nuser's SIP uri.\n\nThe function returns TRUE if R-URI is alias and it was replaced by\nuser's SIP uri.\n\nMeaning of the parameters is as follows:\n\n- *table_name* - the name of the table where to search for alias. It can\n  include pseudo-variables.\n\n- *flags* (optional) - set of flags (char based flags) to control the\n  alias lookup process:\n\n  - *d* - do not use domain URI part in the alias lookup query (use only\n    a username-based lookup). By default, both username and domain are\n    used.\n\n  - *r* - do reverse alias lookup - lookup for the alias mapped to the\n    current URI (URI 2 alias translation); normally, the function looks\n    up for the URI mapped to the alias (alias 2 URI translation).\n\n  - *u* - use domain URI part in the alias lookup query. Default depends\n    on the module parameter use_domain.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nalias_db_lookup(\"dbaliases\", \"rd\");\nalias_db_lookup(\"dba_$(rU{s.substr,0,1})\");\n...\n```\n",
   "alias_db_find": "### `alias_db_find(table_name, input, output[, flags])`\n\nThe function is very similar to `alias_db_lookup()`, but instead of\nusing fixed input (RURI) and output (RURI) is able to get the input SIP\nURI from a pseudo-variable and place the result back also in a\npseudo-variable.\n\nThe function is useful as the alias lookup does not affect the request\nitself (no RURI changes), can be used in a reply context (as it does not\nwork with RURI only) and can be used for others URI than the RURI (To\nURI, From URI, custom URI).\n\nThe function returns TRUE if any alias mapping was found and returned.\n\nMeaning of the parameters is as follows:\n\n- *table_name* - any PV (string or PV or mix) the name of the table\n  where to search for alias.\n\n- *input* - any PV (string or PV or mix) carrying the SIP URI that needs\n  to be looked up.\n\n- *output* - PV (AVP or script VAR) where to place the SIP URI resulting\n  from the alias lookup.\n\n- *flags* (optional) - set of flags (char based flags) to control the\n  alias lookup process:\n\n  - *d* - do not use domain URI part in the alias lookup query (use only\n    a username-based lookup). Default depends on the module parameter\n    use_domain.\n\n  - *r* - do reverse alias lookup - lookup for the alias mapped to the\n    current URI (URI 2 alias translation); normally, the function looks\n    up for the URI mapped to the alias (alias 2 URI translation).\n\n  - *u* - use domain URI part in the alias lookup query. Default depends\n    on the module parameter use_domain.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, LOCAL_ROUTE,\nSTARTUP_ROUTE, FAILURE_ROUTE and ONREPLY_ROUTE.\n\n```\n...\n# do reverse alias lookup and find the alias for the FROM URI\nalias_db_find(\"dbaliases\" , \"$fu\", \"$avp(from_alias)\", \"r\");\n...\n```\n"
  }
 },
 "app_java": {
  "overview": "This module allows execution of Java compiled classes from the Kamailio\nconfig file, exporting functions to access the SIP message from Java\nusing the Java Native Interface (JNI).\n",
  "parameters": {
   "class_name": "### `class_name` (string)\n\nThe class name should have the same compiled file name. If the value is\n*\"Kamailio\"*, then the compiled file should be named as\n*\"Kamailio.class\"*.\n\n*Default value is \u201cKamailio\u201d.*\n\n```\n...\nmodparam(\"app_java\", \"class_name\", \"Kamailio\")\n...\n```\n",
   "child_init_method": "### `child_init_method` (string)\n\nTBD.\n\n*Default value is \u201cchild_init\u201d.*\n\n```\n...\nmodparam(\"app_java\", \"child_init_method\", \"my_mod_init\")\n...\n```\n",
   "java_options": "### `java_options` (string)\n\nJava options for Java Virtual Machine. For more info read [java\ndocs](http://docs.oracle.com/javase/6/docs/technotes/tools/windows/java.html)\n\n*Default value is \u201c-Djava.compiler=NONE\u201d.*\n\n```\n...\nmodparam(\"app_java\", \"java_options\", \"-Djava.compiler=NONE\")\n...\n\n...\n# Assumes \"application java folder\" is located at /opt/kamailio/java\nmodparam(\"app_java\", \"java_options\", \"-Djava.compiler=NONE\n    -Djava.class.path=/path/to/kamailio/modules:/opt/kamailio/java:\n    /opt/kamailio/java/kamailio.jar\")\n...\n\n...\n# Assumes \"application java folder\" is located at /opt/kamailio/java\nmodparam(\"app_java\", \"java_options\", \"-verbose:gc,class,jni\n    -Djava.compiler=NONE -Djava.class.path=/path/to/kamailio/modules:\n    /opt/kamailio/java:/opt/kamailio/java/kamailio.jar\")\n...\n\n...\n# Assumes \"application java folder\" is located at /opt/kamailio/java\nmodparam(\"app_java\", \"java_options\", \"-Xdebug -verbose:gc,class,jni\n    -Djava.compiler=NONE -Djava.class.path=/path/to/kamailio/modules:\n    /opt/kamailio/java:/opt/kamailio/java/kamailio.jar\")\n...\n```\n",
   "force_cmd_exec": "### `force_cmd_exec` (int)\n\nThis parameter forces execution a kamailio command with java native\nmethod \u201cKamExec\u201d. # Note: this is an untested yet feature, may cause\n(but may not) a memory leaks if used from embedded languages.\n\n*Default value is \u201c0 (off)\u201d.*\n\n```\n...\nmodparam(\"app_java\", \"force_cmd_exec\", 1)\n...\n```\n"
  },
  "functions": {
   "Common": "### Common requirements\n\nEach function has a required parameter \u201cmethod_signature\u201d. For more info\nsee [Determine the signature of a\nmethod](http://www.rgagnon.com/javadetails/java-0286.html). Signature\nrepresents the variable type. The mapping between the Java type and C\ntype is\n\n```\n        Type     Chararacter\n        boolean      Z\n        byte         B\n        char         C\n        double       D\n        float        F\n        int          I\n        long         J\n        object       L\n        short        S\n        void         V\n        Note that to specify an object, the \"L\" is followed by the\n        object's class name and ends with a semi-colon, ';' .\n                \n```\n\napp_java supports the following signatures:\n\n```\n        Primitives: Z,B,C,D,F,I,J,L,S,V\n        Objects:\n            Ljava/lang/Boolean;\n            Ljava/lang/Byte;\n            Ljava/lang/Character;\n            Ljava/lang/Double;\n            Ljava/lang/Float;\n            Ljava/lang/Integer;\n            Ljava/lang/Long;\n            Ljava/lang/Short;\n            Ljava/lang/String;\n            NULL parameter: V\n\n    Each parameter passed to function will be cast according to given signature.\n\n    Parameters are optional, omitting a parameter meant the passed value is NULL.\n    Parameters count should be exactly the same as signature count.\n    Note 1: Arrays representation (symbol '[') is not supported yet.\n    Note 2: You shall use a correct signature, e.g. the following examples\n    of combinations are invalid:\n        java_method_exec(\"ExampleMethod\", \"ZI\", \"False\");\n        java_method_exec(\"ExampleMethod\", \"LI\", \"something\", \"5\");\n```\n",
   "java_method_exec": "### java_method_exec(method, method_signature, [param1[, param2[, ...]]])\n\nExecutes a java class method *method*. Parameter *method_signature* is\nrequired.\n\n- Kamailio prototype\n\n  ```\n  java_method_exec(\"ExampleMethod\", \"V\");\n  ```\n\n  Java prototype\n\n  ```\n  public int ExampleMethod();\n  ```\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_method_exec(\"ExampleMethod\", \"V\");\n\n  # Java\n  public int ExampleMethod()\n  {\n      ... do something;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_method_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"Hello world\", \"5\");\n  ```\n\n  Java prototype\n\n  ```\n  public int ExampleMethod(String param1, int param2);\n  ```\n\n  In the above scenario parameter 2 (\"5\") will be cast to integer\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_method_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"$mb\", \"$ml\");\n\n  # Java\n  public int ExampleMethod(String SipMessageBuffer, int SipMessageLength)\n  {\n      ... do something with buffer;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_method_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n  ```\n\n  Java prototype\n\n  ```\n  public int ExampleMethod(boolean param1, byte param2);\n  ```\n\n  In the above scenario parameter 1 (\"true\") will be cast to boolean\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_method_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n\n  # Java\n  public int ExampleMethod(boolean flagSet, byte bFlag);\n  {\n      if (flagSet)\n      {\n          ... do something with flags;\n      }\n\n      return 1;\n  }\n  ```\n",
   "java_staticmethod_exec": "### java_staticmethod_exec(method, method_signature, [param1[, param2[, ...]]])\n\nExecutes a Java static method *method*. Parameter *method_signature* is\nrequired.\n\n- Kamailio prototype\n\n  ```\n  java_staticmethod_exec(\"ExampleMethod\", \"V\");\n  ```\n\n  Java prototype\n\n  ```\n  public static int ExampleMethod();\n  ```\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_staticmethod_exec(\"ExampleMethod\", \"V\");\n\n  # Java\n  public static int ExampleMethod()\n  {\n      ... do something;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_staticmethod_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"Hello world\", \"5\");\n  ```\n\n  Java prototype\n\n  ```\n  public static int ExampleMethod(String param1, int param2);\n  ```\n\n  In the above scenario parameter 2 (\"5\") will be cast to integer\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_staticmethod_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"$mb\", \"$ml\");\n\n  # Java\n  public static int ExampleMethod(String SipMessageBuffer, int SipMessageLength)\n  {\n      ... do something with buffer;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_staticmethod_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n  ```\n\n  Java prototype\n\n  ```\n  public static int ExampleMethod(boolean param1, byte param2);\n  ```\n\n  In the above scenario parameter 1 (\"true\") will be cast to boolean\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_staticmethod_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n\n  # Java\n  public static int ExampleMethod(boolean flagSet, byte bFlag);\n  {\n      if (flagSet)\n      {\n          ... do something with flags;\n      }\n\n      return 1;\n  }\n  ```\n",
   "java_s_method_exec": "### java_s_method_exec(method, method_signature, [param1[, param2[, ...]]])\n\nExecutes a Java class synchronized method *method*. Parameter\n*method_signature* is required.\n\nFor more info see [Synchronized\nMethods](http://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html)\n\n- Kamailio prototype\n\n  ```\n  java_s_method_exec(\"ExampleMethod\", \"V\");\n  ```\n\n  Java prototype\n\n  ```\n  public synchronized int ExampleMethod();\n  ```\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_s_method_exec(\"ExampleMethod\", \"V\");\n\n  # Java\n  public synchronized int ExampleMethod()\n  {\n      ... do something;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_s_method_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"Hello world\", \"5\");\n  ```\n\n  Java prototype\n\n  ```\n  public synchronized int ExampleMethod(String param1, int param2);\n  ```\n\n  In the above scenario parameter 2 (\"5\") will be cast to integer\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_s_method_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"$mb\", \"$ml\");\n\n  # Java\n  public synchronized int ExampleMethod(String SipMessageBuffer, int SipMessageLength)\n  {\n      ... do something with buffer;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_s_method_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n  ```\n\n  Java prototype\n\n  ```\n  public synchronized int ExampleMethod(boolean param1, byte param2);\n  ```\n\n  In the above scenario parameter 1 (\"true\") will be cast to boolean\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_s_method_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n\n  # Java\n  public synchronized int ExampleMethod(boolean flagSet, byte bFlag);\n  {\n      if (flagSet)\n      {\n          ... do something with flags;\n      }\n\n      return 1;\n  }\n  ```\n",
   "java_s_staticmethod_exec": "### java_s_staticmethod_exec(method, method_signature, [param1[, param2[, ...]]])\n\nExecutes a java synchronized static method *method*. Parameter\n*method_signature* is required.\n\nFor more info see [Synchronized\nMethods](http://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html)\n\n- Kamailio prototype\n\n  ```\n  java_s_staticmethod_exec(\"ExampleMethod\", \"V\");\n  ```\n\n  Java prototype\n\n  ```\n  public static synchronized int ExampleMethod();\n  ```\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_s_staticmethod_exec(\"ExampleMethod\", \"V\");\n\n  # Java\n  public static synchronized int ExampleMethod()\n  {\n      ... do something;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_s_staticmethod_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"Hello world\", \"5\");\n  ```\n\n  Java prototype\n\n  ```\n  public static synchronized int ExampleMethod(String param1, int param2);\n  ```\n\n  In the above scenario parameter 2 (\"5\") will be cast to integer\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_s_staticmethod_exec(\"ExampleMethod\", \"Ljava/lang/String;I\", \"$mb\", \"$ml\");\n\n  # Java\n  public static synchronized int ExampleMethod(String SipMessageBuffer, int SipMessageLength)\n  {\n      ... do something with buffer;\n      return 1;\n  }\n  ```\n\n- Kamailio prototype\n\n  ```\n  java_s_staticmethod_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n  ```\n\n  Java prototype\n\n  ```\n  public static synchronized int ExampleMethod(boolean param1, byte param2);\n  ```\n\n  In the above scenario parameter 1 (\"true\") will be cast to boolean\n  representation.\n\n  Example of usage:\n\n  ```\n  # Kamailio\n  java_s_staticmethod_exec(\"ExampleMethod\", \"ZB\", \"true\", \"0x05\");\n\n  # Java\n  public static synchronized int ExampleMethod(boolean flagSet, byte bFlag);\n  {\n      if (flagSet)\n      {\n          ... do something with flags;\n      }\n\n      return 1;\n  }\n  ```\n"
  }
 },
 "app_jsdt": {
  "overview": "This module allows executing JavaScript scripts from the Kamailio\nconfiguration file. It exports all KEMI functions to JavaScript in order\nto access the currently processed SIP message. These functions are named\nwithin the JavaScript object 'KSR'.\n\nThe module is based on the Duktape JavaScript engine\n(http://www.duktape.org), which is a fast and easy to embed JavaScript\ninterpreter. The exported API from Kamailio to JavaScript is documented\nin the wiki.\n\nThe module has two JavaScript contexts:\n\n- *first* is used for functions jsdt_dofile() and jsdt_dostring().\n\n- *second* is used for function jsdt_run() and parameter 'load'.\n  Therefore jsdt_run() cannot execute functions from scripts loaded via\n  jsdt_dofile() in config. This is kind of caching mode, avoiding\n  reading file every time, but you must be sure you do not have\n  something that is executed by default and requires access to SIP\n  message. This environment is also used by KEMI framework for the\n  config SIP routing functions.\n",
  "parameters": {
   "load": "### `load` (str)\n\nSet the path to the JavaScript file to be loaded at startup. Then you\ncan use jsdt_run(function, params) to execute a function from the script\nat runtime. If you use it for KEMI configuration, then it has to include\nthe required functions.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"app_jsdt\", \"load\", \"/usr/local/etc/kamailio/js/myscript.js\")\n...\n```\n",
   "mode": "### `mode` (int)\n\nControl if the API to load JavaScript module (nodejs interface) is\ninitialized or not.\n\n*Default value is \u201c1\u201d (initialize).*\n\n```\n...\nmodparam(\"app_jsdt\", \"mode\", 0)\n...\n```\n"
  },
  "functions": {
   "jsdt_dofile": "### `jsdt_dofile(path)`\n\nExecute the JavaScript script stored in 'path'. The parameter can be a\nstring with pseudo-variables evaluated at runtime.\n\n```\n...\njsdt_dofile(\"/usr/local/etc/kamailio/js/myscript.js\");\n...\n```\n",
   "jsdt_dostring": "### `jsdt_dostring(script)`\n\nExecute the JavaScript script stored in parameter. The parameter can be\na string with pseudo-variables.\n\n```\n...\nif(!jsdt_dostring('KSR.dbg(\"test message\\n\")'))\n{\n    xdbg(\"SCRIPT: failed to execute js script!\\n\");\n}\n...\n```\n",
   "jsdt_run": "### `jsdt_run(function, params)`\n\nExecute the JS function 'func' giving params as parameters. There can be\nup to 3 string parameters. The function must exist in the script loaded\nat startup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n```\n...\nif(!jsdt_run(\"js_append_fu_to_reply\"))\n{\n    xdbg(\"SCRIPT: failed to execute js function!\\n\");\n}\n...\njsdt_run(\"js_funcx\", \"$rU\", \"2\");\n...\n```\n",
   "jsdt_runstring": "### `jsdt_runstring(script)`\n\nExecute the JS script stored in parameter. The parameter can be a string\nwith pseudo-variables. The script is executed in JS context specific to\nloaded JS files at startup.\n\n```\n...\nif(!jsdt_runstring('KSR.dbg(\"Hello World from $fU\\n\")'))\n{\n    xdbg(\"failed to execute js script!\\n\");\n}\n...\n```\n"
  }
 },
 "app_lua": {
  "overview": "This module allows executing Lua scripts from config file, implementing\nthe KEMI framework and exporting Lua module 'KSR'.\n\nTo read more about KEMI exports and available KSR submodules, see:\n\n- <https://kamailio.org/docs/tutorials/devel/kamailio-kemi-framework/>\n\nNote: to have the old Lua module 'sr' available, load the 'app_lua_sr'\nKamailio module.\n\nLua (http://www.lua.org) is a fast and easy to embed scripting language.\nExported API from SIP router to Lua is documented in the dokuwiki.\n\nThe module has two Lua contexts:\n\n- *first* is used for functions lua_dofile() and lua_dostring().\n\n- *second* is used for function lua_run() and parameter 'load'.\n  Therefore lua_run() cannot execute functions from scripts loaded via\n  lua_dofile() in config. This is kind of caching mode, avoiding reading\n  file every time, but you must be sure you do not have something that\n  is executed by default and requires access to SIP message. This is\n  also the context used with KEMI framework.\n",
  "parameters": {
   "load": "### `load` (string)\n\nSet the path to the Lua script to be loaded at startup. Then you can use\nlua_run(function, params) to execute a function from the script at\nruntime. The script can be in Lua-source or bytecode.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"app_lua\", \"load\", \"/usr/local/etc/kamailio/lua/myscript.lua\")\n...\n```\n",
   "reload": "### `reload` (boolean)\n\nIf reload is 1 enables the ability to reload the scripts using the RPC\napp_lua.reload command. To disable reload feature, set this parameter to\n0.\n\n*Default value is \u201c1 (on)\u201d.*\n\n```\n...\nmodparam(\"app_lua\", \"reload\", 0)\n...\n```\n",
   "log_mode": "### `log_mode` (int)\n\nControl what is printed in log messages. If bit 1 is set, then the\nmodule prints debug messages for each KEMI export.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"app_lua\", \"log_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "lua_dofile": "### `lua_dofile(path)`\n\nExecute the Lua script stored in 'path'. The parameter can be a string\nwith pseudo-variables evaluated at runtime.\n\n```\n...\nlua_dofile(\"/usr/local/etc/kamailio/lua/myscript.lua\");\n...\n```\n",
   "lua_dostring": "### `lua_dostring(script)`\n\nExecute the Lua script stored in parameter. The parameter can be a\nstring with pseudo-variables.\n\n```\n...\nif(!lua_dostring(\"KSR.log([[err]], [[----------- Hello World from $fU\\n]])\"))\n{\n    xdbg(\"SCRIPT: failed to execute lua script!\\n\");\n}\n...\n```\n",
   "lua_run": "### `lua_run(func [, params])`\n\nExecute the Lua function 'func' giving 'params' as parameters. There can\nbe up to 3 string parameters after 'func' (overall, max 4 params, first\nis the function). The function must exist in the Lua script loaded at\nstartup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n```\n...\nif(!lua_run(\"sr_append_fu_to_reply\")) {\n    xdbg(\"SCRIPT: failed to execute lua function!\\n\");\n}\n...\nlua_run(\"lua_func0\");\nlua_run(\"lua_func1\", \"$rU\");\nlua_run(\"lua_func2\", \"$rU\", \"2\");\nlua_run(\"lua_func3\", \"$rU\", \"2\", \"$si\");\n...\n```\n",
   "lua_runstring": "### `lua_runstring(script)`\n\nExecute the Lua script stored in parameter. The parameter can be a\nstring with pseudo-variables. The script is executed in Lua context\nspecific to loaded Lua files at startup.\n\n```\n...\nif(!lua_runstring(\"KSR.log([[err]], [[----------- Hello World from $fU\\n]])\"))\n{\n    xdbg(\"SCRIPT: failed to execute lua script!\\n\");\n}\n...\n```\n"
  }
 },
 "app_lua_sr": {
  "overview": "This module exports the Lua module 'sr', the old API existing before the\nKEMI framework. The module requires 'app_lua' module.\n\nIMPORTANT: this module is kept to allow a smooth migration of the\nscripts using 'sr' module in Lua to KEMI framework and the 'KSR' module.\nIt will be marked as obsolete in the near future and removed afterwards.\nIf you find any function exported to Lua via 'sr' that has no\nalternative in Lua 'KSR' module, report it to sr-dev mailing list.\n\nLua (http://www.lua.org) is a fast and easy to embed scripting language.\nExported API from Kamailio to Lua is documented in the dokuwiki.\n",
  "parameters": {
   "register": "### `register` (string)\n\nNOTE: Since Kamailio v5.0, KEMI exports are available in Lua script\nunder KSR module exposed by 'app_lua'. These exports cover most of the\nmodules, a lot more than those listed next. The KEMI exports are the\nrecommended to be used, the old 'sr' module might be obsoleted soon. To\nread more about KEMI exports and available KSR submodules, see:\n\n- <https://kamailio.org/docs/tutorials/devel/kamailio-kemi-framework/>\n\nUse this parameter to register optional Kamailio submodules to Lua.\nAvailable submodules are:\n\n- *alias_db* - register functions from alias_db module under\n  'sr.alias_db'.\n\n- *auth* - register functions from auth module under 'sr.auth'.\n\n- *auth_db* - register functions from auth_db module under 'sr.auth_db'.\n\n- *dispatcher* - register functions from dispatcher module under\n  'sr.dispatcher'.\n\n- *maxfwd* - register functions from maxfwd module under 'sr.maxfwd'.\n\n- *msilo* - register functions from msilo module under 'sr.msilo'.\n\n- *presence* - register functions from presence module under\n  'sr.presence'.\n\n- *presence_xml* - register functions from presence_xml module under\n  'sr.presence_xml'.\n\n- *pua_usrloc* - register functions from pua_usrloc module under\n  'sr.pua_usrloc'.\n\n- *registrar* - register functions from registrar module under\n  'sr.registrar'.\n\n- *rls* - register functions from rls module under 'sr.rls'.\n\n- *rr* - register functions from rr module under 'sr.rr'.\n\n- *sanity* - register functions from sanity module under 'sr.sanity'.\n\n- *sdpops* - register functions from sdpops module under 'sr.sdpops'.\n\n- *siputils* - register functions from siputils module under\n  'sr.siputils'.\n\n- *sl* - register functions from sl module under 'sr.sl'.\n\n- *sqlops* - register functions from sqlops module under 'sr.sqlops'.\n\n- *textops* - register functions from textops module under 'sr.textops'.\n\n- *tm* - register functions from tm module under 'sr.tm'.\n\n- *xhttp* - register functions from xhttp module under 'sr.xhttp'.\n\nNote that 'sr', 'sr.hdr' and 'sr.pv' modules are always registered to\nLua.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"app_lua_sr\", \"register\", \"sl\")\n...\n```\n"
  },
  "functions": {}
 },
 "app_mono": {
  "overview": "This module allows the execution of assemblies of managed code, among\nthe most popular of which is C# (.NET). It uses the Mono project\n(http://www.mono-project.com/) to embed the managed code interpreter\ninside the SIP server, providing fast execution.\n\nBesides C#, other languages can be used to build managed assemblies,\nsuch as: Java, Python, VisualBasic.NET, JavaScript. For more details on\nwhat kind of languages can be used to build managed assemblies, see:\nhttp://www.mono-project.com/Languages\n\nA managed assembly can get access to any Kamailio config variables and\nset them. It can also perform many other functions implemented inside\nKamailio itself, allowing easier handling of SIP from managed code.\n\nThere are two ways to execute managed code assemblies: load the code at\nstartup and only execute at runtime, or load and execute at runtime.\nOnly one mode at a time may be used. The mode is determined by the\n'load' parameter and the function used to execute the code.\n",
  "parameters": {
   "load": "### `load` (string)\n\nSet the path to the Mono assembly to be loaded at startup. You can use\nmono_run(param) to execute the assembly at runtime.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"app_mono\", \"load\", \"/usr/local/etc/kamailio/mono/myscript.exe\")\n...\n```\n"
  },
  "functions": {
   "mono_exec": "### `mono_exec(path [, param])`\n\nExecute the managed code assembly stored in 'path'. The path can be a\nstring with pseudo-variables evaluated at runtime. A second parameter\ncan optionally be provided; it will be passed to the assembly.\n\nNote that the assembly is loaded every time from the file, so any change\nto it is immediately live. This function cannot be used if 'load'\nparameter is set.\n\n```\n...\nmono_exec(\"/usr/local/etc/kamailio/mono/myscript.exe\");\n...\n```\n",
   "mono_run": "### `mono_run([param])`\n\nExecute the assembly specified by 'load' module parameter. The assembly\nis loaded at startup, so changes to it will be effective only after\nKamailio restart.\n\nAn optional parameter can be given and it will be passed over to the\nassembly. It can be a string with pseudo-variables; these will be\nevaluated at runtime.\n\n```\n...\nif(!mono_run(\"myparam\"))\n{\n    xdbg(\"SCRIPT: failed to execute mono assembly!\\n\");\n}\n...\n```\n"
  }
 },
 "app_perl": {
  "overview": "The time needed when writing a new Kamailio module unfortunately is\nquite high, while the options provided by the configuration file are\nlimited to the features implemented in the modules.\n\nWith this Perl module, you can easily implement your own Kamailio\nextensions in Perl. This allows for simple access to the full world of\nCPAN modules. SIP URI rewriting could be implemented based on regular\nexpressions; accessing arbitrary data backends, e.g. LDAP or Berkeley DB\nfiles, is now extremely simple.\n",
  "parameters": {
   "filename": "### `filename` (string)\n\nThis is the file name of your script. This may be set once only, but it\nmay include an arbitrary number of functions and \u201cuse\u201d as many Perl\nmodule as necessary.\n\n*Must not be empty!*\n\n```\n...\nmodparam(\"app_perl\", \"filename\", \"/home/test/kamailio/myperl.pl\")\n...\n```\n",
   "modpath": "### `modpath` (string)\n\nThe path to the Perl modules included (Kamailio.pm et.al). It is not\nabsolutely crucial to set this path, as you *may* install the Modules in\nPerl's standard path, or update the \u201c%INC\u201d variable from within your\nscript. Using this module parameter is the standard behavior, though.\nMultiple paths may be specified by separating them with a \u201c:\u201d character.\nThe maximum is 10 paths.\n\n```\n...\nmodparam(\"app_perl\", \"modpath\", \"/usr/local/lib/kamailio/perl/\")\n...\n```\n",
   "reset_cycles": "### `reset_cycles` (int)\n\nThe number of execution cycles after which the embedded perl interpreter\nis reset. Sometimes is hard to track the scope of variables in all used\nperl modules and that can result in leaks of system memory. Resetting\nthe interpreter cleans the memory space.\n\nWhen the interpreter is reset, the perl script is loaded again. Note\nthat not all Kamailio processes will reset the interpreter at the same\ntime. Each will do it when it has executed the script for the number of\nreset_cycles. Also, be aware that the reset of the interpreter is taking\na bit of time (in the order of tens of milliseconds).\n\nDefault value is *0* - never reset the interpreter.\n\n```\n...\nmodparam(\"app_perl\", \"reset_cycles\", 100000)\n...\n```\n",
   "perl_destroy_func": "### `perl_destroy_func` (string)\n\nThe name of Perl function to be executed before the interpreter is\nre-initialized (reset -- see reset_cycles parameter) at runtime. This\ncould be useful to clean global variables or file descriptors from the\nPerl script.\n\n```\n...\nmodparam(\"app_perl\", \"perl_destroy_func\", \"my_perl_destroy\")\n...\n```\n",
   "parse_mode": "### `parse_mode` (int)\n\nControl how to behave on perl_parse() return code - on some versions it\nis the value for application exit and can break reloading.\n\nIf set to 0, continue even of perl_parse() returns non-zero, logging a\nwarning. If set to 1, reload fails on non-zero return code and triggers\nan exit.\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"app_perl\", \"parse_mode\", 1)\n...\n```\n",
   "warn_mode": "### `warn_mode` (int)\n\nAllows to enable warning for perl_parse(). If set to 1, \"-w\" is passed\nto perl_parse() and detected warnings in the Perl script should be\nprinted to the log. If set to 1, then \"-W\" is passed to perl_parse().\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"app_perl\", \"warn_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "perl_exec_simple": "### `perl_exec_simple(func, [param])`\n\nCalls a perl function *without* passing it the current SIP message. May\nbe used for very simple simple requests that do not have to fiddle with\nthe message themselves, but rather return information values about the\nenvironment.\n\nThe first parameter is the function to be called. An arbitrary string\nmay optionally be passed as a parameter.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif (method==\"INVITE\") {\n    perl_exec_simple(\"dosomething\", \"on invite messages\");\n};\n...\n```\n",
   "perl_exec": "### `perl_exec(func, [param])`\n\nCalls a perl function *with* passing it the current SIP message. The SIP\nmessage is reflected by a Perl module that gives you access to the\ninformation in the current SIP message (Kamailio::Message).\n\nThe first parameter is the function to be called. An arbitrary string\nmay be passed as a parameter.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif (perl_exec(\"ldapalias\")) {\n    ...\n};\n...\n```\n"
  }
 },
 "app_python3": {
  "overview": "This module is a port of the 'app_python' module to Python 3. It is\nbased on the work of Maxim Sobolev.\n\n*This module cannot be loaded together with 'app_python'* as global\nsymbols have not been renamed. To ease transition, the functions, KEMI\nexports, and RPC commands have the same names as 'app_python', which\nalso means the two modules cannot coexist.\n\nThis module allows executing Python scripts from the config file,\nexporting functions to access the SIP message from Python.\n\nFor some basic examples of Python scripts that can be used with this\nmodule, look at the files inside the source tree located at\n'modules/app_python3/python_examples/'.\n\nNote: if symbols exported to KEMI (module or function names) conflict\nwith Python's reserved keywords, use the 'getattr()' function or the\n'__dict__' attribute for 'KSR' (e.g.,\n'KSR.__dict__[\"async\"].task_route(\"myroute\")').\n",
  "parameters": {
   "load": "### `load` (string)\n\nThe path to the file with Python code to be executed from configuration\nfile.\n\n*Default value is \u201c/usr/local/etc/kamailio/handler.py\u201d.*\n\n```\n...\nmodparam(\"app_python3\", \"load\", \"/usr/local/etc/kamailio/myscript.py\")\n...\n```\n",
   "script_name": "### `script_name` (string)\n\nThis is same as \"load\" parameter, kept for backward compatibility with\nthe older versions of the module.\n",
   "mod_init_function": "### `mod_init_function` (string)\n\nThe Python function to be executed by this module when it is initialized\nby Kamailio.\n\n*Default value is \u201cmod_init\u201d.*\n\n```\n...\nmodparam(\"app_python3\", \"mod_init_function\", \"my_mod_init\")\n...\n```\n",
   "child_init_method": "### `child_init_method` (string)\n\nThe Python function to be executed by this module when a new worker\nprocess (child) is initialized by Kamailio.\n\n*Default value is \u201cchild_init\u201d.*\n\n```\n...\nmodparam(\"app_python3\", \"child_init_method\", \"my_child_init\")\n...\n```\n"
  },
  "functions": {
   "python_exec": "### `python_exec(method [, args])`\n\nExecute the Python function with the name given by the parameter\n'method'. Optionally can be provided a second string with parameters to\nbe passed to the Python function.\n\nBoth parameters can contain pseudo-variables.\n\n```\n...\npython_exec(\"my_python_function\");\npython_exec(\"my_python_function\", \"my_params\");\npython_exec(\"my_python_function\", \"$rU\");\n...\n```\n"
  }
 },
 "app_python3s": {
  "overview": "This module is an alternative 'app_python3' module with static export of\n'KSR' object and functions, without instantiating the SIP message\nobject.\n\n*This module cannot be loaded together with 'app_python3'* as some\nglobal symbols conflict.\n\nThis module allows executing Python3 scripts from the config file,\nexporting functions to access the SIP message from Python3.\n\nNote: if symbols exported to KEMI (module or function names) conflict\nwith Python's reserved keywords, use the 'getattr()' function or the\n'__dict__' attribute for 'KSR' (e.g.,\n'KSR.__dict__[\"async\"].task_route(\"myroute\")').\n",
  "parameters": {
   "load": "### `load` (string)\n\nThe path to the file with Python code to be executed from configuration\nfile.\n\n*Default value is \u201c/usr/local/etc/kamailio/kamailio.py\u201d.*\n\n```\n...\nmodparam(\"app_python3s\", \"load\", \"/usr/local/etc/kamailio/myscript.py\")\n...\n```\n",
   "script_init": "### `script_init` (string)\n\nThe name of the Python function to be executed when the script is loaded\nor reloaded.\n\n*Default value is \u201c\u201d (not set).*\n\n```\n...\nmodparam(\"app_python3s\", \"script_init\", \"ksr_script_init\")\n...\ndef ksr_script_init():\n    KSR.info(\"init python script\\n\")\n    return 1\n...\n```\n",
   "script_child_init": "### `script_child_init` (string)\n\nThe name of the Python function to be executed when Kamailio forks child\nprocesses at startup and when the script is reloaded.\n\n*Default value is \u201c\u201d (not set).*\n\n```\n...\nmodparam(\"app_python3s\", \"script_child_init\", \"ksr_script_child_init\")\n...\ndef ksr_script_child_init():\n    KSR.info(\"child init python script\\n\")\n    return 1\n...\n```\n"
  },
  "functions": {
   "app_python3s_exec": "### `app_python3s_exec(method [, param])`\n\nExecute the Python function with the name given by the parameter\n'method'. Optionally can be provided a second string with the parameter\nto be passed to the Python function.\n\nBoth parameters can contain pseudo-variables.\n\n```\n...\napp_python3s_exec(\"my_python_function\");\napp_python3s_exec(\"my_python_function\", \"my_params\");\napp_python3s_exec(\"my_python_function\", \"$rU\");\n...\n```\n"
  }
 },
 "app_ruby": {
  "overview": "This module allows executing Ruby scripts from the Kamailio\nconfiguration file. It exports all KEMI functions to Ruby in order to\naccess the currently processed SIP message. These functions are\navailable within the Ruby module 'KSR'.\n\nIMPORTANT: because of Ruby language policy (which require that a public\nsubmodule name has to start with an uppercase letter), the KSR submodule\nnames are with all letters uppercase. For example, what is documented as\nKSR.sl in KEMI docs, must be used as KSR::SL in Ruby scripts.\n",
  "parameters": {
   "load": "### `load` (str)\n\nSet the path to the Ruby file to be loaded at startup. Then you can use\nRuby_run(function, params) to execute a function from the script at\nruntime. If you use it for KEMI configuration, then it has to include\nthe required functions.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"app_ruby\", \"load\", \"/usr/local/etc/kamailio/ruby/myscript.rb\")\n...\n```\n",
   "xval_mode": "### `xval_mode` (int)\n\nControl if the external sub-module functions returning extended-values\nshould propagate their string return value (when set to 0) or be\nreplaced by NULL/nil (when set to 1).\n\nWhen set to 0, the KSR::PV Ruby submodule is implemented with the\ninternal functions from the app_ruby module, otherwise the ones from\ncore are used.\n\nNote: upt to version 5.7, when set to 1, there were crashing reports\nthat are under investigation, this option being provided as intermediary\nsolution to preserve the behaviour from older versions.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"app_ruby\", \"xval_mode\", 0)\n...\n```\n",
   "modproc": "### `modproc` (str)\n\nThe name of or the path to the required per-process API module.\n\n*Default value is \"app_ruby_proc.so\".*\n\n```\n...\nmodparam(\"app_ruby\", \"modproc\", \"app_ruby_proc2.so\")\n...\n```\n"
  },
  "functions": {
   "ruby_run": "### `ruby_run(function, params)`\n\nExecute the Ruby function 'func' giving params as parameters. There can\nbe up to 3 string parameters. The function must exist in the script\nloaded at startup via parameter 'load'. Parameters can be strings with\npseudo-variables that are evaluated at runtime.\n\n```\n...\nif(!ruby_run(\"rb_append_fu_to_reply\"))\n{\n    xdbg(\"SCRIPT: failed to execute ruby function!\\n\");\n}\n...\nruby_run(\"rb_funcx\", \"$rU\", \"2\");\n...\n```\n"
  }
 },
 "app_ruby_proc": {
  "overview": "The module implements per-child-process C API functions required by\napp_ruby module.\n\nImportant: this module must not be loaded standalone via loadmodule, the\napp_ruby module loads it in each child process. This is required because\nlibruby 1.9+ is multi-threaded and must be initialized per each child\nprocess, after forking, otherwise threads locks and resources are\ninherited and can lead to unpredictable behaviour, such as crashes.\n",
  "parameters": {},
  "functions": {}
 },
 "async": {
  "overview": "This module provides asynchronous operations for handling SIP requests\nin the configuration file.\n\nAsync uses t_suspend() and t_continue() from the TM and TMX modules.\n\nNote that after invoking the asynchronous operation, the processing will\ncontinue later in another application process. Therefore variables\nstored in private memory should not be used, try to use shared memory if\nyou want to get values after the processing is resumed (e.g.,\n$avp(...), $xavp(...), $shv(...), htable $sht(...)).\n",
  "parameters": {
   "workers": "### `workers` (int)\n\nNumber of worker processes to be started to handle the asynchronous\ntasks for async_route() and async_sleep().\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"async\", \"workers\", 2)\n...\n```\n",
   "ms_timer": "### `ms_timer` (int)\n\nEnables millisecond timer for async_ms_sleep() and async_ms_route()\nfunctions. The integer value is the timer resolution in milliseconds. A\nsmaller timer resolution will generate a higher load on the system. If\nyou set ms_timer to 1 you will get a timer with 1 millisecond\nresolution, a setting of 20 provides a resolution of 20ms.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"async\", \"ms_timer\", 10)\n...\n```\n",
   "return": "### `return` (int)\n\nThe value to be returned by async functions on success. It does not\napply for async data functions, only for those that suspend the SIP\ntransaction.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"async\", \"return\", 1)\n...\n```\n"
  },
  "functions": {
   "async_route": "### `async_route(routename, seconds)`\n\nSimulate a sleep of 'seconds' and then continue the processing of the\nSIP request with the route[routename]. In case of internal errors, the\nfunction returns false, otherwise the function exits the execution of\nthe script at that moment (return 0 behaviour).\n\nThe routename parameter can be a static string or a dynamic string value\nwith config variables.\n\nThe sleep parameter represent the number of seconds to suspend the\nprocessing of a SIP request. Maximum value is 100. The parameter can be\na static integer or a variable holding an integer.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution state is practically lost. Therefore beware that the\nexecution of config after resume will end once the route[routename] is\nfinished.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    async_route(\"RESUME\", \"4\");\n    ...\n}\nroute[RESUME] {\n   send_reply(\"404\", \"Not found\");\n   exit;\n}\n...\n```\n",
   "async_ms_route": "### `async_ms_route(routename, milliseconds)`\n\nSimulate a sleep of 'milliseconds' and then continue the processing of\nthe SIP request with the route[routename]. In case of internal errors,\nthe function returns false, otherwise the function exits the execution\nof the script at that moment (return 0 behaviour). This function works\nonly if the ms_timer parameter has a value greater than 0.\n\nThe routename parameter can be a static string or a dynamic string value\nwith config variables.\n\nThe sleep parameter represent the number of milliseconds to suspend the\nprocessing of a SIP request. Maximum value is 30000 (30 sec). The\nparameter can be a static integer or a variable holding an integer.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution state is practically lost. Therefore beware that the\nexecution of config after resume will end once the route[routename] is\nfinished.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    async_ms_route(\"RESUME\", \"250\");\n    ...\n}\nroute[RESUME] {\n   send_reply(\"404\", \"Not found\");\n   exit;\n}\n...\n```\n",
   "async_sleep": "### `async_sleep(seconds)`\n\nSimulate a sleep of 'seconds' and then continue the processing of SIP\nrequest with the next action. In case of internal errors, the function\nreturns false.\n\nThe sleep parameter represent the number of seconds to suspend the\nprocessing of SIP request. Maximum value is 100. The parameter can be a\nstatic integer or a variable holding an integer.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nasync_sleep(\"4\");\nsend_reply(\"404\", \"Not found\");\nexit;\n...\n```\n",
   "async_ms_sleep": "### `async_ms_sleep(milliseconds)`\n\nSimulate a sleep of 'milliseconds' and then continue the processing of\nSIP request with the next action. In case of internal errors, the\nfunction returns false. This function works only if the ms_timer\nparameter has a value greater than 0.\n\nThe sleep parameter represent the number of milliseconds to suspend the\nprocessing of SIP request. Maximum value is 30000 (30 sec). The\nparameter can be a static integer or a variable holding an integer.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nroute[REQUESTSHAPER] {\n    $var(res) = http_connect(\"leakybucket\",\n            \"/add?key=$fd\", $null, $null,\"$avp(delay)\");\n    $var(d) = $(avp(delay){s.int});\n    if ($var(d) > 0) {\n        # Delay the request by $avp(delay) ms\n        async_ms_sleep(\"$var(d)\");\n        if (!t_relay()) {\n            sl_reply_error();\n        }\n        exit;\n    }\n    # No delay\n    if (!t_relay()) {\n        sl_reply_error();\n    }\n    exit;\n}\n...\n```\n",
   "async_task_route": "### `async_task_route(routename)`\n\nContinue the processing of the SIP request with the route[routename]\nin one of the processes from first group of core asynchronous framework.\nThe core parameter async_workers has to be set to enable asynchronous\nframework. The task is executed as soon as a process from asynchronous\nframework is idle, there is no wait time for the task like for\nasync_route(...).\n\nTo enable the core asynchronous framework, you need to set the\n*async_workers* core parameter in the configuration file. See the core\ncookbook for more information.\n\n```\n...\n# Enable 8 worker processes used by async and other modules\nasync_workers=8\n...\n```\n\nIn case of internal errors, the function returns false, otherwise the\nfunction exits the execution of the script at that moment (return 0\nbehaviour).\n\nThe routename parameter can be a static string or a dynamic string value\nwith config variables.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution state is practically lost. Therefore beware that the\nexecution of config after resume will end once the route[routename] is\nfinished.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    async_task_route(\"RESUME\");\n    ...\n}\nroute[RESUME] {\n   t_relay();\n   exit;\n}\n...\n```\n",
   "async_task_group_route": "### `async_task_group_route(routename, groupname)`\n\nSimilar to async_task_route(), but allows to specify the name of the\ngroup for asynchronous workers. See also 'async_workers_group' core\nglobal parameter.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nasync_workers_group=\"name=abc;workers=4;nonblock=0;usleep=0\"\n...\nrequest_route {\n    ...\n    async_task_route(\"RESUME\", \"abc\");\n    ...\n}\nroute[RESUME] {\n   t_relay();\n   exit;\n}\n...\n```\n",
   "async_task_data": "### `async_task_data(routename, data)`\n\nSend the data to an asynchronous task process (in the first group) that\nexecutes the route[rountename] and makes the data available via\n$async(data).\n\nThe current SIP message is not suspended and it is not available in the\nasynchronous task process, a local faked SIP request is used there.\n\nThe parameters can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nasync_workers_group=\"name=abc;workers=4;nonblock=0;usleep=0\"\n...\nrequest_route {\n    ...\n    async_task_data(\"RESUME\", \"caller: $fU - callee: $tU\");\n    ...\n}\nroute[RESUME] {\n   xinfo(\"$async(data)\\n\");\n   exit;\n}\n...\n```\n",
   "async_task_group_data": "### `async_task_group_data(routename, groupname, data)`\n\nSimilar to async_task_route(), but allows to specify the name of the\ngroup for asynchronous workers. See also 'async_workers_group' core\nglobal parameter.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nasync_workers_group=\"name=abc;workers=4;nonblock=0;usleep=0\"\n...\nrequest_route {\n    ...\n    async_task_data(\"RESUME\", \"abc\", \"caller: $fU - callee: $tU\");\n    ...\n}\nroute[RESUME] {\n   xinfo(\"$async(data)\\n\");\n   exit;\n}\n...\n```\n"
  }
 },
 "auth": {
  "overview": "This is a generic module that itself doesn't provide all functions\nnecessary for authentication but provides functions that are needed by\nall other authentication related modules (so called authentication\nbackends).\n\nWe decided to divide the authentication code into several modules\nbecause there are now more than one backends (currently database\nauthentication and radius are supported). This allows us to create\nseparate packages so users can install and load only the required\nfunctionality. This also allows us to avoid unnecessary dependencies in\nthe binary packages.\n",
  "parameters": {
   "auth_checks_register": "### `auth_checks_register` (flags)\n\nSee description of parameter `auth_checks_in_dlg`.\n",
   "auth_checks_no_dlg": "### `auth_checks_no_dlg` (flags)\n\nSee description of parameter `auth_checks_in_dlg`.\n",
   "auth_checks_in_dlg": "### `auth_checks_in_dlg` (flags)\n\nThese three module parameters control which optional integrity checks\nwill be performed on the SIP message carrying digest response during SIP\nMD5 digest authentication. `auth_checks_register` controls integrity\nchecks to be performed on REGISTER messages, `auth_checks_no_dlg`\ncontrols which optional integrity checks will be performed on SIP\nrequests that have no To header field or no To tag (in other words the\nrequests either establishing or outside dialogs). `auth_checks_in_dlg`\ncontrols which integrity checks will be performed on SIP requests within\ndialogs, such as BYE or re-INVITE. The default value for all three\nparameters is 0 (old behaviour, no extra checks). The set of integrity\nchecks that can be performed on REGISTERs is typically different from\nsets of integrity checks that can be performed for other SIP request\ntypes, hence we have three independent module parameters.\n\nWithout the extra checks the nonce will protect only against expired\nvalues. Some reply attacks are still possible in the expire \"window\". A\npossible workaround is to always force qop authentication and always\ncheck the uri from the authorization header, but this would not work if\nan upstream proxy rewrites the uri and it will also not work with a lot\nof UA implementations.\n\nIn this case the nonce value will be used only to hold the expire time\n(see `nonce_expire`) and an MD5 over it and some secret (the MD5 is used\nto make sure that nobody tampers with the nonce expire time).\n\nWhen the extra checks are enabled, the nonce will include an extra MD5\nover the selected part/parts of the message (see below) and some other\nsecret. This will be used to check if the selected part of the message\nis the same when an UA tries to reuse the nonce, thus protecting or\nseverely limiting reply attacks.\n\nThe possible flag values for all three parameters are:\n\n- *1* for checking if the message URI changed (uses the whole URI)\n\n- *2* for checking the callid\n\n- *4* for checking the From tag\n\n- *8* for checking the source IP address (see nonce.h).\n\nAs an example setting `auth_checks_register` to 3 would check if the\ncallid or the request uri changed from the REGISTER message for which\nthe original nonce was generated (this would allow nonce reuse only\nwithin the same UA and for the expire time). Note that enabling the\nextra checks will limit nonce caching by UAs, requiring extra challenges\nand roundtrips, but will provide much better protection.\n\n<div class=\"warning\">\n\n\nDo not enable the from tag check (4) for REGISTERs\n(`auth_checks_register`) and out-of-dialog messages\n(`auth_checks_no_dlg`) unless you are sure that all your user agents do\nnot change the from tag when challenged. Some user agents will also\nchange the callid when the challenged request is not in-dialog, so avoid\nenabling the callid check (2) for messages that are not part of a dialog\n(`auth_checks_no_dlg`). In some rare case this will also have to be done\nfor REGISTERs.\n\n</div>\n\n\nWhen the `secret` parameter is set and the extra checks are enabled, the\nfirst half of the `secret` will be used for the expire time MD5 and the\nother half for the extra checks MD5, so make sure you have a long secret\n(32 chars or longer are recommended).\n\n```\n...\n# For REGISTER requests we hash the Request-URI, Call-ID, and source IP of the\n# request into the nonce string. This ensures that the generated credentials\n# cannot be used with another registrar, user agent with another source IP\n# address or Call-ID. Note that user agents that change Call-ID with every\n# REGISTER message will not be able to register if you enable this.\nmodparam(\"auth\", \"auth_checks_register\", 11)\n\n# For dialog-establishing requests (such as the original INVITE, OPTIONS, etc)\n# we hash the Request-URI and source IP. Hashing Call-ID and From tags takes\n# some extra precaution, because these checks could render some UA unusable.\nmodparam(\"auth\", \"auth_checks_no_dlg\", 9)\n\n# For mid-dialog requests, such as re-INVITE, we can hash source IP and\n# Request-URI just like in the previous case. In addition to that we can hash\n# Call-ID and From tag because these are fixed within a dialog and are\n# guaranteed not to change. This settings effectively restrict the usage of\n# generated credentials to a single user agent within a single dialog.\nmodparam(\"auth\", \"auth_checks_in_dlg\", 15)\n\n...\n        \n```\n",
   "qop": "### `qop` (string)\n\nIf set, enable *qop* for challenges: each challenge will include a *qop*\nparameter. This is the recommended way, but some older non rfc3261\ncompliant UAs might get confused and might not authenticate properly if\n`qop` is enabled.\n\nEnabling `qop` together with `nonce_count` will provide extra-security\n(protection against replay attacks) while still allowing credentials\ncaching at the UA side and thus not compromising performance.\n\nThe possible values are: \"auth\", \"auth-int\" and \"\" (unset).\n\nThe default value is not-set (\"\").\n\nSee also: `nonce_count`.\n\n```\n...\nmodparam(\"auth\", \"qop\", \"auth\")   # set qop=auth\n...\n        \n```\n",
   "nonce_count": "### `nonce_count` (boolean)\n\nIf enabled the received *nc* value is remembered and checked against the\nolder value (for a successful authentication the received *nc* must be\ngreater than the previously received one, see rfc2617 for more details).\nThis will provide protection against replay attacks while still allowing\ncredentials caching at the UA side.\n\nIt depends on `qop` being enabled (if `qop` is not enabled, the\nchallenges won't include *qop* and so the UA will probably not include\nthe *qop* or *nc* parameters in its response).\n\nIf a response doesn't include *qop* or *nc* (for example obsolete UAs\nthat don't support them) the response will be checked according to the\nother enabled nonce checks, in this order: `one_time_nonce` and\n`auth_checks_*`. If a response includes *nc* only the normal\n`nonce_expire` checks and the `nonce_count` checks will be performed,\nall the other checks will be ignored.\n\nThe `nonce_count` checks work by tracking a limited number of nonces.\nThe maximum number of tracked nonces is set using the `nc_array_size` or\n`nc_array_order` parameters. If this number is exceeded, older entries\nwill be overwritten. As long as the maximum rate of challengeable\nmessages per average response time is lower than `nc_array_size`, the\n`nonce_count` checks should work flawlessly. For optimum performance\n(maximum reuse of cache credentials) `nc_array_size` divided by\n`nid_pool_no` should be lower than the message rate multiplied by the\ndesired `nonce_expire`.\n\nThe maximum accepted *nc* value is 255. If *nc* becomes greater than\nthis, the nonce will be considered stale and the UA will be\nre-challenged.\n\n*Note:* `nonce_count` should be enabled only in stateful mode (a\ntransaction should be created prior to the authentication check to\nabsorb possible retransmissions and all the replies should be sent\nstatefully, using `t_reply()`). If `nonce_count` and the authentication\nchecks are used in the stateless mode then all retransmissions will be\nchallenged.\n\nThe default value is 0 (off).\n\nSee also: `qop`, `nc_array_size`, `nc_array_order`, `nid_pool_no`,\n`nonce_expire`. `one_time_nonce`.\n\n```\n...\nmodparam(\"auth\", \"nonce_count\", 1) # enable nonce_count support\nmodparam(\"auth\", \"qop\", \"auth\")    # enable qop=auth\n\n....\nroute{\n...\n    # go stateful and catch retransmissions\n    if (!t_newtran()) {\n        xlog(\"L_NOTICE\", \"Failed to create new transaction\\n\");\n        drop;\n    };\n    if (method==\"REGISTER\"){\n        if (!www_authenticate(\"test\", \"credentials\")){\n            # reply must be sent with t_reply because the\n            # transaction is already created at this point\n            # (we are in \"stateful\" mode)\n            if ($? == -2){\n                t_reply(\"500\", \"Internal Server Error\");\n            }else if ($? == -3){\n                t_reply(\"400\", \"Bad Request\");\n            }else{\n                if ($digest_challenge)\n                    append_to_reply(\"%$digest_challenge\");\n                t_reply(\"401\", \"Unauthorized\");\n            }\n            drop;\n        }\n        if (!save_noreply(\"location\")) {\n            t_reply(\"400\", \"Invalid REGISTER Request\");\n            drop;\n        }\n        append_to_reply(\"%$contact\");\n        t_reply(\"$code\", \"$reason\"); # no %, avps are used directly\n        drop;\n    }else{\n        if (!proxy_authenticate(\"my_realm\", \"credentials\")){\n            if ($? == -2){\n                t_reply(\"500\", \"Internal Server Error\");\n            }else if ($? == -3){\n                t_reply(\"400\", \"Bad Request\");\n            }else{\n                if ($digest_challenge)\n                    append_to_reply(\"%$digest_challenge\");\n                t_reply(\"401\", \"Unauthorized\");\n            }\n            drop;\n        }\n    }\n...\n        \n```\n",
   "one_time_nonce": "### `one_time_nonce` (boolean)\n\nIf set to 1 nonce reuse is disabled: each nonce is allowed only once, in\nthe first response to a challenge. All the messages will be challenged,\neven retransmissions. Stateful mode should be used, to catch\nretransmissions before the authentication checks (using `t_newtran()`\nbefore the authentication checks and sending all the replies with\n`t_reply()`).\n\n`one_time_nonce` provides enhanced replay protections at the cost of\ninvalidating UA side credentials caching, challenging every message (and\nthus generating extra messages and extra round-trips) and requiring\nstateful mode. In general `qop` and `nonce_count` should be prefered (if\npossible) with fallback to `auth_checks_*`. Due to the disadvantages\nlisted above, `one_time_nonce` should be used only if the extra checks\nprovided by `auth_checks_register`, `auth_checks_no_dlg` and\n`auth_checks_in_dlg` are deemed insufficient for a specific setup.\n\nCompared to `nonce_count`, `one_time_nonce` provides the same\nprotection, but at a higher message cost. The only advantages are that\nit works with user agents that do not support *qop* and *nc* and that it\nuses less memory for the same supported number of maximum in-flight\nnonces (by a factor of 8). `one_time_nonce` can be used as fallback from\n`nonce_count`, when the UA doesn't support *nc* (it happens\nautomatically when both of them are enabled).\n\nLike `nonce_count`, `one_time_nonce` works by tracking a limited number\nof nonces. The maximum number of tracked nonces is set using the\n`otn_in_flight_no` or `otn_in_flight_order` parameters. If this number\nis exceeded, older entries will be overwritten. As long as the maximum\nrate of challengeable messages per average response time is lower than\n`otn_in_flight_no`, the `one_time_nonce` checks should work flawlessly.\n\nThe default value is 0 (off).\n\nSee also: `otn_in_flight_no`, `otn_in_flight_order`, `nid_pool_no` and\n`nonce_count`.\n\n```\n...\nmodparam(\"auth\", \"one_time_nonce\", 1)\n# Note: stateful mode should be used, see the nonce_count example\n...\n        \n```\n",
   "nid_pool_no": "### `nid_pool_no` (integer)\n\nControls the number of partitions for the `nonce_count` and\n`one_time_nonce` arrays (it's common to both of them to reduce the nonce\nsize).\n\nInstead of using single arrays for keeping nonce state, these arrays can\nbe divided into more partitions. Each Kamailio process is assigned to\none of these partitions, allowing for higher concurrency on multi-CPU\nmachines. Besides increasing performance, increasing `nid_pool_no` has\nalso a negative effect: it could decrease the maximum supported\nin-flight nonces in certain conditions. In the worst case, when only one\nKamailio process receives most of the traffic (e.g. very busy tcp\nconnection between two proxies), the in-flight nonces could be limited\nto the array size (`nc_array_size` for `nonce_count` or\n`otn_in_flight_no` for `one_time_nonce`) divided by the partitions\nnumber (`nid_pool_no`). However for normal traffic, when the process\nreceiving a message is either random or chosen in a round-robin fashion\nthe maximum in-flight nonces number will be very little influenced by\n`nid_pool_no` (the messages will be close to equally distributed to\nprocesses using different partitions).\n\n`nid_pool_no` value should be one of: 1, 2, 4, 8, 16, 32 or 64 (the\nmaximum value is 64 and all values should be of the form 2^k or else\nthey will be rounded down to 2^k).\n\nThe default value is 1.\n\nSee also: `nonce_count`, `one_time_nonce`, `nc_array_size` and\n`otn_in_flight_no`.\n\n```\n...\nmodparam(\"auth\", \"nid_pool_no\", 4)\n...\n        \n```\n",
   "nc_array_size": "### `nc_array_size` (integer)\n\nMaximum number of in-flight nonces for `nonce_count`. It represents the\nmaximum nonces for which state will be kept. When this number is\nexceeded, state for the older nonces will be discarded to make space for\nnew ones (see `nonce_count` for more details).\n\nThe value should be of the form 2^k. If it's not it will be rounded down\nto 2^k (for example a value of 1000000 will be rounded down to\n2^19=524288). `nc_array_order` can be used to directly specify the power\nof 2 (e.g. `nc_array_order` set to 20 is equivalent to `nc_array_size`\nset to 1048576).\n\nThe memory used to keep the nonce state will be `nc_array_size` in\nbytes.\n\nThe default value is 1048576 (1M in-flight nonces, using 1Mb memory).\n\nSee also: `nonce_count` and `nid_pool_no`.\n\n```\n...\nmodparam(\"auth\", \"nc_array_size\", 4194304)   # 4Mb\n...\n        \n```\n",
   "nc_array_order": "### `nc_array_order` (integer)\n\nEquivalent to `nc_array_size`, but instead of directly specifying the\nsize, its value is the power at which 2 should be raised\n(log2(`nc_array_size`)).\n\n`nc_array_size` = 2^`nc_array_order`. For more details see\n`nc_array_size`.\n\nThe default value is 20 (1M in-flight nonces, using 1Mb memory).\n\nSee also: `nonce_count`, `nc_array_size` and `nid_pool_no`.\n\n```\n...\nmodparam(\"auth\", \"nc_array_order\", 22)   # 4Mb\n...\n        \n```\n",
   "otn_in_flight_no": "### `otn_in_flight_no` (integer)\n\nMaximum number of in-flight nonces for `one_time_nonce`. It represents\nthe maximum number of nonces remembered for the one-time-nonce check.\nWhen this number is exceeded, information about older nonces will be\ndiscarded and overwritten with information about the new generated ones\n(see `one_time_nonce` for more details).\n\nThe value should be of the form 2^k. If it's not it will be rounded down\nto 2^k (for example a value of 1000000 will be rounded down to\n2^19=524288). `otn_in_flight_no` can be used to directly specify the\npower of 2 (e.g. `otn_in_flight_order` set to 19 is equivalent to\n`otn_in_fligh_number` set to 524288).\n\nThe memory used to keep the nonce information will be the\n`otn_in_flight_no` divided by 8 (only 1 bit of state is kept per nonce).\n\nThe default value is 1048576 (1M in-flight nonces, using 128Kb memory).\n\nSee also: `one_time_nonce` and `nid_pool_no`.\n\n```\n...\nmodparam(\"auth\", \"otn_in_flight_no\", 8388608)   # 8 Mb (1Mb memory)\n...\n        \n```\n",
   "otn_in_flight_order": "### `otn_in_flight_order` (integer)\n\nEquivalent to `otn_in_flight_no`, but instead of directly specifying the\nsize, its value is the power at which 2 should be raised\n(log2(`otn_in_flight_no`)).\n\n`otn_in_flight_no` = 2^`otn_in_flight_order`. For more details see\n`otn_in_flight_order`.\n\nThe default value is 20 (1M in-flight nonces, using 128Kb memory).\n\nSee also: `one_time_nonce`, `otn_in_flight_no` and `nid_pool_no`.\n\n```\n...\nmodparam(\"auth\", \"otn_in_flight_order\", 23)   # 8 Mb (1Mb memory)\n...\n        \n```\n",
   "secret": "### `secret` (string)\n\nSecret phrase used to calculate the nonce value used to challenge the\nclient for authentication.\n\nIf you use multiple servers in your installation, and would like to\nauthenticate on the second server against the nonce generated at the\nfirst one, it is necessary to explicitly set the secret to the same\nvalue on all servers. However, as the use of a shared (and fixed) secret\nas nonce is insecure, it is much better is to stay with the default. Any\nclients should send the authenticated request to the server that issued\nthe challenge.\n\nDefault value is randomly generated string.\n\n```\n...\nmodparam(\"auth\", \"secret\", \"johndoessecretphrase\")\n...\n        \n```\n",
   "nonce_expire": "### `nonce_expire` (integer)\n\nNonces have limited lifetime. After a given period of time nonces will\nbe considered invalid. This is to protect replay attacks. Credentials\ncontaining a stale nonce will be not authorized, but the user agent will\nbe challenged again. This time the challenge will contain `stale`\nparameter which will indicate to the client that it doesn't have to\ndisturb user by asking for username and password, it can recalculate\ncredentials using existing username and password.\n\nThe value is in seconds and default value is 300 seconds.\n\n```\n...\nmodparam(\"auth\", \"nonce_expire\", 600)   # Set nonce_expire to 600s\n...\n        \n```\n",
   "nonce_auth_max_drift": "### `nonce_auth_max_drift` (integer)\n\nMaximum difference in seconds between a nonce creation time and the\ncurrent time, if the nonce creation time appears to be in the future.\n\nIn some cases, like shortly after a system time backward adjustment or\nwhen the current proxy is part of a cluster which is not\ntime-synchronized, it's possible to receive a nonce with creation time\nin the future. In this case if the difference is greater than\n`nonce_auth_max_drift` seconds, consider the nonce stale and\nre-challenge (otherwise after a dramatic time change backwards, it might\nhappen that some previously generated nonces will be valid for too much\ntime).\n\nThe default value is 3 seconds\n\nSee also: `nonce_expire`.\n\n```\n...\nmodparam(\"auth\", \"nonce_auth_max_drift\", 1)   # set max drift to 1 s\n...\n        \n```\n",
   "force_stateless_reply": "### `force_stateless_reply` (boolean)\n\nIf set to 1, `www_challenge()` and `proxy_challenge()` functions send\nreply statelessly no matter if transaction exists or not. If set to 0\n(default), reply is sent statefully if transaction exists and\nstatelessly otherwise.\n\n```\n...\nmodparam(\"auth\", \"force_stateless_reply\", 1)\n...\n        \n```\n",
   "realm_prefix": "### `realm_prefix` (string)\n\nPrefix to be automatically stripped from the realm. As an alternative to\nSRV records (not all SIP clients support SRV lookup), a subdomain of the\nmaster domain can be defined for SIP purposes (like sip.mydomain.net\npointing to same IP address as the SRV record for mydomain.net). By\nignoring the realm_prefix \u201csip.\u201d, at authentication, sip.example.com\nwill be equivalent to example.com .\n\nDefault value is empty string.\n\n```\nmodparam(\"auth\", \"realm_prefix\", \"sip.\")\n```\n",
   "use_domain": "### `use_domain` (boolean)\n\nIf set to 1, `pv_auth_check()` uses domain parts of the URIs to check\nuser identity.\n\n```\n...\nmodparam(\"auth\", \"use_domain\", 1)\n...\n        \n```\n",
   "algorithm": "### `algorithm` (string)\n\nConfigure hash algorithm used for digest authentication. Possible values\nare \"MD5\" or \"SHA-256\". If left empty MD5 is used. If specified, the\nspecified algorithm is used and is also put in the 'algorithm' field of\nthe challenge header.\n\nWarning: SHA-256 hash values take twice the space of MD5 hash values. So\na buffer overflow might occur if this option is used in combination with\nanother auth_* module that does not allocate at least 65 bytes to\nstore hash values. SHA-256 can safely be used with the module auth_db as\nit allocates 256 bytes to store HA1 values.\n\n```\n...\nmodparam(\"auth\", \"algorithm\", \"SHA-256\")\n...\n            \n```\n",
   "add_authinfo_hdr": "### `add_authinfo_hdr` (boolean)\n\nShould an Authentication-Info header be added on 200 OK responses? The\nAuthentication-Info header offers mutual authentication. The server\nproves to the client that it knows the user's secret.\n\nThe header also includes the next nonce which may be used by the client\nin a future request. If one_time_nonce is enabled, a new nonce is\ncalculated for the next nonce. Otherwise the current nonce is used for\nthe next nonce.\n\nThe default value is 0 (no).\n\n```\n...\nmodparam(\"auth\", \"add_authinfo_hdr\", yes)\n...\n            \n```\n"
  },
  "functions": {
   "consume_credentials": "### `consume_credentials()`\n\nThis function removes previously authorized credential headers from the\nmessage being processed by the server. That means that the downstream\nmessage will not contain credentials there were used by this server.\nThis ensures that the proxy will not reveal information about\ncredentials used to downstream elements and also the message will be a\nlittle bit shorter. The function must be called after `www_authorize`,\n`proxy_authorize`, `www_authenticate` or `proxy_authenticate`.\n\n```\n...\nif (www_authenticate(\"realm\", \"subscriber\")) {\n    consume_credentials();\n}\n...\n        \n```\n",
   "has_credentials": "### `has_credentials(realm)`\n\nThis function returns true if the request has Authorization or\nProxy-Authorization header with provided realm. The parameter can be\nstring with pseudo-variables.\n\n```\n...\nif (has_credentials(\"myrealm\")) {\n    ...\n}\n...\n        \n```\n",
   "www_challenge": "### `www_challenge(realm, flags)`\n\nThe function challenges a user agent. It will generate a WWW-Authorize\nheader field containing a digest challenge, it will put the header field\ninto a response generated from the request the server is processing and\nsend the 401 reply. Upon reception of such a reply the user agent should\ncompute credentials and retry the request. For more information\nregarding digest authentication see RFC2617. See module parameter\nforce_stateless_reply regarding sending of the reply.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests, the To\n  header field domain (e.g., variable $td) can be used (because this\n  header field represents the user being registered), for all other\n  messages From header field domain can be used (e.g., variable $fd).\n\n  The string may contain pseudo variables.\n\n- *flags* - Value of this parameter can be a bitmask of following:\n\n  - *1* - build challenge header with qop=auth\n\n  - *2* - build challenge header with qop=auth-int\n\n  - *4* - do not send '500 Internal Server Error' reply automatically in\n    failure cases (error code is returned to config)\n\n  - *16* - build challenge header with stale=true\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!www_authenticate(\"$td\", \"subscriber\")) {\n    www_challenge(\"$td\", \"1\");\n    exit;\n}\n...\n```\n",
   "proxy_challenge": "### `proxy_challenge(realm, flags)`\n\nThe function challenges a user agent. It will generate a Proxy-Authorize\nheader field containing a digest challenge, it will put the header field\ninto a response generated from the request the server is processing and\nsend the 407 reply. Upon reception of such a reply the user agent should\ncompute credentials and retry the request. For more information\nregarding digest authentication see RFC2617. See module parameter\nforce_stateless_reply regarding sending of the reply.\n\nMeaning of the parameters is the same as for function\nwww_challenge(realm, flags)\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!proxy_authenticate(\"$fd\", \"subscriber\")) {\n    proxy_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "auth_challenge": "### `auth_challenge(realm, flags)`\n\nThe function challenges a user agent for authentication. It combines the\nfunctions www_challenge() and proxy_challenge(), by calling internally\nthe first one for REGISTER requests and the second one for the rest of\nother request types. In other words, it challenges for authentication by\nsending a 401 reply for REGISTER requests and 407 reply for the other\ntypes of SIP requests.\n\nMeaning of the parameters the same as for function www_challenge(realm,\nflags)\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!auth_check(\"$fd\", \"subscriber\", \"1\")) {\n    auth_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "pv_www_authenticate": "### `pv_www_authenticate(realm, passwd, flags [, method])`\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nNegative codes may be interpreted as follows:\n\n- *-1 (generic error)* - some generic error occurred and no reply was\n  sent out\n\n- *-2 (invalid password)* - wrong password\n\n- *-4 (nonce expired)* - the nonce has expired\n\n- *-5 (no credentials)* - request does not contain an Authorization\n  header with the correct realm\n\n- *-6 (nonce reused)* - the nonce has already been used to authenticate\n  a previous request\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests To header\n  field domain (e.g., variable $td) can be used (because this header\n  field represents a user being registered), for all other messages From\n  header field domain can be used (e.g., variable $fd).\n\n  The string may contain pseudo variables.\n\n- *passwd* - the password to be used for authentication. Can contain\n  config variables. The Username is taken from Auth header.\n\n- *flags* - the value of this parameter can be a bitmask of following:\n\n  - *1* - the value of password parameter is HA1 format\n\n  - *2* - build challenge header with no qop and add it to avp\n\n  - *4* - build challenge header with qop=auth and add it to avp\n\n  - *8* - build challenge header with qop=auth-int and add it to avp\n\n  - *16* - build challenge header with stale=true\n\n  - *32* - don't invalidate nc on authentication failure\n\n\n- *method* - the method to be used for authentication. This parameter is\n  optional and if not set is the first \"word\" on the request-line.\n\nWhen challenge header is built and stored in avp, append_to_reply() and\nthe sl reply functions can be used to send appropriate SIP reply to\nchallenge for authentication.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!pv_www_authenticate(\"$td\", \"123abc\", \"0\")) {\n    www_challenge(\"$td\", \"1\");\n    exit;\n}\n...\n```\n",
   "pv_proxy_authenticate": "### `pv_proxy_authenticate(realm, passwd, flags)`\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again. For more about\nthe negative return codes, see the above function.\n\nMeaning of the parameters is the same as for pv_www_authenticate(realm,\npasswd, flags)\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n$avp(password)=\"xyz\";\nif (!pv_proxy_authenticate(\"$fd\", \"$avp(password)\", \"0\")) {\n    proxy_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "pv_auth_check": "### `pv_auth_check(realm, passwd, flags, checks)`\n\nThe function combines the functionalities of `pv_www_authenticate` and\n`pv_proxy_authenticate`, first being executed if the SIP request is a\nREGISTER, the second for the rest.\n\nMeaning of the first three parameters is the same as for\npv_www_authenticate(realm, passwd, flags).\n\nParameter *checks* can be used to control the behaviour of the function.\nIf it is 1, then the function will check to see if the authentication\nusername matches either To or From header username, a matter of whether\nit is for a REGISTER request or not. The parameter may be a pseudo\nvariable.\n\nThe set of possible return codes is the same than\npv_{www,proxy}_authenticate, with one more possible value:\n\n*-8 (auth user mismatch)* - the auth user is different than the From/To\nuser\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n$avp(password)=\"xyz\";\nif (!pv_auth_check(\"$fd\", \"$avp(password)\", \"0\", \"1\")) {\n    auth_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "auth_get_www_authenticate": "### `auth_get_www_authenticate(realm, flags, pvdest)`\n\nBuild WWW-Authentication header and set the resulting value in 'pvdest'\npseudo-variable parameter.\n\nMeaning of the realm and flags parameters is the same as for\npv_www_authenticate(realm, passwd, flags)\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (auth_get_www_authenticate(\"$fd\", \"0\", \"$var(wauth)\")) {\n    xlog(\"www authenticate header is [$var(wauth)]\\n\");\n}\n...\n```\n"
  }
 },
 "auth_db": {
  "overview": "This module contains all authentication related functions that need the\naccess to the database. This module should be used together with auth\nmodule, it cannot be used independently because it depends on the\nmodule. Select this module if you want to use database to store\nauthentication information like subscriber usernames and passwords. If\nyou want to use radius authentication, then use auth_radius instead.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThis is URL of the database to be used. Value of the parameter depends\non the database module used. For example for mysql and postgres modules\nthis is something like mysql://username:password@host:port/database. For\ndbtext module (which stores data in plaintext files) it is directory in\nwhich the database resides.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"auth_db\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "user_column": "### `user_column` (string)\n\nThis is the name of the column holding usernames. Default value is fine\nfor most people. Use the parameter if you really need to change it.\n\nDefault value is \u201cusername\u201d.\n\n```\n...\nmodparam(\"auth_db\", \"user_column\", \"user\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nThis is the name of the column holding domains of users. Default value\nis fine for most people. Use the parameter if you really need to change\nit.\n\nDefault value is \u201cdomain\u201d.\n\n```\n...\nmodparam(\"auth_db\", \"domain_column\", \"domain\")\n...\n```\n",
   "password_column": "### `password_column` (string)\n\nThis is the name of the column holding passwords. Passwords can be\neither stored as plain text or pre-calculated HA1 strings. HA1 strings\nare MD5 hashes of username, password, and realm. HA1 strings are more\nsafe because the server doesn't need to know plaintext passwords and\nthey cannot be obtained from HA1 strings.\n\nDefault value is \u201cha1\u201d.\n\n```\n...\nmodparam(\"auth_db\", \"password_column\", \"password\")\n...\n```\n",
   "password_column_2": "### `password_column_2` (string)\n\nAs described in the previous section this parameter contains name of\ncolumn holding pre-calculated HA1 string that were calculated including\nthe domain in the username. This parameter is used only when\n`calculate_ha1` is set to 0 and user agent send a credentials containing\nthe domain in the username.\n\nDefault value of the parameter is ha1b.\n\n```\n...\nmodparam(\"auth_db\", \"password_column_2\", \"ha1_2\")\n...\n```\n",
   "calculate_ha1": "### `calculate_ha1` (integer)\n\nThis parameter tells the server whether it should use a pre-calculated\nHA1 string or plaintext passwords for authentication.\n\nIf the parameter is set to 0 and the username parameter of credentials\ncontains also \u201c@domain\u201d (some user agents append the domain to the\nusername parameter), then the server will use the HA1 values from the\ncolumn specified in the \u201cpassword_column_2\u201d parameter. If the username\nparameter doesn't contain a domain, the server will use the HA1 values\nfrom the column given in the \u201cpassword_column\u201dparameter.\n\nIf the parameter is set to 1 then the HA1 value will be calculated from\nthe column specified in the \u201cpassword_column\u201d parameter.\n\nThe \u201cpassword_column_2\u201dcolumn contain also HA1 strings but they should\nbe calculated including the domain in the username parameter (as opposed\nto password_column which (when containing HA1 strings) should always\ncontains HA1 strings calculated without domain in username.\n\nThis ensures that the authentication will always work when using\npre-calculated HA1 strings, not depending on the presence of the domain\nin username.\n\nDefault value of this parameter is 0.\n\n```\n...\nmodparam(\"auth_db\", \"calculate_ha1\", 1)\n...\n```\n",
   "use_domain": "### `use_domain` (integer)\n\nIf true (not 0), domain will be also used when looking up in the\nsubscriber table. If you have a multi-domain setup, it is strongly\nrecommended to turn on this parameter to avoid username overlapping\nbetween domains.\n\nIMPORTANT: before turning on this parameter, be sure that the `domain`\ncolumn in `subscriber` table is properly populated.\n\nDefault value is \u201c0 (false)\u201d.\n\n```\n...\nmodparam(\"auth_db\", \"use_domain\", 1)\n...\n        \n```\n",
   "load_credentials": "### `load_credentials` (string)\n\nThis parameter specifies of credentials to be fetch from database when\nthe authentication is performed. The loaded credentials will be stored\nin AVPs. If the AVP name is not specifically given, it will be used a\nNAME AVP with the same name as the column name.\n\nParameter syntax:\n\n- *load_credentials = credential (';' credential)**\n\n- *credential = (avp_specification '=' column_name) | (column_name)*\n\n- *avp_specification = '$avp(' + 'i:'ID | 's:'NAME | alias + ')'*\n\nDefault value of this parameter is \u201cNULL\u201d (no credentials loaded).\n\n```\n...\n# load rpid column into $avp(i:123) and email_address column\n# into $avp(s:email_address)\nmodparam(\"auth_db\", \"load_credentials\", \"$avp(i:123)=rpid;email_address\")\n...\n```\n",
   "version_table": "### `version_table` (integer)\n\nIf set to 0, the module will skip checking the version for subscriber\ntable.\n\nDefault value is \u201c1 (check for table version)\u201d.\n\n```\n...\nmodparam(\"auth_db\", \"version_table\", 0)\n...\n        \n```\n",
   "force_generate_avps": "### `force_generate_avps` (integer)\n\nIf set to different than 0, the module will fetch user DB attributes\neven if authentication failed.\n\nDefault value is \u201c0\u201d (don't fetch user DB attributes if authentication\nfailed).\n\n```\n...\nmodparam(\"auth_db\", \"force_generate_avps\", 1)\n...\n        \n```\n"
  },
  "functions": {
   "www_authenticate": "### `www_authenticate(realm, table [, method])`\n\nName alias: www_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nNegative codes may be interpreted as follows:\n\n- *-1 (generic error)* - Bad credentials , couldn't parse credentials ,\n  no memory left , couldn't fetch from table , couldn't get realm or\n  some generic error occurred and no reply was sent out;\n\n- *-2 (invalid password)* - wrong password;\n\n- *-3 (invalid user)* - authentication user does not exist.\n\n- *-4 (nonce expired)* - the nonce has expired\n\n- *-5 (no credentials)* - request does not contain an Authorization\n  header with the correct realm.\n\n- *-6 (nonce reused)* - the nonce has already been used to authenticate\n  a previous request\n\n- *-8 (authuser mismatch)* - depending on the method, the From/To/RURI\n  user does not match the authentication user (see auth_check()\n  function).\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests To header\n  field domain (e.g., variable $td) can be used (because this header\n  field represents the user being registered), for all other messages\n  From header field domain can be used (e.g., variable $fd).\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\n- *method* - the method to be used for authentication. This parameter is\n  optional and if not set is the first \"word\" on the request-line.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!www_authorize(\"kamailio.org\", \"subscriber\")) {\n    www_challenge(\"kamailio.org\", \"1\");\n};\n...\n```\n",
   "www_authorize": "### `www_authorize(realm, table)`\n\nIt is same function as www_authenticate(realm, table). This name is kept\nfor backward compatibility, since it was named this way first time by it\nactually does user authentication.\n",
   "proxy_authenticate": "### `proxy_authenticate(realm, table)`\n\nName alias: proxy_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable $fd).\n\n  If an empty string \u201c\u201d is used then the server will generate it from\n  the request. From header field domain will be used as realm.\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!proxy_authorize(\"$fd\", \"subscriber)) {\n    proxy_challenge(\"$fd\", \"1\");  # Realm will be autogenerated\n};\n...\n```\n",
   "proxy_authorize": "### `proxy_authorize(realm, table)`\n\nIt is same function as proxy_authenticate(realm, table). This name is\nkept for backward compatibility, since it was named this way first time\nbut it actually does user authentication.\n",
   "auth_check": "### `auth_check(realm, table, flags)`\n\nThe function combines the functionalities of `www_authenticate` and\n`proxy_authenticate`, first being executed if the SIP request is a\nREGISTER, the second for the rest.\n\nIn addition, a matter of *flags* parameter value, the function checks if\nauthentication username matches From/To header username, and Request-URI\nin case of PUBLISH.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable $fd).\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\n  The string may contain pseudo variables.\n\n- *flags* - set of flags to control the behaviour of the function. If it\n  is 1, then the function will check to see if the authentication\n  username matches either To or From header username. REGISTER requests:\n  From and To must match the authentication user. PUBLISH requests:\n  From, To and Request-URI must match the authentication user. All other\n  requests: From header must match the authentication user. If bit 2 is\n  set as well (flags==3), the ID check is skipped for INVITE, BYE,\n  PRACK, UPDATE, MESSAGE - these requests can come with anonymous caller\n  id. If set to 0, then all user checks are skipped.\n\n  Additionally all domains in the checked URIs and the realm in the\n  authentication header will be checked to match the provided realm\n  parameter.\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!auth_check(\"$fd\", \"subscriber\", \"1\")) {\n    auth_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "is_subscriber": "### `is_subscriber(uri, dbtable, flags)`\n\nThe function checks if there is a subscriber corresponding to the AoR in\nuri parameter. It uses same database connection as for authentication\nfunctions.\n\nIn addition, if the subscriber record is found, then the\nload_credentials attributes are loaded. A use case can be loading the\ncredential attributes for callee.\n\nMeaning of the parameters is as follows:\n\n- *uri* - a valid SIP URI value to identify the subscriber. The string\n  may contain pseudo variables.\n\n- *dbtable* - Table to be used to lookup username and domain from URI\n  (usually subscriber table). The string may contain pseudo variables.\n\n- *flags* - set of flags to control the behaviour of the function. If\n  1st bit is set, then the function will use the domain part of the URI\n  to perform the database table search. If 2nd bit is set, then the\n  credentials are not loaded in variables (a simple check if subscriber\n  exists).\n\n  The parameter may be a pseudo variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (!is_subscriber(\"$ru\", \"subscriber\", \"3\")) {\n    # callee is not a local subscriber\n    ...\n}\n...\n```\n"
  }
 },
 "auth_diameter": {
  "overview": "This module implements SIP authentication and authorization with\nDIAMETER server, namely DIameter Server Client (DISC).\n\nNOTE: diameter support was developed for DISC (DIameter Server Client\nproject at http://developer.berlios.de/projects/disc/). This project\nseems to be no longer maintained and DIAMETER specifications were\nupdated in the meantime. Thus, the module is obsolete and needs rework\nto be usable with opendiameter or other DIAMETER servers.\n\nThe digest authentication mechanism is presented in next figure.\n\n```\n...\n    a) First phase of Digest Authentication for SIP:\n\n\n     +----+ SIP INVITE   +=====+  DIAMETER      +------+       +------+\n     |    | no Auth hdr  #/////#  AA-Request    |      |       |      |\n     |    |---------1--->#/////#-------2------->|      |---2-->|      |\n     |UAC |              #UAS//#                |DClnt |       |DSrv  |\n     |    |<-----4-------#(SER)#<------3--------|(DISC)|<--3---|(DISC)|\n     |    |     401      #/////#  DIAMETER      |      |       |      |\n     +----+ Unauthorized +=====+  AA-Answer     +------+       +------+\n                                  Result-Code=4001\n\n\n    b) Second phase of Digest Authentication for SIP:\n\n\n     +----+ SIP INVITE   +=====+  DIAMETER     +------+       +----+\n     |    | Auth hdr     #/////#  AA-Request   |      |       |    |\n     |    |--------1---->#/////#-------2------>|      |---2-->|    |\n     |UAC |              #UAS//#               |DClnt |       |DSrv|\n     |    |<-------4-----#(SER)#<------3-------|      |<--3---|    |\n     |    |      200 OK  #/////#  DIAMETER     |      |       |    |\n     +----+              +=====+  AA-Answer    +------+       +----+\n                                  Result-Code=2001\n\n...\n```\n",
  "parameters": {
   "diameter_client_host": "### `diameter_client_host` (string)\n\nHostname of the machine where the DIAMETER Client is running.\n\n*Default value is \u201clocalhost\u201d.*\n\n```\n...\nmodparam(\"auth_diameter\", \"diameter_client_host\", \"10.10.10.10\")\n...\n```\n",
   "diameter_client_port": "### `diameter_client_port` (int)\n\nPort number where the DIAMETER Client is listening.\n\n*Default value is \u201c3000\u201d.*\n\n```\n...\nmodparam(\"auth_diameter\", \"diameter_client_port\", 3000)\n...\n```\n",
   "use_domain": "### `use_domain` (int)\n\nSpecifies whether the domain name part of URI is used when checking the\nuser's privileges.\n\n*Default value is \u201c0 (0==false and 1==true )\u201d.*\n\n```\n...\nmodparam(\"auth_diameter\", \"use_domain\", 1)\n...\n```\n"
  },
  "functions": {
   "diameter_www_authorize": "### `diameter_www_authorize(realm)`\n\nSIP Server checks for authorization having a DIAMETER server in backend.\nIf no credentials are provided inside the SIP request then a challenge\nis sent back to UAC. If the credentials don't match the ones computed by\nDISC then \u201c403 Forbidden\u201d is sent back.\n\nNegative codes may be interpreted as follows:\n\n- *-5 (generic error)* - some generic error occurred and no reply was\n  sent out;\n\n- *-3 (stale nonce)* - stale nonce;\n\nMeaning of the parameters is as follows:\n\n- *realm* - the realm to be use for authentication and authorization.\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif(!diameter_www_authorize(\"siphub.net\"))\n{ /* user is not authorized */\n    exit;\n};\n...\n```\n",
   "diameter_proxy_authorize": "### `diameter_proxy_authorize(realm)`\n\nSIP Proxy checks for authorization having a DIAMETER server in backend.\nIf no credentials are provided inside the SIP request then a challenge\nis sent back to UAC. If the credentials don't match the ones computed by\nDISC then \u201c403 Forbidden\u201d is sent back. For more about the negative\nreturn codes, see the above function.\n\nMeaning of the parameters is as follows:\n\n- *realm* - the realm to be use for authentication and authorization.\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif(!diameter_proxy_authorize(\"siphub.net\"))\n{ /* user is not authorized */\n    exit;\n};\n...\n```\n",
   "diameter_is_user_in": "### `diameter_is_user_in(who, group)`\n\nThe method performs group membership checking with DISC.\n\nMeaning of the parameters is as follows:\n\n- *who* - what header to be used to get the SIP URI that is wanted to be\n  checked being member in a certain group. It can be: \u201cRequest-URI\u201d,\n  \u201cFrom\u201d, \u201cTo\u201d or \u201cCredentials\u201d.\n\n- *group* - the group name where to check if the user is part of.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif(!diameter_is_user_in(\"From\", \"voicemail\"))\n{ /* user is not authorized */\n    exit;\n};\n...\n```\n"
  }
 },
 "auth_ephemeral": {
  "overview": "This module contains all authentication related functions that can work\nwith ephemeral credentials. This module can be used together with the\n*auth* module for digest authentication. Use this module if you want to\nuse ephemeral credentials instead of ordinary usernames and passwords.\n",
  "parameters": {
   "secret": "### `secret` (string)\n\nThe shared secret to use for generating credentials. This parameter can\nbe set multiple times - this enables the secret used for new credentials\nto be changed without causing existing credentials to stop working. The\nlast secret set is the first that will be tried.\n\n```\n...\nmodparam(\"auth_ephemeral\", \"secret\", \"kamailio_rules\")\n...\n```\n",
   "username_format": "### `username_format` (integer)\n\nThe format of the username in the web-service response.\n\n- 0 (deprecated - pre IETF draft format) - <username parameter from the\n  request>:<timestamp>\n\n- 1 (default - IETF draft format) - <timestamp>:<username parameter\n  from the request>\n\n<!-- -->\n\n\n```\n...\nmodparam(\"auth_ephemeral\", \"username_format\", 0)\n...\n```\n",
   "sha_algorithm": "### `sha_algorithm` (integer)\n\nThe SHA algorithm to be used for the Hash.\n\n- 0 - SHA1 (default, as per IETF/RFC)\n\n- 1 - SHA256\n\n- 2 - SHA384\n\n- 3 - SHA512\n\n<!-- -->\n\n\n```\n...\nmodparam(\"auth_ephemeral\", \"sha_algorithm\", 2)\n...\n```\n"
  },
  "functions": {
   "autheph_proxy": "### `autheph_proxy(realm)`\n\nThis function performs proxy authentication.\n\n<div class=\"note\">\n\n\nThis function can only be used when the *auth* module is loaded before\nthis module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *realm* - realm is an opaque string that the user agent should present\n  to the user so that he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be an empty string \u201c\u201d. Apart from a static string, a\n  typical value is the From-URI domain (i.e., $fd).\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_proxy(\"$fd\")) {\n    auth_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "autheph_www": "### `autheph_www(realm[, method])`\n\nThis function performs WWW digest authentication.\n\n<div class=\"note\">\n\n\nThis function can only be used when the *auth* module is loaded before\nthis module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *realm* - realm is an opaque string that the user agent should present\n  to the user so that he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be an empty string \u201c\u201d. Apart from a static string, a\n  typical value is the From-URI domain (i.e., $fd).\n\n  The string may contain pseudo variables.\n\n- *method* - the method to be used for authentication. This parameter is\n  optional and if not set the first \"word\" on the request-line is used.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_www(\"$fd\")) {\n    auth_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "autheph_check": "### `autheph_check(realm)`\n\nThis function combines the functionalities of `autheph_www` and\n`autheph_proxy`, the first being executed if the SIP request is a\nREGISTER, the second for the rest.\n\n<div class=\"note\">\n\n\nThis function can only be used when the *auth* module is loaded before\nthis module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *realm* - realm is an opaque string that the user agent should present\n  to the user so that he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be an empty string \u201c\u201d. Apart from a static string, a\n  typical value is the From-URI domain (i.e., $fd).\n\n  The string may contain pseudo variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_check(\"$fd\")) {\n    auth_challenge(\"$fd\", \"1\");\n    exit;\n}\n...\n```\n",
   "autheph_authenticate": "### `autheph_authenticate(username, password)`\n\nThis function performs non-digest ephemeral authentication. This may be\nused when digest authentication cannot. For example, during WebSocket\nhandshake the username may be part of the requested URI and the password\npresented in a Cookie: header.\n\n<div class=\"note\">\n\n\nThis function may be used without loading the *auth* module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *username* - the username returned in the response from the\n  web-service.\n\n- *password* - the password returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_authenticate(\"$var(username)\", \"$var(password)\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n```\n",
   "autheph_check_from": "### `autheph_check_from([username])`\n\nThis function checks that the username (or username and domain) in the\nFrom: URI matches the credentials.\n\nWhen used without the *username* parameter it compares the From: URI\nwith the credentials used to authenticate the request (in the\nAuthorization: or Proxy-Authorization: headers).\n\nThe *username* parameter can be used to check the From: when individual\nSIP requests are not authenticated (for example, when they are over\nWebSockets and the connection was authenticated during the handshake).\nIn this scenario the username should be cached (perhaps in a hash-table)\nat the point the authentication occurs.\n\n<div class=\"note\">\n\n\nThis function must have the optional *username* parameter specified to\nuse it without loading the *auth* module before this module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *username* (optional) - the username returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_check_from()) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n```\n",
   "autheph_check_to": "### `autheph_check_to([username])`\n\nThis function checks that the username (or username and domain) in the\nTo: URI matches the credentials.\n\nWhen used without the *username* parameter it compares the To: URI with\nthe credentials used to authenticate the request (in the Authorization:\nor Proxy-Authorization: headers).\n\nThe *username* parameter can be used to check the From: when individual\nSIP requests are not authenticated (for example, when they are over\nWebSockets and the connection was authenticated during the handshake).\nIn this scenario the username should be cached (perhaps in a hash-table)\nat the point the authentication occurs.\n\n<div class=\"note\">\n\n\nThis function must have the optional *username* parameter specified to\nuse it without loading the *auth* module before this module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *username* (optional) - the username returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_check_to()) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n```\n",
   "autheph_check_timestamp": "### `autheph_check_timestamp(username)`\n\nThis function checks that the timestamp in the *username* parameter has\nnot expired. The *autheph_(check|proxy|www)* functions all do this\nautomatically, but in a scenario when individual SIP requests are not\nauthenticated (for example, when they are over WebSockets and the\nconnection was authenticated during the handshake) you may want to\nre-check for each new out-of-dialog request. In this scenario the\nusername should be cached (perhaps in a hash-table) at the point\nauthentication occurs.\n\n<div class=\"note\">\n\n\nThis function may be used without loading the *auth* module.\n\n</div>\n\n\nThe meaning of the parameters are as follows:\n\n- *username* - the username returned in the response from the\n  web-service.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!autheph_check_timestamp(\"$var(username)\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n```\n"
  }
 },
 "auth_radius": {
  "overview": "This module contains functions that are used to perform authentication\nusing a Radius server. Basically the proxy will pass along the\ncredentials to the radius server which will in turn send a reply\ncontaining result of the authentication. So basically the whole\nauthentication is done in the Radius server. Before sending the request\nto the radius server we perform some sanity checks over the credentials\nto make sure that only well formed credentials will get to the server.\nWe have implemented radius authentication according to\ndraft-sterman-aaa-sip-00. This module requires the radiusclient-ng\nlibrary version 0.5.0 or higher or freeradius-client which is available\nfrom <https://github.com/FreeRADIUS/freeradius-client/>. You can also\ninstall this library from distribution repositories.\n",
  "parameters": {
   "radius_config": "### `radius_config` (string)\n\nThis is the location of the configuration file of radius client\nlibraries.\n\nDefault value is \u201c/usr/local/etc/radiusclient-ng/radiusclient.conf\u201d.\n\n```\nmodparam(\"auth_radius\", \"radius_config\", \"/etc/radiusclient.conf\")\n        \n```\n",
   "service_type": "### `service_type` (integer)\n\nThis is the value of the Service-Type radius attribute to be used. The\ndefault should be fine for most people. See your radius client include\nfiles for numbers to be put in this parameter if you need to change it.\n\nDefault value is \u201c15\u201d.\n\n```\nmodparam(\"auth_radius\", \"service_type\", 15)\n        \n```\n",
   "auth_extra": "### `auth_extra` (string)\n\nSemi-colon separated list of extra RADIUS attribute name=pseudo variable\npairs. When radius_www_authorize() or radius_proxy_authorize() function\nis called, listed extra attributes are included in RADIUS request with\ncurrent values of corresponding pseudo variables.\n\nThere is no default value, i.e., by default no extra attributes are\nincluded.\n\n```\nmodparam(\"auth_radius\", \"auth_extra\", \"Acct-Session-Id=$ci\")\n        \n```\n",
   "use_ruri_flag": "### `use_ruri_flag` (integer)\n\nWhen this parameter is set to the value other than \"-1\" and the request\nbeing authenticated has flag with matching number set via setflag()\nfunction, use Request URI instead of uri parameter value from the\nAuthorization / Proxy-Authorization header field to perform RADIUS\nauthentication. This is intended to provide workaround for misbehaving\nNAT / routers / ALGs that alter request in the transit, breaking\nauthentication. At the time of this writing, certain versions of Linksys\nWRT54GL are known to do that.\n\nDefault value is \u201c-1\u201d.\n\n```\nmodparam(\"auth_radius\", \"use_ruri_flag\", 22)\n                \n```\n",
   "radius_avps_mode": "### `radius_avps_mode` (integer)\n\nIf set to 1, all RADIUS AVPs returned by RADIUS server are stored in\nKamailio AVPs list. If set to 0, only the SIP_AVP type of RADIUS AVPs\nare stored in Kamailio AVPs list.\n\nDefault value is 0.\n\n```\nmodparam(\"auth_radius\", \"radius_avps_mode\", 1)\n        \n```\n",
   "append_realm_to_username": "### `append_realm_to_username` (integer)\n\nIf set to 1, the username passed to the RADIUS server will have the\ndigest realm appended to it, if no domain is provided in the digest\nusername.\n\nDefault value is 1.\n\n```\nmodparam(\"auth_radius\", \"append_realm_to_username\", 0)\n        \n```\n"
  },
  "functions": {
   "radius_www_authorize": "### `radius_www_authorize(realm [, uri_user])`\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions).\n\nIf the function was unable to verify the credentials for some reason, it\nfails and assigns a WWW-Authorize header containing a new challenge to\ndigest_challenge AVP (see modules/auth). The script should then respond\nwith 401 that includes this header, which will challenge the user again.\n\nNegative result codes may be interpreted as follows:\n\n- *-7 (internal error)* - some internal error occurred (see syslog);\n\n- *-6 (nonce reused)* - nonce is used more than once;\n\n- *-5 (no credentials)* - credentials were not found in request;\n\n- *-4 (stale nonce)* - stale nonce;\n\n- *-2 (authorization failed)* - RADIUS responded with Access Reject\n  which may be, for example, due to user not found or wrong password;\n\n- *-1 (error)* - some error occurred during authorization (see syslog);\n\nThis function will perform sanity checks over the received credentials\nand then pass them along to RADIUS server which will verify the\ncredentials and return whether they are valid or not.\n\nMeaning of the parameter is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use. In\n  case of REGISTER requests it is usually hostpart of To URI.\n\n  The string may contain pseudo variables.\n\n- *uri_user* - Uri_user is an optional pseudo variable parameter whose\n  value, if present, will be given to Radius server as value of\n  SIP-URI-User check item. If uri_user pseudo variable parameter is not\n  present, the server will generate SIP-URI-User check item value from\n  user part of To/From URI.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    if (!radius_www_authorize(\"$td\")) {\n        switch ($rc) {\n        case -7:\n        send_reply(\"500\", \"Server Internal Error\");\n        exit;\n        case -1:\n        send_reply(\"400\", \"Bad Request\");\n        exit;\n        default:\n        };\n        if (defined($avp(digest_challenge)) &&\n                ($avp(digest_challenge) != \"\")) {\n            append_to_reply(\"$avp(digest_challenge)\");\n        };\n        send_reply(\"401\", \"Unauthorized\");\n        exit;\n    };\n...\n```\n",
   "radius_proxy_authorize": "### `radius_proxy_authorize(realm [, uri_user])`\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions).\n\nIf the function was unable to verify the credentials for some reason, it\nfails and assigns a Proxy-Authorize header containing a new challenge to\ndigest_challenge AVP. The script should then respond with 407 that\nincludes this header, which will challenge the user again. For negative\nresult codes, see the above function.\n\nThis function will perform sanity checks over the received credentials\nand then pass them along to RADIUS server which will verify the\ncredentials and return whether they are valid or not.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is an opaque string that the user agent should present\n  to the user so he can decide what username and password to use. In\n  case of non-REGISTER requests it is usually hostpart of From or\n  P-Preferred-Identity URI.\n\n  The string may contain pseudo variables.\n\n- *uri_user* - Uri_user is an optional pseudo variable parameter whose\n  value, if present, will be given to Radius server as value of\n  SIP-URI-User check item. If uri_user pseudo variable parameter is not\n  present, the server will generate SIP-URI-User check item value from\n  user part of To/From URI.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    if (!radius_proxy_authorize(\"$pd\", \"$pU\")) { # Realm and URI user are taken\n        switch ($rc) {                           # from P-Preferred-Identity\n        case -7:                                 # header field\n        send_reply(\"500\", \"Server Internal Error\");\n        exit;\n        case -1:\n        send_reply(\"400\", \"Bad Request\");\n        exit;\n        default:\n        };\n        if (defined($avp(digest_challenge)) &&\n                ($avp(digest_challenge) != \"\")) {\n            append_to_reply(\"$avp(digest_challenge)\");\n        };\n        send_reply(\"407\", \"Proxy Authentication Required\");\n        exit;\n    };\n...\n```\n"
  }
 },
 "auth_xkeys": {
  "overview": "This module provides a custom mechanism to authenticate a SIP entity\nusing a list of shared keys.\n\nIt is similar to the API key based authentication used by many web\nservices. In short, the sender adds a particular header with a hash\ntoken computed with the shared key and some values from the SIP request\n(e.g., local IP, From/To/R-URI username, Call-ID, CSeq). The receiver\nwill check the hash value and decide whether the SIP message is\nauthenticated or not. The sender and receiver have to agree beforehand\non the name of the server, shared secret, algorithm to be used and what\ndata is going to be hashed.\n\nThe module is designed to work with many shared keys on the same group,\nfor more flexibility in adding/removing keys. The last added key in the\ngroup is used to add the header, but older ones are used for matching\nthe hash value. That allows to change the active shared key without\naffecting ongoing traffic. If one decides to use a new share key, add it\nfirst to receiver (it will still authenticate with older key) and then\nto the sender. Once both nodes are provisioned with the new key, the\nolder one can be removed.\n\nFor proper protection, it is recommended to use this authentication\nmechanism over a secure channel (e.g., TLS, VPN, private network).\n\nThe benefit is avoiding the extra traffic and processing required by\nWWW-Digest authentication schema (no more 401/407 and a follow up\nrequest with credentials).\n\nAnother goal is to provide more elasticity for scalability needs of the\ncore SIP network nodes. Most of the nodes in the core network or the\ninterconnecting peers trust each other based on IP address. But adding a\nnew node requires updates to the exiting ones to trust the IP address of\nthe new node. On large deployments, that can become rather complex. For\nexample, as a replacement for IP trust relationships, the sender can\nhash the local IP with the secret shared key, add it in the header and\nthe receiver will check if the source ip hashed with the key results in\nthe same value.\n\nNot being a challenge-reply mechanism, this can be used to authenticate\nSIP responses from trusted peers.\n",
  "parameters": {
   "xkey": "### `xkey` (str)\n\nSpecify the attributes for a shared secret. The value is in the format\n'name1=value1;name2=value2;...'. The attributes can be:\n\n- *id* - the id of the group for keys\n\n- *name* - the name of the key within group\n\n- *value* - the value of the key\n\n- *expires* - expiration time (seconds)\n\n*Default value is empty.*\n\n```\n...\nmodparam(\"auth_xkeys\", \"xkey\", \"id=abc;name=xyz;value=secret;expires=72000\")\n...\n```\n"
  },
  "functions": {
   "auth_xkeys_add": "### `auth_xkeys_add(hdr, kid, alg, data)`\n\nAdd a header computed with the first key in the group kid, hashing with\nalgorithm alg over the content of parameter data. The parameters can\ninclude variables.\n\nThe algorithm can be: sha256, sha384, sha512.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nauth_xkeys_add(\"X-My-Key\", \"abc\", \"sha256\", \"$Ri:$fu:$ru:$hdr(CSeq)\");\n...\n```\n",
   "auth_xkeys_check": "### `auth_xkeys_check(hdr, kid, alg, data)`\n\nCheck if the value of header hdr matches the value computed with the\nfirst key in the group kid, hashing with algorithm alg over the content\nof parameter data. The parameters can include variables.\n\nThe algorithm can be: sha256, sha384, sha512.\n\nNote that the header is not removed by the function, it is recommended\nto remove it if sending to untrusted destination.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(!auth_xkeys_check(\"X-My-Key\", \"abc\", \"sha256\", \"$si:$fu:$ru:$hdr(CSeq)\")) {\n    send_reply(\"403\", \"Forbidden\");\n    exit;\n}\nremove_hf(\"X-My-Key\");\n...\n```\n"
  }
 },
 "avp": {
  "overview": "This module contains several functions that can be used to manipulate\nthe contents of AVPs (Attribute-Value pairs). The AVPs are variables\nattached to the SIP message being processed. Each variable has its name\nand value. AVPs can be used to store arbitrary data or as a means of\ninter-module communication.\n\nYou may also want to check the *avpops* module which is more flexible\nand contains more functions. In future Kamailio releases the avp module\nwill be probably deprecated in favor of avpops module.\n",
  "parameters": {
   "xlbuf_size": "### `xlbuf_size` (integer)\n\nDefines size of internal buffer for all xprint formatting calls. If you\ndon't use xprint formatting calls, you can set it to 0 to preserve some\nmemory, if you get errors while formatting due to buffer size, you can\nenlarge it.\n\nDefault value is 256.\n\n```\n...\nmodparam(\"avp\", \"xlbuf_size\", 1024)\n...\n        \n```\n"
  },
  "functions": {
   "set_iattr": "### `set_iattr(attribute, value)`\n\nCreate an AVP of type integer.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP to be created.\n\n- *value* - Integer value of the AVP.\n\n<!-- -->\n\n\n```\n...\nset_iattr(\"fr_inv_timer\", \"60\")\n...\n        \n```\n",
   "flags2attr": "### `flags2attr(&quot;$avp&quot;)`\n\nStore the current state of Kamailio flags into the specified AVP.\n\n```\n...\nflags2attr(\"$msg_flags\")\n...\n        \n```\n",
   "set_sattr": "### `set_sattr(attribute, value)`\n\nCreate an AVP of type string.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP to be created.\n\n- *value* - String value of the AVP.\n\n<!-- -->\n\n\n```\n...\nset_sattr(\"called_number\", \"1234\")\n...\n        \n```\n",
   "print_attr": "### `print_attr($attribute)`\n\nPrint the value of an AVP to syslog.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n",
   "attr2uri": "### `attr2uri($attribute[, uri-part])`\n\nRewrite the whole Request-URI of the message being processed with the\nvalue of an AVP, or if an `uri-part` is specified, rewrite only that\nspecific part.\n\nMeaning of the parameter is as follows:\n\n- *$attribute* - The name of the AVP.\n\n- *uri-part* - The name of the part of the uri that will be rewritten.\n  The supported values are: \"prefix\", \"uri\", \"username\", \"user\",\n  \"usernamepassword\", \"userpass\", \"domain\", \"host\", \"domainport\",\n  \"hostport\", \"port\", \"strip\", \"strip_tail\". \"prefix\" will add the AVP\n  as a prefix to the username (equivalent to prefix(\"string\")), \"strip\"\n  and \"strip_tail\" expect a number in the AVP and they will remove the\n  specified number of characters from the beginning, respective the end\n  of the username part of the uri. The rest of the uri-part values names\n  are self-explaining.\n",
   "attr_exists": "### `attr_exists(attribute)`\n\nTest for the existence of AVP with given name. The function returns 1 if\ngiven AVP exists and -1 if not.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n<!-- -->\n\n\n```\n...\nif (attr_exists(\"saved_ruri\")) {\n    attr2uri(\"saved_uri\");\n} else {\n    rewriteuri(\"sip:a@iptel.org\");\n};\n...\n        \n```\n",
   "attr_equals": "### `attr_equals(attribute, value)`\n\nTest whether an AVP with given name and value exists. The function\nreturns 1 if the AVP with given name and value exists and -1 if not. The\nvalue of the AVP is compared string-wise. The comparison is case\nsensitive.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n- *value* - The AVP value to look for.\n",
   "attr_equals_xl": "### `attr_equals_xl(attribute, xl_format)`\n\nTest whether an AVP with given name and value exists. The function\nreturns 1 if the AVP with given name and value exists and -1 if not. The\nvalue of the AVP is compared string-wise to the result of xprint\nformatting call. The comparison is case sensitive.\n\nMeaning of the parameter is as follows:\n\n- *attribute* - The name of the AVP.\n\n- *xl_format* - The xprint formatting string, result of which is looked\n  for in AVP.\n\nNote: You must ensure, that the xprint module is loaded to be able to\nuse this function.\n\n```\n...\nif (attr_equals_xl(\"my_avp\", \"%ct\")) {\n  # my_avp has value equal to current Contact header field\n} else {\n  # my_avp was different\n}\n...\n        \n```\n",
   "dump_attrs": "### `dump_attrs()`\n\nDumps all AVPs in user lists to the debug output (with level INFO).\n\nThe function does not require any parameters.\n",
   "xlset_attr": "### `xlset_attr($attribute, xl_format)`\n\nCreates new AVP identified by *attribute* and assigns the result string\nof xprint formatting rules as its value.\n\nMeaning of the parameter is as follows:\n\n- *$attribute* - The name of the AVP.\n\n- *xl_format* - String used for xprint formatting. For detailed info see\n  documentation of xprint module.\n\nNote: You must ensure, that the xprint module is loaded to be able to\nuse this function.\n",
   "xlfix_attr": "### `xlfix_attr($attribute)`\n\nFixes an xl formatted *attribute* value to pure string.\n\nMeaning of the parameter is as follows:\n\n- *$attribute* - The name of the AVP.\n",
   "insert_attr_hf": "### `insert_attr_hf(header_name, $avp_name)`\n\nInserts new header into the request, which is being forwarded.\n\nInserting means putting the header to the beginning of the request,\nbefore any others.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is inserted into\n  forwarded request.\n\n- *$avp_name* - The name of AVP which's value is put as the header\n  field value.\n\n<!-- -->\n\n\n```\n...\nset_sattr(\"my_route\",\"<sip:user@host:port;lr>\");\ninsert_attr_hf(\"Route\", \"$my_route\");\n...\n        \n```\n",
   "append_attr_hf": "### `append_attr_hf(header_name, $avp_name)`\n\nAppends new header into the request, which is being forwarded.\n\nAppending means putting the header to the end of the request, after any\nothers.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is appended into\n  forwarded request.\n\n- *$avp_name* - The name of AVP which's value is put as the header\n  field value.\n",
   "replace_attr_hf": "### `replace_attr_hf(header_name, $avp_name)`\n\nReplaces header in the request, which is being forwarded.\n\nReplacing means removing all the headers with specified name and\nappending new one at the end, with the value from AVP.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is replaced in\n  forwarded request.\n\n- *$avp_name* - The name of AVP which's value is put as the header\n  field value.\n",
   "attr_to_reply": "### `attr_to_reply(header_name, $avp_name)`\n\nAppends new header into the reply at the request time processing.\n\nMeaning of the parameter is as follows:\n\n- *header_name* - The name of the header field which is appended into\n  reply.\n\n- *$avp_name* - The name of AVP which's value is put as the header\n  field value.\n\n<!-- -->\n\n\n```\n...\nxlset_attr(\"$my_route\",\"<sip:%Hf:5080;lr>\";\nattr_to_reply(\"P-Hint-Route\", \"my_route\");\n...\n        \n```\n",
   "attr_destination": "### `attr_destination($avp_name)`\n\nSets the destination of the forwarded request to the value of AVP, which\nmust be either a SIP URI or a string in nameaddr format (e.g. \"Foo Bar\"\n<sip:uri>).\n\nMeaning of the parameter is as follows:\n\n- *$avp_name* - The name of AVP which's value is used for further\n  request forwarding.\n\n<!-- -->\n\n\n```\n...\nxlset_attr(\"$my_route\",\"<sip:%<next_host>:%<next_port>;myparam=a123;lr>\");\ninsert_attr_hf(\"Route\", \"$my_route\");\nattr_destination(\"$my_route\");\nt_relay();\n...\n        \n```\n",
   "xlset_destination": "### `xlset_destination(xl_format)`\n\nSets the destination of the forwarded request to the value of result of\nxprint formatted string. Either SIP URI or nameaddr format is allowed.\n\nMeaning of the parameter is as follows:\n\n- *xl_format* - xprint module formatting string, the result is used for\n  request forwarding.\n\nNote: You must ensure, that the xprint module is loaded to be able to\nuse this function.\n\n```\n...\nxlset_destination(\"%<next_host>:%<next_port>\");\nt_relay();\n...\n        \n```\n",
   "subst_attr": "### `subst_attr($avp_name, subst_re)`\n\nThe value of the AVP identified by *$avp_name* name is matched and\nsubstitued according to the *subst_re* sed like expression. Result of\nthe substitution is then stored in the original AVP.\n\nMeaning of the parameter is as follows:\n\n- *$avp_name* - Name of the AVP which will be used for the\n  substitution.\n\n- *subst_re* - SED like match&replace regullar expression.\n\n<!-- -->\n\n\n```\n...\nsubst_attr(\"$uri\",\"/tel:[0-9]*/sip:\\1@foo.bar;user=phone/\");\n...\n        \n```\n",
   "del_attr": "### `del_attr($avp_name)`\n\nThe AVP identified by *$avp_name* name is deleted.\n\nMeaning of the parameter is as follows:\n\n- *$avp_name* - Name of the AVP which will be deleted.\n\n<!-- -->\n\n\n```\n...\nfailure_route[1] {\n    if (status=~4[0-9][0-9]) {\n        if (attr_exists(\"backup_gw\") {\n            append_branch;\n            attr_destination(\"backup_gw\");\n            del_attr(\"backup_gw\");\n            t_relay();\n        }\n    }\n...\n        \n```\n",
   "hdr_body2attrs": "### `hdr_body2attrs(headername, prefix)`\n\nFunction parses a header body content scans for fld1=val1,fld2=val2,...\nand creates bunch of avps prefixfld1:= val1, prefixfld2:= val2, .... If\npossible stores values as integers.\n\nMeaning of the parameter is as follows:\n\n- *headername* - The header name, which will be scanned for the\n  name=value pairs.\n\n  If you want to create only AVPs with integer value use \"/i\" postfix to\n  the header name.\n\n  If you want to create only AVPs with string value use \"/s\" postfix to\n  the header name.\n\n- *prefix* - The prefix, which is added before the name parsed from the\n  header body.\n",
   "hdr_body2attrs2": "### `hdr_body2attrs2(headername, prefix)`\n\nFunction parses a header body content scans for\nfld1=val1,val2;fld2=val3,... and creates bunch of avps prefixfld1#1:=\nval1, prefixfld1#2:= val2, prefixfld2:=val3 .... If possible stores\nvalues as integers.\n\nMeaning of the parameter is as follows:\n\n- *headername* - The header name, which will be scanned for the\n  name=value pairs.\n\n  If you want to create only AVPs with integer value use \"/i\" postfix to\n  the header name.\n\n  If you want to create only AVPs with string value use \"/s\" postfix to\n  the header name.\n\n- *prefix* - The prefix, which is added before the name parsed from the\n  header body.\n\n<!-- -->\n\n\n```\nif (method==\"BYE\") {\n    # QoS reporting\n    if (search(\"^User-Agent: AVM FRITZ!Box Fon*\")) {\n        hdr_body2attrs2(\"X-RTP-Stat/i\", \"QoS_\");\n        xplog(\"L_INFO\", \"QoS: %Ts, %fu, %tu, %ci, %{User-Agent}, %{X-RTP-Stat}\\n\");\n    } else if (search(\"^User-Agent: Sipura/*\")) {\n        hdr_body2attrs(\"P-RTP-Stat/i\", \"QoS_\");\n        xplog(\"L_INFO\", \"QoS: %Ts, %fu, %tu, %ci, %{User-Agent}, %{P-RTP-Stat}\\n\");\n    }\n}\n# AVP QoS_xx now contain the values from appropriate header\n# e.g. QoS_JI is jitter\n    \n```\n"
  }
 },
 "avpops": {
  "overview": "The AVPops (AVP-operations) module implements a set of script functions\nwhich allow access and manipulation of user attribute-value pairs (AVPs,\npreferences) and pseudo-variables. AVPs are a powerful tool for\nimplementing services/preferences per user/domain. With this module,\nthey are usable directly from configuration script.\n\nThe module implements functions for interfacing DB resources\n(loading/storing/removing), functions for swapping information between\nAVPs and SIP messages and a function for testing/checking the value of\nan AVP.\n\nIf you just need a way to execute SQL statements in a Kamailio\nconfiguration script, please consider use the *sqlops* module instead.\n\nAVPs are persistent per SIP transaction, being available in \"route\",\n\"branch_route\" and \"failure_route\". A tutorial providing more\ninformation (detailed explanations and commented examples) can be found\non the SIP-router web site.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nDB URL for database connection.\n\n*The default value is NULL.*\n\n```\n...\nmodparam(\"avpops\",\"db_url\",\"mysql://user:passwd@host/database\")\n...\n                \n```\n",
   "avp_table": "### `avp_table` (string)\n\nDB table to be used.\n\n*The default value is NULL. But if you specify a db_url, you need also\nto setup this parameter.*\n\n```\n...\nmodparam(\"avpops\",\"avp_table\",\"avptable\")\n...\n                \n```\n",
   "use_domain": "### `use_domain` (integer)\n\nIf the domain part of the URI should be used for identifying an AVP in\nDB operations.\n\n*Default value is 0 (no).*\n\n```\n...\nmodparam(\"avpops\",\"use_domain\",1)\n...\n                \n```\n",
   "uuid_column": "### `uuid_column` (string)\n\nName of column containing the uuid (unique user id).\n\n*Default value is \u201cuuid\u201d.*\n\n```\n...\nmodparam(\"avpops\",\"uuid_column\",\"uuid\")\n...\n                \n```\n",
   "username_column": "### `username_column` (string)\n\nName of column containing the username.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"avpops\",\"username_column\",\"username\")\n...\n                \n```\n",
   "domain_column": "### `domain_column` (string)\n\nName of column containing the domain name.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"avpops\",\"domain_column\",\"domain\")\n...\n                \n```\n",
   "attribute_column": "### `attribute_column` (string)\n\nName of column containing the attribute name (AVP name).\n\n*Default value is \u201cattribute\u201d.*\n\n```\n...\nmodparam(\"avpops\",\"attribute_column\",\"attribute\")\n...\n                \n```\n",
   "value_column": "### `value_column` (string)\n\nName of column containing the AVP value.\n\n*Default value is \u201cvalue\u201d.*\n\n```\n...\nmodparam(\"avpops\",\"value_column\",\"value\")\n...\n                \n```\n",
   "type_column": "### `type_column` (string)\n\nName of integer column containing the AVP type.\n\n*Default value is \u201ctype\u201d.*\n\nPossible column values are\n\n- *0 - AVP with string name and string value*\n\n- *1 - AVP with string name and integer value*\n\n- *2 - AVP with integer name and string value*\n\n- *3 - AVP with integer name and integer value*\n\n<!-- -->\n\n\n```\n...\nmodparam(\"avpops\",\"type_column\",\"type\")\n...\n                \n```\n",
   "db_scheme": "### `db_scheme` (string)\n\nDefinition of a DB scheme to be used for non-standard access to Database\ninformation.\n\nDefinition of a DB scheme. Scheme syntax is:\n\n- *db_scheme = name':'element[';'element]**\n\n- *element* =\n\n  - 'uuid_col='string\n\n  - 'username_col='string\n\n  - 'domain_col='string\n\n  - 'value_col='string\n\n  - 'value_type='('integer'|'string')\n\n  - 'table='string\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"avpops\",\"db_scheme\",\n\"scheme1:table=subscriber;uuid_col=uuid;value_col=first_name\")\n...\n                \n```\n"
  },
  "functions": {
   "avp_db_load": "### `avp_db_load(source, name)`\n\nLoads from DB into memory the AVPs corresponding to the given *source*.\nIf given, it sets the script flags for loaded AVPs. It returns true if\nit loaded some values in AVPs, false otherwise (db error, no avp loaded\n...).\n\nMeaning of the parameters is as follows:\n\n- *source* - what info is used for identifying the AVPs. Parameter\n  syntax:\n\n  - *source = (pvar|str_value)\n    ['/'('username'|'domain'|'uri'|'uuid')])*\n\n  - *pvar = any pseudo variable defined in Kamailio. If the pvar is $ru\n    (request uri), $fu (from uri), $tu (to uri) or $ou (original\n    uri), then the implicit flag is 'uri'. Otherwise, the implicit flag\n    is 'uuid'.*\n\n\n- *name* - which AVPs will be loaded from DB into memory. Parameter\n  syntax is:\n\n  - *name = avp_spec['/'(table_name|'$'db_scheme)]*\n\n  - *avp_spec = matching_flags|$avp(avp_name)|$avp(avp_alias)*\n\n  - *matching_flags = 'a' | 'A' | 'i' | 'I' | 's' | 'S'\n    [script_flags]*\n\n    'a' or 'A' means matching any of AVP name types ('i' and 's') (NOTE:\n    matching_flags cannot be used with $db_scheme because the name of\n    AVP to save in cannot be specified), the rest have the meaning\n    described in 'AVP naming format' chapter.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_db_load(\"$fu\",\"$(i:678)\");\navp_db_load(\"$ru/domain\",\"i:/domain_preferences\");\navp_db_load(\"$uuid\",\"$avp(s:404fwd)/fwd_table\");\navp_db_load(\"$ru\",\"$avp(i1:123)/$some_scheme\");\n...\n                \n```\n",
   "avp_db_store": "### `avp_db_store(source, name)`\n\nStores to DB the AVPs corresponding to the given *source*.\n\nThe meaning and usage of the parameters are identical as for\n*avp_db_load(source,name)* function. Please refer to its description.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_db_store(\"$tu\",\"$avp(i:678)\");\navp_db_store(\"$ru/username\",\"$avp(email)\");\n...\n                \n```\n",
   "avp_db_delete": "### `avp_db_delete(source, name)`\n\nDeletes from DB the AVPs corresponding to the given *source*.\n\nThe meaning and usage of the parameters are identical as for\n*avp_db_load(source,name)* function. Please refer to its description.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_db_delete(\"$tu\",\"$avp(i:678)\");\navp_db_delete(\"$ru/username\",\"$avp(email)\");\navp_db_delete(\"$uuid\",\"$avp(s:404fwd)/fwd_table\");\n...\n                \n```\n",
   "avp_db_query": "### `avp_db_query(query[, dest])`\n\nMake a database query and store the result in AVPs. This command is\ndeprecated, please use the more flexible and advanced *sqlops* module\ninstead.\n\nThe meaning and usage of the parameters:\n\n- *query* - must be a valid SQL query. The parameter can contain\n  pseudo-variables.\n\n  You must escape any pseudo-variables manually to prevent SQL injection\n  attacks. You can use the existing transformations *escape.common* and\n  *unescape.common* to escape and unescape the content of any\n  pseudo-variable. Failing to escape the variables used in the query\n  makes you vulnerable to SQL injection, e.g. make it possible for an\n  outside attacker to alter your database content.\n\n- *dest* - a list with AVP names where to store the result. The format\n  is \u201c$avp(name1);$avp(name2);...\u201d. If this parameter is ommited, the\n  result is stored in \u201c$avp(i:1);$avp(i:2);...\u201d. If the result gives\n  many rows, then multiple AVPs with corresponding name will be added.\n  The value type of the AVP (string or integer) will be derived from the\n  type of the columns. Please note that only this two datatypes are\n  supported, so it is not possible for example to return floating point\n  or big integer values this way.\n\nThe function delivers the following return-codes:\n\n- *-1* - An error occurred while querying the database (e.g. wrong SQL\n  or database error)\n\n- *1* - Query was successful\n\n- *-2* - Query was successful, but no rows where returned.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_db_query(\"select password, ha1 from subscriber where username='$tu'\",\n    \"$avp(i:678);$avp(i:679)\");\navp_db_query(\"delete from subscriber\");\n...\n                \n```\n",
   "avp_delete": "### `avp_delete(name)`\n\nDeletes from memory the AVPs with *name* or, if empty, all AVPs.\n\nMeaning of the parameters is as follows:\n\n- *name* - which AVPs will be deleted from memory. Parameter syntax is:\n\n  - *name = (matching_flags|avp_name|avp_alias)['/'flag]*\n\n  - *matching_flags = please refer to avp_db_load() function*\n\n  - *flag = 'g'|'G' = deletes not only the last value but the complete\n    AVP.*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_delete(\"$avp(i:678)/g\");\navp_delete(\"$avp(email)\");\navp_delete(\"i\");\navp_delete(\"a3\");\n...\n                \n```\n",
   "avp_pushto": "### `avp_pushto(destination, name)`\n\nPushes the value of AVP(s) into the SIP message.\n\nMeaning of the parameters is as follows:\n\n- *destination* - as what will be the AVP value pushed into SIP message.\n  Parameter syntax:\n\n  - *destination = '$ru' ['/'('username'|'domain')] | '$du' |\n    '$br'*\n\n  - *$ru '['/'('username'|'domain')] - write the AVP in the request\n    URI or in username/domain part of it*\n\n  - *$du - write the AVP in 'dst_uri' field*\n\n  - *$br - write the AVP directly as a new branch (does not affect\n    RURI)*\n\n\n- *name* - which AVP(s)/pseudo-variable should be pushed into the SIP\n  message. Parameter syntax is:\n\n  - *name = ( avp_name | avp_alias | pvar_name )['/'flags]*\n\n  - *flags = 'g' - effective only with AVPs*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_pushto(\"$ru/domain\",\"$fd\");\navp_pushto(\"$ru\",\"$avp(i:678)\");\navp_pushto(\"$ru/domain\",\"$avp(s:backup_domains)/g\");\navp_pushto(\"$du\",\"$avp(i:679)\");\navp_pushto(\"$br\",\"$avp(i:680)\");\n...\n                \n```\n",
   "avp_check": "### `avp_check(name, op_value)`\n\nChecks the value of the AVP(s) against an operator and value.\n\nMeaning of the parameters is as follows:\n\n- *name* - which AVP(s) should be checked. Parameter syntax is:\n\n  - *name = ( pseudo-variable )*\n\n- *op_value* - define the operator, the value and flags for checking.\n  Parameter syntax is:\n\n  - *op_value = operator '/' value ['/'flags]*\n\n  - *operator = 'eq' | 'ne' | 'lt' | 'le' | 'gt' | 'ge' | 're' |\n    'fm' | 'and' | 'or' | 'xor'*\n\n  - *value = pseudo-variable | fix_value*\n\n  - *fix_value = 'i:'integer | 's:'string | string*\n\n  - *flags = 'g' | 'G' | 'i' | 'I'*\n\n\n  Operator meaning:\n\n  - *eq* - equal\n\n  - *ne* - not equal\n\n  - *lt* - less than\n\n  - *le* - less or equal\n\n  - *gt* - greater than\n\n  - *ge* - greater or equal\n\n  - *re* - regexp (regular expression match)\n\n  - *fm* - fast match (see: man fnmatch)\n\n  - *and* - bitwise 'and'\n\n  - *or* - bitwise 'or'\n\n  - *xor* - bitwise 'xor'\n\n\n  Integer values can be given in hexadecimal using notation:\n  'i:0xhex_number' (e.g.,: 'i:0xabcd');\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_check(\"$avp(i:678)\", \"lt/i:345/g\");\navp_check(\"$fd\",\"eq/$td/I\");\navp_check(\"$avp(s:foo)\",\"gt/$avp($var(bar))/g\");\navp_check(\"$avp(s:foo)\",\"re/sip:.*@bar.net/g\");\navp_check(\"$avp(s:foo)\",\"fm/$avp(fm_avp)/g\");\n...\n                \n```\n\nNOTE: you can use a xavp variable\n($xavp(key1[indx1]=>key2[indx2])) as first or second parameter. If\nyou want to check all the values of the key2 you should use [*] at\nindx2. The [*] index is not allowed at indx1.\n\n```\n...\navp_check(\"$xavp(op[0]=>lt[0])\", \"lt/i:345/g\");\navp_check(\"$xavp(op=>fd\",\"eq/$td/I\");\navp_check(\"$xavp(op[1]=>foo[*])\",\"gt/$avp($var(bar))/g\");\navp_check(\"$avp(s:foo)\",\"re/$xavp(op[0]=>re[*]/g\");\n$var(id)=2;\navp_check(\"$xavp(op=>foo[*])\",\"fm/$xavp(op=>fm[$var(id)])/g\");\n...\n                \n```\n",
   "avp_copy": "### `avp_copy(old_name, new_name)`\n\nCopy / move an avp under a new name.\n\nMeaning of the parameters is as follows:\n\n- *name1* - which AVP(s) should be copied/moved. Parameter syntax is:\n\n  - *name = ( avp_name | avp_alias )*\n\n- *name2* - the new name of the copied/moved AVP(s). Parameter syntax\n  is:\n\n  - *name = ( avp_name | avp_alias ) ['/'flags]*\n\n  - *flags = 'g' | 'G' | 'd' | 'D' | 'n' | 'N' | 's' | 'S'*\n\nNOTE: if a list of AVPs is copied/moved (flag g|G), then the order of\nthe values is reversed. Copy/move twice in order to get the same order\nas in original list.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\navp_copy(\"$avp(i:678)\", \"$avp(s:345)/g\");\navp_copy(\"$avp(old)\",\"$avp(new)/gd\");\n...\n                \n```\n",
   "avp_printf": "### `avp_printf(dest, format)`\n\nNOTE: since Kamailio 1.3.0 the function has been moved to core and it is\nan alias to pv_printf().\n\nPrints the formatted string 'format' in the AVP 'dest'. The 'format'\nparameter can include any pseudo-variable defined in Kamailio. The list\nwith all pseudo-variables in Kamailio can be found at:\n<https://www.kamailio.org/wikidocs/>\n\nMeaning of the parameters is as follows:\n\n- *dest* - in which AVP should be stored the result. Parameter syntax\n  is:\n\n  - *name = ( avp_name | avp_alias )*\n\n- *format* - the formatted string to be printed in 'dest' AVP.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_printf(\"$avp(i:20)\", \"This is a $rm request with call-id $hdr(call-id)\");\n...\n                \n```\n",
   "avp_subst": "### `avp_subst(avps, subst)`\n\nPerl/sed-like subst applied to AVPs having string value.\n\nMeaning of the parameters is as follows:\n\n- *avps* - source AVP, destination AVP and flags. Parameter syntax is:\n\n  - *avps = src_avp [ '/' dst_avp [ '/' flags ] ]*\n\n  - *src_avp = ( avp_name | avp_alias )*\n\n  - *dst_avp = ( avp_name | avp_alias ) - if dst_avp is missing then\n    the value of src_avp will be replaced*\n\n  - *flags = ( d | D | g | G ) -- (d, D - delete source avp; g, G -\n    apply to all avps matching src_avp name)*\n\n\n- *subst* - perl/sed-like reqular expression. Parameter syntax is:\n\n  - *subst = \"/regexp/replacement/flags\"*\n\n  - *regexp - regular expression*\n\n  - *replacement - replacement string, can include pseudo-variables and\n    \\1, ..., \\9 for matching tokens, \\0 for whole matching text*\n\n  - *flags = 'g' | 'G' | 'i' | 'i' (g, G - replace all matching\n    tokens; i, I - match ignore case)*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\n# if avp i:678 has a string value in e-mail format, replace the\n# domain part with the value of domain part from R-URI\navp_subst(\"$avp(i:678)\", \"/(.*)@(.*)/\\1@$rd/\");\n\n# if any avp i:678 has a string value in e-mail format, replace the\n# domain part with the value of domain part from R-URI\n# and place the result in avp i:679\navp_subst(\"$avp(i:678)/$avp(i:679)/g\", \"/(.*)@(.*)/\\1@$rd/\");\n...\n                \n```\n\nIMPORTANT NOTE: if the replacement string includes src_avp or dst_avp\nyou will get something that you may not expect. In case you have many\nsrc_avp and you make the substitution to be applied to all of them,\nafter the first src_avp is processed, it will be added in avp list and\nnext processing will use it.\n",
   "avp_subst_pv": "### `avp_subst_pv(avps, subst)`\n\nSame functionality than avp_subst() but seccond parameter will be\nevaluated first.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\n$(avp(src)[*]) = \"testME\";\n$var(z) = \"j\";\n$var(y) = \"e\";\n$var(x) = \"/\" + $var(y) + \"/\" + $var(z) + \"/gi\";\n\n## all this calls will produce the same result \"tjstMj\"\navp_subst_pv(\"$avp(src)\", \"/e/j/gi\");\navp_subst_pv(\"$avp(src)\", \"/\" + $var(y) + \"/\" + $var(z) + \"/gi\");\navp_subst_pv(\"$avp(src)\", \"/$var(y)/$var(z)/gi\");\navp_subst_pv(\"$avp(src)\", \"$var(x)\");\n...\n                \n```\n",
   "avp_op": "### `avp_op(name, op_value)`\n\nDifferent integer operations with avps.\n\nMeaning of the parameters is as follows:\n\n- *name* - 'source_avp/destination_avp' - which AVP(s) should be\n  processed and where to store the result. If 'destination_avp' is\n  missing, same name as 'source_avp' is used to store the result.\n\n  Parameter syntax is:\n\n  - *name = ( source_avp[/destination_avp] )*\n\n    *source_avp = ( avp_name | avp_alias )*\n\n    *destination_avp = ( avp_name | avp_alias )*\n\n\n- *op_value* - define the operation, the value and flags. Parameter\n  syntax is:\n\n  - *op_value = operator '/' value ['/'flags]*\n\n  - *operator = 'add' | 'sub' | 'mul' | 'div' | 'mod' | 'and' |\n    'or' | 'xor' | 'not'*\n\n  - *value = pseudo-variable | fix_value*\n\n  - *fix_value = 'i:'integer*\n\n  - *flags = 'g' | 'G' | 'd' | 'D'*\n\n\n  Integer values can be given in hexadecimal using notation\n  'i:0xhex_number' (e.g.,: 'i:0xabcd');\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_op(\"$avp(i:678)\", \"add/i:345/g\");\navp_op(\"$avp(number)\",\"sub/$avp(number2)/d\");\n...\n                \n```\n",
   "is_avp_set": "### `is_avp_set(name)`\n\nCheck if any AVP with *name* is set.\n\nMeaning of the parameters is as follows:\n\n- *name* - name of AVP to look for. Parameter syntax is:\n\n  - *name = avp_name|avp_alias [ '/' flags ])*\n\n    *flags = ('e'|'s'|'n') - e = empty value; s = value string; n =\n    value number (int)*\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\nif(is_avp_set(\"$avp(i:678)\"))\n    log(\"AVP with integer id 678 exists\\n\");\n...\n                \n```\n",
   "avp_print": "### `avp_print()`\n\nPrints the list with all the AVPs from memory. This is only a\nhelper/debug function.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, LOCAL_ROUTE and ONREPLY_ROUTE.\n\n```\n...\navp_print();\n...\n                \n```\n"
  }
 },
 "benchmark": {
  "overview": "This module helps developers to benchmark their module functions. By\nadding this module's functions via the configuration file or through its\nAPI, Kamailio can log profiling information for every function.\n\nThe duration between calls to start_timer and log_timer is stored and\nlogged via Kamailio's logging facility. Please note that all durations\nare given as microseconds (don't confuse with milliseconds!).\n",
  "parameters": {
   "enable": "### `enable` (int)\n\nEven when the module is loaded, benchmarking is not enabled per default.\nThis variable may have three different values:\n\n- -1 - Globally disable benchmarking\n\n- 0 - Enable per-timer enabling. Single timers are inactive by default\n  and can be activated through the RPC interface as soon as that feature\n  is implemented.\n\n- 1 - Globally enable benchmarking\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"benchmark\", \"enable\", 1)\n...\n```\n",
   "granularity": "### `granularity` (int)\n\nLogging normally is not done for every reference to the log_timer()\nfunction, but only every n'th call. n is defined through this variable.\nA sensible granularity seems to be 100.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"benchmark\", \"granularity\", 500)\n...\n```\n",
   "loglevel": "### `loglevel` (int)\n\nSet the log level for the benchmark logs. These levels should be used:\n\n- -5 - L_ALERT\n\n- -4 - L_BUG\n\n- -3 - L_CRIT\n\n- -2 - L_CRIT (no prefix)\n\n- -1 - L_ERR\n\n- 0 - L_WARN\n\n- 1 - L_NOTICE\n\n- 2 - L_INFO\n\n- 3 - L_DBG\n\n*Default value is \u201c3\u201d (L_INFO).*\n\n```\n...\nmodparam(\"benchmark\", \"loglevel\", 4)\n...\n```\n\nThis will set the logging level to L_DBG.\n",
   "register": "### `register` (str)\n\nRegister a timer id at startup. Required when using the start/log\nfunctions via Kemi framework. This parameter can be set many times to\nregister several timer ids.\n\n*Default value is \u201cNONE\u201d.*\n\n```\n...\nmodparam(\"benchmark\", \"register\", \"test\")\nmodparam(\"benchmark\", \"register\", \"auth\")\n...\n```\n"
  },
  "functions": {
   "bm_start_timer": "### `bm_start_timer(name)`\n\nStart timer \u201cname\u201d. A later call to \u201cbm_log_timer()\u201d logs this timer..\n\n```\n...\nbm_start_timer(\"test\");\n...\n```\n",
   "bm_log_timer": "### `bm_log_timer(name)`\n\nThis function logs the timer with the given ID. The following data are\nlogged:\n\n- *Last msgs* is the number of calls in the last logging interval. This\n  equals the granularity variable.\n\n<!-- -->\n\n\n- *Last sum* is the accumulated duration in the current logging interval\n  (i.e. for the last \u201cgranularity\u201d calls).\n\n<!-- -->\n\n\n- *Last min* is the minimum duration between start/log_timer calls\n  during the last interval.\n\n<!-- -->\n\n\n- *Last max* - maximum duration.\n\n<!-- -->\n\n\n- *Last average* is the average duration between bm_start_timer() and\n  bm_log_timer() since the last logging.\n\n<!-- -->\n\n\n- *Global msgs* number of calls to log_timer.\n\n<!-- -->\n\n\n- *Global sum* total duration in microseconds.\n\n<!-- -->\n\n\n- *Global min*... You get the point. :)\n\n<!-- -->\n\n\n- *Global max* also obvious.\n\n<!-- -->\n\n\n- *Global avg* possibly the most interesting value.\n\n<!-- -->\n\n\n```\n...\nbm_log_timer(\"test\");\n...\n```\n"
  }
 },
 "blst": {
  "overview": "This module exports blocklist related functions to the script.\n",
  "parameters": {},
  "functions": {
   "blst_add": "### `blst_add([timeout])`\n\nAdds the source of the current message to the blocklist for `timeout`\nseconds. If timeout is missing or 0 it uses the default blocklist\ntimeout (`dst_blocklist_expire`).\n\n```\n...\nif (src_ip==10.0.0.0/9)\n    blst_add(30); # 30 s\nelse\n    blst_add();  # use default blocklist timeout\n...\n        \n```\n",
   "blst_add_retry_after": "### `blst_add_retry_after(min, max)`\n\nAdds the source of the current message to the blocklist for the time\ninterval specified in the *Retry-After* header. If the *Retry-After*\nheader is missing, it will fail (returns false). If the *Retry-After*\nvalue is less than `min`, then `min` seconds will be used instead. If\nthe *Retry-After* value is greater than `max`, then `max` seconds will\nbe used instead.\n\n```\n...\n# on_reply route\nif (msg_status==503){ # blocklist 503 source for Retry-After seconds\n    if (! blst_add_retry_after(30, 3600))\n        blst_add(60); # if no retry_after header add it for 60s\n}\n...\n        \n```\n",
   "blst_del": "### `blst_del()`\n\nRemoves the source of the current message from the blocklist. If the\naddress is not present in the blocklist at the time of the call it\nreturns false.\n\n```\n...\n    blst_del();\n...\n        \n```\n",
   "blst_is_blocklisted": "### `blst_is_blocklisted()`\n\nReturns true if the source of the current message is blocklisted.\n\n```\n...\n    if (blst_is_blocklisted()){\n        log(\"message from a blocklisted source\");\n        drop;\n   }\n...\n        \n```\n",
   "blst_set_ignore": "### `blst_set_ignore([flags])`\n\nSet errors that will not be taken into account when deciding whether to\nblocklist a destination for the current message or a local reply to the\ncurrent message.\n\n`blst_set_ignore(..)` works for forwarding the current message and\n`blst_rpl_set_ignore(...)` works for local replies to the current\nmessage.\n\nThe variants of these functions with no parameters will ignore\neverything (equivalent to passing 0xff).\n\nThe flags are stored internally as a bitmask, and are applied by bitwise\nANDing them together. The following flags are available:\n\n- 0x02\n  - generic send error (send denied/ failed).\n- 0x04\n  - connect failed (TCP, TLS or SCTP).\n- 0x08\n  - ICMP error (not currently used).\n- 0x10\n  - SIP transaction timeout.\n- 0x20\n  - 503 reply (stateful mode only). For more details see\n  tm\n  blst_503\n  .\n\n<div class=\"note\">\n\n\nTCP and TLS send and connect errors are handled per connection and not\nper message. The connection blocklist ignore flags are inherited from\nthe message that caused the connection establishment.\n\n</div>\n\n\n```\n...\n    blst_set_ignore(6); # ignore send and connect errors\n...\n        \n```\n",
   "blst_rpl_set_ignore": "### `blst_rpl_set_ignore([flags])`\n\nSee function `blst_set_ignore([flags])`.\n",
   "blst_clear_ignore": "### `blst_clear_ignore([flags])`\n\nClears blocklist ignore flags previously set by the corresponding\n`blst_set_ignore(...)` or `blst_rpl_set_ignore(...)` functions.\n\nSee also `blst_set_ignore`.\n\n```\n...\n    blst_clear_ignore(4); # ignore connect errors\n...\n        \n```\n",
   "blst_rpl_clear_ignore": "### `blst_rpl_clear_ignore([flags])`\n\nSee function `blst_clear_ignore([flags])`.\n"
  }
 },
 "call_control": {
  "overview": "This module allows one to limit the duration of calls and automatically\nend them when they exceed the imposed limit. Its main use case is to\nimplement a prepaid system, but it can also be used to impose a global\nlimit on all calls processed by the proxy.\n",
  "parameters": {},
  "functions": {
   "call_control": "### `call_control()`\n\nTrigger the use of callcontrol for the dialog started by the INVITE for\nwhich this function is called (the function should only be called for\nthe first INVITE of a call). Further in-dialog requests will be\nprocessed automatically using internal bindings into the dialog state\nmachine, allowing callcontrol to update its internal state as the dialog\nprogresses, without any other intervention from the script.\n\nThis function should be called right before the message is sent out\nusing t_relay(), when all the request uri modifications are over and a\nfinal destination has been determined.\n\nThis function has the following return codes:\n\n- +2 - call has no limit\n\n- +1 - call has limit and is traced by callcontrol\n\n- -1 - not enough credit to make the call\n\n- -2 - call is locked by another call in progress\n\n- -5 - internal error (message parsing, communication, ...)\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_avp_set(\"$avp(i:805)\")) {\n    # the diverter AVP is set, use it as billing party\n    $avp(s:billing_party_domain) = $(avp(i:805){uri.domain});\n} else {\n    $avp(s:billing_party_domain) = $fd;\n}\n\nif (method==INVITE && !has_totag() &&\n    is_domain_local(\"$avp(s:billing_party_domain)\")) {\n    call_control();\n    switch ($retcode) {\n    case 2:\n        # Call with no limit\n    case 1:\n        # Call has limit and is under callcontrol management\n        break;\n    case -1:\n        # Not enough credit (prepaid call)\n        sl_send_reply(\"402\", \"Not enough credit\");\n        exit;\n        break;\n    case -2:\n        # Locked by another call in progress (prepaid call)\n        sl_send_reply(\"403\", \"Call locked by another call in progress\");\n        exit;\n        break;\n    default:\n        # Internal error (message parsing, communication, ...)\n        if (PREPAID_ACCOUNT) {\n            xlog(\"Call control: internal server error\\n\");\n            sl_send_reply(\"500\", \"Internal server error\");\n            exit;\n        } else {\n            xlog(\"L_WARN\", \"Cannot set time limit for postpaid call\\n\");\n        }\n    }\n}\nt_relay();\n...\n        \n```\n"
  }
 },
 "call_obj": {
  "overview": "This module provides a way to identify calls using an increasing\nsequence of integers.\n\nIt starts assigning an integer to a call. Next call gets next free\ninteger in a ring. When a call finishes its assigned number shall be\nfreed.\n",
  "parameters": {
   "start": "### `start` (integer)\n\nFirst number to assign when no number has been assigned yet.\n\n*This parameter has no default value. Not setting it raises an error.*\n\nIts value shall be greater than zero.\n\n```\n...\nmodparam(\"call_obj\", \"start\", 10)\n...\n```\n",
   "end": "### `end` (integer)\n\nLast number to assign when all other numbers have been already assigned.\n\n*No default value. Not setting this parameter raises an error.*\n\nIts value shall be greater than zero.\n\n```\n...\nmodparam(\"call_obj\", \"end\", 93)\n...\n            \n```\n"
  },
  "functions": {
   "call_obj_get": "### `call_obj_get(reply_number)`\n\nGet next free number. reply_number parameter is a variable where\nfunction will store result in string format.\n\n```\n...\nif (call_obj_get(\"$dlg_var(x)\")) {\n    xlog(\"Object: $dlg_var(x)\\n\");\n}\n...\n```\n",
   "call_obj_free": "### `call_obj_free(object_number)`\n\nMark an object_number as free, so it can be assigned again. This number\nwill not be readily assigned until a loop in the ring has completed.\nobject_number shall be provided in string format.\n\n```\n...\n$dlg_var(y) = \"27\";\nif (call_obj_free(\"$dlg_var(y)\")) {\n    xlog(\"object $dlg_var(y) freed OK\\n\");\n}\n...\n        \n```\n"
  }
 },
 "carrierroute": {
  "overview": "A module which provides routing, balancing and blocklisting\ncapabilities.\n\nThe module provides routing, balancing and blocklisting capabilities. It\nreads routing entries from a database source or from a config file at\nKamailio startup. It can use one routing tree (for one carrier), or if\nneeded, for every user a different routing tree (unique for each\ncarrier) for number prefix based routing. It supports several route tree\ndomains, e.g. for fallback routes or different routing rules for VoIP\nand PSTN targets.\n\nBased on the tree, the module decides which number prefixes are\nforwarded to which gateway. It can also distribute the traffic by ratio\nparameters. Furthermore, the requests can be distributed by a hash\nfunction to predictable destinations. The hash source is configurable,\ntwo different hash functions are available.\n\nThis module scales up to more than a few million users, and is able to\nhandle more than several hundred thousand routing table entries. We\nreceived reports of some setups that used more than a million routing\ntable entries. It also supports a large number of carriers and domains\nwhich can be efficiently looked up in most of the cases (see below for\nmore informations). In load balancing scenarios the usage of the config\nfile mode is recommended, to avoid the additional complexity that the\ndatabase driven routing creates.\n\nRouting tables can be reloaded and edited (in config file mode) with the\nRPC interface, the config file is updated according to the changes. This\nis not implemented for the db interface, because it is easier to do the\nchanges directly on the db. But the reload and dump functions work of\ncourse here as well.\n\nSome module functionality is not fully available in the config file\nmode, as it is not possible to specify all information that can be\nstored in the database tables in the config file. Further information\nabout these limitations is given in a later sections. For user based\nrouting or LCR you should use the database mode.\n\nIn database mode, this module supports names and IDs for the carriers\nand domains. When using IDs for the routing functions, efficient binary\nsearch is used to find the needed data structures. If you are using\nconstant strings as parameter, these will be converted to IDs during the\nfixup procedure using learner search to find the needed data structures.\nSo from a performance point of view it is better to pass only IDs in the\nrouting functions.\n\nBasically this module could be used as a replacement for the lcr and the\ndispatcher module, if you have certain flexibility, integration and/or\nperformance requirements that can not be satisfied with these modules.\nBut for smaller installations it probably make more sense to use the lcr\nand dispatcher module.\n\nStarting with version 3.1 , if you want to use this module in failure\nroutes, it is not needed to call\u201cappend_branch()\u201d after rewriting the\nrequest URI in order to relay the message to the new target. It also\nsupports the usage of database drived failure routing decisions using\nthe carrierfailureroute table.\n",
  "parameters": {
   "subscriber_table": "### `subscriber_table` (string)\n\nThe name of the table containing the subscribers\n\n*Default value is \u201csubscriber\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"subscriber_table\", \"subscriber\")\n...\n        \n```\n",
   "subscriber_user_col": "### `subscriber_user_col` (string)\n\nThe name of the column in the subscriber table containing the usernames.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"subscriber_user_col\", \"username\")\n...\n        \n```\n",
   "subscriber_domain_col": "### `subscriber_domain_col` (string)\n\nThe name of the column in the subscriber table containing the domain of\nthe subscriber.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"subscriber_domain_col\", \"domain\")\n...\n        \n```\n",
   "subscriber_carrier_col": "### `subscriber_carrier_col` (string)\n\nThe name of the column in the subscriber table containing the carrier id\nof the subscriber.\n\n*Default value is \u201ccr_preferred_carrier\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"subscriber_carrier_col\", \"cr_preferred_carrier\")\n...\n        \n```\n",
   "config_source": "### `config_source` (string)\n\nSpecifies whether the module loads its config data from a file or from a\ndatabase. Possible values are \u201cfile\u201d and \u201cdb\u201d.\n\n*Default value is \u201cfile\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"config_source\", \"file\")\n...\n        \n```\n",
   "config_file": "### `config_file` (string)\n\nSpecifies the path to the config file. The file has to be owned by the\nuser and group used to run Kamailio.\n\n*Default value is \u201c/etc/kamailio/carrierroute.conf\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"config_file\", \"/etc/kamailio/carrierroute.conf\")\n...\n        \n```\n",
   "default_tree": "### `default_tree` (string)\n\nThe name of the carrier tree used per default (if the current subscriber\nhas no preferred tree)\n\n*Default value is \u201cdefault\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"default_tree\", \"default\")\n...\n        \n```\n",
   "use_domain": "### `use_domain` (int)\n\nWhen using tree lookup per user, this parameter specifies whether to use\nthe domain part for user matching or not. This parameter is tunable via\nthe ser cfg framework.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"use_domain\", 0)\n...\n        \n```\n",
   "fallback_default": "### `fallback_default` (int)\n\nThis parameter defines the behaviour when using user-based tree lookup.\nIf the user has a non-existing tree set and fallback_default is set to\n1, the default tree is used. Otherwise, cr_user_rewrite_uri returns an\nerror. This parameter is tunable via the ser cfg framework.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"fallback_default\", 1)\n...\n        \n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nThe number of the rows to be fetched at once from database when loading\nthe routing data. This value can be used to tune the load time at\nstartup. For 1MB of private memory (default) it should be below 3750.\nThe database driver must support the fetch_result() capability. This\nparameter is tunable via the ser cfg framework.\n\n*Default value is \u201c2000\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"fetch_rows\", 3000)\n...\n        \n```\n",
   "db_load_description": "### `db_load_description` (integer)\n\nToggle on/off loading in memory the description column in the\ncarrierroute/carrierfailureroute database tables. This reduces the\nshared memory used by the module.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"db_load_description\", 0)\n...\n        \n```\n",
   "match_mode": "### `match_mode` (integer)\n\nThe number of individual characters that are used for matching. Valid\nvalues are 10 or 128. When you specify 10, only digits will be used for\nmatching, this operation mode is equivalent to the old behaviour. When\nconfigured with 128, all standard ascii chars are available for\nmatching. Please be aware that memory requirements for storing the\nrouting tree in shared memory will also increase by a factor of 12.8.\n\n*Default value is \u201c10\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"match_mode\", 10)\n...\n        \n```\n",
   "avoid_failed_destinations": "### `avoid_failed_destinations` (integer)\n\nInteger parameter to toggle on/off the possibility that in the\nfailurerouting cases destinations that previously failed are avoided.\nPossible values are 0 (off), 1 (on). Also see cr_route section.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"carrierroute\", \"avoid_failed_destinations\", 0)\n...\n        \n```\n"
  },
  "functions": {
   "cr_user_carrier": "### `cr_user_carrier(user, domain, dstvar)`\n\nThis function loads the carrier and stores it in a config variable. It\ncannot be used in the config file mode, as it needs a mapping of the\ngiven user to a certain carrier. The is drived from a database entry\nbelonging to the user parameter. This mapping must be available in the\ntable that is specified in the \u201csubscriber_table\u201d variable. This data is\nnot cached in memory, that means for every execution of this function a\ndatabase query will be done.\n\nMeaning of the parameters is as follows:\n\n- *user* - Name of the user for the carrier tree lookup. Additional to a\n  string any pseudo-variable could be used as input.\n\n- *domain* - Name of the routing domain to be used. Additional to a\n  string any pseudo-variable could be used as input.\n\n- *dstvar* - Name of the writable config variable (e.g., an AVP) where\n  to store the carrier id.\n",
   "cr_route": "### `cr_route(carrier, domain, prefix_matching, rewrite_user, hash_source, descavp)`\n\nThis function searches for the longest match for the user given in\nprefix_matching with the given domain in the given carrier tree. The\nRequest URI is rewritten using rewrite_user and the given hash source\nand algorithm. Returns -1 if there is no data found or an empty rewrite\nhost on the longest match is found. On success, it also stores the\ncarrier description in the given AVP (if present). This is useful if you\nneed some additional informations that belongs to each gw, like the\ndestination uri, force socket or any arbitrary info.\n\nDepending on the value of the avoid_failed_destinations module\nparameter, the function pays special attention to the failurerouting\ncases, so that any destination that has failed to provide a successful\nresponse will not be reused in a subsequent call of this function. This\nsituation can appear when different route domains contain a set of\ncommon gateways.\n\nThis function is only usable with rewrite_user and prefix_matching\ncontaining a valid string. This string needs to be numerical if the\nmatch_mode parameter is set to 10. It uses the standard CRC32 algorithm\nto calculate the hash values.\n\nIf flags and masks values are specified in the routing rule, they will\nbe compared by this function to the message flags. Specify a flag and\nmask value of \u201c0\u201d to match to all possible message flags (this is the\ndefault value). If flags and mask are not zero, and no match to the\nmessage flags is possible, no routing will be done. The calculation of\nthe hash and the load-balancing is done after the flags matching.\n\nMeaning of the parameters is as follows:\n\n- *carrier* - The routing tree to be used. It must be string containing\n  either carrier id (nummeric) or carrier name (arbitrary string). It\n  also accepts any pseudo-variable as input.\n\n- *domain* - Name of the routing domain to be used. it must be string\n  containing either domain id (nummeric) or domain name (arbitrary\n  string). It also accepts any pseudo-variable as input.\n\n- *prefix_matching* - User name to be used for prefix matching in the\n  routing tree. It also accepts any pseudo-variable as input\n\n- *rewrite_user* - The user name to be used for applying the rewriting\n  rule. Usually this is the user part of the request URI. It also\n  accepts any pseudo-variable as input\n\n- *hash_source* - The hash values of the destination set, it must be a\n  contiguous range starting at 1, limited by the configuration parameter\n  \u201cmax_targets\u201d. Possible values for hash_source are: \u201ccall_id\u201d,\n  \u201cfrom_uri\u201d, \u201cfrom_user\u201d, \u201cto_uri\u201d, \u201cto_user\u201d and \u201crand\u201d.\n\n- *decsavp* - AVP where to store the description. This parameter is\n  optional.\n",
   "cr_nofallback_route": "### `cr_nofallback_route(carrier, domain, prefix_matching, rewrite_user, hash_source, descavp)`\n\nThis function searches for the longest match for the user given in\nprefix_matching with the given domain in the given carrier tree. The\nRequest URI is rewritten using rewrite_user and the given hash source\nand algorithm. Returns -1 if there is no data found or an empty rewrite\nhost on the longest match is found. On success it also stores the\ncarrier description in the given AVP (if present). This is useful if you\nneed some additional informations that belongs to each gw, like the\ndestination uri, force socket or any arbitrary info.\n\nThis function is only usable with rewrite_user and prefix_matching\ncontaining a valid string. This string needs to be numerical if the\nmatch_mode parameter is set to 10.\n\nIt uses the standard CRC32 algorithm to calculate the hash values. In\ncontrast to the normal *cr_route* function, the backup rules of (now\nobsolete) cr_prime_route is used. This means none of the configured\nprobabilities will be used, only a fixed hash distribution is used. This\nmakes sense to distribute incoming register requests e.g. to a bunch of\nregistrar servers. If one of the hash targets is not available and\nbackup rule is configured, the function will return -1.\n\nMeaning of the parameters is as follows:\n\n- *carrier* - The routing tree to be used. It must be string containing\n  either carrier id (nummeric) or carrier name (arbitrary string). It\n  also accepts any pseudo-variable as input.\n\n- *domain* - Name of the routing domain to be used. it must be string\n  containing either domain id (nummeric) or domain name (arbitrary\n  string). It also accepts any pseudo-variable as input\n\n- *prefix_matching* - User name to be used for prefix matching in the\n  routing tree. It also accepts any pseudo-variable as input\n\n- *rewrite_user* - The user name to be used for applying the rewriting\n  rule. Usually this is the user part of the request URI. It also\n  accepts any pseudo-variable as input\n\n- *hash_source* - The hash values of the destination set, it must be a\n  contiguous range starting at 1, limited by the configuration parameter\n  \u201cmax_targets\u201d. Possible values for hash_source are: \u201ccall_id\u201d,\n  \u201cfrom_uri\u201d, \u201cfrom_user\u201d, \u201cto_uri\u201d, \u201cto_user\u201d and \u201crand\u201d.\n\n- *decsavp* - AVP where to store the description. This parameter is\n  optional.\n",
   "cr_next_domain": "### `cr_next_domain(carrier, domain, prefix_matching, host, reply_code, dstavp)`\n\nThis function searches for the longest match for the user given in\nprefix_matching with the given domain in the given carrier failure tree.\nIt tries to find a next domain matching the given host, reply_code and\nthe message flags. The matching is done in this order: \u201chost\u201d then\n\u201creply_code\u201d and then \u201cflags\u201d. The more wildcards in reply_code and the\nmore bits used in flags, the lower the priority will be. Returns -1, if\nthere is no data found or if the next_domain on the longest match is\nempty. Otherwise the next domain is stored in the given variable.\n\nThis function is only usable if rewrite_user and prefix_matching\ncontains a valid string. This string must be numerical if the match_mode\nparameter is set to 10.\n\nMeaning of the parameters is as follows:\n\n- *carrier* - The routing tree to be used. It must be string containing\n  either carrier id (nummeric) or carrier name (arbitrary string). It\n  also accepts any pseudo-variable as input.\n\n- *domain* - Name of the routing domain to be used. it must be string\n  containing either domain id (nummeric) or domain name (arbitrary\n  string). It also accepts any pseudo-variable as input.\n\n- *prefix_matching* - User name to be used for prefix matching in the\n  routing tree. It also accepts any pseudo-variable as input.\n\n- *host* - The host name to be used for failure route rule matching.\n  Usually this is the last tried routing destination stored in an avp by\n  cr_route. It also accepts any pseudo-variable as input\n\n- *reply_code* - The reply code to be used for failure route rule\n  matching. It also accepts any pseudo-variable as input\n\n- *dstavp* - Name of the AVP where to store the next routing domain.\n"
  }
 },
 "cdp": {
  "overview": "CDP (C Diameter Peer) allows Diameter communication to and from\nKamailio. Most of the code is inherited from DISC\nhttp://developer.berlios.de/projects/disc/ and OpenIMS and modified for\nuse within Kamailio. A few improvements and new functionality has been\nadded along the way, for example, threshold reporting on Diameter calls\nthat are serviced above a certain threshold.\n",
  "parameters": {
   "config_file": "### config_file (string)\n\nThis is the location of the XML configuration file.\n\n*Default value is \u201cDiameterPeer.xml\u201d.*\n\n```\n...\nmodparam(\"cdp\", \"config_file\", \"/etc/kamailio/diametercfg.xml\")\n...\n```\n",
   "latency_threshold": "### latency_threshold (int)\n\nThe time in ms above which a log error is written to log file for long\nCDP transactions.\n\n*Default value is \u201c500\u201d.*\n\n```\n...\nmodparam(\"cdp\", \"latency_threshold\", 1000)\n...\n```\n",
   "workerq_latency_threshold": "### `workerq_latency_threshold` (int)\n\nThe time in ms above which a log error is written to log file for\nputting tasks into task queue.\n\n*Default value is \u201c100\u201d.*\n\n```\n...\nmodparam(\"cdp\", \"workerq_latency_threshold\", 250)\n...\n    \n```\n",
   "workerq_length_threshold_percentage": "### `workerq_length_threshold_percentage` (int)\n\nThe threshold of the length of the worker queue as a percentage of the\nmaximum queue size - when exceeded a warning is written to the log file.\n0 means disabled\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"cdp\", \"workerq_length_threshold_percentage\", 25)\n...\n    \n```\n",
   "debug_heavy": "### debug_heavy (int)\n\nFlag to enable a more verbose log, which tells you more details about\npeers. This is disabled by default because it brings to a log too much\nverbose in DBG mode Can be enabled upon needs\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"cdp\", \"debug_heavy\", 1)\n...\n    \n```\n",
   "enable_tls": "### enable_tls (int)\n\nFlag to enable TLS for communication with all the peers.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"cdp\", \"enable_tls\", 1)\n...\n    \n```\n",
   "tls_method": "### tls_method (string)\n\nSets the TLS protocol method. Possible values are:\n\n- *TLSv1.3+* - TLSv1.3 or newer connections are accepted (available\n  starting with openssl/libssl v1.1.1)\n\n- *TLSv1.3* - only TLSv1.3 connections are accepted (available starting\n  with openssl/libssl v1.1.1)\n\n- *TLSv1.2+* - TLSv1.2 or newer (TLSv1.3, ...) connections are accepted\n  (available starting with openssl/libssl v1.1.1)\n\n- *TLSv1.2* - only TLSv1.2 connections are accepted (available starting\n  with openssl/libssl v1.0.1e)\n\n- *TLSv1.1+* - TLSv1.1 or newer (TLSv1.2, ...) connections are accepted\n  (available starting with openssl/libssl v1.0.1)\n\n- *TLSv1.1* - only TLSv1.1 connections are accepted (available starting\n  with openssl/libssl v1.0.1)\n\n- *TLSv1+* - TLSv1.0 or newer (TLSv1.1, TLSv1.2, ...) connections are\n  accepted.\n\n- *TLSv1* - only TLSv1 (TLSv1.0) connections are accepted. This is the\n  default value.\n\n*Default value is \u201cTLSv1.2\u201d.*\n\n```\n...\nmodparam(\"tls\", \"tls_method\", \"TLSv1\")\n...\n    \n```\n",
   "private_key": "### private_key (string)\n\nSets the private key file name.\n\n```\n...\nmodparam(\"cdp\", \"private_key\", \"/usr/local/etc/kamailio/my_pkey.pem\")\n...\n    \n```\n",
   "certificate": "### certificate (string)\n\nSets the certificate file name. Must be in PEM format.\n\n```\n...\nmodparam(\"cdp\", \"certificate\", \"/usr/local/etc/kamailio/my_certificate.pem\")\n...\n    \n```\n",
   "ca_list": "### ca_list (string)\n\nSets the CA list file name. This file contains a list of all the trusted\nCAs certificates used when connecting to other SIP implementations. If a\nsignature in a certificate chain belongs to one of the listed CAs, the\nverification of that certificate will succeed. If not set, the PCRF sent\ncertificate is not checked.\n\nThe parameter must contain an absolute path. Only PEM files are\naccepted.\n\nBy default this parameter is not set.\n\nAn easy way to create the CA list is to append each trusted trusted CA\ncertificate in the PEM format to one file.\n\n```\n...\nmodparam(\"cdp\", \"ca_list\", \"/usr/local/etc/kamailio/ca_list.pem\")\n...\n    \n```\n"
  },
  "functions": {
   "cdp_check_peer": "### `cdp_check_peer(fqdn)`\n\nThe method checks, if a specific peer is connected and ready.\n\nMeaning of the parameter is as follows:\n\n- *fqdn* - the Fully qualified domain name of the peer, that should be\n  checked. The parameter may contain pseudovariables.\n\n<!-- -->\n\n\n```\n...\nif(!cdp_check_peer(\"hss.mnc001.mcc001.3gppnetwork.org\")) {\n    send_reply(\"503\", \"HSS not ready\");\n    exit;\n}\n...\n```\n",
   "cdp_has_app": "### `cdp_has_app([vendorid, ]application)`\n\nThe method checks, if any peer with this specific application has\nconnected.\n\nMeaning of the parameters are as follows:\n\n- *vendorid* - The Vendor ID of the App\n\n  *application* - The Application ID\n\n<!-- -->\n\n\n```\n...\nif(!cdp_has_app(\"10415\", \"4\")) {\n    send_reply(\"503\", \"Charging Server not ready\");\n    exit;\n}\n...\n\n...\nif(!cdp_has_app(\"16777216\")) {\n    send_reply(\"503\", \"Cx/Dx Interface not ready\");\n    exit;\n}\n...\n```\n"
  }
 },
 "cdp_avp": {
  "overview": "CDP AVP is a helper module for various applications ontop of CDP (C\nDiameter Peer). CDP AVP module adds support for the following\napplications:\n\n- Various base AVPs (implemented in base.h) for RFC3588 base AVPs\n\n- Base AVPs (implemented in nasapp.h) for RFC4005 base AVPs\n\n- Diameter Credit Control App (implemented in ccap.h) for RFC4006 AVPs\n\n- EPC (implemented in epcapp.h) for 3GPP Rx, Gx(x) interface AVPs - see\n  TS29l061, TS29.212, TS29.214, TS29.272 and TS29.299\n\n- IMS (implemented in imsapp.h) for 3GPP IMS AVPs, Cx, Dx, Sh\n  interfaces - see TS29.229 and TS29.329\n",
  "parameters": {},
  "functions": {}
 },
 "cfg_db": {
  "overview": "The module implements a database driver for the configuration parameters\nAPI. When configuration parameters are being declared (typically when\nstarting) API then driver is notified and has chance to set value (of\nany parameter) based on value taken from database. It's primarily\ntargeted for interfacing with 3rd party software which is aware of the\nKamailio configuration.\n\nA parameter is uniquely identified by a *group_name* plus a *name*,\nwhich is used by the driver to check if a value can be found. Because\nconfiguration parameters may be spread in many tables, a translation\ntable is used to indicate where to start searching. Multiple look-up\ntables may be defined for single parameter, tables are searched in the\nfirst round by exact match until parameter is found, all tables listed\nwith wildcard (asterisk) in group name are searched in the second round.\nIf a parameter is not found then its value is left unchanged.\n\nConfiguration parameters are normally declared in C code and this module\nadditionally supports also declaring custom parameters in extra table.\nSuch parameters may be used typically in script only. All parameters\nlisted in the table are declared in the first step, values are\ninitialized in the second step using the same procedure as C-code\nparameters.\n\nThe module does not reflect changes made in parameters when Kamailio is\nrunning. It just declares variables and assigns values when Kamailio is\nstarting. That's all.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nDefault database URL.\n\nThe format is:\n\n```\n        db_url = database\n        \n\nloadmodule(\"mysql.so\");\nloadmodule(\"cfg_db.so\");\n...\nmodparam(\"cfg_db\", \"db_url\", \"mysql://SER:123@127.0.0.1:12345/SER\");\n...\n            \n```\n",
   "transl_tbl": "### `transl_tbl` (string) := \"cfg_transl\"\n\nName of table used for pointing group_name+name into configuration\ntable. If empty/null field values are found then default values will be\nused. The default values are declared in record having *group_name*\ncalled *<default>*. The C-code \"absolutely\" default values (\"cfg_var\",\n\"group_name\", \"name\", \"value\"). The other keyword is asterisk *** which\nmatches all parameters and will be used if parameter is not explicitly\nmentioned.\n",
   "custom_tbl": "### `custom_tbl` (string) := \"cfg_custom\"\n\nName of table used for extra param declaration (group_name, name, type,\nmin/max value, description).\n"
  },
  "functions": {}
 },
 "cfg_rpc": {
  "overview": "The module implements RPC commands to set and get configuration\nvariables on-the-fly, that are declared by Kamailio core and by the\nmodules.\n\nFor example, it can be used to fine-tune values for global parameters\nsuch as debug, tcp/sctp/dns attributes, without the need of restart.\n\nRPC connector modules, such as \u201cctl\u201d or \u201cxmlrpc\u201d, although not a\ndependency, should be loaded in order to execute the RPC commands\nexported by this module. When the ctl module is loaded, the tool\n'kamcmd' can be used to execute the RPC commands implemented in this\nmodule.\n",
  "parameters": {},
  "functions": {}
 },
 "cfgt": {
  "overview": "This module provides a report of the way Kamailio SIP Server Platform\nconfiguration has been executed as part of a unit test for different SIP\nscenarios.\n\nIn order to identify different scenarios a prefix string should be used\ninside the Call-ID header.\n",
  "parameters": {
   "basedir": "### `basedir` (string)\n\nControl where the config reports should be stored. The dir must exist\nand Kamailio SIP Server Platform must have permissions to write on it.\n\n*Default value is \u201c/tmp\u201d.*\n\n```\n...\nmodparam(\"cfgt\", \"basedir\", \"/run/kamailio/cfgtest\")\n...\n```\n",
   "mask": "### `mask` (int)\n\n*Default value is \u201c32\u201d (ALL).*\n\n```\n...\n# dump xavp(8) and avp(4) vars\nmodparam(\"cfgt\", \"mask\", 12)\n...\n```\n",
   "callid_prefix": "### `callid_prefix` (string)\n\nPrefix used to identify test scenario messages. Last char of the string\nwill be used as delimiter for the scenario ID. With parameter set to\n\u201cNGCP%\u201d and Call-ID \u201cNGCP%123%456\u201d the scenario identified will be\n\u201c123\u201d.\n\n*Default value is \u201cNGCP%\u201d (using \u201c%\u201d as delimiter).*\n\n```\n...\n# using '%' as delimiter\nmodparam(\"cfgt\", \"callid_prefix\", \"TEST-ID%\")\n...\n```\n",
   "skip_unknown": "### `skip_unknown` (int)\n\nIf enabled, value different from 0, cfgt will not generate the report of\nany message that doesn't match the callid_prefix.\n\n*Default value is \u201c0\u201d, false.*\n\n```\n...\nmodparam(\"cfgt\", \"skip_unknown\", \"1\")\n...\n```\n",
   "route_log": "### `route_log` (int)\n\nIf enabled, value different from 0, cfgt will log (WARN) the execution\ntime of routes.\n\n*Default value is \u201c0\u201d, false.*\n\n```\n...\nmodparam(\"cfgt\", \"route_log\", \"1\")\n...\n```\n"
  },
  "functions": {}
 },
 "cfgutils": {
  "overview": "Useful extensions for the server configuration.\n\nThe cfgutils module can be used to introduce randomness to the behaviour\nof the server. It provides setup functions and the \u201crand_event\u201d\nfunction. This function return either true or false, depending on a\nrandom value and a specified probability. E.g. if you set via fifo or\nscript a probability value of 5%, then 5% of all calls to rand_event\nwill return true. The pseudovariable \u201c$RANDOM\u201d could be used to\nintroduce random values e.g. into a SIP reply.\n\nThe benefit of this module is the probability of the decision can be\nmanipulated by external applications such as web interface or command\nline tools. The probability must be specified as percent value, ranging\nfrom 0 to 100.\n\nThe module exports commands to FIFO server that can be used to change\nthe global settings via FIFO interface. The FIFO commands are:\n\u201cset_prob\u201d, \u201creset_prob\u201d and \u201cget_prob\u201d.\n\nThis module can be used for simple load-shedding, e.g. reply 5% of the\nInvites with a 503 error and an adequate random Retry-After value.\n\nThe module provides as well functions to delay the execution of the\nserver. The functions \u201csleep\u201d and \u201cusleep\u201d could be used to let the\nserver wait a specific time interval.\n\nIt can also hash the config file used from the server with a (weak)\ncryptographic hash function on startup. This value is saved and can be\nlater compared to the actual hash, to detect modifications of this file\nafter the server start. This functions are available as the FIFO\ncommands \u201ccheck_config_hash\u201d and \u201cget_config_hash\u201d.\n\nThe gflags functionality (global flags) keeps a bitmap of flags in\nshared memory and may be used to change behaviour of server based on\nvalue of the flags. Example:\n\n```\n    if (is_gflag(\"1\")) {\n        t_relay(\"udp:10.0.0.1:5060\");\n    } else {\n        t_relay(\"udp:10.0.0.2:5060\");\n    }\n    \n```\n\nThe benefit of this is the value of the switch flags can be manipulated\nby external applications such as web interface or command line tools.\nThe size of bitmap is 32.\n\nThe module exports external commands that can be used to change the\nglobal flags via Management Interface and RPC. See relevant sections\nbelow.\n",
  "parameters": {
   "initial_probability": "### `initial_probability` (string)\n\nThe initial value of the probability.\n\nDefault value is \u201c10\u201d.\n\n```\n...\nmodparam(\"cfgutils\", \"initial_probability\", 15)\n...\n```\n",
   "hash_file": "### `hash_file` (string)\n\nThe config file name for that a hash value should be calculated on\nstartup.\n\nThere is no default value, is no parameter is given the hash\nfunctionality is disabled.\n\n```\n...\nmodparam(\"cfgutils\", \"hash_file\", \"/etc/kamailio/kamailio.cfg\")\n...\n```\n",
   "initial_gflags": "### `initial_gflags` (integer)\n\nThe initial value of global flags bitmap.\n\nDefault value is \u201c0\u201d.\n\n```\n...\nmodparam(\"cfgutils\", \"initial_gflags\", 15)\n...\n        \n```\n",
   "lock_set_size": "### `lock_set_size` (integer)\n\nSize of lock set - the value is used as power of two to compute the size\nof lock array.\n\nDefault value is \u201c0\u201d - no lock set created.\n\n```\n...\nmodparam(\"cfgutils\", \"lock_set_size\", 4)\n...\n        \n```\n"
  },
  "functions": {
   "rand_event": "### `rand_event()`\n\nReturn true or false, depending on a random value and a probability\nvalue.\n\n```\n...\nif (rand_event()) {\n  append_to_reply(\"Retry-After: 120\\n\");\n  sl_send_reply(\"503\", \"Try later\");\n  exit;\n};\n# normal message processing follows\n...\n```\n",
   "rand_set_prob": "### `rand_set_prob(probability)`\n\nSet the \u201cprobability\u201d of the decision.\n\n\u201cprobability\u201d can have a value from the range 0..100.\n\n```\n...\nrand_set_prob(\"4\");\n...\n```\n",
   "rand_reset_prob": "### `rand_reset_prob()`\n\nReset the probability back to the initial value.\n\n```\n...\nrand_reset_prob();\n...\n```\n",
   "rand_get_prob": "### `rand_get_prob()`\n\nReturn the current probability setting, e.g. for logging purposes.\n\n```\n...\nrand_get_prob();\n...\n```\n",
   "sleep": "### `sleep(time)`\n\nWaits \"time\" seconds.\n\nMeaning of the parameters is as follows:\n\n- *time* - Time to wait in seconds. It can be an integer or a variable\n  holding an integer.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsleep(\"1\");\n...\n            \n```\n",
   "usleep": "### `usleep(time)`\n\nWaits \"time\" micro-seconds.\n\nMeaning of the parameters is as follows:\n\n- *time* - Time to wait in micro-seconds (1/1000000 of a second). It can\n  be an integer or a variable holding an integer.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# wait 5 milliseconds\nusleep(\"5000\");\n...\n            \n```\n",
   "abort": "### `abort()`\n\nDebugging function that aborts the server. Depending on the\nconfiguration of the server a core dump will be created.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nabort();\n...\n            \n```\n",
   "pkg_status": "### `pkg_status()`\n\nDebugging function that dumps the status for the private (PKG) memory.\nThis information is logged to the default log facility, depending on the\ngeneral log level and the memlog setting. You need to compile the server\nwith activated memory debugging to get detailed informations.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\npkg_status();\n...\n            \n```\n",
   "pkg_summary": "### `pkg_summary()`\n\nDebugging function that dumps the summary for the private (PKG) memory\nusage. This information is logged to the default log facility, depending\non the general log level and the memlog setting. You need to compile the\nserver with activated memory debugging to get detailed informations.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npkg_summary();\n...\n            \n```\n",
   "shm_status": "### `shm_status()`\n\nDebugging function that dumps the status for the shared (SHM) memory.\nThis information is logged to the default log facility, depending on the\ngeneral log level and the memlog setting. You need to compile the server\nwith activated memory debugging to get detailed informations.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nshm_status();\n...\n            \n```\n",
   "shm_summary": "### `shm_summary()`\n\nDebugging function that dumps the summary for the shared (SHM) memory\nusage. This information is logged to the default log facility, depending\non the general log level and the memlog setting. You need to compile the\nserver with activated memory debugging to get detailed informations.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nshm_summary();\n...\n            \n```\n",
   "set_gflag": "### `set_gflag(flag)`\n\nSet the bit at the position \u201cflag\u201d in global flags.\n\n\u201cflag\u201d can have a value in the range of 0..31.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nset_gflag(\"4\");\n...\n```\n",
   "reset_gflag": "### `reset_gflag(flag)`\n\nReset the bit at the position \u201cflag\u201d in global flags.\n\n\u201cflag\u201d can have a value in the range of 0..31.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nreset_gflag(\"4\");\n...\n```\n",
   "is_gflag": "### `is_gflag(flag)`\n\nCheck if bit at the position \u201cflag\u201d in global flags is set.\n\n\u201cflag\u201d can have a value in the range of 0..31.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif(is_gflag(\"4\"))\n{\n    log(\"global flag 4 is set\\n\");\n} else {\n    log(\"global flag 4 is not set\\n\");\n};\n...\n```\n",
   "lock": "### `lock(key)`\n\nLock the key. Can be used to synchronize operations in config file, a\nhash id is computed over the key and appropriate lock is set in the lock\narray controlled by parameter \"lock_set_size\". Do not use lock() after\nanother lock() unless you are sure the keys hit different array entries.\n\n\u201ckey\u201d can be static string or string with PVs.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nlock(\"$rU\");\n...\n```\n",
   "trylock": "### `trylock(key)`\n\nTry to lock the key. If the lock can not be obtained (possibly already\nlocked), the function returns an error and script execution continues.\n\n\u201ckey\u201d can be static string or string with PVs.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (trylock(\"$rU\")) {\n    xlog(\"L_INFO\", \"Doing some cool stuff\\n\");\n    unlock(\"$rU\");\n}\n...\n```\n",
   "unlock": "### `unlock(key)`\n\nUnlock the key.\n\n\u201ckey\u201d can be static string or string with PVs.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nunlock(\"$rU\");\n...\n```\n",
   "check_route_exists": "### `check_route_exists(route)`\n\nCheck if a route block exists. It returns true (1) on found and false on\nnot found or error.\n\nParameters:\n\n\u201cname\u201d of a route block in the config file, like \u201croute[FROGJUMP]\u201d\n\nThis function can be used from any route. You can only check for\nroute[] blocks, not reply, event or other routes.\n\n```\n...\nif(check_route_exists(\"JUMP\") {\n    $var(jumping_frogs) = 1;\n};\n...\n```\n",
   "route_if_exists": "### `route_if_exists(route)`\n\nExecute a routing block only if it is defined. If it's not defined,\nsilently move to the next action in the configuration script.\n\nIt returns the code of last action in the route block, if that exists,\nor false if the route doesn't exists or was an error executing it.\n\nParameters:\n\n\u201cname\u201d of a route block in the config file, like \u201croute[FROGJUMP]\u201d\n\nThis function can be used from any route. You can only execute it for\nroute[] blocks, not reply, event or other routes.\n\n```\n...\nif(route_if_exists(\"JUMP\")) {\n    exit;\n}\n...\n```\n",
   "core_hash": "### `core_hash(string1, string2, size)`\n\nExported function that enables the core_hash() function to be used from\nthe configuration file.\n\nThis is a quick and simple hash function and it is not cryptographically\nsecure. This function should not be used for any security related\npurposes.\n\nParameters:\n\n- \u201cstring1\u201d first string to hash\n\n- \u201cstring2\u201d (optional) second string to hash (set to \"\" if not needed)\n\n- \u201csize\u201d size of the hash space (used as a power of 2)\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ncore_hash(\"$ci\", \"\", 4);\n...\n```\n"
  }
 },
 "cnxcc": {
  "overview": "This module was designed to act as a mechanism to limit call duration\nbased on credit information parameters. After getting the credit\ninformation of the call being set up, you can instruct the module to\nstart monitoring the consumed credit to shutdown a single call or a\ngroup of calls in case of credit exhaustion.\n\nEvery call is associated to an unique client/customer identifier. If a\ncredit event occurs, all calls hooked to this identifier are\nautomatically shutdown.\n\nCnxcc is dialog-aware so there's no need to explicitly\nallocate/deallocate the monitoring. Only a single function call inside\nthe script is needed upon reception of the INVITE.\n\nThe credit discount rate is proportional to the number of calls grouped\ninside an identifier. Once the setup of the first call is done, the\ninformation remains while the call is active. If the customer starts a\nnew call with the same routing criteria, it will land in the same\nmonitoring bag and it will consume the same pool of credit in rates that\nare equal to the cost per second of both calls.\n\nIf your accounting program does not maintain the state of the call in\nreal time, this module can provide you with that ability.\n\nCnxcc can also provide more common means of monitoring, i.e., by time\nlimit or by maximum simultaneous calls.\n",
  "parameters": {
   "redis": "### `redis` (integer)\n\nRedis datasource connection information\n\n```\n...\nmodparam(\"cnxcc\", \"redis\", \"addr=127.0.0.1;port=6379;db=1\")\n...\n```\n",
   "credit_check_period": "### `credit_check_period` (integer)\n\nIndicates how often the credit checking function should be called. It is\ndirectly related to the precision of the module. The maximum precision\nis 1, which means that every call is checked every one second.\n\nValues greater than 1 leads to precision lost but less CPU consumption.\n\n```\n...\nmodparam(\"cnxcc\", \"credit_check_period\", 1)\n...\n```\n"
  },
  "functions": {
   "cnxcc_set_max_credit": "### `cnxcc_set_max_credit(customer, maxcredit, connect, cps, ipulse, fpulse)`\n\nAssociates the call with a customer id and sets the max credit, connect\ncost, cost per second, initial pulse and final pulse. The discount is\ncalculated in pulses (1/1, 60/1, etc) and subtracted from the pool of\ncredit.\n\nThe customer value can be provided as a string or a variable holding a\nstring. This value identifies all calls from the same customer.\n\nThe maxcredit (float) value is the maximum credit available for the\ncurrent call.\n\nThe connect (float) value is the connect cost for the current call.\n\nThe cps (float) value is the cost per second for the current call.\n\nThe ipuse (integer) value is the initial pulse and establishes the\nminimum time to be charged. For example, value 1 establishes a charge\nper second and value 60 sets a charge per minute. If it is taken as\nvalue 60, even if the duration is 5 seconds, 1 minute will be charged.\n\nThe fpulse (integer) value is the final pulse and establishes, from the\ninitial pulse, the time range to be charged. For example, the value 1\nestablishes a charge per second, 5 sets a charge in blocks of 5 seconds,\n60 sets a full minute charge.\n\n1/1 will make a charge per seconds for the entire call. 60/1 will make a\ncharge per seconds with the first full minute. 60/60 always perform a\nfull minute charge.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n- *-4 - call-id already present for this client*\n\n<!-- -->\n\n\n```\n...\ncnxcc_set_max_credit(\"john-doe\", \"100\", \"3.0\", \"0.5\", 60, 1);\n...\n$var(customer)  = \"john-doe\"; # customer id\n$var(credit)    = \"100\";      # max credit for all calls with the same\n                              # customer id\n$var(connect)   = \"3.0\";      # connect cost or initial cost for the call\n$var(cps)       = \"0.5\";      # cost per second\n$var(initial_p) = 60;         # initial pulse (60 = the first minute will be\n                              # charged even if the call is shorter)\n$var(final_p)   = 1;          # final pulse (after the first minute, it will\n                              # be charge in ranges of 1 second)\ncnxcc_set_max_credit(\"$var(customer)\", \"$var(credit)\", \"$var(connect)\",\n        \"$var(cps)\", \"$var(initial_p)\", \"$var(final_p)\");\n...\n```\n",
   "cnxcc_set_max_time": "### `cnxcc_set_max_time(customer, maxtime)`\n\nSpecifies the amount of time the call should last at most.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\nThe maxtime value is an integer values, it can be also given via a\nvariable holding an integer.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n- *-4 - call-id already present for this client*\n\n<!-- -->\n\n\n```\n...\n$var(customer) = \"john-doe-basic\";\n$var(max_time) = 120;\ncnxcc_set_max_time(\"$var(customer)\", \"$var(max_time)\");\n...\n```\n",
   "cnxcc_update_max_time": "### `cnxcc_update_max_time(customer, maxtime)`\n\nUpdates max-time of an established and monitored call. This can be used\nto grant minimum values and to update them every short periods on time\nas a mean to prevent frauds and/or to mimic requested/granted units of\ntime of Credit Control Application behavior.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\nThe maxtime value is an integer values, it can be also given via a\nvariable holding an integer.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n\n```\n...\n$var(client)       = \"john-doe-basic\";\n$var(update_time)  = 5;\n\nif (!cnxcc_update_max_time(\"$var(client)\", \"$var(update_time)\")) {\n    xlog(\"Error updating max-time\");\n    return;\n    }\n...\n```\n",
   "cnxcc_set_max_channel": "### `cnxcc_set_max_channel(customer, maxchan)`\n\nSpecifies a limit for the number of simultaneous calls.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\nThe maxchan value is an integer values, it can be also given via a\nvariable holding an integer.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n- *-2 - failed, calls established plus calls being established result in\n  more than the limit you specified*\n\n- *-3 - failed, number of calls established is more than the limit you\n  specified*\n\n- *-4 - call-id already present for this client*\n\n<!-- -->\n\n\n```\n...\n$var(customer)  = \"john-doe-123-basic\";\n$var(max_chan)  = 2;\n$var(retcode)   = cnxcc_set_max_channels(\"$var(customer)\", \"$var(max_chan)\");\n\nif ($var(retcode) == -1) {\n    xlog(\"Error setting up credit control\");\n    return;\n}\n\nif ($var(retcode) < -1) {\n    xlog(\"Too many channels for customer\");\n    sl_send_reply(403, \"Forbidden\");\n\n    if (!cnxcc_terminate_all(\"$var(customer)\")) {\n        xlog(\"Error terminating customer's calls\");\n    }\n\n    exit;\n}\n...\n```\n",
   "cnxcc_terminate_all": "### `cnxcc_terminate_all(customer)`\n\nTerminates all calls of the specified customer/profile.\n\nThe customer value can be provided as a string or a variable holding a\nstring.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n\n```\n...\n$var(customer)  = \"john-doe-123-basic\";\n\nif (!cnxcc_terminate_all(\"$var(customer)\")) {\n    xlog(\"Error terminating customer's calls\");\n}\n...\n```\n"
  }
 },
 "corex": {
  "overview": "This module provides reimplementation of a few very old functions that\nused to be in the core and supported only static string or integer\nparameters. The new versions bring support for dynamic parameters\n(allowing variables inside the parameters).\n\nThere are also brand new features, related to core internals, but\ncontrolled from configuration file or via control interfaces.\n\nContributions to this module must be done under the BSD license, to\nfollow the requirements of the core contributions.\n\nThis module now also provides access to network input / output (nio)\ndata through event_route[network:msg]. The raw data received from a\nremote host or about to be sent to a remote host is available in\nvariable $mb. The script writer may manipulate this data and save the\nfinal result in an AVP defined by msg_avp module parameter. The content\nof this AVP will then be processed by SIP worker as normal, i.e. a\nreceived message will be parsed and sent to appropriate route block\nwhile a sent message is forwarded to remote host.\n",
  "parameters": {
   "alias_subdomains": "### `alias_subdomains` (string)\n\nRegister a domain and all its sub-domains to match the \u201cmyself\u201d\ncondition. It can be set many times. Its full format is:\n'proto:domain:port', allowing to set restrictions on protocol and port\nas well. Protocol and port are optional.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"corex\", \"alias_subdomains\", \"kamailio.org\")\nmodparam(\"corex\", \"alias_subdomains\", \"udp:sip-router.org:5060\")\n...\n```\n",
   "dns_cache": "### `dns_cache` (string)\n\nAdd A or AAAA records to internal DNS cache at startup. It can be set\nmany times to add more than one record.\n\nThe format of the value follows the SIP params style:\n\"attr1=val1;attr2=val2;...\". The attributes can be:\n\n- *type* - it can be \"A\" (IPv4), \"AAAA\" (IPv6) or \"SRV\"\n\n- *name* - the domain name\n\n- *addr* - the IP address\n\n- *ttl* - TTL value\n\n- *priority* - priority value for SRV record\n\n- *weight* - weight value for SRV record\n\n- *port* - port value for SRV record\n\n- *flags* - can be: 1 - the domain is unresolvable (like blocklisted);\n  2 - the record is permanent (never times out, never deleted, never\n  overwritten)\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"corex\", \"dns_cache\", \"type=A;name=kamailio.org;addr=193.22.119.66;ttl=3600000;flags=0\")\nmodparam(\"corex\", \"dns_cache\", \"type=AAAA;name=kamailio.org;addr=2a00:d60:0:400::2;ttl=3600000;flags=0\")\n...\n```\n",
   "evcb_reply_out": "### `evcb_reply_out` (string)\n\nName of KEMI callback function to be executed instead of\nevent_route[corex:reply-out].\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"corex\", \"evcb_reply_out\", \"ksr_corex_reply_out\")\n...\n```\n",
   "nio_intercept": "### `nio_intercept` (int)\n\nIf set to non-zero then raw data received from a remote host or about to\nbe sent to a remote host is made available in\nevent_route[network:msg]. The script writer may modify this and save\nto msg_avp, which will then be processed by SIP worker as normal.\n\n*Default value is 0, i.e. do not allow access to network io data.*\n\n```\n...\nmodparam(\"corex\", \"nio_intercept\", 1)\n...\n```\n",
   "nio_min_msg_len": "### `nio_min_msg_len` (int)\n\nMinimum content length of the packet to execute the\nevent_route[network:msg]. This only works if nio_intercept parameter\nis set to non-zero.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"corex\", \"nio_min_msg_len\", 32)\n...\n```\n",
   "nio_msg_avp": "### `nio_msg_avp` (string)\n\nAVP name to store modified content to be set in the packet. If not set\nin event_route[network:msg], then all changes are lost and original\ncontents are used. This only works if nio_intercept parameter is to set\nnon-zero.\n\n*Default value is empty.*\n\n```\n...\nmodparam(\"corex\", \"nio_msg_avp\", \"$avp(msg)\")\n...\n```\n"
  },
  "functions": {
   "append_branch": "### `append_branch([ uri, [ q ] ])`\n\nAppend a new branch to the destination set, useful to build the set of\ndestination addresses for parallel forking or redirect replies.\n\nBoth parameters are optional, If no uri parameter is provided, then the\naddress from request URI (r-uri) is used to build the new branch.\n\nMeaning of the parameters is as follows:\n\n- *uri* - SIP address of the branch to be used as R-URI in the outgoing\n  request.\n\n- *q* - the Q value to set the priority of the branch based on Contact\n  address specifications\n\nThis function can be used from REQUEST_ROUTE or FAILURE_ROUTE.\n\n```\n...\n    append_branch();\n    append_branch(\"$avp(uri)\", \"0.5\");\n...\n```\n",
   "send_udp": "### `send_udp([ host [ :port ] ])`\n\nSend the original SIP message to a specific destination in stateless\nmode. No changes are applied to received message, no Via header is\nadded. Host can be an IP address or hostname. Port is optional and\ndefaults to 5060. Used protocol: UDP.\n\nThe parameter is optional and defaults to the destination URI from the\nSIP message if left out. Otherwise it's a string parameter (supporting\npseudo-variables) in format \"*hostname*\" or \"*hostname*:*port*\", where\n*hostname*\" can also be a numeric IP address.\n\nThis function can be used from REQUEST_ROUTE or FAILURE_ROUTE.\n\n```\n...\n    send_udp();\n    send_udp(\"10.20.15.10\");\n    send_udp(\"sip.example.com:5070\");\n    send_udp(\"$var(res)\");\n...\n```\n",
   "send_tcp": "### `send_tcp([ host [ :port ] ])`\n\nThis function is identical to *send_udp()* described above, except that\nit sends the SIP message using the TCP protocol instead of UDP.\n\n```\n...\n    send_tcp();\n    send_tcp(\"10.20.15.10\");\n    send_tcp(\"sip.example.com:5070\");\n    send_tcp(\"$var(res)\");\n...\n```\n",
   "send_data": "### `send_data(uri, data)`\n\nSend the data to address specified by uri. Both parameters can contain\npseudo-variables. The uri parameter has to be a valid SIP URI. The data\nparameter can by any arbitrary content.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    send_data(\"sip:example.com:5070;transport=sctp\", \"Message at $Ts\");\n...\n```\n",
   "sendx": "### `sendx(uri, sock, data)`\n\nSend the data to address specified by uri using a specific local socket.\nAll parameters can contain pseudo-variables. The uri parameter has to be\na valid SIP URI. The sock parameter has to be a valid socket specifier\n(like values assigned to $fs). The data parameter can by any arbitrary\ncontent.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsendx(\"sip:example.com:5070;transport=sctp\", \"sctp:2.3.4.5:5060\", \"Message at $Ts\");\n...\n```\n",
   "is_incoming": "### `is_incoming()`\n\nReturns true if contents of message buffer $mb are the data received\nfrom remote host, otherwise false indicating that the contents of $mb\nare data that is about to be sent out to remote host. This only works if\nnio_intercept parameter is set to non-zero.\n\nThis function can be used from event_route[network:msg].\n\n```\n...\nevent_route[network:msg] {\n    if (is_incoming()) {\n        xlog(\"L_INFO\", \"Received message '$mb' \\n\");\n        $avp(msg) = $mb;\n    } else {\n        xlog(\"L_INFO\", \"Sending message '$mb' \\n\");\n        $avp(msg) = $mb;\n    };\n}\n...\n```\n",
   "msg_iflag_set": "### `msg_iflag_set(flagname)`\n\nSet internal SIP message flag. The parameter flagname can be:\nUSE_UAC_FROM, USE_UAC_TO or UAC_AUTH.\n\nThis functions should not be used in configuration file for (re)setting\nthe internal flags, those are done by various functions internally,\nhowever, in very particular cases they might be useful (e.g., changing\nFrom/To via textops functions).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    msg_iflag_set(\"UAC_AUTH\");\n...\n```\n",
   "msg_iflag_reset": "### `msg_iflag_reset(flagname)`\n\nReset the internal flag given as parameter.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    msg_iflag_reset(\"UAC_AUTH\");\n...\n```\n",
   "msg_iflag_is_set": "### `msg_iflag_is_set(flagname)`\n\nTest if the internal flag given as parameter is set.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    if(msg_iflag_is_set(\"UAC_AUTH\")) { ... }\n...\n```\n",
   "file_read": "### `file_read(fpath, var)`\n\nRead content of a text file into a variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(file_read(\"/tmp/data.txt\", \"$var(data)\")) { ... }\n...\n```\n",
   "file_write": "### `file_write(fpath, content)`\n\nWrite content of parameter to a text file.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(file_write(\"/tmp/data.txt\", \"Data is: $var(data)\")) { ... }\n...\n```\n",
   "setxflag": "### `setxflag(flag)`\n\nSet the extended message (transaction) flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the flag to be set. Can be integer or\n  pseudo-variable with integer value (range 0-63).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsetxflag(\"1\");\n...\n$var(flag) = 11;\nsetxflag(\"$var(flag)\");\n...\n```\n",
   "isxflagset": "### `isxflagset(flag)`\n\nReturn true if the extended message (transaction) flag is set.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the flag to be tested. Can be integer or\n  pseudo-variable with integer value (range 0-63).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(isxflagset(\"1\"))\n{\n    ...\n}\n...\n```\n",
   "resetxflag": "### `resetxflag(flag)`\n\nReset the extended message (transaction) flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the flag to be reset. Can be integer or\n  pseudo-variable with integer value (range 0-63).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nresetxflag(\"1\");\n...\n```\n",
   "set_send_socket": "### `set_send_socket(saddr)`\n\nSet the socket for sending out.\n\nMeaning of the parameters is as follows:\n\n- *saddr* - the address of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nset_send_socket(\"udp:127.0.0.1:5060\");\n...\n```\n",
   "set_send_socket_name": "### `set_send_socket_name(sname)`\n\nSet the socket for sending out.\n\nMeaning of the parameters is as follows:\n\n- *sname* - the name of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nset_send_socket_name(\"sock1\");\n...\n```\n",
   "set_recv_socket": "### `set_recv_socket(saddr)`\n\nSwitch local socket used for receiving the message.\n\nMeaning of the parameters is as follows:\n\n- *saddr* - the address of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nset_recv_socket(\"udp:127.0.0.1:5060\");\n...\n```\n",
   "set_recv_socket_name": "### `set_recv_socket_name(sname)`\n\nSwitch local socket used for receiving the message.\n\nMeaning of the parameters is as follows:\n\n- *sname* - the name of the local socket (listen address). Can be a\n  static string or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nset_recv_socket_name(\"sock1\");\n...\n```\n",
   "set_source_address": "### `set_source_address(saddr)`\n\nSet the source address for the message.\n\nMeaning of the parameters is as follows:\n\n- *saddr* - the source address in socket format. Can be a static string\n  or contain pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nset_source_address(\"udp:127.0.0.1:5080\");\n...\n```\n",
   "via_add_srvid": "### `via_add_srvid(flags)`\n\nControl if srvid parameter is added or not to local Via. If yes, the\nvalue is server_id, added only if it is different than 0.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - add srvid parameter; 0 - do not add srvid parameter.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nvia_add_srv(\"1\");\n...\n```\n",
   "via_add_xavp_params": "### `via_add_xavp_params(flags)`\n\nControl if fields of the xavp with the name specified by xavp_via_params\nglobal parameter are added or not to local Via.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - add xavp parameters; 0 - do not add xavp parameters.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxavp_via_params=\"xvia\"\n...\nrequest_route {\n    ...\n    $xavp(xvia=>srvid) = \"1\";\n    $xavp(xvia[0]=>myval) = \"xyz\";\n    via_add_xavp_params(\"1\");\n    ...\n}\n...\n```\n",
   "via_use_xavp_fields": "### `via_use_xavp_fields(flags)`\n\nControl if fields of the xavp with the name specified by xavp_via_fields\nglobal parameter are used or not to build local Via.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - use xavp fields; 0 - do not use xavp fields.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxavp_via_fields=\"mvia\"\n...\nrequest_route {\n    ...\n    $xavp(mvia=>address) = \"10.10.10.10\";\n    $xavp(mvia[0]=>port) = \"5060\";\n    via_use_xavp_fields(\"1\");\n    ...\n}\n...\n```\n",
   "via_reply_add_xavp_params": "### `via_reply_add_xavp_params(flags)`\n\nControl if fields of the xavp with the name specified by\nxavp_via_reply_params global parameter are added or not to the top Via\nof replies.\n\nMeaning of the parameters is as follows:\n\n- *flags*: 1 - add xavp parameters; 0 - do not add xavp parameters.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxavp_via_reply_params=\"xviarpl\"\n...\nrequest_route {\n    ...\n    $xavp(xviarpl=>srvid) = \"1\";\n    $xavp(xviarpl[0]=>myval) = \"xyz\";\n    via_reply_add_xavp_params(\"1\");\n    ...\n}\n...\n```\n",
   "is_faked_msg": "### `is_faked_msg()`\n\nReturns 1 (native config true) if the SIP message under processing is\nthe internal faked msg structure. Returns -1 (native config false) if\nthe SIP message under processing is received from the network.\n\nThe function should be useful in event route blocks or async route\nblocks where it can be processed either a message from the network or\nthe internal faked message.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[dispatcher:dst-down] {\n    if (is_faked_msg()) {\n        xinfo(\"Running with faked message\\n\");\n    }\n}\n...\n```\n",
   "is_socket_name": "### `is_socket_name(sockname)`\n\nReturns 1 (native config true) if the parameter matches a local socket\nname, otherwise -1 (native config false). The parameter can contain\nvariables.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\n    if (is_socket_name(\"socktls\")) {\n        xinfo(\"matched local socket name\\n\");\n    }\n...\n```\n",
   "forward_reply": "### `forward_reply()`\n\nForward received reply on demand.\n\nThis function can be used in CORE_ONREPLY_ROUTE.\n\n```\n...\nroute[reply] {\n    forward_reply();\n}\n...\n```\n"
  }
 },
 "counters": {
  "overview": "This module exports counters/statistics manipulating script functions\nand RPCs.\n",
  "parameters": {
   "script_counter": "### `script_counter`\n\nDefine a new counter that can be used from the script. The declaration\nmight include a group in front of the counter name, separated with '.'.\nIt might also include a counter description string (help message),\nseparated from the name with a ' ' or ':'. If the group is missing, the\ngroup defined in the `script_cnt_grp_name` module parameter will be used\n(the default is \"script\"). If the description is missing, the default is\n\"custom script counter\". The format of the declaration is:\n[group.]name[( |:)description].\n\n```\nmodparam(\"counters\", \"script_counter\", \"foo\")  # script.foo\nmodparam(\"counters\", \"script_counter\", \"test.bar\")  # test.bar\nmodparam(\"counters\", \"script_counter\", \"baz example counter\")  # script.baz\nmodparam(\"counters\", \"script_counter\", \"test.x:another example\") # test.x\n            \n```\n",
   "script_cnt_grp_name": "### `script_cnt_grp_name`\n\nGroup name that will be used for the counters defined via the\n`script_counter` module parameter which do not have a specified group.\n\nDefault: \"script\".\n\n```\nmodparam(\"counters\", \"script_cnt_grp_name\", \"my_counters\")\n            \n```\n"
  },
  "functions": {
   "cnt_inc": "### `cnt_inc([group.]name)`\n\nIncrements the counter *group.name*. The counter must be defined using\nthe `script_counter` module parameter. If the group name is missing, the\ngroup specified by the `script_cnt_grp_name` modparam will be used.\n\n```\n...\nmodparam(\"counters\", \"script_counter\", \"reqs\")\nmodparam(\"counters\", \"script_counter\", \"out.reqs  forwarded requests\")\n...\nroute {\n    cnt_inc(\"reqs\");\n    if (forward(uri:host, uri:port))\n        cnt_inc(\"out.reqs\");\n...\n}\n        \n```\n",
   "cnt_add": "### `cnt_add([group.]name, number)`\n\nAdds *number* the counter *group.name*. The counter must be defined\nusing the `script_counter` module parameter. If the group name is\nmissing, the group specified by the `script_cnt_grp_name` modparam will\nbe used.\n\n```\n...\nmodparam(\"counters\", \"script_counter\", \"reqs10  reqs times 10\")\n...\nroute {\n    cnt_add(\"reqs10\", 10);\n...\n}\n        \n```\n",
   "cnt_reset": "### `cnt_reset([group.]name)`\n\nResets the counter *group.name*. The counter must be defined using the\n`script_counter` module parameter. If the group name is missing, the\ngroup specified by the `script_cnt_grp_name` modparam will be used.\n\n```\n...\nmodparam(\"counters\", \"script_counter\", \"reqs\")\n...\nroute {\n    if (...)\n        cnt_reset(\"reqs\");\n...\n}\n        \n```\n"
  }
 },
 "cplc": {
  "overview": "cplc modules implements a CPL (Call Processing Language) interpreter.\nSupport for uploading/downloading/removing scripts via SIP REGISTER\nmethod is present.\n\nCPL is an IETF specification detailed in RFC3880\n(https://tools.ietf.org/html/rfc3880).\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nA SQL URL have to be given to the module for knowing where the database\ncontaining the table with CPL scripts is locates. If required a user\nname and password can be specified for allowing the module to connect to\nthe database server.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"db_url\",\"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_table": "### `db_table` (string)\n\nIndicates the name of the table that store the CPL scripts. This table\nmust be locate into the database specified by \u201cdb_url\u201d parameter. For\nmore about the format of the CPL table please see the\nmodules/cplc/init.mysql file.\n\n*Default value is \u201ccpl\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"cpl_table\",\"cpl\")\n...\n```\n",
   "username_column": "### `username_column` (string)\n\nIndicates the name of the column used for storing the username.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"username_column\",\"username\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nIndicates the name of the column used for storing the domain.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"domain_column\",\"domain\")\n...\n```\n",
   "cpl_xml_column": "### `cpl_xml_column` (string)\n\nIndicates the name of the column used for storing the XML version of the\ncpl script.\n\n*Default value is \u201ccpl_xml\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"cpl_xml_column\",\"cpl_xml\")\n...\n```\n",
   "cpl_bin_column": "### `cpl_bin_column` (string)\n\nIndicates the name of the column used for storing the binary version of\nthe cpl script (compiled version).\n\n*Default value is \u201ccpl_bin\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"cpl_bin_column\",\"cpl_bin\")\n...\n```\n",
   "cpl_dtd_file": "### `cpl_dtd_file` (string)\n\nPoints to the DTD file describing the CPL grammar. The file name may\ninclude also the path to the file. This path can be absolute or relative\n(be careful the path will be relative to the starting directory of\nKamailio).\n\n*This parameter is MANDATORY!*\n\n```\n...\nmodparam(\"cplc\",\"cpl_dtd_file\",\"/etc/kamailio/cpl-06.dtd\")\n...\n```\n",
   "log_dir": "### `log_dir` (string)\n\nPoints to a directory where should be created all the log file generated\nby the LOG CPL node. A log file per user will be created (on demand)\nhaving the name username.log.\n\n*If this parameter is absent, the logging will be disabled without\ngenerating error on execution.*\n\n```\n...\nmodparam(\"cplc\",\"log_dir\",\"/var/log/kamailio/cpl\")\n...\n```\n",
   "proxy_recurse": "### `proxy_recurse` (int)\n\nTells for how many time is allow to have recurse for PROXY CPL node If\nit has value 2, when doing proxy, only twice the proxy action will be\nre-triggered by a redirect response; the third time, the proxy execution\nwill end by going on REDIRECTION branch. The recurse feature can be\ndisable by setting this parameter to 0\n\n*Default value of this parameter is 0.*\n\n```\n...\nmodparam(\"cplc\",\"proxy_recurse\",2)\n...\n```\n",
   "proxy_route": "### `proxy_route` (string)\n\nBefore doing proxy (forward), a script route can be executed. This\nparameter indicates the name of the route called. All modifications made\nby that route will be reflected only for the current branch.\n\n*Default value of this parameter is NULL (none).*\n\n```\n...\nmodparam(\"cplc\",\"proxy_route\",\"CPL_PROXY\")\n...\n```\n",
   "case_sensitive": "### `case_sensitive` (int)\n\nTells if the username matching should be perform case sensitive or not.\nSet it to a non zero value to force a case sensitive handling of\nusernames.\n\n*Default value of this parameter is 0.*\n\n```\n...\nmodparam(\"cplc\",\"case_sensitive\",1)\n...\n```\n",
   "realm_prefix": "### `realm_prefix` (string)\n\nDefines a prefix for the domain part which should be ignored in handling\nusers and scripts.\n\n*Default value of this parameter is empty string.*\n\n```\n...\nmodparam(\"cplc\",\"realm_prefix\",\"sip.\")\n...\n```\n",
   "timer_avp": "### `timer_avp` (string)\n\nFull specification (ID, NAME, ALIAS) of the AVP to be used to set the\nvalue of the Final Response INVITE timeout - it's used by the TIMEOUT\nattribute from the PROXY tag.\n\nNOTE: take care and synchronize this value with the similar parameters\nin TM module.\n\n*Default value of this parameter is NULL.*\n\n```\n...\nmodparam(\"cplc\",\"timer_avp\",\"$avp(i:14)\")\n...\n```\n",
   "lookup_domain": "### `lookup_domain` (string)\n\nUsed by lookup tag to indicate where to perform user location. Basically\nthis is the name of the usrloc domain (table) where the user\nregistrations are kept.\n\nIf set to empty string, the lookup node will be disabled - no user\nlocation will be performed.\n\n*Default value of this parameter is NULL.*\n\n```\n...\nmodparam(\"cplc\",\"lookup_domain\",\"location\")\n...\n```\n",
   "lookup_append_branches": "### `lookup_append_branches` (int)\n\nTells if the lookup tag should append branches (to do parallel forking)\nif user_location lookup returns more than one contact. Set it to a non\nzero value to enable parallel forking for location lookup tag.\n\n*Default value of this parameter is 0.*\n\n```\n...\nmodparam(\"cplc\",\"lookup_append_branches\",1)\n...\n```\n",
   "use_domain": "### `use_domain` (integer)\n\nIndicates if the domain part of the URI should be used in user\nidentification (otherwise only username part will be used).\n\n*Default value is \u201c0 (disabled)\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"use_domain\",1)\n...\n```\n",
   "redirect_route": "### `redirect_route` (string)\n\nBefore doing redirect (deflection), a script route can be executed. This\nparameter indicates the name of the route called. All modifications made\nby that route will be reflected only for the current branch.\n\n*Default value of this parameter is NULL (none).*\n\n```\n...\nmodparam(\"cplc\",\"redirect_route\", \"CPL_REDIRECT\")\n...\n                \n```\n",
   "ignore3xx": "### `ignore3xx` (integer)\n\nIndicates if 3xx SIP response must be ignored.\n\n*Default value is \u201c0 (disabled)\u201d.*\n\n```\n...\nmodparam(\"cplc\",\"ignore3xx\",1)\n...\n                \n```\n"
  },
  "functions": {
   "cpl_run_script": "### `cpl_run_script(type, mode[, uri])`\n\nStarts the execution of the CPL script. The user name is fetched from\nnew_uri or requested uri or from To header -in this order- (for incoming\nexecution) or from FROM header (for outgoing execution). Regarding the\nstateful/stateless message processing, the function is very flexible,\nbeing able to run in different modes (see below the\"mode\" parameter).\nNormally this function will end script execution. There is no guaranty\nthat the CPL script interpretation ended when Kamailio script ended also\n(for the same INVITE ;-)) - this can happen when the CPL script does a\nPROXY and the script interpretation pause after proxying and it will be\nresumed when some reply is received (this can happen in a different\nprocess of SER). If the function returns to script, the SIP server\nshould continue with the normal behavior as if no script existed. When\nsome error is returned, the function itself haven't sent any SIP error\nreply (this can be done from script).\n\nMeaning of the parameters is as follows:\n\n- *type* - which part of the script should be run; set it to \"incoming\"\n  for having the incoming part of script executed (when an INVITE is\n  received) or to \"outgoing\" for running the outgoing part of script\n  (when a user is generating an INVITE - call).\n\n- *mode* - sets the interpreter mode as stateless/stateful behavior. The\n  following modes are accepted:\n\n  - *IS_STATELESS* - the current INVITE has no transaction created yet.\n    All replies (redirection or deny) will be done is a stateless way.\n    The execution will switch to stateful only when proxy is done. So,\n    if the function returns, will be in stateless mode.\n\n  - *IS_STATEFUL* - the current INVITE has already a transaction\n    associated. All signaling operations (replies or proxy) will be done\n    in stateful way. So, if the function returns, will be in stateful\n    mode.\n\n  - *FORCE_STATEFUL* - the current INVITE has no transaction created\n    yet. All signaling operations will be done is a stateful way (on\n    signaling, the transaction will be created from within the\n    interpreter). So, if the function returns, will be in stateless\n    mode.\n\n\n  *HINT*: is_stateful is very difficult to manage from the routing\n  script (script processing can continue in stateful mode); is_stateless\n  is the fastest and less resources consumer (transaction is created\n  only if proxying is done), but there is minimal protection against\n  retransmissions (since replies are sent stateless); force_stateful is\n  a good compromise - all signaling is done stateful (retransmission\n  protection) and in the same time, if returning to script, it will be\n  in stateless mode (easy to continue the routing script execution)\n\n- *uri* - optional - provide the SIP URI to be used for loading the CPL\n  script, instead of taking it from R-URI or headers.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\ncpl_run_script(\"incoming\",\"force_stateful\");\n...\n```\n",
   "cpl_process_register": "### `cpl_process_register()`\n\nThis function MUST be called only for REGISTER requests. It checks if\nthe current REGISTER request is related or not with CPL script\nupload/download/ remove. If it is, all the needed operation will be\ndone. For checking if the REGISTER is CPL related, the function looks\nfirst to \"Content-Type\" header. If it exists and has a the mime type set\nto \"application/cpl+xml\" means this is a CPL script upload/remove\noperation. The distinction between to case is made by looking at\n\"Content-Disposition\" header; id its value is \"script;action=store\",\nmeans it's an upload; if it's \"script;action=remove\", means it's a\nremove operation; other values are considered to be errors. If no\n\"Content-Type\" header is present, the function looks for \"Accept\" header\nand if it contains \"*\" or \"application/cpl-xml\" the request will be\nconsidered for downloading CPL scripts. The functions returns to script\nonly if the REGISTER is not related to CPL. In other case, the function\nwill send by itself the necessary replies (stateless - using sl),\nincluding for errors.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (method==\"REGISTER\") {\n    cpl_process_register();\n}\n...\n```\n",
   "cpl_process_register_norpl": "### `cpl_process_register_norpl()`\n\nSame as \u201ccpl_process_register\u201d without internally generating the reply.\nAll information (script) is appended to the reply but without sending it\nout.\n\nMain purpose of this function is to allow integration between CPL and\nUserLocation services via same REGISTER messages.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (method==\"REGISTER\") {\n    cpl_process_register();\n    # continue with usrloc part\n    save(\"location\");\n}\n...\n```\n"
  }
 },
 "crypto": {
  "overview": "This module provides various cryptography tools for use in Kamailio\nconfiguration file. For compatibility with existing crypto libraries its\ninternal operation mode can be configured as well. This allows the\nmodule to be used e.g. with existing Java applications or PostgreSQL DB\nfunctions.\n\nIt relies on OpenSSL libraries for cryptographic operations (libssl,\nlibcrypto).\n",
  "parameters": {
   "salt": "### `salt` (str)\n\nA keyword to generate salt for encryption. It must be at least 8 chars\nlong. If set to empty, no salt is used for encryption.\n\nThe salt is a binary array that is appended to the encryption password\nfor better protection against dictionary attacks. Same salt and password\nneed to be used when encrypting and decrypting.\n\n*Default value is \"...\" (see code).*\n\n```\n...\nmodparam(\"crypto\", \"salt\", \"l0Bh2M8a\")\n...\n```\n",
   "register_callid": "### `register_callid` (int)\n\nSet it to 1 in order to register a callback to core for generation of\ncallid values for requests generated by Kamailio tm module.\n\nThis callid generator uses libssl random and hashing functions for\ngenerating RFC 4122 version 4 UUID with high quality entropy. It is\nuseful when wanting to have new callids that cannot be predicted from\nprevious values.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"crypto\", \"register_callid\", 1)\n...\n```\n",
   "register_evcb": "### `register_evcb` (int)\n\nSet it to 1 in order to register the event route callbacks, in case AES\nencryption/decryption of SIP traffic is wanted. The\nevent_route[crypto:netio] or corresponding KEMI callback are executed.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"crypto\", \"register_evcb\", 1)\n...\n```\n",
   "kevcb_netio": "### `kevcb_netio` (str)\n\nName of the KEMI callback function for netio events. It receives a\nstring parameter with event route name.\n\n*Default value is not set.*\n\n```\n...\nmodparam(\"crypto\", \"kevcb_netio\", \"ksr_crypto_netio\")\n...\nfunction ksr_crypto_netio(evname)\n  ...\nend\n...\n```\n",
   "netio_key": "### `netio_key` (str)\n\nThe shared secret used to encrypt/decrypt network traffic.\n\n*Default value is not set.*\n\n```\n...\nmodparam(\"crypto\", \"netio_key\", \"strong-password-here\")\n...\n```\n",
   "key_derivation": "### `key_derivation` (str)\n\nSpecify if the module should use an internal derivation function to\ngenerate the initialization vector for encryption operations. This is\nthe default mode. If set to 0 the initialization vector will be\ngenerated randomly or read from the configuration file.\n\nThe source of the initialization vector is configured with the\n*init_vector* parameter.\n\n*Default value is 1 - generate the initialization vector internally*\n\n```\n...\nmodparam(\"crypto\", \"key_derivation\", 0)\n...\n```\n",
   "init_vector": "### `init_vector` (str)\n\nThe initialization vector used for the cryptographic operations. This\nneeds to be a Base64 encoded value with 16 bytes lengths.\n\nIf this parameter is not set and the *key_derivation* parameter is also\nset to 0, the module will create a random initialization vector for\ndecryption operations. For encryption operations the initialization\nvector will be read from the first 16 bytes of the cipher text.\n\n*Default value is not set.*\n\n```\n...\nmodparam(\"crypto\", \"init_vector\", \"MTIzNDU2Nzg5MTIzNDU2Nw==\")\n...\n```\n"
  },
  "functions": {
   "crypto_aes_encrypt": "### `crypto_aes_encrypt(text, key, res)`\n\nEncrypts the text with the key using AES encryption algorithm. The\nresult is encoded in base64 format and stored in res. The parameter res\nmust be a read-write variables. The parameters text and key can be\nstatic strings or strings with variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ncrypto_aes_encrypt(\"$rb\", \"my-secret-key\", \"$var(encrypted)\");\n...\n```\n",
   "crypto_aes_decrypt": "### `crypto_aes_decrypt(text, key, res)`\n\nDecrypts the text with the key using AES encryption algorithm. The text\nhas to be encoded in base64 format. The parameter res must be a\nread-write variables. The parameters text and key can be static strings\nor strings with variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ncrypto_aes_decrypt(\"$var(encrypted)\", \"my-secret-key\", \"$var(text)\");\n...\n```\n",
   "crypto_hmac_sha256": "### `crypto_hmac_sha256(text, key, res)`\n\nCalculates HMAC (keyed-hash message authentication code) with SHA256 as\na cryptographic hash function. The result is encoded in base64 url\nencoded format and stored in res. The parameter res must be a read-write\nvariable. The parameters text and key can be static strings or strings\nwith variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ncrypto_hmac_sha256(\"$var(text)\", \"my-secret-key\", \"$var(hmac)\");\n...\n```\n",
   "crypto_netio_in": "### `crypto_netio_in)`\n\nReturn 1 (true) if it is an incoming net message, or -1 (false)\notherwise.\n\nThis function can be used from EVENT_ROUTE.\n\n```\n...\nevent_route[crypto:netio] {\n  if(crypto_netio_in()) {\n    crypto_netio_decrypt();\n  }\n...\n```\n",
   "crypto_netio_out": "### `crypto_netio_out()`\n\nReturn 1 (true) if it is an outgoing net message, or -1 (false)\notherwise.\n\nThis function can be used from EVENT_ROUTE.\n\n```\n...\nevent_route[crypto:netio] {\n  if(crypto_netio_out()) {\n    crypto_netio_encrypt();\n  }\n...\n```\n",
   "crypto_netio_encrypt": "### `crypto_netio_encrypt()`\n\nMark the network message for encryption.\n\nThis function can be used from EVENT_ROUTE.\n\n```\n...\nevent_route[crypto:netio] {\n  if(crypto_netio_out()) {\n    crypto_netio_encrypt();\n  }\n...\n```\n",
   "crypto_netio_decrypt": "### `crypto_netio_decrypt()`\n\nMark the network message for decryption.\n\nThis function can be used from EVENT_ROUTE.\n\n```\n...\nevent_route[crypto:netio] {\n  if(crypto_netio_in()) {\n    crypto_netio_decrypt();\n  }\n...\n```\n"
  }
 },
 "ctl": {
  "overview": "This module implements the binrpc transport interface for Kamailio RPCs.\nIt supports various transports over which it speaks binrpc: Unix\ndatagram sockets, Unix stream sockets, UDP and TCP. It also supports a\nbackward compatible FIFO interface (using the old Kamailio FIFO\nprotocol).\n\nBy default (if no parameters are changed in the config file) it uses a\nUnix stream socket under /run/kamailio: /run/kamailio/kamailio_ctl. This\nsocket is also the default for kamcmd.\n\nIn general it's used in conjunction with kamcmd. kamcmd is a Unix tool\nfor invoking Kamailio RPC functions. It can be used both in interactive\nmode (supports tab-completion and history) or command line mode.\n\n```\n$ kamcmd ps\n11262   attendant\n11268   udp receiver child=0 sock=127.0.0.1:5060\n11269   udp receiver child=1 sock=127.0.0.1:5060\n11270   udp receiver child=0 sock=192.168.1.101:5060\n11271   udp receiver child=1 sock=192.168.1.101:5060\n11272   slow timer\n11273   timer\n11274   ctl handler\n11275   tcp receiver child=0\n11276   tcp receiver child=1\n11277   tcp main process\n\n        \n```\n\nSee\n[utils/kamcmd/EXAMPLES](http://git.sip-router.org/cgi-bin/gitweb.cgi?p=sip-router;a=blob;f=utils/sercmd/EXAMPLES)\nfor more examples.\n",
  "parameters": {
   "binrpc": "### `binrpc` (string)\n\nSpecifies the transport used for the binrpc protocol. The following\ntransport protocol are supported: Unix datagram sockets, Unix stream\nsockets, UDP and TCP.\n\nThe format is: [ protocol:] address_port|path .\n\n- For *Unix* sockets: [unixd|unixs|unix]:path where `&quot;unixd&quot;` means\n  Unix datagram sockets and `&quot;unix&quot;` `&quot;unixs&quot;` mean Unix stream sockets.\n  Examples: \"unixd:/tmp/unix_dgram\", \"unixs:/tmp/unix_stream\",\n  \"unix:/tmp/unix_stream\".\n\n- For *UDP* or *TCP* sockets: [udp|tcp]:address:port. If the address\n  is \"*\" or missing, it will bind to all the local addresses (0.0.0.0).\n  Examples: \"udp:localhost:2046\", \"tcp:localhost:2046\", \"tcp:3012\",\n  \"udp:*:3012\".\n\nIf the protocol part is missing and the address/path part looks like a\nfile system path it will default to a Unix stream socket and if not to a\nUnix UDP socket. Examples:\n\n- \"/tmp/unix_test\" - equivalent to \"unixs:/tmp/unix_test\".\n- \"localhost:3000\" - equivalent to \"udp:localhost:3000\".\n\nMultiple transports / listen addresses can be specified, just by setting\nthe parameter multiple times.\n\n*Default:* \"unix:/run/kamailio/kamailio_ctl\" (Unix stream socket). The\ndefault value is used *only* if no `binrpc` parameter is found in the\nconfig file.\n\n```\nloadmodule \"ctl\"\n# optional listen addresses, if no one is specified,\n# ctl will listen on unixs:/tmp/kamailio_ctl\n\nmodparam(\"ctl\", \"binrpc\", \"unix:/run/kamailio/kamailio_ctl\") # default\nmodparam(\"ctl\", \"binrpc\", \"udp:localhost:2046\")\nmodparam(\"ctl\", \"binrpc\", \"tcp:localhost:2046\")\nmodparam(\"ctl\", \"binrpc\", \"unixd:/tmp/unix_dgram\")  # unix datagram\nmodparam(\"ctl\", \"binrpc\", \"unixs:/tmp/unix_stream\") # unix stream\nmodparam(\"ctl\", \"binrpc\", \"unix:/tmp/unix_default\") # unix stream\nmodparam(\"ctl\", \"binrpc\", \"/tmp/unix_test\")         # unix stream\nmodparam(\"ctl\", \"binrpc\", \"localhost:3000\")         # udp\nmodparam(\"ctl\", \"binrpc\", \"tcp:3012\")               # tcp any , port 3012\nmodparam(\"ctl\", \"binrpc\", \"udp:*:3012\")             # udp any , port 3012\n        \n```\n",
   "binrpc_buffer_size": "### `binrpc_buffer_size` (integer)\n\nThe size of the internal buffer used for printing elements of the RPC\nresponse (e.g., internal RPC printf()). The value is given in bytes.\n\nDefault: 1024.\n\n```\n            ...\n            modparam(\"ctl\", \"binrpc_buffer_size\", 4096)\n            ...\n        \n```\n",
   "mode": "### `mode` (integer)\n\nPermissions used for the created Unix sockets or for the fifo.\n\nDefault: 0600.\n\n```\nmodparam(\"ctl\", \"mode\", 0600) # permissions\n        \n```\n",
   "user": "### `user` (integer or string)\n\nUsername or uid used for the created Unix sockets or for the fifo.\n\nDefault: not set (the user under which SER runs).\n\n```\n...\nmodparam(\"ctl\", \"user\", \"andrei\")\n...\n        \n```\n",
   "group": "### `group` (integer or string)\n\nGroup name or gid used for the created Unix sockets or for the fifo.\n\nDefault: not set (the group under which SER runs).\n\n```\n...\nmodparam(\"ctl\", \"group\", 100)\n...\n        \n```\n",
   "fifo": "### `fifo` (integer)\n\nfifo used for the obsolete fifo protocol. The fifo protocol can be run\nover a real fifo, over UDP or over TCP. Format:\n[protocol:]path|address. If no protocol is specified the default is\n\"fifo\". Examples: \"fifo:/tmp/kamailio_fifo\", \"/tmp/kamailio_fifo2\",\n\"udp:*:2050\", \"tcp:localhost:2050\". For more details on the UDP and TCP\nformats see `binrpc`. Multiple fifos or fifo transports can be used in\nthe same time (just by setting the `fifo` parameter multiple times in\nthe config).\n\nDefault: not set (no fifo will be used).\n\n```\n...\n# old fifo support\nmodparam(\"ctl\", \"fifo\", \"fifo:/tmp/kamailio_fifo\")      # classic fifo\nmodparam(\"ctl\", \"fifo\", \"/tmp/kamailio_fifo2\")\nmodparam(\"ctl\", \"fifo\", \"udp:*:2050\")              # fifo protocol over udp\nmodparam(\"ctl\", \"fifo\", \"tcp:*:2050\")              # fifo over tcp\n...\n        \n```\n",
   "autoconversion": "### `autoconversion` (integer)\n\nEnable or disable automatic type conversion globally, for all the\nmethods parameters. If on, a type mismatch in a method parameter will\nnot cause a fault if it is possible to automatically convert it to the\nexpected type.\n\nDefault: off\n\nIt is recommended to leave this parameter to its default off value and\nfix instead the client application (which should use the proper types)\nor to modify the target rpc to accept any type (see the rpc scan '.'\nmodifier).\n\n```\n...\nmodparam(\"ctl\", \"autoconversion\", 1)\n...\n        \n```\n",
   "binrpc_max_body_size": "### `binrpc_max_body_size` (integer)\n\nSet the size of binrpc buffer for RPC reply. Value represents kilobytes.\n\nDefault: 32 (meaning 32KB);\n\n```\n...\nmodparam(\"ctl\", \"binrpc_max_body_size\", 16)\n...\n        \n```\n",
   "binrpc_struct_max_body_size": "### `binrpc_struct_max_body_size` (integer)\n\nSet the size of binrpc structure buffer for RPC reply. Value represents\nkilobytes.\n\nDefault: 8 (meaning 8KB);\n\n```\n...\nmodparam(\"ctl\", \"binrpc_struct_max_body_size\", 4)\n...\n        \n```\n"
  },
  "functions": {}
 },
 "db2_ldap": {
  "overview": "The LDAP module is database driver, i.e. it implements DBv2 API\nfunctions. The goal is map database query defined by table, matching\nfields and result fields to LDAP search in sub-tree defined by root,\nobject class, attributes and pass it to the *OpenLDAP* which\ncommunicates with the LDAP server.\n\nThis procedure is sometimes tricky because the LDAP does not support all\ndatabase features or supports them in different manner. Here we must\nexpress especially *filtering* and *multi-values*. The multi-value is de\nfacto array of single values. If the LDAP module gets a multi-value\nfield then it generates record for every single value, respectively for\nevery combination in case the more fields contain multi-value.\n\nThe LDAP supports natively \"AND\", \"OR\", \"NOT\" logical operators and\n\"equal\", \"non-equal\", \"less-or-equal\" and \"greater-or-equal\" comparison\noperators. Therefore \"less\" and \"greater\" operators are mapped as\n\"less/greater-or-equal-AND-not-equal\". It's important realize it when\nthe attribute which will be used for filtering may contain multi-value.\nThe LDAP server evaluates comparison operator on multi-value so that the\nresult for record is true if the condition is satisfied for any single\nvalue. The single values not satisfying condition are not truncated. It\nimplies two cases for positive comparison, e.g. \"equal\", the result\ncontains values not satisfying the condition, the case may be handled by\nadditional filter in the LDAP module, the negative comparison, e.g.\n\"non-equal\", does not return record at all. Because the LDAP module\ncannot know if the LDAP attribute may logically contain multi-value so\nthere is introduced DB API option *client_side_filtering* which forces\nfiltering such fields in the LDAP module, i.e. the LDAP server returns\nlarger result set because the filtering condition is not passed there.\n\nThe syntax of *client_side_filtering* value is comma delimited of field\nnames which won't be used for server-side filter if such a field appears\nin a match condition. Instead records will be filtered out in module. It\nimplies such fields MUST exist in result field list.\n\nThe necessary condition of successful filtering of particular attribute\nat the LDAP server is correct attribute definition. The\n\"equal\"/\"non-equal\" operator requires *equality matching rule*, the\n\"greater\"/\"less\" operator requires *ordering matching rule*. If required\nmatching rule is missing the LDAP server silently returns empty result\nset. In case of double filtering both at the LDAP server and the LDAP\nmodule, e.g. multi-value and equal comparison, check the LDAP server\nmatching rule satisfies your needs or use *client_side_filtering*\nfeature.\n\nThe LDAP server may be identified either complete specification of host,\nuser, password in URI or is specification reference to `connection`\nsection of `config` file. Note in the second case there is only one\nslash.\n\n```\n    ...\n    modparam(\"auth\", \"db_url\", \"ldap://admin:heslo@127.0.0.1\");\n\n    modparam(\"auth\", \"db_url\", \"ldap:/ldap_server1\");\n\n    ...\n            \n```\n\nFeatures:\n\n- simple, SASL authentication, TLS\n\n- server and client side filtering\n\n- read-only queries\n\n- optional referral chasing by OpenLDAP\n\n- optional reference chasing by OpenLDAP\n",
  "parameters": {
   "config": "### `config` (string)\n\nDefault value is *ldap.cfg*.\n\nThe filename (relatively to ser config file) of mapping database to LDAP\ndefinition. It is the main configuration file for the LDAP module in\nSER. The configuration file maps database table names used in SER to\nLDAP directory sub-trees to be searched. In addition to that the\nconfiguration file also allows to configure the LDAP search filter and\nmaps database field names to LDAP attribute names and vice versa.\n\n```\n    ...\n    modparam(\"ldap\", \"config\", \"my-ldap.cfg\");\n    ...\n                \n\n# Supported Attribute Type Names:\n#  * GeneralizedTime\n#  * Integer\n#  * BitString\n#  * Boolean\n#  * String\n#  * Binary\n#  * Float\n#\n\n[connection:ldap_server1]\nhost=127.0.0.1\nport=389\nusername=ser\npassword=heslo\n# LDAP or LDAP SASL authentication mechanism.\n# Allowed values: none (default), simple, digest-md5, external\nauthtype=simple\n\n# tls encryption\ntls=off\n\n# Specifies the file that contains certificates for all of the Certificate\n# Authorities the ldap module will recognize.\nca_list=/home/kg/work/openssl/demoCA/cacert.pem\n\n# Specifies what checks to perform on server certificates in a TLS session\n# allowed values are never/allow/try/demand\n# see the TLS_REQCERT tls option part of ldap.conf(8) man page for more details\nrequire_certificate=demand\n\n#\n# Table credentials contains SIP digest authentication credentials.\n#\n[table:credentials]\n\n# In our LDAP directory we store SIP digest credentials under\n# \"Digest Credentials\" organization unit so this is where searches for digest\n# credentials should start.\nbase = \"ou=Digest Credentials,dc=iptel,dc=org\"\n\n# We search the whole subtree.\nscope = subtree\n\n# For digest credentials we are only interested in objects with objectClass\n# 'digestAuthCredentials', objects of all other types are ignored.\nfilter = \"(objectClass=digestAuthCredentials)\"\n\n# Mapping of field names to LDAP attribute names and vice versa. Names are\n# delimited using ':', the first name is database field name as used in SER\n# modules, the second name (after :) is corresponding LDAP attribute name,\n# optionally preceded with LDAP attribute syntax name in parentheses.\nfield_map = password : (Binary) digestPassword\nfield_map = realm : digestRealm\nfield_map = auth_username : digestUsername\nfield_map = uid : serUID\nfield_map = flags : (BitString) serFlags\n\n# retrieve at most sizelimit entries for a search\n#sizelimit = 2147483647\n\n# wait at most timelimit seconds for a search to complete\n#timelimit = 120\n\n# chase references automatically by OpenLDAP. Default is \"never\"\n# chase_references = never | searching | finding | always\n\n# chase referrals automatically by OpenLDAP. Default is \"no\"\n# chase_referrals = yes | no\n\n#\n# Domain table stores information about virtual domains\n#\n[table:domain]\n\n# Objects mapping domain IDs to domain names and vice versa are stored\n# in the subtree with the following root:\nbase = \"ou=Domains,dc=iptel,dc=org\"\n\nscope = subtree\n\n# We are only interested in serDomain objects when looking up information\n# about virtual domains.\nfilter = \"(objectClass=serDomain)\"\n\nfield_map = did : (String) serDID\nfield_map = domain : (String) serDomain\nfield_map = flags : (BitString) serFlags\n\n#\n# Table domain_attrs contains domain attributes, domain attributes store\n# extra information about virtual domains.\n#\n[table:domain_attrs]\nbase = \"ou=Domains, dc=iptel,dc=org\"\nscope = subtree\n\nfilter = \"(objectClass=serDomainAttr)\"\n\nfield_map = did : serDID\nfield_map = name : serAttrName\nfield_map = type : (Integer) serAttrType\nfield_map = value : serAttrValue\nfield_map = flags : (BitString) serFlags\n                \n```\n",
   "reconnect_attempt": "### `reconnect_attempt` (integer)\n\nDefault value is *3*.\n\nNumber of reconnect attempts when connection to the LDAP server is lost.\n\n```\n    ...\n    modparam(\"ldap\", \"reconnect_attempt\", \"5\");\n    ...\n                \n```\n"
  },
  "functions": {}
 },
 "db2_ops": {
  "overview": "The module introduces possibility to run SQL queries from script.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nDefault database URL.\n\nThe format is:\n\n```\n            db_url = database\n            \n\n    ...\n    modparam(\"db_ops\", \"db_url\", \"mysql://ser:123@127.0.0.1:12345/ser\");\n    ...\n                \n```\n",
   "declare_query": "### `declare_query` (string)\n\nDeclare query_id for `@db.query_id` (see select syntax) or for reference\nfrom `db_query(query_id)`. Queries are pre-compiled therefore volatile\nstuff must be passed via parameters (AVP or so).\n\nThe format is:\n\n```\n            declare_query = declare_query_param\n            \n\n    ...\n    modparam(\"db_ops\", \"declare_query\", \"sel1=select/location/received/uid///%$f.uid\");\n    ...\n                \n```\n",
   "declare_handle": "### `declare_handle` (string)\n\nDeclare handle for fetching.\n\nThe format is:\n\n```\n            declare_handle = declare_handle_param\n            \n\n    ...\n    modparam(\"db_ops\", \"declare_handle\", \"my_handle\");\n    ...\n                \n```\n"
  },
  "functions": {
   "db_query": "### `db_query(query | query_id[, handle])`\n\nExecutes query and in case of SELECT returns result via *handle*, seeks\nthe first record and returns TRUE if table is not empty. The result is\naccessible using `@db.fetch` select. See also `declare_handle`.\n*Query_id* references to query declared using `declare_query`, *handle*\nreferences to query declared using `declare_handle`.\n\n```\n    ...\n    db_query(\"delete/silo///\");\n    if (db_query(\"select/silo/body/uid//inc_time/%$f.uid\", my_handle)) {\n    ...\n    }\n    ...\n    if (db_query(sel1, my_handle)) {\n\n    }\n                \n```\n",
   "db_close": "### `db_close(handle)`\n\nClose table that has been opened using `db_query`. Note all close after\nscript processing automatically.\n\n```\n    ...\n    db_close(my_handle);\n    ...\n                \n```\n",
   "db_first": "### `db_first(handle)`\n\nReturns TRUE if table is not empty. Note that rewind might not be\nsupported by particular db driver.\n\n```\n    ...\n    if (db_first(my_handle)) {\n    ...\n    }\n    ...\n                \n```\n",
   "db_next": "### `db_next(handle)`\n\nMoves to the next record and returns TRUE if not EOF.\n\n```\n    ...\n    if (db_next(my_handle)) {\n    ...\n    }\n    ...\n                \n```\n",
   "db_seek": "### `db_seek(handle, row_no)`\n\nSeeks at the row no (origin is zero) and Returns TRUE in case of\nsuccess. Backward seek might not be supported by db driver.\n\n```\n    ...\n    if (db_seek(my_handle, $row_no)) {\n    ...\n    }\n    ...\n                \n```\n",
   "db_foreach": "### `db_foreach(handle, route)`\n\nCall specific route for each row, loop is interrupted if route returns\ncode <= 0. Return code of the last route call is returned as result of\n`db_foreach` (or -1 when no select is empty).\n\n```\n    route[\"print_row\"] {\n    ....\n    }\n\n    ...\n    if (db_foreach(my_handle, print_row)) {\n    ...\n    }\n    ...\n                \n```\n",
   "db_proper": "### `db_proper()`\n\nHack which enables using db_ops queries in failure route. Call it at the\nbeginning of FAILURE_ROUTE block.\n\n```\n    failure_route[\"my_failure\"] {\n        db_proper();\n        db_query(my_query, my_handle);\n    ....\n    }\n                \n```\n",
   "db": "### `@db.fetch.handle.row_no`\n\nReturns current row number (origin is zero).\n\n```\n    db_query(sel1, my_handle);\n    ...\n    db_next(my_handle);\n    if (@db.handle == \"xyz\") {\n        db_next(my_handle);\n    }\n    if (@db.fetch.my_handle.row_no == \"1\") {\n\n        }\n    }\n    if (@db.fetch.my_handle.count == \"10\") {\n        ...\n    }\n    if (@db.fetch.my_handle.row_no == \"1\") {    # always false because .count has invalidated current record!\n\n    }\n    db_close(my_handle);\n\n                \n```\n"
  }
 },
 "db_berkeley": {
  "overview": "This is a module which integrates the Berkeley DB into SIP-router. It\nimplements the DB API defined in SIP-router.\n",
  "parameters": {
   "auto_reload": "### `auto_reload` (integer)\n\nThe auto-reload will close and reopen a Berkeley DB when the files inode\nhas changed. The operation occurs only during a query. Other operations\nsuch as insert or delete, do not invoke auto_reload.\n\n*Default value is 0 (1 - on / 0 - off).*\n\n```\n...\nmodparam(\"db_berkeley\", \"auto_reload\", 1)\n...\n        \n```\n",
   "log_enable": "### `log_enable` (integer)\n\nThe log_enable boolean controls when to create journal files. The\nfollowing operations can be journaled: INSERT, UPDATE, DELETE. Other\noperations such as SELECT, do not. This journaling are required if you\nneed to recover from a corrupt DB file. That is, kambdb_recover requires\nthese to rebuild the db file. If you find this log feature useful, you\nmay also be interested in the METADATA_LOGFLAGS bitfield that each table\nhas. It will allow you to control which operations to journal, and the\ndestination (like syslog, stdout, local-file). Refer to bdblib_log() and\ndocumentation on METADATA.\n\n*Default value is 0 (1 - on / 0 - off).*\n\n```\n...\nmodparam(\"db_berkeley\", \"log_enable\", 1)\n...\n        \n```\n",
   "journal_roll_interval": "### `journal_roll_interval` (integer seconds)\n\nThe journal_roll_interval will close and open a new log file. The roll\noperation occurs only at the end of writing a log, so it is not\nguaranteed to to roll 'on time'.\n\n*Default value is 0 (off).*\n\n```\n...\nmodparam(\"db_berkeley\", \"journal_roll_interval\", 3600)\n...\n        \n```\n"
  },
  "functions": {}
 },
 "db_cassandra": {
  "overview": "Note: the module requires old version of external library, not compiling\nwith those available out of the stock in the Linux distributions. It is\ngoing to be kept for a while in case someone wants to pick it up and\nupgrade. Also, the module was never extensively tested, therefore take\nthe appropriate actions in case you plan to use it.\n\nDb_cassandra is one of the Kamailio database modules. It does not export\nany functions executable from the configuration scripts, but it exports\na subset of functions using the database API, and thus, other modules\ncan use it as a database driver, instead of, for example, the Mysql\nmodule.\n\nThe storage backend is a *Cassandra* cluster and this module provides an\nSQL interface to be used by other modules for storing and retrieving\ndata. Because Cassandra is a NoSQL distributed system, there are\nlimitations on the operations that can be performed. The limitations\nconcern the indexes on which queries are performed, as it is only\npossible to have simple conditions (equality comparison only) and only\ntwo indexing levels. These issues will be explained in an example below.\n\nCassandra DB is especially suited for storing large amounts of data or\ndata that requires distribution, redundancy or replication. One usage\nexample is a distributed location system in a platform that has a\ncluster of SIP Router servers, with several proxies and registration\nservers accessing the same location database. This was actually the main\nuse case we had in mind when implementing this module. Please NOTE that\nit has only been tested with the *usrloc*, *auth_db* and *domain*\nmodules.\n\nYou can find a configuration file example for this usage in the module -\nkamailio_cassa.cfg.\n\nBecause the module has to do the translation from SQL to Cassandra NoSQL\nqueries, the schemas for the tables must be known by the module. You\nwill find the schemas for location, subscriber and version tables in\nutils/kamctl/dbcassandra directory. You have to provide the path to the\ndirectory containing the table definitions by setting the module\nparameter schema_path.\n\nThere is no need to configure a table metadata in Cassandra cluster. You\nonly need to define a keyspace with the name of the database and for\neach table a column family inside that keyspace with the name of the\ntable. The comparator and validators should be either UTF8Type or\nASCIIType. Example:\n\n```\n   ...\n   create keyspace kamailio;\n   use kamailio;\n   create column family 'location' with comparator='UTF8Type' and\ndefault_validation_class='UTF8Type' and key_validation_class='UTF8Type';\n   ...\n```\n\nSpecial attention was given to performance in Cassandra. Therefore, the\nimplementation uses only the native row indexing in Cassandra and no\nsecondary indexes, because they are costly. Instead, we simulate a\nsecondary index by using the column names and putting information in\nthem, which is very efficient. Also, for deleting expired records, we\nlet Cassandra take care of this with its own mechanism (by setting the\nTTL for columns).\n\nThe module supports raw queries. However these queries must follow the\nCQL (Cassandra Query Language) syntax. The queries can be issued in the\nscript by means of the AVPOPS module. Keep in mind that when passing\nback the results from the database only the first row is used to set the\nAVP variables. (default AVPOPS behaviour) The script lines below can be\nused as an example for issuing the query towards a cassandra instance.\n(This example will work once the column family `location` is\nconfigured correctly in the cassandra keyspace)\n\n```\n   ...\n   $var(dballowed)=\"select * from location where key = 'userx' limit 1;\";\n   avp_db_query(\"$var(dballowed)\");\n   xlog(\"L_INFO\",\"Got result here: [$avp(i:1)] [$avp(i:2)] [$avp(i:3)].\\n\");\n   ...\n```\n",
  "parameters": {
   "schema_path": "### `schema_path` (string)\n\nThe directory where the files with the table schemas are located. This\ndirectory has to contain the subdirectories corresponding to the\ndatabase name (name of the directory = name of the database). These\ndirectories, in turn, contain the files with the table schemas. See the\nschemas in utils/kamctl/dbcassandra directory.\n\n```\n   ...\n   modparam(\"db_cassandra\", \"schema_path\",\n               \"/usr/local/kamailio/etc/kamctl/dbcassandra\")\n   ...\n```\n"
  },
  "functions": {}
 },
 "db_cluster": {
  "overview": "This module provides a generic database clustering system. It can be\nused as a middle layer between modules and database connectors.\n\nVia clustering, database operations can be executed across multiple\nservers, based on policies such as parallel write, serial or round robin\nwrite and read.\n\nThe following database commands are considered to be write operations:\nINSERT, DELETE, UPDATE, REPLACE, INSERT-DELAYED, INSERT-UPDATE,\nINSERT-ASYNC. The read operations are done for database commands: QUERY\nand RAW-QUERY.\n\nNote: if INSERT-ASYNC is not implemented by DB connector module, then\nstandard INSERT operation is done.\n",
  "parameters": {
   "connection": "### `connection` (str)\n\nSpecify the connection to a real database system. The format is\n'conid=>DBURL' - providing a connection id and the database URL used by\nthe database driver used.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"db_cluster\", \"connection\",\n             \"con1=>mysql://kamailio:kamailiorw@localhost/kamailio1\")\nmodparam(\"db_cluster\", \"connection\",\n             \"con2=>mysql://kamailio:kamailiorw@localhost/kamailio2\")\n...\n```\n",
   "cluster": "### `cluster` (str)\n\nSpecify the cluster definition. The format is\n'clsid=>conid1=def1;conid2=def2' - providing a cluster id and the list\nof database connections to be used. For each connection you have to\nprovide a usage definition. The usage definition is a 4-char long\nstring, specifying priority and command mode for read and write\noperations to be performed on that connection.\n\nThe priority is a digit between 0 and 9, where a higher value means\nhigher priority. Priority 0 means that the connection is not going to be\nused in that cluster.\n\nCommand mode is a character among s, r and p. s is for doing serial\noperations (try first and if fails, try next); r is for doing round\nrobin operations; p - is for doing parallel operations (this is valid\nonly for write operations).\n\nThe first two characters is priority and mode for read, followed by two\ncharacters for priority and mode for write operations. \"p\" is only used\nfor write operations.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"db_cluster\", \"cluster\", \"cls1=>con1=9s8p;con2=9s8p\")\n...\n```\n",
   "inactive_interval": "### `inactive_interval` (int)\n\nHow long (seconds) a connection is considered inactive after a DB\noperations failed on it.\n\n*Default value is 300 (5 min).*\n\n```\n...\nmodparam(\"db_cluster\", \"inactive_interval\", 180)\n...\n```\n",
   "max_query_length": "### `max_query_length` (int)\n\nHow long (seconds) a failed db operation needs to last before\ndeactivating the connection for inactive_interval seconds. This prevents\ndisabling of connections that reply fast with error codes, thus being\nactive (e.g., due to primary key insert errors). In such cases, the\ndatabase server is active.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"db_cluster\", \"max_query_length\", 5)\n...\n```\n"
  },
  "functions": {}
 },
 "db_flatstore": {
  "overview": "Db_flatstore is one of the Kamailio database modules. It does not export\nany functions executable from the configuration scripts, but it exports\na subset of functions from the database API and thus other modules can\nuse it as a database driver, instead of, for example, the db_mysql\nmodule.\n\nThe module does not implement all functions of the database API, it\nsupports only one function, insert. This means that the module is\nlimited but very fast. It is especially suitable for storing accounting\ninformation on sites with extremely high traffic. If MySQL is too slow\nor if you get a huge amount of accounting data then you can consider\nusing this module. Please note that the acc module is the only module\nthat was tested with the flatstore module.\n\nThe format of the files produced by this module is plain text. Each line\nconsists of several fields, fields are separated by the \"|\" character\n(vertical bar). New information is always appended at the end of the\nfile. *Searching, deleting and updating of existing data is not\nsupported by the module*.\n\nThe acc module can be configured to use db_flatstore module as database\nbackend using the db_url_parameter:\n\n```\nmodparam(\"acc\", \"db_url\", \"flatstore:/var/log/acc\")\n    \n```\n\nThis configuration option tells the acc module that it should use the\ndb_flatstore module and the db_flatstore module should create all files\nin the /var/log/acc directory. The directory must exist and Kamailio\nprocesses must have permissions to create files in that directory.\n\nName of files in that directory will follow the following pattern:\n\n```\n<table_name>_<process_name>.log\n    \n```\n\nFor example, entries written by the Kamailio process 8 into the acc\ntable would be written in file acc_8.log. For each table there will be\nseveral files, one file for every Kamailio process that wrote some data\ninto that table. The main reason why there are several files for each\ntable is that it is much faster to have one file per process, because it\ndoes not require any locking and thus Kamailio processes will not block\neach other. To get the complete data for a table you can simply\nconcatenate the contents of files with the same table name but different\nprocess id.\n",
  "parameters": {
   "flush": "### `flush` (integer)\n\nEnable or disable flushing after each write.\n\nDefault value is 1.\n",
   "encode_delimiter": "### `encode_delimiter` (integer)\n\nEnable or disable encoding of the escaped character using \"\"%\" HEX HEX\"\nmechanism for escaping from RFC 2396\n\nDefault value is 1. Default delimiter '|' is replaced with %7C if found\nin any string\n"
  },
  "functions": {}
 },
 "db_mongodb": {
  "overview": "This module provides DB APIv1 connector for MongoDB NoSQL server.\n\nIt can be used as a replacement for other database modules such as\ndb_mysql, db_postgres, a.s.o. Not all the specs of DB APIv1 are\nimplemented, thus the usage of this module might be restricted to\nspecific modules.\n\nYou can read more about MongoDB at: <http://www.mongodb.org>.\n",
  "parameters": {},
  "functions": {}
 },
 "db_mysql": {
  "overview": "This is a module which provides MySQL connectivity for Kamailio. It\nimplements the DB API defined in Kamailio.\n",
  "parameters": {
   "ping_interval": "### `ping_interval` (integer)\n\nTime interval in seconds to send ping messages to MySQL server in order\nto keep the connection open.\n\n*Default value is 300 (5 min).*\n\n```\n...\nmodparam(\"db_mysql\", \"ping_interval\", 600)\n...\n```\n",
   "server_timezone": "### `server_timezone` (integer)\n\nControl if kamailio converts a time to string using the local timezone\nor if MySQL will convert it using FROM_UNIXTIME. This option is useful\nif kamailio and the database are configured for different timezones.\n\n*Default value is 0 (use local conversion)*\n\n```\n...\nmodparam(\"db_mysql\", \"server_timezone\", 1)\n...\n```\n",
   "timeout_interval": "### `timeout_interval` (integer)\n\nTime interval (in seconds) after that a connection attempt, read or\nwrite request is aborted. The value counts three times, as several\nretries are done from the driver before it gives up.\n\nThe read timeout parameter is ignored on MySQL driver versions prior to\n\u201c5.1.12\u201d, \u201c5.0.25\u201d and \u201c4.1.22\u201d. The write timeout parameter is ignored\non versions prior to \u201c5.1.12\u201d and \u201c5.0.25\u201d, the \u201c4.1\u201d release don't\nsupport it at all.\n\n*Default value is 2 (6 sec).*\n\n```\n...\nmodparam(\"db_mysql\", \"timeout_interval\", 2)\n...\n```\n",
   "auto_reconnect": "### `auto_reconnect` (integer)\n\nConfigure whether the module should automatically reconnect to MySQL\nserver if the connection was lost.\n\n*Default value is 1 (1 - on / 0 - off).*\n\n```\n...\nmodparam(\"db_mysql\", \"auto_reconnect\", 0)\n...\n```\n",
   "insert_delayed": "### `insert_delayed` (integer)\n\nIf set to 1, all INSERT SQL queries will be sent to MySQL server as\nINSERT DELAYED.\n\n*Default value is 0 (1 - on / 0 - off).*\n\n```\n...\nmodparam(\"db_mysql\", \"insert_delayed\", 1)\n...\n```\n",
   "update_affected_found": "### `update_affected_found` (integer)\n\nIf set to 1, all UPDATE SQL queries will return the number of matched\nrows instead of the number of \"updated\" rows.\n\n*Default value is 0 (1 - on / 0 - off).*\n\n```\n...\nmodparam(\"db_mysql\", \"update_affected_found\", 1)\n...\n```\n",
   "opt_ssl_mode": "### `opt_ssl_mode` (integer)\n\nControl how the connection to MySQL server is done in regards to\nSSL/TLS. If set to 1, SSL/TLS mode is disabled.\n\nThe 'include/mysql.h' starting with MySQL 5.7.11 defines the values for\nthis option as enum: 'mysql_ssl_mode { SSL_MODE_DISABLED=1,\nSSL_MODE_PREFERRED, SSL_MODE_REQUIRED, SSL_MODE_VERIFY_CA,\nSSL_MODE_VERIFY_IDENTITY}'.\n\nNote: if the value of this parameter is 1, it enforces\nSSL_MODE_DISABLED, any other value is passed to the mysql_options(), not\nchecking if it is defined.\n\nMariaDB client configuration uses the following values: 0, 1 use plain,\n2/3/4 for MYSQL_OPT_SSL_ENFORCE, 5 for MYSQL_OPT_SSL_VERIFY_SERVER_CERT\n(see MariaDB Connector/C documentation) Other values are ignored.\n\n*Default value is 0 (0 - off).*\n\n```\n...\nmodparam(\"db_mysql\", \"opt_ssl_mode\", 1)\n...\n```\n",
   "opt_ssl_ca": "### `opt_ssl_ca` (string)\n\nConfigures the CA certs used to verify the MySQL server cert when SSL is\nenabled.\n\nRequired when opt_ssl_mode = 4 or 5 and db_mysql is built with\nlibmysqlclient.\n\n*Default value is NULL (NULL - not configured).*\n\n```\n...\nmodparam(\"db_mysql\", \"opt_ssl_ca\", \"/etc/ssl/certs/mysql-ca.pem\")\n...\n```\n"
  },
  "functions": {}
 },
 "db_oracle": {
  "overview": "\n",
  "parameters": {},
  "functions": {}
 },
 "db_perlvdb": {
  "overview": "The Perl Virtual Database (VDB) provides a virtualization framework for\nKamailio's database access. It does not handle a particular database\nengine itself but lets the user relay database requests to arbitrary\nPerl functions.\n\nThis module cannot be used \"out of the box\". The user has to supply\nfunctionality dedicated to the client module. See below for options.\n\nThe module can be used in all current Kamailio modules that need\ndatabase access. Relaying of insert, update, query and delete operations\nis supported.\n\nModules can be configured to use the db_perlvdb module as database\nbackend using the db_url_parameter:\n\n```\nmodparam(\"acc\", \"db_url\", \"perlvdb:Kamailio::VDB::Adapter::AccountingSIPtrace\")\n```\n\nThis configuration options tells acc module that it should use the\ndb_perlvdb module which will in turn use the Perl class\nKamailio::VDB::Adapter::AccountingSIPtrace to relay the database\nrequests.\n",
  "parameters": {},
  "functions": {}
 },
 "db_postgres": {
  "overview": "The module is an implementation of the internal DB API v1 and v2\nconnector for PostgreSQL server. It has support for reconnecting when\nthe connection is broken.\n",
  "parameters": {
   "retries": "### `retries` (integer)\n\nHow many retries to attempt to reconnect if connection to Postgres\nserver becomes broken.\n\n*Default value is 2 (that means three attempts to submit the query,\nfirst will trigger the connection error and two more (the value of this\nparameter) after resetting the connection).*\n\n```\n...\nmodparam(\"db_postgres\", \"retries\", 3)\n...\n```\n",
   "timeout": "### `timeout` (integer)\n\nSetting this variable to any value larger than zero (which is the\ndefault value) enables mainly query timeout. For backward compatibility\nit also enables connection timeout if connect_timeout param is not set\nusing the con_param below. If a connection attempt or a query takes\nlonger than this many seconds, the operation will be aborted and an\nerror will be returned.\n\nNote that this timeout is applied to each underlying operation (i.e. for\neach connection attempt), so depending on circumstances and on the value\nof the \u201cretries\u201d variable, a single query from the SIP proxy's point of\nview can take longer than the \u201ctimeout\u201d.\n\n```\n...\nmodparam(\"db_postgres\", \"timeout\", 10)\n...\n```\n",
   "tcp_keepalive": "### `tcp_keepalive` (integer)\n\nEnable the TCP keepalive timer and set the number of seconds the\nconnection must be idle before to start sending keepalive packets.\nDefaults to zero, which disables TCP keepalive packets.\n\n*Only supported on platforms which understand and support the\n\u201cTCP_KEEPIDLE\u201d socket option.*\n\n```\n...\nmodparam(\"db_postgres\", \"tcp_keepalive\", 600)\n...\n```\n",
   "lockset": "### `lockset` (integer)\n\nThe value is used as power of two to compute the size of the lock set\nneeded to implement the equivalent of REPLACE SQL statement.\n\nDefault value is 4 (lock set size is 16).\n\n```\n...\nmodparam(\"db_postgres\", \"lockset\", 6)\n...\n```\n",
   "bytea_output_escape": "### `bytea_output_escape` (integer)\n\nControl if the module should request escaping the output for bytea\nfields.\n\nDefault value is 1 (do the escape).\n\n```\n...\nmodparam(\"db_postgres\", \"bytea_output_escape\", 0)\n...\n```\n",
   "con_param": "### `con_param` (str)\n\nSpecifies the connection string parameters. Parameter definition must be\nin the format param1=value1;param2=value2. Many parameters can be set.\n\nNOTE: See postgres connection keyword list\n(https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS)\n\n```\n...\nmodparam(\"db_postgres\", \"con_param\", \"connect_timeout=15;tcp_user_timeout=5000\")\n...\n```\n"
  },
  "functions": {}
 },
 "db_redis": {
  "overview": "This module provides a DB APIv1 connector for the Redis server\n(<https://www.redis.io>).\n\nIt can be used as a replacement for other database modules such as\ndb_mysql and db_postgres. Not all the specs of DB APIv1 are implemented,\nthus the usage of this module might be restricted to specific modules.\nAlso, for proper performance, this module needs particular configuration\ntailored to the modules that make use of it.\n\nSince Redis does not provide a schema by itself, db_redis ships with\nschema files. The path to these has to be defined using the module\nparameter \"schema_path\". The schema definition is defined in one file\nper table, such that the file name corresponds to the table name, and\neach file is composed of a comma-separated list of column definitions in\nthe format <column-name>/<type>[,<column-name>/<type> ...] in\none line, followed by a line holding the table version.\n\nExample definition for the \"location\" table (from the usrloc module):\n\n```\nusername/string,domain/string,contact/string,received/string,path/string,expires/timestamp,q/double,callid/string,cseq/int,last_modified/timestamp,flags/int,cflags/int,user_agent/string,socket/string,methods/int,ruid/string,reg_id/int,instance/string,server_id/int,connection_id/int,keepalive/int,partition/int\n8\n            \n```\n\nBecause Redis is a key-value store, it requires unique keys. This means\nthat tables and rows from a relational SQL database, e.g. from MySQL,\ncan not be ported one a 1:1 basis to Redis.\n\nFor instance, usrloc relies on a key of \"username@domain\", but in order\nto store multiple contacts per AoR, it cannot be constrained to\nuniqueness. To work around this, db_redis supports mapping sets in such\na way as to, in the case of the usrloc module, have a set with a key of\n\"username@domain\" and its entries being unique keys per contact based on\nthe ruid of a contact. Thus, one contact in usrloc consists of a unique\nkey \"location:entry::example-ruid-1\" being a hash with the columns like\nusername, domain, contact, path etc. In addition, this unique key is\nstored in a set \"location:usrdom::exampleuser:exampledomain.org\". When\nusrloc does a lookup based on \"username@domain\", db_redis figures out\nvia the keys/values the query constructed by usrloc to look for the\nfinal entry key in the mapping set first. It then query the actual\nentries from there, avoiding full table scans. For usrloc, the same\nholds true for expired contacts, requiring a different kind of mapping.\nThere is a certain balance of read performance vs. write performance to\nconsider, because inserts and deletes also have to maintain the\nmappings, though this yields much faster selects. The mappings can be\nfreely defined, so even though other kamailio modules don't require a\nspecific mapping to be in place for proper performance, mappings could\nbe defined for external applications to read faster (for instance\nletting the acc module also write mappings besides the actual records\nfor billing systems to correlate start and stop records faster).\n\nThe key is always prefixed with 'tablename:entry::'. For example the\nrecord in 'subscriber' table for user 'alice@sip.com' has the key:\n'subscriber:entry::alice:sip.com'. If all the records are just loaded at\nstartup (or all reloaded at runtime), the key can just be made unique\nusing whatever values added after 'tablename:entry::' prefix. For\nexample, keys for 'address' table records can be: 'address:entry::1',\naddress:entry::2', address:entry::3', ... No 'keys' modparam of\n'db_redis' for 'address' table needs to be defined.\n\nImportant Note: at this moment the module requires at least one 'keys'\nparameter, but it does not need to be related to the table loaded from\nRedis server -- for example, if used only for permissions module with\n'address' table, then the 'keys' parameter can be specified for\n'version' table. However, if it used for a module that inserts or\nupdates the records in database table, the key for entry must be defined\nfor that table.\n\nThe mappings can be freely defined in the \"keys\" module parameter, which\nis composed of a semi-colon separated list of definitions in the format\n<table-name>=<entry>:<column-name>[&<map-name>:<column-name>,<column-name>...].\nEach table must at least have an \"entry\" key for db_redis to be able to\nstore data.\n\nExample:\n\n```\nlocation=entry:ruid&usrdom:username,domain&timer:partition,keepalive;acc=entry:callid,time_hires&cid:callid\n            \n```\n\nFor readability purposes, definitions of keys per table can span\nmultiple Kamailio config lines by providing multiple \"keys\" modparams.\n",
  "parameters": {
   "schema_path": "### `schema_path` (string)\n\nThe path to the table schemas.\n\nDefault value: \"/usr/share/kamailio/db_redis\".\n\n```\n...\nmodparam(\"db_redis\", \"schema_path\", \"/usr/local/share/kamailio/db_redis/kamailio\")\n...\n                \n```\n",
   "keys": "### `keys` (string)\n\nThe entry and mapping keys of tables.\n\nDefault value: \"\" (empty).\n\n```\n...\nmodparam(\"db_redis\", \"keys\", \"version=entry:table_name;location=entry:ruid&usrdom:username,domain&timer:partition,keepalive\")\n...\n                \n```\n",
   "verbosity": "### `verbosity` (int)\n\nControl the verbosity of debug messages printed by the module. If set to\n1, the module prints schema details for all tables on each connect\noperation to Redis server.\n\nDefault value: 1.\n\n```\n...\nmodparam(\"db_redis\", \"verbosity\", 0)\n...\n                \n```\n",
   "opt_tls": "### `opt_tls` (int)\n\nControls TLS usage while connecting to a remote DB. If set to 1, TLS is\nused to connect to the DB.\n\nDefault value: 0.\n\n```\n...\nmodparam(\"db_redis\", \"opt_tls\", 1)\n...\n                \n```\n",
   "db_pass": "### `db_pass` (string)\n\nSets the password to connect to the DB.\n\nDefault value: \"\" (empty).\n\n```\n...\nmodparam(\"db_redis\", \"db_pass\", \"r3d1sPass\")\n...\n                \n```\n",
   "ac_path": "### `ac_path` (string)\n\nSets the path where Certificates Authorities certs are stored.\n\nDefault value: \"\" (empty).\n\n```\n...\nmodparam(\"db_redis\", \"ca_path\", \"/etc/ssl/certs\")\n...\n                \n```\n"
  },
  "functions": {}
 },
 "db_sqlite": {
  "overview": "The module is an implementation of the internal DB API v1 connector for\nSQlite 3 file.\n",
  "parameters": {
   "db_set_readonly": "### `db_set_readonly` (string)\n\nThis will set the db connection to \"SQLITE_OPEN_READONLY\", useful if\nanother program is writing to the DB. The value is the full path to the\nsqlite file used for example in any db_url or sqlops/sqlcon This\nparameter may be set multiple times to set many DB connections to\nreadonly in the same configuration file.\n\n*By default all the db connections are using \"SQLITE_OPEN_READWRITE |\nSQLITE_OPEN_CREATE\"*\n\n```\n...\nmodparam(\"db_sqlite\",\"db_set_readonly\",\"/var/mydb.sqlite\")\nmodparam(\"sqlops\",\"sqlcon\",\"lrn=>sqlite:////var/mydb.sqlite\") # Example if using the sqlops module\n...\n        \n```\n",
   "db_set_journal_mode": "### `db_set_journal_mode` (string)\n\nThis will set the db connection journal mode, for the given connection.\nThe value is the full path to the sqlite file used for example in any\ndb_url or sqlops/sqlcon Other journal mode are : DELETE | TRUNCATE |\nPERSIST | MEMORY | WAL | OFF This parameter may be set multiple times\nto set many DB connections to readonly in the same configuration file.\n\n*By default all the db connections are using sqlite default journaling\nmode.*\n\n```\n...\n# In this example we are using Write-Ahead Logging in order to update the database from another process(external to Kamailio) without facing any locking.\n\n#!subst \"!DB_FILE!/var/mydb.sqlite!\"\nmodparam(\"db_sqlite\",\"db_set_readonly\",\"DB_FILE\")   # We are also opening the database in readonly\nmodparam(\"db_sqlite\",\"db_set_journal_mode\",\"DB_FILE=WAL;\")\nmodparam(\"sqlops\",\"sqlcon\",\"lrn=>sqlite:///DB_FILE\")\n...\n        \n```\n"
  },
  "functions": {}
 },
 "db_text": {
  "overview": "The module implements a simplified database engine based on text files.\nIt can be used by Kamailio DB interface instead of other database module\n(like MySQL).\n\nThe module is meant for use in demos or small devices that do not\nsupport other DB modules. It keeps everything in memory and if you deal\nwith large amount of data you may run out of memory quickly. Also, it\ndoes not implement all standard database facilities (like order by), it\nincludes minimal functionality to work properly (who knows ?!?) with\nKamailio.\n\nNOTE: the timestamp is printed in an integer value from time_t\nstructure. If you use it in a system that cannot do this conversion, it\nwill fail (support for such situation is in to-do list).\n\nNOTE: even when db_text is in non-caching mode, the module does not\nwrite back to hard drive after changes. In this mode, the module checks\nif the corresponding file on disk has changed, and reloads it. The write\nto disk happens at Kamailio shut down. If db_text is in caching mode,\nmany \"reload\" functions in various modules will not work.\n",
  "parameters": {
   "db_mode": "### `db_mode` (integer)\n\nSet caching mode (0) or non-caching mode (1). In caching mode, data is\nloaded at startup. In non-caching mode, the module checks every time a\ntable is requested whether the corresponding file on disk has changed,\nand if yes, will re-load the table from file.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"db_text\", \"db_mode\", 1)\n...\n```\n",
   "db_delim": "### `db_delim` (string)\n\nSet the delimiter inside the db_text file.\n\n*Default value is \u201c:\u201d.*\n\n```\n...\nmodparam(\"db_text\", \"db_delim\", \"|\")\n...\n```\n",
   "default_connection": "### `default_connection` (string)\n\nconnection for use with rpc query command.\n\n*Default value is \u201cnone\u201d (off).*\n\n```\n                    ...\n                    modparam(\"db_text\", \"default_connection\", \"text:///var/db/kamailio/dbtext\")\n                    ...\n                \n```\n",
   "emptystring": "### `emptystring` (integer)\n\ndb_text by default handles an empty string as a NULL value. Some\nmodules, like the dialplan module, does not accept NULL strings. If you\nenable emptystring an empty string will not be NULL, but an empty\nstring.\n\n*Default value is \u201c0\u201d (off).*\n\n```\n...\nmodparam(\"db_text\", \"emptystring\", 1)\n...\n```\n",
   "file_buffer_size": "### `file_buffer_size` (integer)\n\nsize of the buffer used to read the text file. Some presence tables have\ncolumns with large content.\n\n*Default value is \u201c16384\u201d.*\n\n```\n...\nmodparam(\"db_text\", \"file_buffer_size\", 8192)\n...\n```\n",
   "max_result_rows": "### `max_result_rows` (integer)\n\nnumber of rows to read from the text file.\n\n*Default value is \u201c100000\u201d.*\n\n```\n...\nmodparam(\"db_text\", \"max_result_rows\", 1000000)\n...\n```\n"
  },
  "functions": {}
 },
 "db_unixodbc": {
  "overview": "This module allows to use the unixodbc package with Kamailio. It have\nbeen tested with mysql and the odbc connector, but it should work also\nwith other database. The auth_db module works.\n\nFor more information, see the <http://www.unixodbc.org/> project web\npage.\n\nTo see what DB engines can be used via unixodbc, look at\n<http://www.unixodbc.org/drivers.html>.\n",
  "parameters": {
   "ping_interval": "### `ping_interval` (int)\n\nSets the ping time interval.\n\n*Default value is \u201c300\u201d seconds.*\n\n```\n...\nmodparam(\"db_unixodbc\", \"ping_interval\", 600)\n...\n```\n",
   "auto_reconnect": "### `auto_reconnect` (int)\n\nTurns on or off the auto_reconnect mode.\n\n*Default value is \u201c1\u201d, this means it is enabled.*\n\n```\n...\nmodparam(\"db_unixodbc\", \"auto_reconnect\", 0)\n...\n```\n",
   "use_escape_common": "### `use_escape_common` (int)\n\nEscape values in query using internal escape_common() function. It\nescapes single quote ''', double quote '\"', backslash '\\, and NULL\ncharacters.\n\nYou should enable this parameter if you know that the ODBC driver\nconsiders the above characters as special (for marking begin and end of\na value, escape other characters ...). It prevents against SQL\ninjection.\n\n*Default value is \u201c0\u201d (0 = disabled; 1 = enabled).*\n\n```\n...\nmodparam(\"db_unixodbc\", \"use_escape_common\", 1)\n...\n```\n",
   "replace_query": "### `replace_query` (int)\n\nTells if the ODBC replace query is supported by the DB odbc driver.\n\n*Default value is \u201c1\u201d seconds.*\n\n```\n...\nmodparam(\"db_unixodbc\", \"replace_query\", 0)\n...\n```\n",
   "quote_char": "### `quote_char` (str)\n\nThe character to be used for quoting the table and column names in\ndatabase queries.\n\n*Default value: \u201cnot set\u201d (no quoting).*\n\n```\n...\nmodparam(\"db_unixodbc\", \"quote_char\", \"`\")\n...\n```\n"
  },
  "functions": {}
 },
 "debugger": {
  "overview": "This module provides an interactive config file debugger. It can print a\ntrace of config script execution for a SIP message to log and set\nbreakpoints on every script action, allowing step-by-step execution of\nthe routing and response scripts. Moreover, this module allows setting\nstatic and dynamic module specific debug settings.\n\nDebugging can be done from local or remote host via RPC interface (e.g.,\nXMLRPC, kamcmd, siremis).\n\nThe framework to set breakpoints on specific actions and config lines is\nnot exported to RPC. Each action can be accompanied by a breakpoint or\nyou can use dbg_breakpoint() function to set a breakpoint at certain\nline. Global breakpoints can be enabled/disabled at runtime. The script\nrunning trace can also be enabled/disabled at runtime.\n\nWhen the SIP router process is stopped at a breakpoint, you can\ninvestigate the values of any pseudo-variables. Note that some of\npseudo-variables may produce memory leaks; a fix is planned in the\nfuture (here fall pseudo-variables with dynamic name such as htable,\nsqlops). References to SIP message, avps, headers, script and shared\nvariables are safe.\n",
  "parameters": {
   "cfgtrace": "### `cfgtrace` (int)\n\nControl whether the config script trace is enabled or disabled at\nstartup. You can change the value at runtime without restart, globally\nor per process.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"debugger\", \"cfgtrace\", 1)\n...\n```\n",
   "cfgtrace_format": "### `cfgtrace_format` (int)\n\nControl what is printer in the cfgtrace log message. If it is set to 1,\nthen the configuration file path is not printed, making the log messages\nshorter when not including other configuration files in the main one.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"debugger\", \"cfgtrace_format\", 1)\n...\n```\n",
   "breakpoint": "### `breakpoint` (int)\n\nControl whether every line (global) breakpoint is enabled or disabled at\nstartup.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"debugger\", \"breakpoint\", 1)\n...\n```\n",
   "log_level": "### `log_level` (int)\n\nWhat log level is to be used to print module-specific messages.\n\n*Default value is \u201c-1\u201d (L_ERR).*\n\n```\n...\nmodparam(\"debugger\", \"log_level\", 1)\n...\n```\n",
   "log_level_name": "### `log_level_name` (str)\n\nWhat log level name is to be used to print cfg trace messages.\n\n*Default value is \u201cNULL\u201d (use default log names).*\n\n```\n...\nmodparam(\"debugger\", \"log_level_name\", \"exec\")\n...\n```\n",
   "log_facility": "### `log_facility` (str)\n\nWhich log facility is to be used to print module-specific messages. By\nusing this setting, you can configure syslog to send debug messages to a\nseparate log channel, like a specific kamailio-debug log file.\n\n*Default value is \u201cNULL\u201d (default from core).*\n\n```\n...\nmodparam(\"debugger\", \"log_facility\", \"LOG_DAEMON\")\n...\n```\n",
   "log_prefix": "### `log_prefix` (str)\n\nString to print before any module-specific messages.\n\n*Default value is \u201c\\*** cfgtrace:\u201d.*\n\n```\n...\nmodparam(\"debugger\", \"log_prefix\", \"from-debugger-with-love:\")\n...\n```\n",
   "step_usleep": "### `step_usleep` (int)\n\nMicroseconds to sleep before checking for new commands when waiting at a\nbreakpoint.\n\n*Default value is \u201c100000\u201d (that is 0.1 sec).*\n\n```\n...\nmodparam(\"debugger\", \"step_usleep\", 500000)\n...\n```\n",
   "step_loops": "### `step_loops` (int)\n\nHow many sleeps of 'step_usleep' the RPC process performs when waiting\nfor a reply from a worker process before responding to RPC. This avoids\nblocking RPC process forever in case the worker process 'forgets' to\nwrite back a reply.\n\n*Default value is \u201c200\u201d.*\n\n```\n...\nmodparam(\"debugger\", \"step_loops\", 100)\n...\n```\n",
   "mod_hash_size": "### `mod_hash_size` (int)\n\nUsed to compute power of two as size of internal hash table to store\nlevels per module (e.g., if it is set to 4, internal hash table has 16\nslots). One must set its value grater than 0 such that memory to be\nallocated to save the module specific debug levels or facility\nconfigured by `mod_level` or `mod_facility`. This parameter is\naccessible readonly via the Kamailio config framework.\n\n*Default value is \u201c0\u201d - feature disabled.*\n\n```\n...\nmodparam(\"debugger\", \"mod_hash_size\", 5)\n...\n```\n",
   "mod_level_mode": "### `mod_level_mode` (int)\n\nEnable or disable per module log level (0 - disabled, 1 - enabled). This\nparameter is tunable via the Kamailio config framework. To use per\nmodule log level you also have to set `mod_hash_size`.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"debugger\", \"mod_level_mode\", 1)\n...\n```\n",
   "mod_level": "### `mod_level` (str)\n\nSpecify module log level - the value must be in the format:\nmodulename=level. The parameter can be set many times. For core log\nlevel, use module name 'core'. You also must enable `mod_level_mode` and\n`mod_hash_size`.\n\n```\n...\nmodparam(\"debugger\", \"mod_level\", \"core=3\")\nmodparam(\"debugger\", \"mod_level\", \"tm=3\")\n...\n```\n",
   "mod_facility_mode": "### `mod_facility_mode` (int)\n\nEnable or disable per module log facility (0 - disabled, 1 - enabled).\nThis parameter is tunable via the Kamailio config framework. To use per\nmodule log facility you also have to set `mod_hash_size`.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"debugger\", \"mod_facility_mode\", 1)\n...\n        \n```\n",
   "mod_facility": "### `mod_facility` (str)\n\nSpecify module log facility - the value must be in the format:\nmodulename=facility. The parameter can be set many times. For core log\nfacility, use module name 'core'. You also must enable\n`mod_facility_mode` and `mod_hash_size`.\n\nNOTE: See the *syslog()* library call for facility names\n(http://linux.die.net/man/3/syslog). The most used facilities are\nLOG_LOCAL[0-7].\n\n```\n...\nmodparam(\"debugger\", \"mod_facility\", \"core=LOG_LOCAL0\")\nmodparam(\"debugger\", \"mod_facility\", \"debugger=LOG_LOCAL1\")\n...\n        \n```\n",
   "log_assign": "### `log_assign` (int)\n\nEnable or disable log assign actions on config (0 - disabled, 1 -\nenabled).\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"debugger\", \"log_assign\", 1)\n...\n```\n",
   "cfgpkgcheck": "### `cfgpkgcheck` (int)\n\nIf set, before each config action is done pkg memory check, useful to\ndetect buffer overflows.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"debugger\", \"cfgpkgcheck\", 1)\n...\n```\n",
   "reset_msgid": "### `reset_msgid` (int)\n\nUsed to enable or disable the ability to reset the msgid ($mi) through\nthe dbg.reset_msgid RPC command. (0 - disabled, 1 - enabled).\n\n*Default value is \u201c0\u201d - feature disabled.*\n\n```\n...\nmodparam(\"debugger\", \"reset_msgid\", 1)\n...\n```\n",
   "cfgtest": "### `cfgtest` (int)\n\nControl whether the cfgt module is enabled or disabled at startup.\nModule cfgt needs to be loaded before.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nloadmodule \"cfgt.so\"\nmodparam(\"debugger\", \"cfgtest\", 1)\n...\n```\n"
  },
  "functions": {
   "dbg_breakpoint": "### `dbg_breakpoint(mode)`\n\nAnchor a breakpoint at the current line of the config (the one on which\nthis function is called). The 'mode' specifies whether the breakpoint is\nenabled (1) or disabled (0) at startup.\n\nNote that this version of the module does not export this anchors to RPC\nfor interactive debugging (temporarily disabled).\n\n```\n...\nif($si==\"10.0.0.10\")\n    dbg_breakpoint(\"1\");\n...\n```\n",
   "dbg_pv_dump": "### `dbg_pv_dump([mask] [, level])`\n\nPrints the content of pv_cache on json format. Defaults are mask=31 and\nlevel = \"L_DBG\"\n\n<!-- -->\n\n\n```\n...\n$var(temp) = 1;\n$avp(s:more_avp) = 2;\n$avp(s:more_avp) = 3;\n$xavp(x=>more) = \"bye\";\n$xavp(x[0]=>more) = \"hi\";\n$xavp(x[0]=>other) = 1;\n$xavp(x[0]=>other) = 2;\n$xavp(x=>different) = \"foo\";\n$var(empty) = $null;\n\ndbg_pv_dump(30, \"L_DBG\");\n...\n```\n\nOutput\n\n```\n...\n 4(30943) DEBUG: debugger [debugger_api.c:1613]: dbg_dump_json(): {\"$sp\":37597,\"$var(rc)\":0,\"$var(temp)\":1,\"$avp(more_avp)\":[3,2],\"$si\":\"127.0.0.1\",\"$rc\":0,\"$xavp(x)\":[{\"different\":[\"foo\"]},{\"other\":[2,1],\"more\":[\"hi\",\"bye\"]}],\"$T_branch_idx\":0,\"$var(empty)\":0}\n ...\n```\n",
   "dbg_sip_msg": "### `dbg_sip_msg([log_level], [facility])`\n\nPrints how the sip message *would look* like if it *would be sent* out\nat that point in the config(i.e. if the current lump lists would have\nbeen applied at that point in the config). It also prints a diff list\nfor both header and body of sip msg which contain the lump lists\ncontent. The lumps deleted are printed with \"-\" sign whereas the lumps\nadded have no sign. The config line where the function has been called\nis also printed.\n\nNOTE that dbg_sip_msg function does not modify the initially received\nSIP message. Just displays how it WOULD look like if it were to send it\nat that point.\n\nNOTE that the lump lists are usually applied only once, just before\nsending, to spare message reparse processing. All the changes present in\nlump list are applied on the *initially received* SIP message. One can\nforce the lump application using msg_apply_changes() function from\ntextopsx module.\n\n```\n...\n    dbg_sip_msg();\n    dbg_sip_msg(\"L_ERR\");\n    dbg_sip_msg(\"L_ERR\", \"LOG_LOCAL0\");\n...\n        \n```\n\nOutput when dbg_sip_msg(\"L_ERR\") is called after *append_hf(\"P-Hint: My\nhint\\r\\n\"); remove_hf(\"Contact\");*\n\n```\nERROR: debugger [debugger_mod.c:467]: w_dbg_sip_msg(): CONFIG LINE 338\n------------------------- START OF SIP message debug --------------------------\nOPTIONS sip:nobody@127.0.0.1 SIP/2.0\nVia: SIP/2.0/UDP 127.0.1.1:56872;branch=z9hG4bK.6d7c487a;rport;alias\nFrom: sip:sipsak@127.0.1.1:56872;tag=188b7433\nTo: sip:nobody@127.0.0.1\nCall-ID: 411792435@127.0.1.1\nCSeq: 1 OPTIONS\nContent-Length: 0\nMax-Forwards: 70\nUser-Agent: sipsak 0.9.6\nAccept: text/plain\nP-Hint: My hintt\n\n------------------------------ SIP header diffs -------------------------------\n- Contact: sip:sipsak@127.0.1.1:56872\nP-Hint: My hint\n------------------------------- SIP body diffs --------------------------------\n-------------------------- END OF SIP message debug ---------------------------\n        \n```\n"
  }
 },
 "dialog": {
  "overview": "Kamailio can behave as a stateful proxy through the TM module. However,\n\"stateful\" in this context refers to *transaction* state, not dialog\nstate. Certain applications may benefit from an awareness of \"calls\" in\nthe proxy, not just SIP transactions.\n\nFor example, a common need is to limit the number of calls that can be\nmade concurrently by an endpoint, account, user group, etc. In order to\ncount the number of calls in progress, it is necessary for the proxy to\nbe aware of whole dialogs, not just transactions, and to provide some\nmeans of programmatically classifying these dialogs. This is just one\ncommon application discussed for illustrative purposes; there are many\nothers.\n\nThe dialog module provides dialog awareness for the Kamailio proxy. Its\nfunctionality is to keep track of the current dialogs, to offer\ninformation about them (e.g. how many dialogs are active), and to manage\nvarious characteristics of dialogs. The module exports several functions\nthat can be used directly from the configuration route script as well as\nfunctions for the RPC interface.\n\nThis module also provides an API foundation on which to build more\ncomplex dialog-oriented functionality in other Kamailio modules.\n",
  "parameters": {
   "enable_stats": "### `enable_stats` (integer)\n\nIf statistics support should be enabled or not. Via statistics\nvariables, the module provides information about the dialog processing.\nSet it to zero to disable or to non-zero to enable it.\n\n*Default value is \u201c1 (enabled)\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"enable_stats\", 0)\n...\n```\n",
   "hash_size": "### `hash_size` (integer)\n\nThe size of the hash table internally used to keep the dialogs. A larger\ntable is much faster but consumes more memory. The hash size must be a\npower of two.\n\nIMPORTANT: If dialog information should be stored in a database, a\nconstant hash_size should be used, otherwise the restoring process will\nnot take place. If you really want to modify the hash_size, you must\ndelete all table's rows before restarting the server.\n\n*Default value is \u201c4096\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"hash_size\", 1024)\n...\n```\n",
   "rr_param": "### `rr_param` (string)\n\nName of the Record-Route parameter used to store the dialog cookie. It\nis used for the fast matching of sequential requests to tracked dialogs.\n\n*Default value is \u201cdid\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"rr_param\", \"xyz\")\n...\n```\n",
   "dlg_flag": "### `dlg_flag` (integer)\n\nFlag to be used for marking if a dialog should be constructed for the\ncurrent request (this makes sense only for initial requests).\n\nNote: it is not needed to set this parameter and its corresponding flag\nfor initial request in case the \u201cdlg_manage()\u201d function is used. In\nother words, using \u201cdlg_manage()\u201d alone is enough.\n\n*Default value is \u201cnone\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_flag\", 4)\n...\n```\n",
   "timeout_avp": "### `timeout_avp` (string)\n\nThe specification of an AVP that contains a custom timeout value (in\nseconds) for the dialog. It may be used only in a request (initial or\nsequential) context.\n\n*Default value is \u201cnone\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"timeout_avp\", \"$avp(i:10)\")\n...\n```\n",
   "default_timeout": "### `default_timeout` (integer)\n\nThe default dialog timeout (in seconds), in the absence of a custom\nvalue provided in an AVP.\n\n*Default value is \u201c43200 (12 hours)\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"default_timeout\", 21600)\n...\n```\n",
   "early_timeout": "### `early_timeout` (integer)\n\nThe timeout (in seconds) after which the dialogs in unconfirmed or early\nstate (no final response received) are destroyed.\n\n*Default value is \u201c300 (5 minutes)\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"early_timeout\", 180)\n...\n```\n",
   "noack_timeout": "### `noack_timeout` (integer)\n\nThe timeout (in seconds) after which the dialogs which were answered\nwith 200 OK but didn't receive the ACK are marked for termination (the\nlifetime is set to 10 more seconds).\n\n*Default value is \u201c60 (1 minute)\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"noack_timeout\", 90)\n...\n```\n",
   "end_timeout": "### `end_timeout` (integer)\n\nThe timeout (in seconds) after which the dialogs in terminated state are\ndestroyed.\n\n*Default value is \u201c300 (5 minutes)\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"end_timeout\", 180)\n...\n```\n",
   "dlg_extra_hdrs": "### `dlg_extra_hdrs` (string)\n\nA string containing the extra headers (full format, with EOH) to be\nadded to requests generated locally by the module (like BYEs).\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_extra_hdrs\", \"Hint: credit expired\\r\\n\")\n...\n```\n",
   "dlg_match_mode": "### `dlg_match_mode` (integer)\n\nHow the sequential requests should be matched against the known dialogs.\nThe modes are a combination of matching based on a cookie (DID) stored\nas cookie in Record-Route header and matching based on SIP elements (as\nin RFC 3261).\n\nNote: DID-based matching does not replace callid/fromtag/totag\ncomparison. It will speed up dialog matching by not iterating over the\nwhole dialog list for callid/fromtag/totag comparison, but instead it\nuses a hash table to find the respective dialog and then doing only one\ncallid/fromtag/totag comparison. Thus, there is no security issue when\nusing DID based matching. Use DID_FALLBACK for maximum interoperability\nor use DID_ONLY to reject buggy clients or hacking attempts. DID_NONE is\nonly useful, when you want to hide dialog-tracking from the users\n(preventing the DID Record-Route cookie).\n\nThe supported modes are:\n\n- *0 - DID_ONLY* - the match is done exclusively based on DID;\n\n- *1 - DID_FALLBACK* - the match is first tried based on DID and if not\n  present, it will fall back to SIP matching;\n\n- *2 - DID_NONE* - the match is done exclusively based on SIP elements;\n  no DID information is added in RR.\n\n*Default value is \u201c0 (DID_ONLY)\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_match_mode\", 1)\n...\n```\n",
   "detect_spirals": "### `detect_spirals` (integer)\n\nWhether spirals (i.e., messages routed through the proxy multiple times)\nshould be detected.\n\nIf set to 0, spirals will not be detected and result in the generation\nof a new, possibly dangling dialog structure per occurring spiral. If\nset to 1, spirals are detected and internally mapped to existing dialog\nstructures.\n\nDefault value is 1.\n\n```\n...\nmodparam(\"dialog\", \"detect_spirals\", 1)\n...\n            \n```\n",
   "db_url": "### `db_url` (string)\n\nIn order to store information about dialogs in a database, a database\nURL must be specified.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_mode": "### `db_mode` (integer)\n\nMode of synchronisation of dialog information from memory to an\nunderlying database (if desired):\n\nThe supported modes are:\n\n- *0 - NO_DB* - the memory content is not flushed into DB;\n\n- *1 - REALTIME* - any dialog information changes will be reflected into\n  the database immediately.\n\n- *2 - DELAYED* - the dialog information changes will be flushed into DB\n  periodically, based on a timer routine.\n\n- *3 - SHUTDOWN* - the dialog information will be flushed into DB only\n  at shutdown - no runtime updates.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"db_mode\", 1)\n...\n```\n",
   "db_update_period": "### `db_update_period` (integer)\n\nThe interval (seconds) at which to update dialogs' information, if the\nserver is configured to store the dialog information at a given\ninterval. A too short interval will generate intensive database\noperations, while an excessively long one will miss dialogs with a short\nlifetime.\n\n*Default value is \u201c60\u201d seconds.*\n\n```\n...\nmodparam(\"dialog\", \"db_update_period\", 120)\n...\n```\n",
   "db_fetch_rows": "### `db_fetch_rows` (integer)\n\nThe number of the rows to be fetched at once from database when loading\nthe dialog records at startup from the database. This value can be used\nto tune the load time at startup. For 1MB of private memory (default),\nit should be below 400. The database driver must support the\nfetch_result() capability. A value of 0 means the database fetch is not\nlimited.\n\n*Default value is \u201c200\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"db_fetch_rows\", 500)\n...\n```\n",
   "db_skip_load": "### `db_skip_load` (integer)\n\nSet db_skip_load to 1, to skip the loading of dialog data from the\ndatabase.\n\n*Default value is \u201c0\u201d ( not skipped ).*\n\n```\n...\nmodparam(\"dialog\", \"db_skip_load\", 1)\n...\n```\n",
   "table_name": "### `table_name` (string)\n\nDatabase table name used for storing dialog information.\n\n*Default value is \u201cdialog\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"table_name\", \"my_dialog\")\n...\n```\n",
   "call_id_column": "### `call_id_column` (string)\n\nThe column name in the database to store the dialog call-id.\n\n*Default value is \u201ccallid\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"call_id_column\", \"callid_c_name\")\n...\n```\n",
   "from_uri_column": "### `from_uri_column` (string)\n\nThe column name in the database to store the caller's SIP address (URI).\n\n*Default value is \u201cfrom_uri\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"from_uri_column\", \"from_uri_c_name\")\n...\n```\n",
   "from_tag_column": "### `from_tag_column` (string)\n\nThe column name in the database to store the From header tag from the\nINVITE request.\n\n*Default value is \u201cfrom_tag\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"from_tag_column\", \"from_tag_c_name\")\n...\n```\n",
   "to_uri_column": "### `to_uri_column` (string)\n\nThe column name in the database to store the callee's SIP address (URI).\n\n*Default value is \u201cto_uri\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"to_uri_column\", \"to_uri_c_name\")\n...\n```\n",
   "to_tag_column": "### `to_tag_column` (string)\n\nThe column name in the database to store the To header tag from the 200\nOK response to the INVITE request, if present.\n\n*Default value is \u201cto_tag\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"to_tag_column\", \"to_tag_c_name\")\n...\n```\n",
   "from_cseq_column": "### `from_cseq_column` (string)\n\nThe column name in the database to store the Cseq from caller side.\n\n*Default value is \u201ccaller_cseq\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"from_cseq_column\", \"from_cseq\")\n...\n```\n",
   "to_cseq_column": "### `to_cseq_column` (string)\n\nThe column name in the database to store the cseq from callee side.\n\n*Default value is \u201ccallee_cseq\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"to_cseq_column\", \"to_cseq\")\n...\n```\n",
   "from_route_column": "### `from_route_column` (string)\n\nThe column name in the database to store the route records from caller\nside (proxy to caller).\n\n*Default value is \u201ccaller_route_set\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"from_route_column\", \"rroute_from\")\n...\n```\n",
   "to_route_column": "### `to_route_column` (string)\n\nThe column name in the database to store the route records from callee\nside (proxy to callee).\n\n*Default value is \u201ccallee_route_set\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"to_route_column\", \"rroute_to\")\n...\n```\n",
   "from_contact_column": "### `from_contact_column` (string)\n\nThe column name in the database to store the caller's contact uri.\n\n*Default value is \u201ccaller_contact\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"from_contact_column\", \"from_contact_uri\")\n...\n```\n",
   "to_contact_column": "### `to_contact_column` (string)\n\nThe column name in the database to store the callee's contact uri.\n\n*Default value is \u201ccallee_contact\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"to_contact_column\", \"to_contact_uri\")\n...\n```\n",
   "from_sock_column": "### `from_sock_column` (string)\n\nThe column name in the database to store the information about the local\ninterface receiving the traffic from caller.\n\n*Default value is \u201ccaller_sock\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"from_sock_column\", \"socket_from\")\n...\n```\n",
   "to_sock_column": "### `to_sock_column` (string)\n\nThe column name in the database to store information about the local\ninterface receiving the traffic from callee.\n\n*Default value is \u201ccallee_sock\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"to_sock_column\", \"socket_to\")\n...\n```\n",
   "h_id_column": "### `h_id_column` (string)\n\nThe column name in the database to store the dialogs' hash id\ninformation.\n\n*Default value is \u201chash_id\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"h_id_column\", \"hash_id_c_name\")\n...\n```\n",
   "h_entry_column": "### `h_entry_column` (string)\n\nThe column name in the database to store the dialog's hash entry\ninformation.\n\n*Default value is \u201chash_entry\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"h_entry_column\", \"h_entry_c_name\")\n...\n```\n",
   "state_column": "### `state_column` (string)\n\nThe column name in the database to store the dialog's state information.\n\n*Default value is \u201cstate\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"state_column\", \"state_c_name\")\n...\n```\n",
   "start_time_column": "### `start_time_column` (string)\n\nThe column name in the database to store the dialog's start time\ninformation.\n\n*Default value is \u201cstart_time\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"start_time_column\", \"start_time_c_name\")\n...\n```\n",
   "timeout_column": "### `timeout_column` (string)\n\nThe column name in the database to store the dialog's timeout.\n\n*Default value is \u201ctimeout\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"timeout_column\", \"timeout_c_name\")\n...\n```\n",
   "sflags_column": "### `sflags_column` (string)\n\nThe column name in the database to store the dialog script flags.\n\n*Default value is \u201csflags\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"sflags_column\", \"s_flags\")\n...\n```\n",
   "toroute_name_column": "### `toroute_name_column` (string)\n\nThe column name in the database to store the index of the route to be\nexecuted at timeout.\n\n*Default value is \u201ctoroute_name\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"toroute_name_column\", \"timeout_route\")\n...\n```\n",
   "vars_table_name": "### `vars_table_name` (string)\n\nIf you want to store the dialog variables (\u201c$dlg_var(name)\u201d) for a\ndialog in a database a table name must be specified.\n\n*Default value is \u201cdialog_vars\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"vars_table_name\", \"my_dialog_vars\")\n...\n```\n",
   "vars_h_id_column": "### `vars_h_id_column` (string)\n\nThe column name in the database to store the dialog's hash id\ninformation (as a reference to the dialog table).\n\n*Default value is \u201chash_id\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"vars_h_id_column\", \"vars_h_id_name\")\n...\n```\n",
   "vars_h_entry_column": "### `vars_h_entry_column` (string)\n\nThe column name in the database to store the dialog's hash entry\ninformation (as a reference to the dialog table).\n\n*Default value is \u201chash_entry\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"vars_h_entry_column\", \"vars_h_entry_name\")\n...\n```\n",
   "vars_key_column": "### `vars_key_column` (string)\n\nThe column name in the database to store the names (keys) of a dialog\nvariable.\n\n*Default value is \u201cdialog_key\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"vars_key_column\", \"vars_key_name\")\n...\n```\n",
   "vars_value_column": "### `vars_value_column` (string)\n\nThe column name in the database to store the values of a dialog\nvariable.\n\n*Default value is \u201cdialog_value\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"vars_value_column\", \"vars_value_name\")\n...\n```\n",
   "profiles_with_value": "### `profiles_with_value` (string)\n\nList of names for profiles with values, separated with semi-colon \";\".\n\n*Default value is \u201cempty\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"profiles_with_value\", \"caller ; my_profile\")\n...\n```\n",
   "profiles_no_value": "### `profiles_no_value` (string)\n\nList of names for profiles without values, separated with semi-colon\n\";\".\n\n*Default value is \u201cempty\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"profiles_no_value\", \"inbound ; outbound\")\n...\n```\n",
   "bridge_controller": "### `bridge_controller` (string)\n\nSIP address to be used in From header when initiating a call bridge.\n\n*Default value is \u201csip:controller@kamailio.org\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"bridge_controller\", \"sip:ctd@kamailio.org\")\n...\n```\n",
   "bridge_contact": "### `bridge_contact` (string)\n\nSIP address to be used in Contact header when doing a call bridge.\n\n*Default value is \u201csip:controller@kamailio.org:5060\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"bridge_contact\", \"sip:ctd@127.0.0.1:5060\")\n...\n```\n",
   "initial_cbs_inscript": "### `initial_cbs_inscript` (int)\n\nIf the initial dialog callbacks (i.e., DLGCB_CREATED and DLGCB_SPIRALED)\nshould be executed in-script or post-script. If dlg_manage() is not\nused, the setting of this parameter does not matter; otherwise, initial\ncallbacks will be executed directly after dlg_manage() is called if this\nparameter is enabled. If it is disabled, initial callback execution will\nbe postponed until configuration script execution completes.\n\nThe supported values are:\n\n- *0 - POST-SCRIPT* - execute initial callbacks after the script\n  completes;\n\n- *1 - IN-SCRIPT* - execute initial callbacks during script execution,\n  i.e., right after dlg_manage() is called;\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"initial_cbs_inscript\", 0)\n...\n```\n",
   "send_bye": "### `send_bye` (int)\n\nIf set to 1, BYE requests will be sent out for each dialog that timed\nout. It is an alternative to $dlg_ctx(timeout_bye)=1 for all dialogs.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"send_bye\", 1)\n...\n```\n",
   "dlg_filter_mode": "### `dlg_filter_mode` (int)\n\nSet dialog fitering mode, which can specify what dialogs are processed.\nIts value can be a combination (the sum) of following flags:\n\n- *1* - do not send keepalives and do not execute timeout function if\n  dialog is not local (if the associated bind address is not a local\n  socket).\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_filter_mode\", 1)\n...\n```\n",
   "wait_ack": "### `wait_ack` (int)\n\nIf set to 1, dialog will be kept a bit longer in memory in order to\nabsorb the ACK negative replies of initial INVITE. If not, the dialog is\ndestroyed when negative reply is sent out (less internal complexity).\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"wait_ack\", 0)\n...\n```\n",
   "ka_timer": "### `ka_timer` (int)\n\nKeep-alive timer step - how often to execute the callback to send dialog\nkeep alives (SIP OPTIONS requests within dialog). The value represents\nthe number of seconds.\n\n*Default value is \u201c0\u201d (no keep alive).*\n\n```\n...\nmodparam(\"dialog\", \"ka_timer\", 10)\n...\n```\n",
   "ka_interval": "### `ka_interval` (int)\n\nThe interval between keep alives within dialog (SIP OPTIONS requests),\nsent to caller or callee. The keep alive request will be sent by the\nfirst callback fired by KA timer after the ka_interval elapsed from\ndialog setup or previous keep-alive. The value represents the number of\nseconds.\n\nIf the requests times out (generating a 408) or if the UA responds with\n481 the lifetime is set to 10 seconds. When lifetime expires the dialog\nwill be terminated. Any other response (including error responses) will\nreset the timers.\n\n*Default value is \u201c0\u201d (no keep alive). The lowest settable interval is\n30 seconds.*\n\n```\n...\nmodparam(\"dialog\", \"ka_interval\", 300)\n...\n```\n",
   "ka_failed_limit": "### `ka_failed_limit` (int)\n\nThe number of failed keep-alive requests that is accepted before\ngenerating a dialog timeout.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"ka_failed_limit\", 5)\n...\n```\n",
   "timeout_noreset": "### `timeout_noreset` (int)\n\nIf set to 1, the dialog timeout won't be reset each time a sequential\nrequest is processed. It is an alternative to\ndlg_set_property(\"timeout-noreset\") for all dialogs.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"timeout_noreset\", 1)\n...\n```\n",
   "timer_procs": "### `timer_procs` (int)\n\nIf set to 1, the dialog module will start a separate dialog timer\nprocess to execute dialog timeout tasks. The default is to use the core\ntimer process.\n\n*Default value is \u201c0\u201d (use core timer process).*\n\n```\n...\nmodparam(\"dialog\", \"timer_procs\", 1)\n...\n```\n",
   "enable_dmq": "### `enable_dmq` (int)\n\nIf set to 1, the dialog will be synced via dmq. For now, only very basic\ndialog info is shared, just enough to have synced profiles. Notably, it\nis not possible to send in-dialog requests on any but the original proxy\ninstance.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"enable_dmq\", 1)\n...\n```\n",
   "track_cseq_updates": "### `track_cseq_updates` (int)\n\nEnable the callbacks for tracking if CSeq number needs to be updated. It\nis the case when the INVITE has to be authenticated to downstream\nprovider using uac_auth() from uac module.\n\nThis is done only for requests in downstream direction. The CSeq\ndifference is stored in $dlg_var(cseq_diff), be sure this variable is\nnot overwritten via config operation.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"dialog\", \"track_cseq_updates\", 1)\n...\n```\n",
   "lreq_callee_headers": "### `lreq_callee_headers` (string)\n\nSIP headers to be added when sending local generated requests (e.g.,\nBYE) to callee. It can be useful when you use topoh module with call-id\nmasking (see the docs of topoh module).\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"lreq_callee_headers\", \"TH: dlh\\r\\n\")\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues are: 'dialog:start', 'dialog:end', 'dialog:failed'. It is also\nexecuted if '$dlg_ctx(timeout_route)' is set, the callback function\nbeing executed with the variable value as parameter.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"dialog\", \"event_callback\", \"ksr_dialog_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_dialog_event(evname)\n    KSR.info(\"===== dialog module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "h_id_start": "### `h_id_start` (int)\n\nSet the offset to be used for generating dialog internal hash id. If set\nto -1, the h_id_start is set to the value of the server_id global\nparameter.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"h_id_start\", 5)\n...\n```\n",
   "h_id_step": "### `h_id_step` (int)\n\nSet the step to increment the dialog internal hash id.\n\nIf the value is greater than 1, the internal hash id is generated with\nthe rule: h_id_start + N * h_id_step. The first value of N is randomly\nselected at startup, then incremented by 1 for each new dialog. Setting\nh_id_start and h_id_step to non-default values should be done when using\ndlg_db_load_callid(...) or dlg_db_load_extra() to load dialog records\ngenerated by another Kamailio instance. Pay attention to ensure that\nthose Kamailio instances are not going to generate overlapping dialog\nhash id values by using different h_id_start and the same h_id_step\n(h_id_step has to be greater than the maximum value of h_id_start).\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"h_id_step\", 10)\n...\n```\n",
   "keep_proxy_rr": "### `keep_proxy_rr` (string)\n\nWhether to keep the record-route header added by the proxy. When\nenabled, it will keep this proxy's record-route header from the reply.\nThe result is that generated requests like the BYE from the dlg_end_dlg\nmi function will pass through the proxy (looped).\n\nValid values are:\n\n- *0* - Don't keep any proxy Record-Route headers\n\n- *1* - Keep Record-route headers for the callee leg\n\n- *2* - Keep Record-route headers for the caller leg\n\n- *3* - Keep Record-route headers for both legs\n\nDefault value is\n\n0\n\n.\n\n```\n...\nmodparam(\"dialog\", \"keep_proxy_rr\", 1)\n...\n```\n",
   "bye_early_code": "### `bye_early_code` (int)\n\nThis parameter defines the reply-code being used for dialogs being\nterminated in early stage (e.g. before 200 OK/ACK).\n\nDefault value is\n\n480\n\n.\n\n```\n...\nmodparam(\"dialog\", \"bye_early_code\", 503)\n...\n```\n",
   "bye_early_reason": "### `bye_early_reason` (string)\n\nThis parameter defines the reply-reason being used for dialogs being\nterminated in early stage (e.g. before 200 OK/ACK).\n\nDefault value is\n\nTemporarily Unavailable\n\n.\n\n```\n...\nmodparam(\"dialog\", \"bye_early_reason\", \"Call terminated\")\n...\n```\n",
   "dlg_ctxiuid_mode": "### `dlg_ctxiuid_mode` (int)\n\nSet dialog context iuid mode, which can specify additional cases when\nthe internal unique id should be set:\n\n- *1* - set it when processing CANCEL requests.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_ctxiuid_mode\", 1)\n...\n```\n",
   "debug_variables": "### `debug_variables` (int)\n\nActivate additional debugging for printing internal lists for dialog\nvariables. This output is only visible at debug log level and should\nonly be used for debugging. By default it is deactivated.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"debug_variables\", 1)\n...\n```\n"
  },
  "functions": {
   "set_dlg_profile": "### `set_dlg_profile(profile[, value])`\n\nInserts the current dialog into a profile. Note that if the profile does\nnot support values, they will be silently discarded. Also, there is no\ncheck for inserting the same dialog into the same profile multiple\ntimes.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to be added to;\n\n- *value* (optional) - string value to define the membership of the\n  dialog in the profile. Note that the profile must support values.\n  Pseudo-variables are supported.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n```\n...\nset_dlg_profile(\"inbound_call\");\nset_dlg_profile(\"caller\",\"$fu\");\n...\n```\n",
   "unset_dlg_profile": "### `unset_dlg_profile(profile[, value])`\n\nRemoves the current dialog from a profile.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to be removed from;\n\n- *value* (optional) - string value to define the belonging of the\n  dialog to the profile - note that the profile must support values.\n  Pseudo-variables are supported.\n\nThis function can be used from BRANCH_ROUTE, REPLY_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\nunset_dlg_profile(\"inbound_call\");\nunset_dlg_profile(\"caller\",\"$fu\");\n...\n```\n",
   "is_in_profile": "### `is_in_profile(profile[, value])`\n\nChecks if the current dialog belongs to a profile. If the profile is\ndefined with values, then the check is also matching with the specific\nvalue provided as parameter.\n\nNote that if the profile is not defined with support for values, the\nvalue parameter will be silently discarded.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to be checked against;\n\n- *value* (optional) - string value to be matched during the check.\n  Pseudo-variables are supported.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n```\n...\nif (is_in_profile(\"inbound_call\")) {\n    log(\"this request belongs to an inbound call\\n\");\n}\n...\nif (is_in_profile(\"caller\",\"XX\")) {\n    log(\"this request belongs to a call of user XX\\n\");\n}\n...\n```\n",
   "get_profile_size": "### `get_profile_size(profile[, value], size)`\n\nReturns the number of dialogs belonging to a profile. If the profile\nsupports values, the check can be reinforced to take into account a\nspecific value, i.e. how many dialogs were inserted into the profile\nwith a specific value. If no value is passed, only the membership of the\ndialog in the profile per se is checked. Note that if the profile does\nnot support values, the value parameter will be silently discarded.\n\nMeaning of the parameters is as follows:\n\n- *profile* - name of the profile to get the size for;\n\n- *value* (optional) - string value to further restrict the check.\n  Pseudo-variables are supported;\n\n- *size* - an AVP or script variable to return the profile size in.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n```\n...\nif(get_profile_size(\"inbound_call\",\"$avp(size)\"))\n    xlog(\"currently there are $avp(size) inbound calls\\n\");\n...\nif(get_profile_size(\"caller\",\"$fu\",\"$avp(size)\"))\n    xlog(\"currently, the user $fu has $avp(size) active outgoing calls\\n\");\n...\n```\n",
   "dlg_isflagset": "### `dlg_isflagset(flag)`\n\nCheck if the dialog flag is set or not.\n\nMeaning of the parameters is as follows:\n\n- *flag* - index of the flag - can be pseudo-variable.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif(dlg_isflagset(\"1\"))\n{\n    ...\n}\n...\n```\n",
   "dlg_setflag": "### `dlg_setflag(flag)`\n\nSet a dialog flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - index of the flag - can be pseudo-variable.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\ndlg_setflag(\"1\");\n...\n```\n",
   "dlg_resetflag": "### `dlg_resetflag(flag)`\n\nReset the dialog flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - index of the flag - can be pseudo-variable.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\ndlg_resetflag(\"1\");\n...\n```\n",
   "dlg_bye": "### `dlg_bye(side)`\n\nSend BYE to parties of a dialog or - if in early stage - a CANCEL to the\nB-Party and a SIP response to the A-Party (as defined in bye_early_code\n/ bye_early_reason).\n\nMeaning of the parameters is as follows:\n\n- *side* - where to send the BYE. It can be: 'caller', 'callee', or\n  'all' (send to both sides).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ndlg_bye(\"all\");\n...\n```\n",
   "dlg_refer": "### `dlg_refer(side, address)`\n\nRefer the 'side' to a new SIP 'address'.\n\nMeaning of the parameters is as follows:\n\n- *side* - which side of the dialog to REFER. It can be: 'caller' or\n  'callee'.\n\n- *address* - SIP address to refer to.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\ndlg_refer(\"caller\", \"sip:announcement@kamailio.org\");\n...\n```\n",
   "dlg_manage": "### `dlg_manage()`\n\nProcess current SIP request with dialog module. It is an alternative to\nsetting dialog flag for initial INVITE and Route-parameter-callback\nexecution for within-dialog requests.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nmodparam(\"dialog\", \"default_timeout\", 100)\n...\nrequest_route {\n...\n    if(is_method(\"INVITE\") && !has_totag())\n    {\n        $dlg_ctx(timeout_route) = \"DLGTIMEOUT\";\n        $dlg_ctx(timeout_bye) = 1;\n    }\n    dlg_manage();\n...\n}\n...\n```\n",
   "dlg_bridge": "### `dlg_bridge(from, to, op)`\n\nBridge 'from' SIP address to 'to' SIP address via outbound proxy 'op'.\n\nMeaning of the parameters is as follows:\n\n- *from* - SIP address of first side to call.\n\n- *to* - SIP address to refer \u201cfrom\u201d to.\n\n- *op* - outbound proxy SIP address.\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\ndlg_bridge(\"sip:user@kamailio.org\", \"sip:annoucement@kamailio.org\",\n   \"sip:kamailio.org:5080\");\n...\n```\n",
   "dlg_get": "### `dlg_get(callid, ftag, ttag)`\n\nSearch and set current dialog based on Call-ID, From-Tag and To-Tag\nparameters.\n\nMeaning of the parameters is as follows:\n\n- *callid* - SIP call-id.\n\n- *ftag* - SIP From tag.\n\n- *ttag* - SIP To tag (it can be empty string to match a dialog during\n  call setup (eg., match for CANCEL)).\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif(dlg_get(\"abcdef\", \"123\", \"456\"))\n{\n    dlg_bye(\"all\");\n}\n...\n```\n",
   "dlg_get_var": "### `dlg_get_var(callid, ftag, ttag, name, dst)`\n\nGet dlg_var of another dialog value based on Call-ID, From-Tag and\nTo-Tag parameters.\n\nMeaning of the parameters is as follows:\n\n- *callid* - SIP call-id.\n\n- *ftag* - SIP From tag.\n\n- *ttag* - SIP To tag. Use \"\" value to indicate early dialog.\n\n- *name* - key name of the $dlg_var.\n\n- *dst* - pv to store the value of $dlg_var(name).\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif(dlg_get_var(\"$var(ci)\", \"$var(ft)\", \"456\", \"test\", \"$var(tmp)\"))\n{\n    xdbg(\"$$dlg_var(test):$var(tmp)\\n\");\n}\n...\n```\n",
   "dlg_set_var": "### `dlg_set_var(callid, ftag, ttag, name, value)`\n\nSet dlg_var of another dialog value based on Call-ID, From-Tag and\nTo-Tag parameters.\n\nMeaning of the parameters is as follows:\n\n- *callid* - SIP call-id.\n\n- *ftag* - SIP From tag.\n\n- *ttag* - SIP To tag. Use \"\" value to indicate early dialog.\n\n- *name* - key name of the $dlg_var.\n\n- *value* - string value to store at $dlg_var(name).\n\nThis function can be used from BRANCH_ROUTE, REQUEST_ROUTE,\nONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif(dlg_set_var(\"$var(ci)\", \"$var(ft)\", \"456\", \"test\", \"$var(tmp)\"))\n{\n    xdbg(\"set $$dlg_var(test):$var(tmp)\\n\");\n}\n# you can set vars in early dialog too\nif(dlg_set_var(\"$var(ci)\", \"$var(ft)\", \"\", \"test\", \"$var(tmp)\"))\n{\n    xdbg(\"set $$dlg_var(test):$var(tmp)\\n\");\n}\n...\n```\n",
   "is_known_dlg": "### `is_known_dlg()`\n\nThis function checks if the current SIP message being processed belongs\nto any transaction within an active dialog that the dialog module is\ncurrently tracking. This is a check for tracking of any kind, without\nregard to profiles.\n\nThis function has numerous potential applications, among which is that\nit can be used to strengthen security for loose-routing sequential\n(in-dialog) requests or responses to them, as by providing a\npreventative check against spoofing on the proxy level instead of\nleaving the issue purely to the receiving UA.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, REPLY_ROUTE\nand FAILURE_ROUTE.\n\n```\n...\nif(!uri == myself) {\n    if(is_known_dlg()) {\n        xlog(\"Request $rm from $ci is in-dialog\\n\");\n    }\n}\n...\n```\n",
   "dlg_set_timeout": "### `dlg_set_timeout(timeout [, h_entry, h_id])`\n\nSet the dialog timeout. Dialog timeout will be updated if it was already\nset. If h_entry and h_id parameters are not provided, the dialog will be\nsearched based on (callid, fromtag, totag) of currently processed SIP\nmessage.\n\nMeaning of the parameters is as follows:\n\n- *timeout* - the interval in seconds after which the dialog will time\n  out.\n\n- *h_entry* - h_entry value of the iternal dialog identifier.\n\n- *h_id* - h_id value if the internal dialog identifier.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(dlg_set_timeout(\"180\", \"123\", \"456\"))\n{\n    ...\n}\n...\n```\n",
   "dlg_set_timeout_by_profile": "### `dlg_set_timeout_by_profile(profile, [value], timeout)`\n\nLike *dlg_set_timeout()*, but simultaneously sets the timeout of all\ndialogs in a given profile. Can be constrained by profile value.\n\nMeaning of the parameters is as follows:\n\n- *profile* - The dialog profile across which to apply the timeout.\n\n  *value* (optional) - The profile value to use when applying the dialog\n  timeout.\n\n  *timeout* - the interval in seconds after which the dialog will time\n  out.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# All dialogs belonging to user abc123 (tracked via set_dlg_profile())\n# will be timed out in 3 seconds.\n\ndlg_set_timeout_by_profile(\"users\", \"abc123\", \"3\");\n...\n```\n",
   "dlg_set_property": "### `dlg_set_property(attr)`\n\nSet a dialog property - an attribute that enable/disable various\nbehaviours (e.g., sending keep alive requests).\n\nMeaning of the parameters is as follows:\n\n- *attr* - name of property. It can be:\n\n  - 'ka-src' - send keep alive OPTION requests to caller\n  - 'ka-dst' - send keep alive OPTION requests to callee\n  - 'timeout-noreset' - don't reset timeout on in-dialog messages\n    reception\n\nIf keep alive is enabled for a dialog, the module will send SIP OPTIONS\nrequests with CSeq lower or equal than last request within dialog, with\nthe scope of detecting if the destination is still in the call. If the\nkeep alive request results in a local timeout or '481 Call\nLeg/Transaction Does Not Exist', then the dialog is ended from the\nserver.\n\nIf 'timeout-noreset' is set, dialog timeout won't be reset upon\nreception of in-dialog messages (default behavior).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ndlg_set_property(\"ka-src\");\ndlg_set_property(\"ka-dst\");\ndlg_set_property(\"timeout-noreset\");\n...\n```\n",
   "dlg_remote_profile": "### `dlg_remote_profile(cmd, profile, value, uid, expires)`\n\nManage remote profile via config file. A remote profile item is\nconsidered when the dialog is not managed by this server instance. The\nnotification to add/remove can be received via SIP or a RPC command, the\noperation can be then triggered from configuration file. This should\nallow counting active dialogs in a profile that are managed by multiple\nSIP server instances.\n\nMeaning of the parameters is as follows:\n\n- *cmd* - the operations to do: add - add an item in profile; rm -\n  remove an item from profile\n\n- *profile* - name of profile\n\n- *value* - value for profile (if no value is needed for that profile,\n  use an empty string.\n\n- *expires* - absolute time (unix timestamp) when this profile item\n  should be removed automatically (time based), if still in the profile\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(exp) = 3600 + $Ts;\ndlg_remote_profile(\"add\", \"caller\", \"test\", \"$sruid\", \"$var(exp)\");\n...\n```\n",
   "dlg_set_ruri": "### `dlg_set_ruri()`\n\nThis function sets the R-URI with the corresponding endpoint address\nstored in dialog structure (i.e., its Contact field).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(has_totag() and is_present_hf(\"Route\") and uri==myself ) {\n    if(dlg_set_ruri()) {\n        xlog(\"Request URI changed from [$ou] to dlg value: [$ru]\\n\");\n    }\n}\n...\n```\n",
   "dlg_db_load_callid": "### `dlg_db_load_callid(cival)`\n\nLoad dialog record from database matching on Call-Id provided as\nparameter.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(has_totag()) {\n    if(!is_known_dlg()) {\n        dlg_db_load_callid(\"$ci\");\n        if(!is_known_dlg()) {\n            xlog(\"no dialog found with callid: $ci\\n\");\n        }\n    }\n}\n...\n```\n",
   "dlg_db_load_extra": "### `dlg_db_load_extra()`\n\nLoad all dialog records from database that are not in memory of the\ncurrent Kamailio instance.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(has_totag()) {\n    if(!is_known_dlg()) {\n        dlg_db_load_extra();\n        if(!is_known_dlg()) {\n            xlog(\"no dialog found with callid: $ci\\n\");\n        }\n    }\n}\n...\n```\n",
   "dlg_reset_property": "### `dlg_reset_property(attr)`\n\nReset a dialog property - an attribute that enable/disable various\nbehaviours (e.g., sending keep alive requests).\n\nMeaning of the parameters is as follows:\n\n- *attr* - name of property. It can be:\n\n  - 'ka-src' - send keep alive OPTION requests to caller\n  - 'ka-dst' - send keep alive OPTION requests to callee\n  - 'timeout-noreset' - don't reset timeout on in-dialog messages\n    reception\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ndlg_reset_property(\"ka-src\");\ndlg_reset_property(\"ka-dst\");\ndlg_reset_property(\"timeout-noreset\");\n...\n```\n",
   "dlg_req_within": "### `dlg_req_within(side, method, [headers], [content_type, content])`\n\nSends an in-dialog SIP Request with method to a party of a dialog\nindicated by the side parameter.\n\nMeaning of the parameters is as follows:\n\n- *side* - where to send the request. It can be: 'caller', 'callee', or\n  'all' (send to both sides).\n\n- *method* - Method of the request\n\n- *headers* (optional) - additional headers to be added to the request.\n\n- *content_type* (optional) - Content-Type of the request body - will be\n  added as Content-Type Header.\n\n- *content* (optional) - Content to be sent as body.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    # Send a simple request:\n    dlg_req_within(\"all\", \"OPTIONS\");\n...\n    # Send a simple request with extra headers:\n    dlg_req_within(\"caller\", \"OPTIONS\", \"X-Info: Bandwidth granted\\r\\nX-Info-2: Go ahead\\r\\n\");\n...\n    # Send a simple request with body:\n    dlg_req_within(\"caller\", \"UPDATE\", \"application/sdp\", \"...some SDP...\");\n...\n    # Send a simple request with extra headers and body:\n    dlg_req_within(\"callee\", \"INFO\", \"X-Info: Bandwidth granted\\r\\n\", \"application/sdp\", \"...some SDP...\");\n...\n        \n```\n"
  }
 },
 "dialplan": {
  "overview": "This module implements generic string translations based on matching and\nreplacement rules. It can be used to manipulate the request URI or a PV\nand to translate it to a new format/value. Dialplan can also be used to\nmatch a given URI and retrieve a set of attributes based on the match.\nIt is a very flexible module that can be used to handle call routing,\nprefix rewrites and much more.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThe translation rules will be loaded using this database URL.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"db_url\", \"mysql://user:passwd@localhost/db\")\n...\n        \n```\n",
   "table_name": "### `table_name` (string)\n\nThe name of the database table used to load the translation rules.\n\n*Default value is \u201cdialplan\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"table_name\", \"my_table\")\n...\n        \n```\n",
   "dpid_col": "### `dpid_col` (string)\n\nThe column name used to store the dialplan group ID.\n\n*Default value is \u201cdpid\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"dpid_col\", \"column_name\")\n...\n        \n```\n",
   "pr_col": "### `pr_col` (string)\n\nThe column name used to store the priority of the corresponding rule\nfrom the database row.\n\n*Default value is \u201cpr\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"pr_col\", \"column_name\")\n...\n        \n```\n",
   "match_op_col": "### `match_op_col` (string)\n\nThe column name used to store the type of matching of the rule.\n\n*Default value is \u201cmatch_op\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"match_op_col\", \"column_name\")\n...\n        \n```\n",
   "match_exp_col": "### `match_exp_col` (string)\n\nThe column name to store the rule match expression.\n\n*Default value is \u201cmatch_exp\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"match_exp_col\", \"column_name\")\n...\n        \n```\n",
   "match_len_col": "### `match_len_col` (string)\n\nThe column name to store the length of a string matching the match\nexpression.\n\n*Default value is \u201cmatch_len\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"match_len_col\", \"column_name\")\n...\n        \n```\n",
   "subst_exp_col": "### `subst_exp_col` (string)\n\nThe column name to store the rule's substitution expression.\n\n*Default value is \u201csubst_exp\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"subst_exp_col\", \"column_name\")\n...\n        \n```\n",
   "repl_exp_col": "### `repl_exp_col` (string)\n\nThe column name to store the rule's replacement expression.\n\n*Default value is \u201crepl_exp\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"repl_exp_col\", \"column_name\")\n...\n        \n```\n",
   "attrs_col": "### `attrs_col` (string)\n\nThe column name to store the rule's attributes to be set after match\n(see `attrs_pvar` )\n\n*Default value is \u201cattrs\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"attrs_col\", \"column_name\")\n...\n        \n```\n",
   "attrs_pvar": "### `attrs_pvar` (string)\n\nThe pseudovariable used to store the rule's attributes, after\ntranslation (when `dp_translate`() succeeds). This parameter can be an\n\u201cAVP\u201d or a script variable (\u201c$var()\u201d)..\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"attrs_pvar\", \"$avp(s:dest)\")\n...\n        \n```\n",
   "fetch_rows": "### `fetch_rows` (int)\n\nThe number of rows to be fetched at once from database\n\n*Default value is \u201c1000\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"fetch_rows\", 4000)\n...\n        \n```\n",
   "match_dynamic": "### `match_dynamic` (int)\n\nIf set to 1, the match and substitution expressions can include script\nvariables and their values are evaluated at runtime.\n\nDuring the loading process, the values that contain variables are no\nlonger pre-compiled to PCRE structure in memory, because the values\nchange at runtime, thus expect slightly slower performances. Values\nwithout script variables are pre-compiled even if this parameter is\nenabled.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"dialplan\", \"match_dynamic\", 1)\n...\n        \n```\n",
   "append_branch": "### `append_branch` (int)\n\nIf set to 1, the module appends a new outgoing branch when request URI\n(r-uri) or its user part are changed by dp_translate() or dp_replace()\ninside a failure_route block. Set it to 0 if the branch should not be\nadded.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"append_branch\", 0)\n...\n        \n```\n",
   "reload_delta": "### `reload_delta` (int)\n\nThe number of seconds that have to be waited before executing a new\nreload of dialplan rules. By default there is a rate limiting of maximum\none reload in five seconds.\n\nIf set to 0, no rate limit is configured. Note carefully: use this\nconfiguration only in tests environments because executing two dialplan\nreloads at the same time can cause to kamailio to crash.\n\n*Default value is \u201c5\u201d.*\n\n```\n...\nmodparam(\"dialplan\", \"reload_delta\", 1)\n...\n        \n```\n"
  },
  "functions": {
   "dp_replace": "### `dp_replace(dpid, inval, outvar)`\n\nThe function translates the input value 'inval' using the rules with\ndialplan id 'dpid', storing the value in the variable 'outvar'. If the\nrule that was applied has attributes, they are stored in the variable\nprovided via the module parameter 'attrs_pvar'.\n\nThe behavior is same as dp_translate(\"dpid\", \"inval/outvar\"), but the\nparameters have a more flexible format.\n\nMeaning of the parameters is as follows:\n\n- *dpid* - the dialplan id to match the rules and apply the\n  transformations. It can be a static string or a config variable\n  holding an integer value.\n\n- *inval* - input value. It can be a static or a dynamic string. The\n  dynamic string can contain config variables, combined or not with\n  static strings, that are evaluated at runtime.\n\n- *outvar* - output variable name. The value resulted after applying the\n  matching rule is stored in this variable. The name must refer to a\n  writable variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ndp_replace(\"240\", \"$rU\", \"$var(newru)\");\nxlog(\"'$rU' was translated to '$var(newru)'\\n\");\ndp_replace(\"240\", \"+49$rU\", \"$var(newval)\");\n...\n    \n```\n",
   "dp_match": "### `dp_match(dpid, inval)`\n\nThe function matches the input value 'inval' using the rules with\ndialplan id 'dpid'. If the rule that was applied has attributes, they\nare stored in the variable provided via the module parameter\n'attrs_pvar'.\n\nThe behavior is same as dp_translate(\"dpid\", \"inval\"), but the\nparameters have a more flexible format.\n\nMeaning of the parameters is as follows:\n\n- *dpid* - the dialplan id to match the rules and apply the\n  transformations. It can be a static string or a config variable\n  holding an integer value.\n\n- *inval* - input value. It can be a static or a dynamic string. The\n  dynamic string can contain config variables, combined or not with\n  static strings, that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ndp_match(\"240\", \"+49$rU\");\nxlog(\"the attributes associated with '+49$rU' are '$var(attrs)'\\n\");\n...\n    \n```\n",
   "dp_translate": "### `dp_translate(id, [src[/dest]])`\n\nWill try to translate \u201csrc\u201d into \u201cdest\u201d according to the translation\nrules in the dialplan identified by \u201cid\u201d . If src/dest is missing the\ndefault parameter \u201cruri.user/ruri.user\u201d will be used, thus translating\nthe request URI user part. If only \u201cdest\u201d is missing, only matching and\nstoring of the matching rule's attributes is done.\n\nReturns 1, if translation succeeded, -1 in case of some error occurred,\nand -2 if dialplan with ID equal to id does not exist.\n\nMeaning of the parameters is as follows:\n\n- *id* -the dialplan id of the possible matching rules. This parameter\n  can have the following types:\n\n  - *integer*- the dialplan id is statically assigned\n\n  - *avp var* - the dialplan id is the value of an existing avp variable\n\n  - *script var* - the dialplan id is the value of an existing script\n    variable.\n\n\n- *src/dest* - input and output of the function.\n\n  Input parameter src can be any pseudo variable. Output parameter dest\n  can be:\n\n  - *R-URI*\n\n    - the string is the r-uri or r-uri user part\n\n  - *avp var*\n\n    - At input the function will get the input string from an existing\n    avp variable. At output the function will add an avp with the value\n    of the output string.\n\n  - *script var*\n\n    - At input the function will get the input string from an existing\n    script variable. At output the function will set a script variable\n    with the value of the output string.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ndp_translate(\"240\", \"$ruri.user/$avp(s:dest)\");\nxlog(\"translated to var $avp(s:dest) \\n\");\n...\n    \n\n...\n$avp(s:src) = $ruri.user;\ndp_translate(\"$var(x)\", \"$avp(s:src)/$var(y)\");\nxlog(\"translated to var $var(y) \\n\");\n...\n    \n```\n",
   "dp_reload": "### `dp_reload()`\n\nReload the translation rules from the database. Note that there is a\nrate limiting defined by 'reload_delta' parameter. By default is allowed\nmaximum one reload in five seconds.\n\nName: *dp_reload*\n\nParameters: *none*\n\nThis function can be used from ANY_ROUTE.\n"
  }
 },
 "dispatcher": {
  "overview": "This module offers SIP load balancer functionality and it can be used as\nSIP traffic dispatcher. There are many load balancing and traffic\ndispatching algorithms that you can choose from, for example:\nround-robin, weight based load balancing, call load distribution, and\nhashing over SIP message attributes.\n\nThe module can be used as a stateless load balancer; it does not depend\non any call state tracking module. It requires the TM module if you\nenable auto-discovery of active/inactive gateways.\n\nIt is very lightweight, therefore suitable for handling heavy SIP\ntraffic. As the module has a small footprint and the ability to load\nbalancing rules from a plain text file, it is suitable for embedded\nsystems.\n",
  "parameters": {
   "list_file": "### `list_file` (string)\n\nPath to the file with destination sets (destination groups).\n\n*Default value is \u201c/etc/kamailio/dispatcher.list\u201d or\n\u201c/usr/local/etc/kamailio/dispatcher.list\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"list_file\", \"/run/kamailio/dispatcher.list\")\n...\n```\n",
   "db_url": "### `db_url` (string)\n\nIf you want to load the list of gateways from the database you must set\nthis parameter.\n\n*Default value is \u201cNULL\u201d (disable DB support).*\n\n```\n...\nmodparam(\"dispatcher\", \"db_url\", \"mysql://user:passwd@localhost/database\")\n...\n```\n",
   "table_name": "### `table_name` (string)\n\nIf you want to load the list of gateways from the database you must set\nthis parameter as the database name.\n\n*Default value is \u201cdispatcher\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"table_name\", \"my_dispatcher\")\n...\n```\n",
   "setid_col": "### `setid_col` (string)\n\nThe column's name in the database storing the gateway's set (group) id.\n\n*Default value is \u201csetid\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"setid_col\", \"groupid\")\n...\n```\n",
   "destination_col": "### `destination_col` (string)\n\nThe column's name in the database storing the destination sip URI.\n\n*Default value is \u201cdestination\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"destination_col\", \"uri\")\n...\n```\n",
   "flags_col": "### `flags_col` (string)\n\nThe column's name in the database storing the flags for the destination\nURI.\n\n*Default value is \u201cflags\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"flags_col\", \"dstflags\")\n...\n```\n",
   "priority_col": "### `priority_col` (string)\n\nThe column's name in the database storing the priority for destination\nURI.\n\n*Default value is \u201cpriority\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"priority_col\", \"dstpriority\")\n...\n```\n",
   "attrs_col": "### `attrs_col` (string)\n\nThe column's name in the database storing the attributes for destination\nURI.\n\n*Default value is \u201cattrs\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"attrs_col\", \"dstattrs\")\n...\n```\n",
   "force_dst": "### `force_dst` (int)\n\nIf set to 1, force overwriting of destination address (outbound proxy)\nwhen that is already set. If set to 0, will return error when the\ndestination address is already set.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"force_dst\", 1)\n...\n```\n",
   "flags": "### `flags` (int)\n\nVarious flags that affect dispatcher's behaviour. The flags are defined\nas a bitmask on an integer value. If flag 1 is set only the username\npart of the URI will be used when computing an URI based hash. If no\nflags are set the username, hostname and port will be used. The port is\nused only if different from 5060 (normal sip URI) or 5061 (in the sips:\ncase).\n\nIf flag 2 is set, then failover support is enabled. The functions\nexported by the module will store the rest of addresses from the\ndestination set in XAPVs, and use these XAVPs to try next address if the\ncurrent-tried destination fails.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"flags\", 3)\n...\n```\n",
   "use_default": "### `use_default` (int)\n\nIf the parameter is set to 1, the last address in destination set is\nused as a final option to send the request to. For example, it is useful\nwhen wanting to send the call to an announcement server saying: \"the\ngateways are full, try later\".\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"use_default\", 1)\n...\n```\n",
   "xavp_dst": "### `xavp_dst` (str)\n\nThe name of the XAVP which will hold the list with addresses and\nassociated properties, in the order they have been selected by the\nchosen algorithm. If use_default is 1, the values of last XAVP\ncorrespond to the last address in destination set. In case of using\ndispatcher.list file, you have to set the priority field for each\ndestination to ensure a particular order there. The first XAVP is the\ncurrent selected destination. All the other addresses from the\ndestination set will be added in the XAVP list to be able to implement\nserial forking.\n\n<div class=\"note\">\n\n\nYou must set this parameter if you want to do load balancing fail over.\n\n</div>\n\n\n*Default value is \u201c_dsdst_\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"xavp_dst\", \"_dsdst_\")\n...\n```\n",
   "xavp_dst_mode": "### `xavp_dst_mode` (int)\n\nControl what fields are added to the XAVP specified by xavp_dst\nparameter.\n\nThe addeded fields are:\n\n- grp - the set id (group id).\n\n- uri - the URI address.\n\n- sock - the socket pointer.\n\n- socket - the socket string - it is added only if xavp_dst_mode has bit\n  2 set (value 2).\n\n- sockname - the sockname string - it is added only if xavp_dst_mode has\n  bit 3 set (value 3).\n\n- dstid - the destination unique id (in case of call load distribution\n  algorithm).\n\n- attrs - the attributes - they are added if xavp_dst_mode does not have\n  the bit 1 set (value 1).\n\n*Default value is \u201c0\u201d (add grp, uri, sock, attr and optionally dstid\nfields).*\n\n```\n...\n    modparam(\"dispatcher\", \"xavp_dst_mode\", 1)\n...\n    modparam(\"dispatcher\", \"xavp_dst_mode\", 2)\n...\n```\n",
   "xavp_ctx": "### `xavp_ctx` (str)\n\nThe name of the XAVP which will hold some attributes specific to\ndispatcher routing context. The XAVP can hold the next fields: cnt - the\nnumber of addresses selected for routing.\n\n*Default value is \u201c_dsctx_\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"xavp_ctx\", \"_dsctx_\")\n...\n```\n",
   "xavp_ctx_mode": "### `xavp_ctx_mode` (int)\n\nControl what fields are added to the XAVP specified by xavp_ctx\nparameter. The cnt field is added if xavp_cnt_mode does not have the bit\n1 set.\n\n*Default value is \u201c0\u201d (add all fields).*\n\n```\n...\nmodparam(\"dispatcher\", \"xavp_ctx_mode\", 1)\n...\n```\n",
   "hash_pvar": "### `hash_pvar` (str)\n\nString with PVs used for the hashing algorithm 7.\n\n<div class=\"note\">\n\n\nYou must set this parameter if you want do hashing over custom message\nparts.\n\n</div>\n\n\n*Default value is \u201cnull\u201d - disabled.*\n\n```\n...\nmodparam(\"dispatcher\", \"hash_pvar\", \"$avp(hash)\")\n...\n\n...\nmodparam(\"dispatcher\", \"hash_pvar\", \"hash the $fU@$ci\")\n...\n```\n",
   "setid_pvname": "### `setid_pvname` (str)\n\nThe name of the PV where to store the set ID (group ID) when calling\nds_is_from_list() with no parameter.\n\n*Default value is \u201cnull\u201d - don't set PV.*\n\n```\n...\nmodparam(\"dispatcher\", \"setid_pvname\", \"$var(setid)\")\n...\n```\n",
   "attrs_pvname": "### `attrs_pvname` (str)\n\nThe name of the PV where to store the attributes of matching address\nwhen calling ds_is_from_list().\n\n*Default value is \u201cnull\u201d - don't set PV.*\n\n```\n...\nmodparam(\"dispatcher\", \"attrs_pvname\", \"$var(attrs)\")\n...\n```\n",
   "ds_ping_method": "### `ds_ping_method` (string)\n\nWith this method you can define, with which method you want to probe the\ngateways. Pinging gateways feature depends on ds_ping_interval\nparameter.\n\n*Default value is \u201cOPTIONS\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_ping_method\", \"INFO\")\n...\n```\n",
   "ds_ping_from": "### `ds_ping_from` (string)\n\nWith this Method you can define the \"From:\"-Line for the request, sent\nto the failed gateways. This method is only available, if compiled with\nthe probing of failed gateways enabled.\n\n*Default value is \u201csip:dispatcher@localhost\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_ping_from\", \"sip:proxy@sip.somehost.com\")\n...\n```\n",
   "ds_ping_interval": "### `ds_ping_interval` (int)\n\nWith this parameter you can define the interval for sending a request to\na gateway marked as inactive upon a failed request routing to it. This\nparameter is only used, when the TM-Module is loaded. If set to \u201c0\u201d, the\npinging of inactive gateway is disabled.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_ping_interval\", 30)\n...\n```\n",
   "ds_probing_threshold": "### `ds_probing_threshold` (int)\n\nIf you want to set a gateway into inactive mode, there can be a specific\nnumber of failed requests until it will change from \"active\" to\n\"inactive\". It is using the state \"trying\", that allows selection of\ngateway but indicates there was a failure previously with the gateway.\nThe number of attempts can be set with this parameter. This parameter\ncan be modified via ser config framework.\n\n*Default value is \u201c1\u201d (set inactive with first failure).*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_probing_threshold\", 10)\n...\n```\n",
   "ds_inactive_threshold": "### `ds_inactive_threshold` (int)\n\nIf you want to set a gateway into active mode (after being inactive),\nthere can be a specific number of successful requests until it will\nchange from \"inactive\" to \"active\". The number of attempts can be set\nwith this parameter. This parameter can be modified via ser config\nframework.\n\n*Default value is \u201c1\u201d (set active with first success).*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_inactive_threshold\", 10)\n...\n```\n",
   "ds_ping_reply_codes": "### `ds_ping_reply_codes` (string)\n\nThis parameter defines the valid response codes, which are accepted as a\nvalid reply to the PING-Method. It is a list separated by colons, where\nyou may define either a single code (e.g. \"code=202\" would accept 202 as\nan additional, valid response) or a class of responses, you want to\naccept (e.g. \"class=2\" would accept everything from 200 to 299 as valid\nresponse). This parameter can be modified via config framework.\n\nPlease note that the response codes the module accepts as valid reply to\nthe PING-Method are not only the ones generated from the remote servers,\nbut also those that are generated locally. E.g.: setting code=408 or\nclass=400 will never set a backend down even if it is, because\ninternally the Kamailio transaction layer generates a 408 in the case of\nno response from the remote server, and this internal code 408 is\naccepted as valid value.\n\n*Default value is \u201c\u201d (only 200 OK is accepted).*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_ping_reply_codes\", \"class=2;code=403;code=488;class=3\")\n...\n```\n",
   "ds_probing_mode": "### `ds_probing_mode` (int)\n\nControls what gateways are tested to see if they are reachable.\n\n- Value 0: If set to 0, only the gateways with state PROBING are tested.\n  After a gateway is probed, the PROBING state is cleared in this mode.\n  This means that no probing will be executed at all only if flag in\n  config file is set to 8/PROBING (please check destination list file\n  syntaxis for more details), it will probe only one time at startup or\n  after dispatcher reload.\n\n- Value 1: If set to 1, all gateways are tested. If set to 1 and there\n  is a failure of keepalive to an active gateway, then it is set to\n  TRYING state. This means that probing will be executed all the time,\n  but you can skip some servers with flag 4 in destination list file,\n  for example.\n\n- Value 2: if set to 2, only gateways in INACTIVE state with PROBING\n  mode set are tested.\n\n- Value 3: If set to 3, any gateway with state PROBING is continually\n  probed without modifying/removing the PROBING state. This allows\n  selected gateways to be probed continually, regardless of state\n  changes.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_probing_mode\", 1)\n...\n```\n",
   "ds_ping_latency_stats": "### `ds_ping_latency_stats` (int)\n\nEnable latency measurement when pinging nodes The estimator can be\ninitialized at startup and reload using the attribute latency.\n\n- If set to 0, disable latency measurement.\n\n- If set to 1, enable latency measurement.\n\n*Default value is \u201c0\u201d.*\n\n```\n# using the command :\nkamcmd dispatcher.list\n...\nDEST: {\n    URI: sip:1.2.3.4\n    FLAGS: AX\n    PRIORITY: 9\n    ATTRS: {\n        BODY: latency=24\n    }\n    LATENCY: {\n        AVG: 24.250000 # weighted moving average for the last few weeks\n        STD: 1.035000  # standard deviation of AVG\n        EST: 25.000000 # short term estimate, see parameter: ds_latency_estimator_alpha\n        MAX: 26        # maximum value seen\n        TIMEOUT: 0     # count of ping timeouts\n    }\n}\n...\n\n...\nmodparam(\"dispatcher\", \"ds_ping_latency_stats\", 1)\n...\n```\n",
   "ds_retain_latency_stats": "### `ds_retain_latency_stats` (int)\n\nRetain latency stats for existing destinations when reloading from file\nor database.\n\n- If set to 0, stats for all destinations will be reset on reload.\n\n- If set to 1, stats for existing destinations will persist across\n  reloads.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_retain_latency_stats\", 1)\n...\n```\n",
   "ds_latency_estimator_alpha": "### `ds_latency_estimator_alpha` (int)\n\nThe value to be used to control the memory of the estimator EWMA\n\"exponential weighted moving average\" or \"the speed at which the older\nsamples are dampened\" a good explanation can be found here :\nhttp://www.itl.nist.gov/div898/handbook/pmc/section3/pmc324.htm Because\nKamailio doesn't support float parameter types, the value in the\nparameter is divided by 1000 and stored as float. For example, if you\nwant to set the alpha to be 0.75, use value 750 here.\n\n*Default value is \u201c900 => 0.9\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_latency_estimator_alpha\", 900)\n...\n```\n",
   "ds_hash_size": "### `ds_hash_size` (int)\n\nThe value to be used as power of two to set the number of slots to hash\ntable storing data for call load dispatching (e.g., value 8 will create\na hash table with 256 slots). It must be greater than 0 to enable call\nload dispatching feature (alg 10).\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_hash_size\", 9)\n...\n```\n",
   "ds_hash_expire": "### `ds_hash_expire` (int)\n\nExpiration time in seconds to remove the load on a destination if no BYE\nwas received meanwhile.\n\n*Default value is \u201c7200\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_hash_expire\", 3600)\n...\n```\n",
   "ds_hash_initexpire": "### `ds_hash_initexpire` (int)\n\nExpiration time in seconds to remove the load on a destination if no 200\nfor INVITE was received meanwhile and state updated with\nds_load_update().\n\n*Default value is \u201c7200\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_hash_initexpire\", 60)\n...\n```\n",
   "ds_hash_check_interval": "### `ds_hash_check_interval` (int)\n\nTime interval in seconds to scan internal hash table with call load\ndispatching data for expired items.\n\n*Default value is \u201c30\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_hash_check_interval\", 60)\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy` (str)\n\nSIP URI of outbound proxy to be used when sending pings.\n\n*By default no outbound proxy is defined.*\n\n```\n...\nmodparam(\"dispatcher\", \"outbound_proxy\", \"sip:outbound.example.com\")\n...\n```\n",
   "ds_default_socket": "### `ds_default_socket` (str)\n\nDefault socket to be used for sending pings and dispatching requests\nwhen a gateway has no send socket configured.\n\n*By default no default socket is defined, the first configuration script\n*listen* directive is used.*\n\nIf parameter \"ds_default_sockname\" is set, then this parameter is\nignored.\n\n```\n...\nmodparam(\"dispatcher\", \"ds_default_socket\", \"udp:192.168.0.125:5060\")\n...\n```\n",
   "ds_default_sockname": "### `ds_default_sockname` (str)\n\nDefault socket name to be used for sending pings and dispatching\nrequests when a gateway has no send socket configured.\n\n*By default no default socket is defined, the first configuration script\n*listen* directive is used.*\n\nThis parameter is used even if \"ds_default_socket\" parameter is set\n(this parameter has higher priority).\n\n```\n...\n listen=udp:1.2.3.4:5060 name \"sock1\"\n...\nmodparam(\"dispatcher\", \"ds_default_sockname\", \"sock1\")\n...\n```\n",
   "ds_timer_mode": "### `ds_timer_mode` (int)\n\nSpecify the timer process to be used by the module for keepalives and\nactive dialogs tracking.\n\nIt can be set to:\n\n- 0 - use main timer process.\n\n- 1 - use secondary timer process.\n\nOn a server with a lot of traffic, using secondary timer can help with\nperformances, because the main timer can be overloaded by taking care of\ntransactions retransmissions and expirations of items in memory.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_timer_mode\", 1)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues are: 'dispatcher:dst-down', 'dispatcher:dst-up'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"dispatcher\", \"event_callback\", \"ksr_dispatcher_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_dispatcher_event(evname)\n    KSR.info(\"===== dispatcher module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "ds_attrs_none": "### `ds_attrs_none` (int)\n\nIf set to 1, \"none=yes\" is set in the attrs for those records that have\nno attrs value, to ensure that corresponding XAVP fields for records do\nnot get mixed up.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_attrs_none\", 1)\n...\n```\n",
   "ds_db_extra_attrs": "### `ds_db_extra_attrs` (str)\n\nSet a list of column names to be loaded from database dispatcher table\nand be concatenated to 'attrs' field. The format is:\n'aname1=cname1;aname2=cname2;...;anameN=cnameN'.\n\nThe 'anameX' is the attribute name and 'cnameX' is column name. The\nadditional columns must be added to database dispatcher table and their\ntype must be VARCHAR (string).\n\n*Default value is \u201cempty\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_db_extra_attrs\", \"socket=socket;pref=prefix\")\n...\n```\n",
   "ds_load_mode": "### `ds_load_mode` (int)\n\nIf set to 1, the module throws error when failing to add a destination\naddress (e.g., invalid URI). If set to 0, it skips the failing address\nand continues with the next ones.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_load_mode\", 1)\n...\n```\n",
   "reload_delta": "### `reload_delta` (int)\n\nThe number of seconds that have to be waited before executing a new\nreload of dispatcher records. By default there is a rate limiting of\nmaximum one reload in five seconds.\n\nIf set to 0, no rate limit is configured. Note carefully: use this\nconfiguration only in tests environments because executing many RPC\nreload commands at the same time can cause unexpected behavior.\n\n*Default value is \u201c5\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"reload_delta\", 1)\n...\n        \n```\n",
   "ds_dns_mode": "### `ds_dns_mode` (int)\n\nSpecify the how DNS resolving is done for destination addresses.\n\nIt is a bitwise flag and can be set to one or the sum of:\n\n- 1 - do it at startup and reload (previous behaviour).\n\n- 2 - do it always when the address is matched with ds_is_from_list().\n\n- 4 - do it startup/reload and refresh on the timer interval specified\n  by ds_dns_interval.\n\n- 8 - do SRV (and NAPTR if enabled in core) query instead of A/AAAA\n  lookup. NAPTR is done if protocol and port are not set. SRV is done if\n  port is not set.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_dns_mode\", 2)\n...\n```\n",
   "ds_dns_interval": "### `ds_dns_interval` (int)\n\nThe interval in seconds to periodically refresh the DNS queries for\ndestination addresses if ds_dns_mode has value 4 set.\n\n*Default value is \u201c600\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_interval_mode\", 1800)\n...\n```\n",
   "ds_dns_ttl": "### `ds_dns_ttl` (int)\n\nThe interval in seconds to set TTL for DNS results received for queries\ndones inside this module. If 0, this TTL is not set, result and core\nvalues are used.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dispatcher\", \"ds_interval_mode\", 7200)\n...\n```\n"
  },
  "functions": {
   "ds_select_dst": "### `ds_select_dst(set, alg[, limit])`\n\nThe method selects a destination from addresses set. It returns true if\na new destination is set. The selected address is set to dst_uri field\n(aka the outbound proxy address or the $du variable), not being visible\nin the SIP request.\n\nIf the bit 2 in 'flags' parameter is set, the rest of the addresses from\nthe destination set are stored in XAVP list (limited with an optional\n'limit' parameter). You can use 'ds_next_dst()' to use next address in\norder to achieve serial forking to all possible destinations.\n\nMeaning of the parameters is as follows:\n\n- *set* - the id of the set from where to pick up destination address.\n  It is the first column in destination list file. The parameter can be\n  an integer or a variable holding an integer.\n\n- *alg* - the algorithm used to select the destination address. The\n  parameter can be an integer or a variable holding an integer.\n\n  - \u201c0\u201d - hash over callid\n\n  - \u201c1\u201d - hash over from URI.\n\n  - \u201c2\u201d - hash over to URI.\n\n  - \u201c3\u201d - hash over request-URI user.\n\n  - \u201c4\u201d - round-robin (next destination).\n\n  - \u201c5\u201d - hash over authorization-username (Proxy-Authorization or\n    \"normal\" authorization). If no username is found, round robin is\n    used.\n\n  - \u201c6\u201d - random destination (using rand()).\n\n  - \u201c7\u201d - hash over the content of PVs string. Note: This works only\n    when the parameter hash_pvar is set.\n\n  - \u201c8\u201d - select destination sorted by priority attribute value (serial\n    forking ordered by priority).\n\n  - \u201c9\u201d - use weight based load distribution. You have to set the\n    attribute 'weight' for each address (gateway) in destination set.\n    See also the description of the 'weight' attribute in the 'Special\n    Attributes' section.\n\n  - \u201c10\u201d - use call load distribution. You have to set the attribute\n    'duid' (as an unique string id) per each address in destination set.\n    Also, you must set the parameter 'ds_hash_size'.\n\n    The algorithm can be used even with stateless proxy mode, there is\n    no SIP dialog tracking depending on other modules, just an internal\n    lightweight call tracking by Call-Id, thus is fast and suitable even\n    for embedded systems.\n\n    The first destination selected by this algorithm is the one that has\n    the least number of calls associated. The rest of the destination\n    list is taken in order of the entries in set - anyhow, until a\n    re-route to next destination happens, the load on each address can\n    change.\n\n    This algorithm can be used only for dispatching INVITE requests as\n    it is the only SIP method creating a SIP call.\n\n  - \u201c11\u201d - use relative weight based load distribution. You have to set\n    the attribute 'rweight' per each address in destination set. Active\n    host usage probability is rweight/(SUM of all active host rweights\n    in destination group).\n\n    The major difference from the weight distribution is the probability\n    recalculation according to rweight value in case of destinations\n    being active or inactive.\n\n    For example, 100 calls in 3-destinations group with rweight params\n    1/2/1 will be distributed as 25/50/25. If the third destination\n    becomes inactive, the distribution is changed to 33/67/0. If the\n    computation of percentage per destination is not an exact integer\n    number, the value is trucated and the last destination is used to\n    fill the remaining percentage till 100.\n\n    Using this algorithm, you can also enable congestion control by\n    setting the attribute 'cc=1', when 'cc' is enabled the 'weight'\n    attribute will also be used to control congestion tolerance. When\n    facing congestion the weight of a gateway is lowered by 1 for every\n    ms of estimated congestion, a 'rweight' value of 50 is recommended.\n    See the example \"configuring load balancing with congestion\n    detection\" below.\n\n    The congestion estimation is done using an EWMA (see\n    ds_latency_estimator_alpha). If all the gateways in a set are above\n    their congestion threshold(weight), the load distribution is instead\n    done using the ratio of estimated congestion ms.\n\n    See also the description of the 'rweight' attribute in the 'Special\n    Attributes' section.\n\n  - \u201c12\u201d - dispatch to all destination in setid at once (parallel\n    forking). Note that the XAVPs are no longer set with the values of\n    the destination records, no re-routing making sense in this case.\n\n  - \u201c13\u201d - latency optimized dispatching\n\n    - The algorithm will load balance using round-robin prioritizing\n    the gateways with the highest priority.\n\n    - If ds_ping_latency_stats is active the algorithm will adjust the\n    priority of the gateway automatically, the priority will be lowered\n    by 1 point every time the latency ms is as high as the priority.\n\n    - If the attribute 'cc=1' is set, the latency used is congestion ms\n    : estimate (current latency ms) - average (normal condition latency\n    ms).\n\n    ```\n    Using this simple formula :\n        ADJUSTED_PRIORITY = PRIORITY - (ESTIMATED_LATENCY_MS/PRIORITY)\n\n    GATEWAY | PRIORITY | ESTIMATED | ADJUSTED | LOAD\n       #    |          |  LATENCY  | PRIORITY | DISTRIBUTION\n       1    |    30    |    21     |    30    | 33%\n       2    |    30    |    91     |    27    | 0%\n       3    |    30    |    61     |    28    | 0%\n       4    |    30    |    19     |    30    | 33%\n       5    |    30    |    32     |    29    | 0%\n       6    |    30    |    0      |    30    | 33%\n       7    |    30    |    201    |    24    | 0%\n\n\n    With congestion control the formula becomes :\n        CONGESTION_MS = CURRENT_LATENCY_MS - NORMAL_CONDITION_LATENCY_MS\n        ADJUSTED_PRIORITY = PRIORITY - (CONGESTION_MS/PRIORITY)\n    ```\n\n  - \u201cX\u201d - if the algorithm is not implemented, the first entry in set is\n    chosen.\n\n\n- *limit* - the maximum number of items to be stored in XAVP list for\n  further fail-overs (the first selected destination and default\n  destination are the first to be put in the list). This can improve the\n  performance especially if you are using a large list of gateways.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nds_select_dst(\"1\", \"0\");\n...\n$var(a) = 4;\nds_select_dst(\"1\", \"$var(a)\");\n...\nds_select_dst(\"1\", \"4\", \"3\");\n...\n\n...\n# sample of SQL provisioning statements\nINSERT INTO \"dispatcher\"\nVALUES(1,1,'sip:192.168.0.1:5060',0,12,'rweight=50;weight=50;cc=1;','');\nINSERT INTO \"dispatcher\"\nVALUES(2,1,'sip:192.168.0.2:5060',0,12,'rweight=50;weight=50;cc=1;','');\n...\nmodparam(\"dispatcher\", \"ds_ping_interval\", 1) # ping gateways once/second\nmodparam(\"dispatcher\", \"ds_ping_latency_stats\", 1) # update congestion metrics\n# configure the latency estimator\nmodparam(\"dispatcher\", \"ds_latency_estimator_alpha\", 900)\n...\nif (!ds_select_dst(\"1\", \"11\")) { # use relative weight based load distribution\n...\n# sample of output from 'kamcmd dispatcher.list'\nDEST: {\n    URI: sip:192.168.0.1:5060\n    FLAGS: AP\n    PRIORITY: 12\n    ATTRS: {\n        BODY: rweight=50;weight=50;cc=1 # configuration values\n        DUID:\n        MAXLOAD: 0\n        WEIGHT: 50\n        RWEIGHT: 50\n        SOCKET:\n        SOCKNAME:\n        OBPROXY:\n    }\n    LATENCY: {\n        AVG: 20.104000\n        STD: 1.273000\n        # estimated congestion is currently 25ms = 45ms(EST) -20ms(AVG)\n        EST: 45.005000\n        MAX: 132\n        TIMEOUT: 3\n    }\n}\n...\n```\n",
   "ds_select_domain": "### `ds_select_domain(set, alg[, limit])`\n\nThe method selects a destination from addresses set and rewrites the\nhost and port from R-URI. The parameters have same meaning as for\nds_select_dst().\n\nIf the bit 2 in 'flags' is set, the rest of the addresses from the\ndestination set are stored in XAVP list (limited with an optional\n'limit' parameter). You can use 'ds_next_domain()' to use next address\nto achieve serial forking to all possible destinations.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\n$var(a) = 4;\nif(ds_select_domain(\"1\", \"$var(a)\")) {\n    t_relay();\n    exit;\n}\n...\n```\n",
   "ds_select": "### `ds_select(set, alg [, limit])`\n\nThe method selects a destination from addresses set and adds it in the\nXAVP specified for this module. It is not updating R-URI nor the\ndestination URI. The parameters have same meaning as for\nds_select_dst().\n\nIf the bit 2 in 'flags' is set, the rest of the addresses from the\ndestination set are stored in XAVP list (limited with an optional\n'limit' parameter). You can execute 'ds_next_domain()' or\n'ds_next_dst()' to use next address to achieve serial forking to all\npossible destinations.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(a) = 4;\nif(ds_select(\"1\", \"$var(a)\")) {\n    ds_next_domain();\n    t_relay();\n    exit;\n}\n...\n```\n",
   "ds_select_routes": "### `ds_select_routes(rules, mode [, limit])`\n\nThe method selects destinations following the rules combining groups add\nalgorithms, controlling where the first destination address is pushed,\nand optionally setting a limit of selected addresses.\n\nParameters:\n\n- *rules* - a string in the format \"grp1=alg1;grp2=alg2;...grpN=algN\",\n  where grpX is an integer number identifying a dispatcher set id and\n  algN is a dispatcher algorithm identifier. No white spaces should be\n  given in the parameter value. The parameter can contain\n  pseudo-variables.\n\n- *mode* - control where to push the first selected target address.\n  Valid values are: '0', 'd' or 'D' to push the address in destination\n  URI; '1', 'r' or 'R' to push the address in R-URI; '2', 'x' or 'X' to\n  push the address only in the XAVP when failure rerouting is enabled.\n  Note that only first character of the parameter matters, therefore one\n  can use a more meaningful value such as 'ruri' instead of 'r'. The\n  parameter can contain pseudo variables.\n\n- *limit* - a positive integer value to restrict the number of selected\n  target addresses. If it is 0, then no limit is considered. The\n  parameter can be a static integer or a variable holding an integer\n  value.\n\nIf the bit 2 in 'flags' is set, the rest of the addresses from the\ndestination groups are stored in XAVP list (limited with an optional\n'limit' parameter). You can execute 'ds_next_domain()' or\n'ds_next_dst()' to use next address to achieve serial forking to all\npossible destinations.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(alg) = 4;\n$var(limit) = 8;\nif(ds_select_routes(\"1=4;2=$var(alg)\", \"ruri\", \"$var(limit)\")) {\n    t_on_failure(\"REROUTE\");\n    t_relay();\n    exit;\n}\nfailure_route[REROUTE] {\n    if(t_check_status(\"408|5[0-9][0-9]\")) {\n        if(ds_next_domain()) {\n            t_on_failure(\"REROUTE\");\n            t_relay();\n            exit;\n        }\n    }\n}\n...\n```\n",
   "ds_next_dst": "### `ds_next_dst()`\n\nTakes the next destination address from the corresponding XAVPs and sets\nthe dst_uri (outbound proxy address).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n",
   "ds_next_domain": "### `ds_next_domain()`\n\nTakes the next destination address from the corresponding XAVPs and sets\nthe domain part of the request URI.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n",
   "ds_set_dst": "### `ds_set_dst()`\n\nTakes the current destination address from the corresponding XAVPs and\nsets the dst_uri (outbound proxy address).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n",
   "ds_set_domain": "### `ds_set_domain()`\n\nTakes the current destination address from the corresponding XAVPs and\nsets the domain part of the request URI.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n",
   "ds_mark_dst": "### `ds_mark_dst([state])`\n\nMark the last used address from destination set as inactive (\"i\"/\"I\"),\nactive (\"a\"/\"A\"), disabled (\"d\"/\"D\") or trying (\"t\"/\"T\"). Apart of\ndisabled state, a destination can be set in probing mode by adding\n(\"p\"/\"P\") flag. With this function, an automatic detection of failed\ngateways can be implemented. When an address is marked as inactive or\ndisabled, it will be ignored by 'ds_select_dst' and 'ds_select_domain'.\n\nThe parameter state is optional, when it is missing, then the\ndestination will be marked inactive (i.e., same as 'i').\n\nPossible values for state parameter:\n\n- *\"a\" or \"A\"* - the last destination should be set to active and the\n  error-counter should set to \"0\".\n\n- *\"i\" or \"I\"* - the last destination should be set to inactive and will\n  be ignored in future requests.\n\n- *\"t\" or \"T\"* - the last destination should be set to temporary trying\n  state and failure counter is incremented. When the failure counter\n  reaches the threshold, the destination will be set inactive.\n\n- *\"p\" and \"P\"* - this has to be used in addition to one of the previous\n  flags - the last destination will be set to probing. This mean the\n  destination will be pinged with SIP OPTIONS requests from time to time\n  to detect if it is up or down.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nfailure_route[tryagain] {\n...\n   if(t_check_status(\"500\"))\n      ds_mark_dst(\"ip\"); # set to inactive and probing\n...\n}\n...\n```\n",
   "ds_list_exists": "### `ds_list_exists(groupid)`\n\nFunction alias: ds_list_exist(groupid)\n\nCheck if a specific group is defined in dispatcher list or database.\n\n- *groupid* - A group ID to check.\n\nIt returns true (value 1) if the group exists, or otherwise false (-1\nwhen the group is not found; -2 when evaluating the parameter fails).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(ds_list_exists(\"10\")) {\n    ...\n}\n...\n```\n",
   "ds_is_from_list": "### `ds_is_from_list([groupid [, mode [, uri] ] ])`\n\nThis function returns true, if there is a match of source address or uri\nwith an address in the given group of the dispatcher-list; otherwise\nfalse.\n\nDescription of parameters:\n\n- *groupid* (optional) - if not given or its value is -1, the matching\n  will be done over all addresses in all dispatcher groups. Otherwise\n  the matching will be done only against the addresses in the specific\n  group id. The parameter can be an integer or a variable holding an\n  integer value.\n\n- *mode* - (optional) - a bitmask to specify how the matching should be\n  done. If the parameter is missing, the matching is done with ignoring\n  the protocol (value 2). If parameter is 0, all ip, port and proto are\n  matched and active status is ignored. If bit one is set, then port is\n  ignored. If bit two is set, then protocol is ignored. If bit three is\n  set, then state must be active. If bit four is set, then\n  socket/sockname be matched. If bit five is set, then try to find the\n  most closest target from all dispatcher targets with the mandatory ip\n  and combination of local socket, protocol, port, the weighted search\n  result is combined from bit flags of matched components: ip - 1,\n  port - 2, protocol - 4, local socket - 8, the target with the maximum\n  value of flags combination will be selected. The parameter can be an\n  integer or a variable holding an integer value. It must be provided if\n  the uri parameter is provided.\n\n- *uri* (optional) - if parameter is empty or missing, the matching is\n  done against source IP, port and protocol. Otherwise the value has to\n  be a valid SIP URI, used to match against addresses in the dispatcher\n  list. Only IP, port and protocol are matches, any additional\n  parameters are ignored. The parameter can be a static or dynamic (with\n  variables) string. The domain part of the URI can be an IP address or\n  a hostname.\n\nUpon a match, the variable specified by 'setid_pvname' parameter will be\nset to groupid of matching address and the attributes will be set in\nvariable specified by 'attrs_pvname'.\n\nNote that for backward compatibility mode, when no parameter is given or\nonly groupid is given, the matching is done only for IP address and port\n(protocol is ignored).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(ds_is_from_list()) {\n    ...\n}\nif(ds_is_from_list(\"10\")) {\n    ...\n}\nif(ds_is_from_list(\"10\", \"3\")) {\n    ...\n}\nif(ds_is_from_list(\"10\", \"3\", \"sip:127.0.0.1:5080\")) {\n    ...\n}\n...\n```\n",
   "ds_is_active": "### `ds_is_active(groupid [, uri])`\n\nThis function returns true, if there is an active URI in the destination\ngroup; otherwise false. If the uri parameter is provided, then the\ncorresponding destination has to be active.\n\nDescription of parameters:\n\n- *groupid* - the group id. The parameter can be an integer or a\n  variable holding an integer value.\n\n- *uri* (optional) - the URI of the destination. if parameter is empty\n  or missing, the any destination is matched.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(ds_is_active(\"10\")) {\n    ...\n}\nif(ds_is_active(\"10\", \"sip:127.0.0.1:5080\")) {\n    ...\n}\n...\n```\n",
   "ds_load_update": "### `ds_load_update()`\n\nUpdates the load state:\n\n- if it is a BYE or CANCEL - remove the load from destination address\n  used to forward the INVITE\n\n- if it is a reply to INVITE - set internal state to confirmed for call\n  load structure when reply code is 2xx.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE and ONREPLY_ROUTE.\n",
   "ds_load_unset": "### `ds_load_unset()`\n\nRemove the call load for the destination that routed the call.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE and ONREPLY_ROUTE.\n\n```\n...\nroute {\n    ...\n    if(is_method(\"BYE|CANCEL\"))\n        ds_load_update();\n    ...\n    ds_select_dst(\"1\", \"10\");\n    ...\n}\n\nonreply_route {\n    ...\n    if(is_method(\"INVITE\")\n    {\n        if(status=~\"2[0-9][0-9]\")\n            ds_load_update();\n        else if(status=~\"[3-7][0-9][0-9]\")\n            ds_load_unset();\n    }\n    ...\n}\n...\n```\n",
   "ds_reload": "### `ds_reload()`\n\nReloads the groups and included destinations.\n\nName: *ds_reload*\n\nParameters: *none*\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    ds_reload();\n...\n```\n",
   "ds_dsg_fetch": "### `ds_dsg_fetch(setid)`\n\nSets the destination group id to setid for fetching $dsg(key)\nattributes.\n\nParameters: *setid* - integer or variable holding the set id value\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    ds_dsg_fetch(\"1\");\n    xinfo(\"set id: 1 - all: $dsg(count); active: $dsg(active)\\n\");\n...\n```\n"
  }
 },
 "diversion": {
  "overview": "The module implements the Diversion extensions as per RFC 5806. The\ndiversion extensions are useful in various scenarios involving call\nforwarding. Typically one needs to communicate the original recipient of\nthe call to the PSTN gateway and this is what the diversion extensions\ncan be used for.\n\n<div class=\"warning\">\n\n\nNote that RFC 5806 has historic status.\n\n</div>\n",
  "parameters": {
   "suffix": "### `suffix` (string)\n\nThe suffix to be appended to the end of the header field. You can use\nthe parameter to specify additional parameters to be added to the header\nfield, see the example.\n\nDefault value is \u201c\u201d (empty string).\n\n```\nmodparam(\"diversion\", \"suffix\", \";privacy=full\")\n```\n"
  },
  "functions": {
   "add_diversion": "### `add_diversion(reason [, uri])`\n\nThe function adds a new diversion header field before any other existing\nDiversion header field in the message (the newly added Diversion header\nfield will become the topmost Diversion header field). If 'uri'\nparameter is missing, the inbound (without any modifications done by the\nproxy server) Request-URI will be used as the Diversion URI.\n\nMeaning of the parameters is as follows:\n\n- *reason* - The reason string to be added as the reason parameter\n\n- *uri* - The URI to be set in Diversion header\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\nadd_diversion(\"user-busy\");\nadd_diversion(\"user-busy\", \"$ru\");\n...\n```\n"
  }
 },
 "dlgs": {
  "overview": "This module tracks dialogs (active calls) in stateless mode and offers\nstatistics about them.\n\nThe dialogs can be tagged and the number of dialogs with the same tag\ncan be retrieved in configuration file.\n\nThe module aims to be a lightweight alternative to dialog module, to\nenable SIP server instances (such as an edge proxy or SBC) to know how\nmany active calls they route, without being a call stateful proxy. The\ntracking of active calls is done without any dependency on other\nmodules, in other words, it does not need the tm (transaction\nmanagement) module.\n",
  "parameters": {
   "active_lifetime": "### `active_lifetime` (int)\n\nThe lifetime in seconds of an active dialog in memory. A dialog is\nconsidered active after the ACK of 200 OK for INVITE.\n\n*Default value is 10800 (3 hours).*\n\n```\n...\nmodparam(\"dlgs\", \"active_lifetime\", 3600)\n...\n```\n",
   "init_lifetime": "### `init_lifetime` (int)\n\nThe lifetime in seconds of an initial dialog in memory. A dialog is in\ninitial state from the moment of creation until it gets to active state.\nIf the dialog stays longer in the initial state, then it is destroyed by\nthe next timer cleanup.\n\n*Default value is 180 (3 minutes).*\n\n```\n...\nmodparam(\"dlgs\", \"init_lifetime\", 240)\n...\n```\n",
   "finish_lifetime": "### `finish_lifetime` (int)\n\nThe lifetime in seconds of a finished dialog in memory. A dialog is\nfinished if the initial INVITE was not answered or the BYE was received.\nOnce this lifetime passes, the dialog record is removed from memory by\nthe next timer cleanup.\n\n*Default value is 10 (seconds).*\n\n```\n...\nmodparam(\"dlgs\", \"finish_lifetime\", 20)\n...\n```\n",
   "timer_interval": "### `timer_interval` (int)\n\nThe value in seconds to run the timer callback function for cleaning up\ndialogs past the lifetime limit.\n\n*Default value is 30.*\n\n```\n...\nmodparam(\"dlgs\", \"timer_interval\", 60)\n...\n```\n",
   "hash_size": "### `hash_size` (integer)\n\nThe size of the hash table internally used to keep the dialogs. A larger\ntable is much faster but consumes more memory. The hash size must be a\npower of two.\n\n*Default value is \u201c9\u201d.*\n\n```\n...\nmodparam(\"dlgs\", \"hash_size\", 5)\n...\n```\n"
  },
  "functions": {
   "dlgs_init": "### `dlgs_init(src, dst, data)`\n\nStart track the dialog corresponding to the current SIP message. It has\nto be used for INVITE messages.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nONREPLY_ROUTE, ONSEND_ROUTE.\n\n```\n...\nonsend_route {\n    ...\n    if(is_method(\"INVITE\")) {\n        dlgs_init(\"$fu\", \"$tu\", \"my data\");\n    }\n    ...\n}\n...\n```\n",
   "dlgs_update": "### `dlgs_update()`\n\nUpdate dialog state. It has to be used for SIP requests only, the SIP\nresponses are handled automatically.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nONSEND_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(is_method(\"ACK|BYE|CANCEL\")) {\n        dlgs_update();\n    }\n    ...\n}\n...\n```\n",
   "dlgs_count": "### `dlgs_count(field, op, data)`\n\nReturn the number of dialogs matching the filter specified by the\nparameters. It does not count the dialogs that are finished (not\nanswered or terminated with BYE).\n\nThe field parameter can be: 'src', 'dst', 'data' to specify what dialog\nattribute has to be used for matching. It can be also 'any' to get the\ncount of all ongoing dialogs.\n\nThe op parameter can be: 'eq' - equal; 'ne' - not equal; 're' - regex;\n'sw' - start with; 'fm' - fnmatch.\n\nIn case of error or no dialog matched, it returns -1 or other negative\n(false) value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    $var(count) = dlgs_count(\"src\", \"eq\", \"$fu\");\n    if($var(count) > 0) {\n        # caller has ongoing dialogs\n    }\n    ...\n    $var(allcalls) = dlgs_count(\"any\", \"eq\", \"*\");\n    if($var(allcalls) > 0) {\n        # there are ongoing dialogs\n    }\n    ...\n}\n...\n```\n",
   "dlgs_tags_add": "### `dlgs_tags_add(vtag)`\n\nAdd a tag to current dialog.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    dlgs_tags_add(\"$si\");\n    ...\n}\n...\n```\n",
   "dlgs_tags_rm": "### `dlgs_tags_rm(vtag)`\n\nRemove a tag from current dialog.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    dlgs_tags_rm(\"$si\");\n    ...\n}\n...\n```\n",
   "dlgs_tags_count": "### `dlgs_tags_count(vtag)`\n\nCount all tags for ongoing dialogs matching the parameter.\n\nIt returns -1 if no tag for ongoing dialogs is matched or there was an\nerror.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    $var(tcount) = dlgs_tags_count(\"$si\");\n    ...\n}\n...\n```\n"
  }
 },
 "dmq": {
  "overview": "The DMQ module implements a distributed message queue on top of Kamailio\nin order to facilitate data propagation and replication between multiple\ninstances, referred as \"nodes\" (or \"peers\").\n\nThe DMQ data flow between nodes is grouped in a logical entity referred\nas \"channel\" (or \"bus\"), many flows (channels) can be active at the same\ntime.\n\nThe communication between the nodes is done using SIP messages, after\nall Kamailio's best ability is routing SIP traffic, therefore reusing\nthe same protocol empowers DMQ cluster with flexible routing policies,\nadvanced authorization and security policies, a.s.o. DMQ sends SIP\nrequests using the *KDMQ* request method (a custom method type specific\nto Kamailio, compliant with SIP specifications RFC3261). Data can be\nsent to all the other active nodes (aka \"broadcast\") or to a specific\nsingle node (aka \"unicast\").\n\nThe nodes can utilize the DMQ channels to pass messages between them to\ndistribute data for various services (e.g., cached items, location\nrecords, active calls, ...). This grouping of messages on channels (per\nservice) is similar to the topic concept in a typical pub/sub system.\nThe channel name appears in the R-URI username part of KDMQ requests.\n\nThe DMQ cluster transparently deals with node discovery, availability,\nconsistency, retransmissions, etc. A new node can join the DMQ cluster\nby sending an availability notification to an existing node in the\nclusters. Nodes that are not responding to KDMQ reguests are removed the\nfrom local list of active nodes, no longer being considered to be part\nof the KDMQ cluster.\n\nIMPORTANT: DMQ must be used only between Kamailio instances having same\nmajor version. Internal structures can be incompatible between different\nmajor versions and can lead to crashes or unexpected behaviour.\n",
  "parameters": {
   "server_address": "### `server_address`(str)\n\nThe local server address. This is the address with which the local DMQ\nnode joins the servers group to send/receive messages.\n\nNote: if server_socket is not set, then this address has to match a\nlocal socket, which will be used to send/receive messages.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"dmq\", \"server_address\", \"sip:10.0.0.20:5060\")\n...\nmodparam(\"dmq\", \"server_address\", \"sip:10.0.0.20:5061;transport=tls\")\n...\n```\n",
   "server_socket": "### `server_socket`(str)\n\nThe local listen address. This is the interface over which the DMQ\nengine will send/receive messages.\n\nNote: if this parameter is not set, the socket to send/receive messages\nis built from server_address parameter.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"dmq\", \"server_socket\", \"udp:10.0.0.20:5060\")\n...\n```\n",
   "notification_address": "### `notification_address`(str)\n\nThe address of another DMQ node from which the local node should\nretrieve initial information about all other nodes. This parameter can\nbe specified multiple times in the configuration, to configure multiple\nnotification servers. If you configure multiple notification servers,\nthe *multi_notify* parameter needs to be disabled.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"dmq\", \"notification_address\", \"sip:10.0.0.21:5060\")\n...\nmodparam(\"dmq\", \"notification_address\", \"sip:10.0.0.21:5061;transport=tls\")\n...\n```\n",
   "notification_channel": "### `notification_channel`(str)\n\nThe name of the channel for notifications about peers availability.\n\n*Default value is \u201cnotification_peer\u201d.*\n\n```\n...\nmodparam(\"dmq\", \"notification_channel\", \"peers\")\n...\n```\n",
   "multi_notify": "### `multi_notify`(int)\n\nEnables the ability to resolve multiple IPv4/IPv6 addresses for a single\nnotification address. Please note that this mode is not supported if you\nspecify multiple notification address parameter.\n\nA value of zero resolves to the first IP address found. A non-zero value\nresolves to all IP addresses associated with the host. This includes\naddresses from DNS SRV records, A and AAAA records.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"dmq\", \"multi_notify\", 1)\n...\n```\n",
   "num_workers": "### `num_workers`(int)\n\nThe number of worker threads for sending/receiving messages.\n\n*Default value is \u201c2\u201d.*\n\n```\n...\nmodparam(\"dmq\", \"num_workers\", 4)\n...\n```\n",
   "worker_usleep": "### `worker_usleep`(int)\n\nThe default locking/synchronisation mechanism between producer/consumer\nthreads is the optimum for most environments. On some systems (e.g.\nFreeBSD) it can cause high CPU load and in such cases, it can be useful\nto disable locking and switch to polling for tasks at set intervals\ninstead - putting the thread to sleep in-between and taking it out of\nprocess during that time.\n\nA value >0 will disable the default locking and set the polling\ninterval (in microseconds), which can be tuned to suit the specific\nenvironment.\n\n*Default value is 0 (recommended for most systems).*\n\n```\n...\nmodparam(\"dmq\", \"worker_usleep\", 1000)\n...\n```\n",
   "ping_interval": "### `ping_interval`(int)\n\nThe number of seconds between node pings (for checking status of other\nnodes).\n\n*Minimum value is \u201c60\u201d (default).*\n\n```\n...\nmodparam(\"dmq\", \"ping_interval\", 90)\n...\n```\n"
  },
  "functions": {
   "dmq_handle_message": "### `dmq_handle_message([continue])`\n\nHandles a DMQ message by passing it to the appropriate local peer\n(module). The peer is identified by the user part of the To header.\n\nMeaning of parameters:\n\n- *continue* - by default, dmq_handle_message() will end execution of\n  routing script. If this optional parameter is set to \"1\",\n  dmq_handle_message() will continue executing the routing script after\n  it's been called.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    if(is_method(\"KDMQ\")) {\n        dmq_handle_message();\n    }\n...\n```\n",
   "dmq_process_message": "### `dmq_process_message([continue])`\n\nSimilar to dmq_handle_message, but the processing is happening\nimmediately, no longer cloning the request in shared memory to be passed\nto a DMQ worker process.\n\nMeaning of parameters:\n\n- *continue* - by default, dmq_process_message() will end execution of\n  routing script by returning 0. If this optional parameter is set to\n  \"1\", dmq_process_message() will continue executing the routing script\n  after it is been executed, returning 1.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    if(is_method(\"KDMQ\")) {\n        dmq_process_message();\n    }\n...\n```\n",
   "dmq_send_message": "### `dmq_send_message(channel, node, body, content_type)`\n\nSends a DMQ message directly from config file to a single node.\n\nMeaning of parameters:\n\n- *channel* - name of the channel that should handle the message.\n\n- *node* - the SIP address of the node to which the message should be\n  sent.\n\n- *body* - the message body.\n\n- *content_type* - the MIME type of the message body.\n\nThis function can be used from any route.\n\n```\n...\n    dmq_send_message(\"channel1\", \"sip:10.0.0.21:5060\", \"Message body...\", \"text/plain\");\n...\n```\n",
   "dmq_bcast_message": "### `dmq_bcast_message(channel, body, content_type)`\n\nBroadcasts a DMQ message from config file to all active nodes (except\nself) on the specific channel.\n\nMeaning of parameters:\n\n- *channel* - name of the channel that should handle the message.\n\n- *body* - the message body.\n\n- *content_type* - the MIME type of the message body.\n\nThis function can be used from any route.\n\n```\n...\n    dmq_bcast_message(\"channel1\", \"Message body...\", \"text/plain\");\n...\n```\n",
   "dmq_t_replicate": "### `dmq_t_replicate([skip_loop_test])`\n\nReplicates the current SIP message to all active nodes (except self).\nUseful for replicating REGISTER, PUBLISH etc. in a clustered\nenvironment.\n\nMeaning of parameters:\n\n- *skip_loop_test* - by default, DMQ checks the source IP of the message\n  prior to replication, to ensure it has not been sent by another DMQ\n  node (to avoid infinite loops). If this optional parameter is set to\n  \"1\", the loop test is not performed. This makes sense, from a\n  performance perspective, if you have already performed the necessary\n  checks in the config script (see dmq_is_from_node()).\n\nThis function can be used from REQUEST_ROUTE only.\n\n```\n...\n    dmq_t_replicate();\n...\n        \n```\n",
   "dmq_is_from_node": "### `dmq_is_from_node()`\n\nChecks whether the current message has been sent by another active DMQ\nnode in the cluster.\n\nThis function can be used from REQUEST_ROUTE only.\n\n```\n...\n    # basic example for REGISTER replication\n    if(is_method(\"REGISTER\")) {\n        if (dmq_is_from_node()) {\n            # coming from a DMQ node - already authenticated there\n            # now just save contact, etc...\n        } else {\n            # coming from end point - authenticate, save contact, etc...\n            dmq_t_replicate(\"1\"); # source address checked, skip the loop test\n        }\n    }\n...\n                \n```\n"
  }
 },
 "dmq_usrloc": {
  "overview": "The module adds user location (usrloc) records replication between\nmultiple servers via DMQ module.\n",
  "parameters": {
   "enable": "### `enable` (int)\n\nThe parameter controls whether the replication is active or not. The\nvalue can be:\n\n- 0 - replication is disabled\n\n- 1 - replication is enabled\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"enable\", 1)\n...\n```\n",
   "sync": "### `sync` (int)\n\nThe parameter controls whether to request synchronization of all usrloc\nrecords at startup. The value can be:\n\n- 0 - disabled\n\n- 1 - enabled\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"sync\", 0)\n...\n```\n",
   "batch_size": "### `batch_size` (int)\n\nThe parameter controls whether to throttle synchronization of all\ncontacts in batches. Once a batch of SIP requests is sent out, then\nsleep for 'batch_usleep' microseconds. The value can be:\n\n- <=0 - disabled (no batching)\n\n- >0 - how many records to be sent in a batch\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"batch_size\", 4000)\n...\n```\n",
   "batch_usleep": "### `batch_usleep` (int)\n\nThe parameter controls whether to throttle synchronization of all\ncontacts in batches. Once a batch of SIP requests is sent out, then\nsleep for 'batch_usleep' microseconds. The value can be:\n\n- <=0 - no sleep (it disables the batching)\n\n- >0 - how many microseconds to sleep before sending out another batch\n  of usrloc records.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"batch_usleep\", 1000)\n...\n```\n",
   "batch_msg_size": "### `batch_msg_size` (int)\n\nThe parameter controls the size of the messages during a sync. This is\nto make sure the messages are never larger than 65536 (the maximum\ndatagram size).\n\nNote that batch_msg_contacts will also be checked.\n\n*Default value is 60000. Maximum value is 60000.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"batch_msg_contacts\", 50)  # 50 contacts / message\nmodparam(\"dmq_usrloc\", \"batch_msg_size\", 500000)\n# with this config, when doing a full sync, each message will be sent a soon as the body is larger 50K or contains 50 contacts\n...\n```\n",
   "batch_msg_contacts": "### `batch_msg_contacts` (int)\n\nThe parameter controls the amount of contact per message/transaction\nduring a sync.\n\nNote that batch_msg_size will also be checked.\n\n*Default value is 1. Maximum value is 150.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"batch_msg_contacts\", 50)  # 50 contacts / message\nmodparam(\"dmq_usrloc\", \"batch_size\", 10000)       # 10000 contacts / batch\nmodparam(\"dmq_usrloc\", \"batch_usleep\", 500000)    # one batch every 500ms\n# syncing 20K contacts/second with 50 contacts/message\n...\n```\n",
   "usrloc_domain": "### `usrloc_domain` (string)\n\nThe usrloc domain to synchronize.\n\n*Default value is \u201clocation\u201d.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"usrloc_domain\", \"my_domain\")\n...\n```\n",
   "replicate_socket_info": "### `replicate_socket_info` (int)\n\nThe parameter controls whether the socket replication is active or not.\nThis is important for anycast scenarios. The value can be:\n\n- 0 - disabled\n\n- 1 - enabled, replicate socket by proto:host:port\n\n- 2 - enabled, replicate socket by socket name\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"replicate_socket_info\", 1)\n...\n```\n",
   "usrloc_delete": "### `usrloc_delete` (int)\n\nEnable (1) or disable (0) synchronizing usrloc delete actions. Disabling\ndelete actions can be useful when user location data is ephemeral.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"dmq_usrloc\", \"usrloc_delete\", 0)\n...\n```\n"
  },
  "functions": {}
 },
 "dnssec": {
  "overview": "The module replaces the common system dns resolver functions from core\nwith the DNSSEC wrappers provided by libval. Practically, by loading the\nmodule, Kamailio will make use of extensions to DNS which provide origin\nauthentication of DNS data, authenticated denial of existence, and data\nintegrity.\n\nThere is no module parameter that should be set nor function that has to\nbe executed by the configuration file. Existing SIP server deployments\ncan be updated to use DNSSEC by loading this module and setting\nappropriate DNS server to the operating system.\n\nInstalling libval can be done from\n[https://www.dnssec-tools.org](https://www.dnssec-tools.org/).\n\nMore details about DNSSEC are available at:\n<http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions>.\n",
  "parameters": {
   "general_query_flags": "### `general_query_flags` (integer)\n\nSet this parameter to an integer value containing of an ORed result of\none or more of the following values (constant present only for\ndocumentation process, as they are mostly mapped to libval flags).\nSetting this parameter will cause the libval defaults to be completely\noverwritten\n\nQUERY_DONT_VALIDATE == 1<<0 causes the validator to disable validation\nfor this query.\n\nQUERY_IGNORE_SKEW == 1<<1 causes the validator to disable checking\nsignature inception and expiration times on RRSIGs.\n\nQUERY_AC_DETAIL == 1<<2 causes the validator to copy the\nauthentication chain details into the val_rc_answer member within the\nreturned val_result_chain structure.\n\nQUERY_NO_DLV == 1<<3 causes the validator to disable DLV processing\nfor this query. This is only available if the libval(3) library has been\ncompiled with DLV support.\n\nQUERY_NO_EDNS0_FALLBACK = 1<<4 In querying various name servers,\nlibsres will also attempt multiple EDNS0 sizes, ending with a query that\nhas EDNS0 disabled (i.e. no CD bit set). This option causes libval to\ndisable EDNS0 fallback for the query.\n\nQUERY_RECURSE == 1<<5 forces libval to recursively answer the query by\niteratively querying various name servers in the delegation hierarchy,\ninstead of requesting this information from any caching name server that\nmay be configured in dnsval.conf\n\nSKIP_RESOLVER == 1<<6 forces libval to only look at its cache while\ntrying to resolve a name.\n\nSKIP_CACHE == 1<<7 forces libval to ignore cached data while trying to\nresolve a name.\n\n*Default value is 0(no changes)*\n\n```\n ...\n modparam(\"dnssec\", \"general_query_flags\", 1) # QUERY_DONT_VALIDATE disable validation\n modparam(\"dnssec\", \"general_query_flags\", 10) # QUERY_IGNORE_SKEW | QUERY_NO_DLV\n ...\n \n```\n"
  },
  "functions": {}
 },
 "domain": {
  "overview": "Domain module implements checks that based on domain table determine if\na domain is \u201clocal\u201d. A \u201clocal\u201d domain is one that the proxy is\nresponsible for. SIP URIs of local users must have hostpart that is\nequal to one of these domains.\n\nDomain module reads the contents of domain and domain_attrs tables into\ncache memory when the module is loaded. Any changes in domain or\ndomain_attrs tables must thus be followed by \u201cdomain.reload\u201d rpc command\nin order to reflect them in module behavior.\n\nCaching is implemented using a hash table. The size of the hash table is\ngiven by HASH_SIZE constant defined in domain_mod.h. Its \u201cfactory\ndefault\u201d value is 128.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThis is URL of the database to be used.\n\nDefault value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d\n\n```\nmodparam(\"domain\", \"db_url\", \"mysql://ser:pass@db_host/ser\")\n```\n",
   "domain_table": "### `domain_table` (string)\n\nName of table containing names of local domains that the proxy is\nresponsible for.\n\nDefault value is \u201cdomain\u201d.\n\n```\nmodparam(\"domain\", \"domain_table\", \"new_name\")\n```\n",
   "domain_attrs_table": "### `domain_attrs_table` (string)\n\nName of table containing attributes of local domains.\n\nDefault value is \u201cdomain_attrs\u201d.\n\n```\nmodparam(\"domain\", \"domain_attrs_table\", \"local_domain_attributes\")\n```\n",
   "did_col": "### `did_col` (string)\n\nName of column containing domain id (did) of domain in domain and\ndomain_attrs tables. In domain table, a did column value may be NULL,\nwhich means that it has same value as domain column.\n\nDefault value is \u201cdid\u201d.\n\n```\nmodparam(\"domain\", \"did_col\", \"domain_did\")\n```\n",
   "domain_col": "### `domain_col` (string)\n\nName of column containing domain name in domain table.\n\nDefault value is \u201cdomain\u201d.\n\n```\nmodparam(\"domain\", \"domain_col\", \"domain_name\")\n```\n",
   "name_col": "### `name_col` (string)\n\nName of column containing attribute name in domain_attrs table.\n\nDefault value is \u201cname\u201d.\n\n```\nmodparam(\"domain\", \"name_col\", \"attr_name\")\n```\n",
   "type_col": "### `type_col` (string)\n\nName of column containing attribute type in domain_attrs table. Type\nvalue 0 is integer and type value 2 is string.\n\nDefault value is \u201ctype\u201d.\n\n```\nmodparam(\"domain\", \"type_col\", \"attr_type\")\n```\n",
   "value_col": "### `value_col` (string)\n\nName of column containing attribute value in domain_attrs table.\n\nDefault value is \u201cvalue\u201d.\n\n```\nmodparam(\"domain\", \"value_col\", \"attr_value\")\n```\n",
   "register_myself": "### `register_myself` (integer)\n\nRegister the list of domains to match 'myself' check: 0 means no myself\nregistration, 1 means enable myself registration.\n\nDefault value is 0 (disable).\n\n```\nmodparam(\"domain\", \"register_myself\", 1)\n```\n"
  },
  "functions": {
   "is_from_local": "### `is_from_local()`\n\nChecks based on domain table if host part of From header uri is one of\nthe local domains that the proxy is responsible for\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n```\n...\nif (is_from_local()) {\n    ...\n};\n...\n        \n```\n",
   "is_uri_host_local": "### `is_uri_host_local()`\n\nIf called from route or failure route block, checks based on domain\ntable if host part of Request-URI is one of the local domains that the\nproxy is responsible for. If called from branch route, the test is made\non host part of URI of first branch, which thus must have been appended\nto the transaction before is_uri_host_local() is called.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n```\n...\nif (is_uri_host_local()) {\n    ...\n};\n...\n        \n```\n",
   "is_domain_local": "### `is_domain_local(domain)`\n\nThis function checks if the domain contained in the parameter is local.\nThe parameter can be a static string or contain pseudo-variables.\n\nThis function is a generalized form of the is_from_local() and\nis_uri_host_local() functions, being able to completely replace them and\nalso extends them by allowing the domain to be taken from any of the\nabove mentioned sources. The following equivalences exist:\n\n- is_domain_local(\"$rd\") is same as is_uri_host_local()\n\n- is_domain_local(\"$fd\") is same as is_from_local()\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n```\n...\nif (is_domain_local(\"$rd\")) {\n    ...\n}\nif (is_domain_local(\"my.domain.com\")) {\n    ...\n}\nif (is_domain_local(\"$fd\")) {\n    ...\n}\nif (is_domain_local(\"$avp(some_avp_alias)\")) {\n    ...\n}\nif (is_domain_local(\"$avp(i:850)\")) {\n    ...\n}\nif (is_domain_local(\"$avp(s:some_avp)\")) {\n    ...\n}\n...\n        \n```\n",
   "lookup_domain": "### `lookup_domain(domain [, prefix])`\n\nThis function checks if domain given in domain argument is local and, if\nso, adds attributes associated with domain's id (did) to AVPs. If prefix\nargument (string) is given, names of attributes are prefixes by it. In\naddition to attributes given in domain_attrs table, AVP named did\ncontaining the did of domain is added.\n\nBoth parameters can contain pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n```\n...\nif (lookup_domain(\"$fd\", \"from_\")) {\n    xlog(\"L_INFO\", \"did of domain $fd is $avp(from_did)\\n\");\n}\n...\n        \n```\n"
  }
 },
 "domainpolicy": {
  "overview": "*This module is considered obsolete. The drafts mentioned here have\nexpired. If you use this module, please send a note to the sr-dev\nmailing list.*\n\nThe Domain Policy module implements draft-lendl-domain-policy-ddds-02 in\ncombination with draft-lendl-speermint-federations-02 and\ndraft-lendl-speermint-technical-policy-00. These IETF drafts define DNS\nrecords with which a domain can announce its federation memberships. A\nlocal database can be used to map policy rules to routing policy\ndecisions. This database can also contain rules concerning destination\ndomains independently of draft-lendl-domain-policy-ddds-02.\n\nThis module requires a database. No caching is implemented.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThis is URL of the database to be used.\n\nDefault value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d\n\n```\nmodparam(\"domainpolicy\", \"db_url\", \"postgres://proxy:frog23@db.sip-router.org/sipdb\")\n        \n```\n",
   "dp_table": "### `dp_table` (string)\n\nName of table containing the local support domain policy setup.\n\nDefault value is \u201cdomainpolicy\u201d.\n\n```\nmodparam(\"domainpolicy\", \"dp_table\", \"supportedpolicies\")\n```\n",
   "dp_col_rule": "### `dp_col_rule` (string)\n\nName of column containing the domain policy rule name which is equal to\nthe URI as published in the domain policy NAPTRs.\n\nDefault value is \u201crule\u201d.\n\n```\nmodparam(\"domainpolicy\", \"dp_col_rule\", \"rules\")\n```\n",
   "dp_col_type": "### `dp_col_type` (string)\n\nName of column containing the domain policy rule type. In the case of\nfederation names, this is \"fed\". For standard referrals according to\ndraft-lendl-speermint-technical-policy-00, this is \"std\". For direct\ndomain lookups, this is \"dom\".\n\nDefault value is \u201ctype\u201d.\n\n```\nmodparam(\"domainpolicy\", \"dp_col_type\", \"type\")\n```\n",
   "dp_col_att": "### `dp_col_att` (string)\n\nName of column containing the AVP's name. If the rule stored in this row\ntriggers, than dp_can_connect() will add an AVP with that name.\n\nDefault value is \u201catt\u201d.\n\n```\nmodparam(\"domainpolicy\", \"dp_col_att\", \"attribute\")\n```\n",
   "dp_col_val": "### `dp_col_val` (string)\n\nName of column containing the value for AVPs created by\ndp_can_connect().\n\nDefault value is \u201cval\u201d.\n\n```\nmodparam(\"domainpolicy\", \"dp_col_val\", \"values\")\n```\n",
   "port_override_avp": "### `port_override_avp` (string)\n\nThis parameter defines the name of the AVP where dp_apply_policy() will\nlook for an override port number.\n\nDefault value is \u201cportoverride\u201d.\n\n```\n# string named AVP\nmodparam(\"domainpolicy\", \"port_override_avp\", \"portoverride\")\n```\n",
   "transport_override_avp": "### `transport_override_avp` (string)\n\nName of the AVP which contains the override transport setting.\n\nDefault value is \u201ctransportoverride\u201d.\n\n```\n# string named AVP\nmodparam(\"domainpolicy\", \"transport_override_avp\", \"transportoverride\")\n```\n",
   "domain_replacement_avp": "### `domain_replacement_avp` (string)\n\nName of the AVP which contains a domain replacement.\n\nDefault value is \u201cdomainreplacement\u201d.\n\n```\n# string named AVP\nmodparam(\"domainpolicy\", \"domain_replacement_avp\", \"domainreplacement\")\n```\n",
   "domain_prefix_avp": "### `domain_prefix_avp` (string)\n\nName of the AVP which contains a domain prefix.\n\nDefault value is \u201cdomainprefix\u201d.\n\n```\n# string named AVP\nmodparam(\"domainpolicy\", \"domain_prefix_avp\", \"domainprefix\")\n```\n",
   "domain_suffix_avp": "### `domain_suffix_avp` (string)\n\nName of the AVP which contains a domain suffix.\n\nDefault value is \u201cdomainsuffix\u201d.\n\n```\n# string named AVP\nmodparam(\"domainpolicy\", \"domain_suffix_avp\", \"domainsuffix\")\n```\n",
   "send_socket_avp": "### `send_socket_avp` (string)\n\nName of the AVP which contains a send_socket. The format of the send\nsocket (the payload of this AVP) must be in the format\n[proto:]ip_address[:port]. The function dp_apply_policy will look\nfor this AVP and if defined, it will force the send socket to its value\n(similar to the force_send_socket core function).\n\nDefault value is \u201csendsocket\u201d.\n\n```\n# string named AVP\nmodparam(\"domainpolicy\", \"send_socket_avp\", \"sendsocket\")\n```\n"
  },
  "functions": {
   "dp_can_connect": "### `dp_can_connect()`\n\nChecks the interconnection policy of the caller. It uses the domain in\nthe request URI to perform the DP-DDDS algorithm according to\ndraft-lendl-domain-policy-ddds-02 to retrieve the domain's policy\nannouncements. As of this version, only records conforming to\ndraft-lendl-speermint-federations-02 and\ndraft-lendl-speermint-technical-policy-00 are supported.\n\nNon-terminal NAPTR records will cause recursion to the replacement\ndomain. dp_can_connect() will thus look for policy rules in the\nreferenced domain. Furthermore, an AVP for \"domainreplacement\"\n(containing the new domain) will be added to the call. This will\nredirect SRV/A record lookups to the new domain.\n\nIn order to simplify direct domain-based peerings all destination\ndomains are treated as if they contain a top priority \"D2P+SIP:dom\" rule\nwith the domain itself as the value of the rule. Thus any database row\nwith type = 'dom' and rule = 'example.com' will override any dynamic\nDNS-discovered rules.\n\nFor NAPTRs with service-type \"D2P+SIP:fed\", the federation IDs (as\nextracted from the regexp field) are used to retrieve policy records\nfrom a local local database (basically: \"SELECT dp_col_att, dp_col_val\nFROM dp_table WHERE dp_col_rule = '[federationID]' AND type = 'fed').\nIf records are found (and all other records with the same order value\nare fulfillable) then AVPs will be created from the dp_col_att and\ndp_col_val columns.\n\nFor NAPTRs with service-type \"D2P+SIP:std\", the same procedure is\nperformed. This time, the database lookup searched for type = 'std',\nthough.\n\n\"D2P+SIP:fed\" and \"D2P+SIP:std\" can be mixed freely. If two rules with\nthe same \"order\" match and try to set the same AVP, then the behaviour\nis undefined.\n\nThe dp_col_att column specifies the AVP's name. If the AVP start with\n\"s:\" or \"i:\", the corresponding AVP type (string named or integer named)\nwill be generated. If the exact specifier is omitted, the AVP type will\nbe guessed.\n\nThe dp_col_val column will always be interpreted as string. Thus, the\nAVP's value is always string based.\n\ndp_can_connect returns:\n\n- *-2*: on errors during the evaluation. (DNS, DB, ...)\n\n- *-1*: D2P+SIP records were found, but the policy is not fullfillable.\n\n- *1*: D2P+SIP records were found and a call is possible\n\n- *2*: No D2P+SIP records were found. The destination domain does not\n  announce a policy for incoming SIP calls.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\ndp_can_connect();\nswitch(retcode) {\n    case -2:\n        xlog(\"L_INFO\",\"Errors during the DP evaluation\\n\");\n        sl_send_reply(\"404\", \"We can't connect you.\");\n        break;\n    case -1:\n        xlog(\"L_INFO\",\"We can't connect to that domain\\n\");\n        sl_send_reply(\"404\", \"We can't connect you.\");\n        break;\n    case 1:\n        xlog(\"L_INFO\",\"We found matching policy records\\n\");\n        avp_print();\n        dp_apply_policy();\n        t_relay();\n        break;\n    case 2:\n        xlog(\"L_INFO\",\"No DP records found\\n\");\n        t_relay();\n        break;\n}\n...\n        \n```\n",
   "dp_apply_policy": "### `dp_apply_policy()`\n\nThis function sets the destination URI according to the policy returned\nfrom the `dp_can_connect()` function. Parameter exchange between\n`dp_can_connect()` and `dp_apply_policy()` is done via AVPs. The AVPs\ncan be configured in the module's parameter section.\n\nNote: The name of the AVPs must correspond with the names in the *att*\ncolumn in the domainpolicy table.\n\nSetting the following AVPs in `dp_can_connect()` (or by any other means)\ncause the following actions in `dp_apply_policy()`:\n\n- *port_override_avp*: If this AVP is set, the port in the destination\n  URI is set to this port. Setting an override port disables NAPTR and\n  SRV lookups according to RFC 3263.\n\n- *transport_override_avp*: If this AVP is set, the transport parameter\n  in the destination URI is set to the specified transport (\"udp\",\n  \"tcp\", \"tls\"). Setting an override transport also disables NAPTR\n  lookups, but retains an SRV lookup according to RFC 3263.\n\n- *domain_replacement_avp*: If this AVP is set, the domain in the\n  destination URI will be replaced by this domain.\n\n  A non-terminal NAPTR and thus a referral to a new domain implicitly\n  sets *domain_replacement_avp* to the new domain.\n\n- *domain_prefix_avp*: If this AVP is set, the domain in the destination\n  URI will be prefixed with this \"subdomain\". E.g. if the domain in the\n  request URI is \"example.com\" and the domain_prefix_avp contains\n  \"inbound\", the domain in the destination URI is set to\n  \"inbound.example.com\".\n\n- *domain_suffix_avp*: If this AVP is set, the domain in the destination\n  URI will have the content of the AVP appended to it. E.g. if the\n  domain in the request URI is \"example.com\" and the domain_suffix_avp\n  contains \"myroot.com\", the domain in the destination URI is set to\n  \"example.com.myroot.com\".\n\n- *send_socket_avp*: If this AVP is set, the sending socket will be\n  forced to the socket in the AVP. The payload format of this AVP must\n  be [proto:]ip_address[:port].\n\nIf both prefix/suffix and domain replacements are used, then the\nreplacement is performed first and the prefix/suffix are applied to the\nnew domain.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (dp_apply_policy()) {\n    t_relay();\n}\n...\n        \n```\n"
  }
 },
 "drouting": {
  "overview": "\n",
  "parameters": {
   "db_url": "### `db_url`(str)\n\nThe database url.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"db_url\",\n    \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n...\n```\n",
   "drd_table": "### `drd_table`(str)\n\nThe name of the db table storing gateway addresses.\n\n*Default value is \u201cdr_gateways\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drd_table\", \"dr_gateways\")\n...\n```\n",
   "drr_table": "### `drr_table`(str)\n\nThe name of the db table storing routing rules.\n\n*Default value is \u201cdr_rules\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drr_table\", \"rules\")\n...\n```\n",
   "drg_table": "### `drg_table`(str)\n\nThe name of the db table storing groups.\n\n*Default value is \u201cdr_groups\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drg_table\", \"groups\")\n...\n```\n",
   "drl_table": "### `drl_table`(str)\n\nThe name of the db table storing definitions of destination lists (to be\nused directly by the routing rules). You will have an identifier to a\ngroup of gateways instead of having all the members of the group as\nindividual elements. Very useful to reuse a list of gateways in\ndifferent places.\n\n*Default value is \u201cdr_gw_lists\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drl_table\", \"my_gw_lists\")\n...\n```\n",
   "sort_order": "### `sort_order` (int)\n\nDefines how the destination list should be processed (ordering of the\nelements). Possible modes are\n\n- 0\n  - destination groups are ignored and all the destinations are tried\n  in the given order; Ex: list 1,2;3,4,5;6 will lead to usage as\n  1,2,3,4,5,6\n\n- 1\n  - the destinations from each group are randomly arranged (only the\n  two first elements are randomly selected); groups do maintain their\n  order (as given); the resulting list is used (with all the defined\n  destinations). Ex: 1,2;3,4,5;6 -> randomizer -> (A) 2,1;4,3,5;6 ->\n  usage 2,1,4,3,5,6 (B) 1,2;3,5,4;6 -> usage 1,2,3,5,4,6\n\n- 2\n  - from each destination group, only a single destination is randomly\n  selected; groups do maintain their order (as given);\n  Ex: 1,2;3,4,5;6 -> randomizer ->\n\n  (A) 2;4;6 -> usage 2,4,6\n\n  (B) 1;5;6 -> usage 1,5,6\n\n  It is ok to have repeating gateways in different groups. The module\n  will take care internally in case of failure not to choose a gateway\n  that was tried already.\n\n  Ex: 1,2,3; 1,2,3; 1,2,3 -> no gateway will be chosen twice. So in\n  case there are 2 failures, all the three gateways (1,2,3) will be\n  tried in a random order.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"sort_order\", 2)\n...\n```\n",
   "ruri_avp": "### `ruri_avp` (str)\n\nThe name of the avp for storing Request URIs to be later used\n(alternative destinations for the current one).\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"ruri_avp\", '$avp(dr_ruri)')\nmodparam(\"drouting\", \"ruri_avp\", '$avp(i:33)')\n...\n    \n```\n",
   "attrs_avp": "### `attrs_avp` (str)\n\nThe name of the avp for storing the attribute of the current selected\ndestination - once a new destination is selected (via the use_next_gw()\nfunction), the AVP will be updated with the attrs of the new used\ndestination.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"attrs_avp\", '$avp(dr_attrs)')\nmodparam(\"drouting\", \"atrrs_avp\", '$avp(i:67)')\n...\n    \n```\n",
   "use_domain": "### `use_domain` (int)\n\nFlag to configure whether to use domain match when querying database for\nuser's routing group.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"use_domain\", 0)\n...\n```\n",
   "drg_user_col": "### `drg_user_col` (str)\n\nThe name of the column in group db table where the username is stored.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drg_user_col\", \"user\")\n...\n```\n",
   "drg_domain_col": "### `drg_domain_col` (str)\n\nThe name of the column in group db table where the domain is stored.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drg_domain_col\", \"host\")\n...\n```\n",
   "drg_grpid_col": "### `drg_grpid_col` (str)\n\nThe name of the column in group db table where the group id is stored.\n\n*Default value is \u201cgroupid\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"drg_grpid_col\", \"grpid\")\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (int)\n\nThe number of rows that should be fetched from the result of a query in\nrules db table.\n\n*Default value is \u201c2000\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"fetch_rows\", 1500)\n...\n```\n",
   "force_dns": "### `force_dns` (int)\n\nForce DNS resolving of GW/destination names (if not IPs) during startup.\nIf not enabled, the GW name will be blindly used during routing.\n\n*Default value is \u201c1 (enabled)\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"force_dns\", 0)\n...\n    \n```\n",
   "enable_keepalive": "### `enable_keepalive` (int)\n\nEnable monitoring of GW/destinations using keepalive module.\nDestinations found unavailable will not be used on do_routing() call.\n\n*Default value is \u201c0 (disabled)\u201d.*\n\n```\n...\nmodparam(\"drouting\", \"enable_keepalive\", 1)\n...\n    \n```\n"
  },
  "functions": {
   "do_routing": "### `do_routing([groupID])`\n\nFunction to trigger routing of the message according to the rules in the\ndatabase table and the configured parameters.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\nThe module can take one optional parameter: the routing group the caller\nbelongs to - this may be a static int value or a variable holding an\nint. If none specified, the function will automatically try to query the\ndr_group table to get the group id associated with the user in From URI.\n\n```\n...\ndo_routing();\n...\ndo_routing(\"0\");\n...\ndo_routing(\"$avp(i:10)\");\n```\n",
   "next_routing": "### `next_routing()`\n\nThe function takes the next available destination (set by do_routing, as\nalternative destinations) and push it into RURI. Note that the function\njust sets the RURI (nothing more).\n\nIf a new RURI is set, the used destination is removed from the pending\nset of alternative destinations.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\nThe function returns true only if a new RURI was set. False is returned\nis no other alternative destinations are found or in case of internal\nprocessing error.\n\n```\n...\nif (next_routing()) {\n    t_relay();\n    exit;\n}\n...\n```\n",
   "use_next_gw": "### `use_next_gw()`\n\nSame as next_routing().\n",
   "goes_to_gw": "### `goes_to_gw([type])`\n\nFunction returns true if the destination of the current request\n(destination URI or Request URI) points (as IP) to one of the gateways.\nThere is no DNS lookups done if the domain part of the URI is not an IP.\n\nThis function does not change anything in the message.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE and\nONREPLY_ROUTE.\n\nThe function can take two optional parameters:\n\n- type\n  - GW/destination type to be checked\n\n<!-- -->\n\n\n```\n...\nif (goes_to_gw(\"1\")) {\n    sl_send_reply(\"403\",\"Forbidden\");\n    exit;\n}\n...\n```\n",
   "is_from_gw": "### `is_from_gw([ type, [flag] ])`\n\nThe function checks if the sender of the message is a gateway from a\ngroup in drouting rules.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE and\nONREPLY_ROUTE.\n\nThe function can take two parameters:\n\n- type\n  (mandatory) - GW/destination type to be checked\n- flags\n  (optional) - if message is a request and the GW has a STRIP defined,\n  then apply it if GW is source.\n\n<!-- -->\n\n\n```\n...\nif (is_from_gw(\"1\") {\n}\n...\nif (is_from_gw(\"3\",\"1\") {\n}\n...\n```\n"
  }
 },
 "enum": {
  "overview": "Enum module implements [i_]enum_query functions that make an enum\nquery based on the user part of the current Request-URI. These functions\nassume that the Request URI user part consists of an international phone\nnumber of the form +decimal-digits, where the number of digits is at\nleast 2 and at most 20. Out of this number `enum_query` forms a domain\nname, where the digits are in reverse order and separated by dots\nfollowed by domain suffix that by default is \u201ce164.arpa.\u201d. For example,\nif the user part is +35831234567, the domain name will be\n\u201c7.6.5.4.3.2.1.3.8.5.3.e164.arpa.\u201d. `i_enum_query` operates in a similar\nfashion. The only difference is that it adds a label (default \"i\") to\nbranch off from the default, user-ENUM tree to an infrastructure ENUM\ntree.\n\nAfter forming the domain name, `enum_query` queries DNS for enum NAPTR\nrecords. From the possible responses `enum_query` chooses those records,\nwhose flags field has string value \"u\", and whose services field has\nstring value \"e2u+[service:]sip\" or\n\"e2u+type[:subtype][+type[:subtype]...]\" (case is ignored in both\ncases), and whose regexp field is of the form !pattern!replacement!.\n\nThen `enum_query` sorts the chosen NAPTR records based on their <order,\npreference>. After sorting, `enum_query` replaces the current Request\nURI by applying the regular expression of the most preferred NAPTR\nrecord to its user part and appends to the request new branches by\napplying regexp of each remaining NAPTR record to the user part of the\ncurrent Request URI. If a new URI is a tel: URI, `enum_query` appends to\nit as tel: URI parameters the value of tel_uri_params module parameter.\nFinally, `enum_query` associates a q value with each new URI based on\nthe <order, preference> of the corresponding NAPTR record.\n\nWhen using `enum_query` without any parameters, it searches for NAPTRs\nwith service type \"e2u+sip\" in the default enum tree. When using\n`enum_query` with a single parameter, this parameter will be used as\nenum tree. When using `enum_query` with two parameters, the\nfunctionality depends on the first letter in the second parameter. When\nthe first letter is not a '+' sign, the second parameter will be used to\nsearch for NAPTRs with service type \"e2u+parameter:sip\". When the second\nparameter starts with a '+' sign, the ENUM lookup also supports compound\nNAPTRs (e.g. \"e2u+voice:sip+video:sip\") and searching for multiple\nservice types within one lookup. Multiple service types must be\nseparated by a '+' sign.\n\nMost of the time you want to route based on the RURI. On rare occasions\nyou may wish to route based on something else. The function\n`enum_pv_query` mimics the behavior of the `enum_query` function except\nthe E.164 number in its pseudo variable argument is used for the enum\nlookup instead of the user part of the RURI.\n\nEnum query returns 1 if the current Request URI was replaced and -1 if\nnot.\n\nEnum module also implements `is_from_user_enum` function. This function\ndoes an enum lookup on the from user and returns true if found, false\notherwise.\n",
  "parameters": {
   "domain_suffix": "### `domain_suffix` (string)\n\nThe domain suffix to be added to the domain name obtained from the\ndigits of an E164 number. Can be overridden by a parameter to\nenum_query.\n\nDefault value is \u201ce164.arpa.\u201d\n\n```\nmodparam(\"enum\", \"domain_suffix\", \"e1234.arpa.\")\n```\n",
   "tel_uri_params": "### `tel_uri_params` (string)\n\nA string whose contents is appended to each new tel URI in the request\nas tel URI parameters.\n\n<div class=\"note\">\n\n\nCurrently SIP Router does not support tel URIs. This means that at\npresent tel_uri_params is appended as URI parameters to every URI.\n\n</div>\n\n\nDefault value is \u201c\u201d\n\n```\nmodparam(\"enum\", \"tel_uri_params\", \";npdi\")\n```\n",
   "i_enum_suffix": "### `i_enum_suffix` (string)\n\nThe domain suffix to be used for i_enum_query() lookups. Can be\noverridden by a parameter to i_enum_query.\n\nDefault value is \u201ce164.arpa.\u201d\n\n```\nmodparam(\"enum\", \"i_enum_suffix\", \"e1234.arpa.\")\n```\n",
   "branchlabel": "### `branchlabel` (string)\n\nThis parameter determines which label i_enum_query() will use to branch\noff to the infrastructure ENUM tree.\n\nDefault value is \u201c\"i\"\u201d\n\n```\nmodparam(\"enum\", \"branchlabel\", \"i\")\n```\n",
   "bl_algorithm": "### `bl_algorithm` (string)\n\nThis parameter determines which algorithm the `i_enum_query()` function\nwill use to select the position in the DNS tree where the infrastructure\ntree branches off the user ENUM tree.\n\nIf set to \"cc\", i_enum_query() will always insert the label at the\ncountry-code level. Examples: i.1.e164.arpa, i.3.4.e164.arpa,\ni.2.5.3.e164.arpa\n\nIf set to \"txt\", i_enum_query() will look for a TXT record at\n[branchlabel].[reverse-country-code].[i_enum_suffix] to indicate\nafter how many digits the label should in inserted.\n\n```\ni.1.e164.arpa.                     IN TXT   \"4\"\n9.9.9.8.7.6.5.i.4.3.2.1.e164.arpa. IN NAPTR \"NAPTR content for  +1 234 5678 999\"\n```\n\nIf set to \"ebl\", i_enum_query() will look for an EBL (ENUM Branch Label)\nrecord at [branchlabel].[reverse-country-code].[i_enum_suffix].\nSee\nhttp://www.ietf.org/internet-drafts/draft-lendl-enum-branch-location-record-00.txt\nfor a description of that record and the meaning of the fields. The RR\ntype for the EBL has not been allocated yet. This version of the code\nuses 65300. See resolve.h.\n\n```\ni.1.e164.arpa.     TYPE65300  \\# 14 (\n                              04    ; position\n                              01 69 ; separator\n                              04 65 31 36 34 04 61 72 70 61 00 ; e164.arpa\n;                               )\n9.9.9.8.7.6.5.i.4.3.2.1.e164.arpa. IN NAPTR \"NAPTR content for  +1 234 5678 999\"\n```\n\nDefault value is \u201ccc\u201d\n\n```\nmodparam(\"enum\", \"bl_algorithm\", \"txt\")\n```\n"
  },
  "functions": {
   "enum_query": "### `enum_query([&quot;suffix&quot; [,&quot;service&quot;]])`\n\nThe function performs an enum query and rewrites the Request-URI with\nthe result of the query. See [Overview](#sec-overview) for more\ninformation.\n\nMeaning of the parameters is as follows:\n\n- *suffix* - Suffix string to be appended to the domain name. String may\n  contain pseudo variables.\n\n- *service* - Service string to be used in the service field. String may\n  contain pseudo variables.\n\nParameters can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n# search for \"e2u+sip\" in freenum.org\nenum_query(\"freenum.org.\");\n...\n# search for \"e2u+sip\" in default tree (configured as parameter)\nenum_query();\n...\n# search for \"e2u+voice:sip\" in e164.arpa\nenum_query(\"e164.arpa.\",\"voice\");\n...\n# search for service type \"sip\" or \"voice:sip\" or \"video:sip\"\n# note the '+' sign in front of the second parameter\nenum_query(\"e164.arpa.\",\"+sip+voice:sip+video:sip\");\n...\n# quering for service sip and voice:sip\nenum_query(\"e164.arpa.\");\nenum_query(\"e164.arpa.\",\"voice\");\n# or use instead\nenum_query(\"e164.arpa.\",\"+sip+voice:sip\");\n...\n```\n",
   "enum_pv_query": "### `enum_pv_query(&quot;pvar&quot; [,&quot;suffix&quot; [,&quot;service&quot;]])`\n\nThe function performs an enum query on E.164 number stored in its first\nargument and rewrites the Request-URI with the result of the query. See\n[Overview](#sec-overview) for more information.\n\nMeaning of the parameters is as follows:\n\n- *pvar* - Pseudo variable that holds an E.164 number on which enum\n  query is performed.\n\n- *suffix* - Suffix to be appended to the domain name.\n\n- *service* - Service string to be used in the service field.\n\nParameters can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n# search for \"e2u+sip\" in freenum.org\nenum_pv_query(\"$avp(i:100)\", \"freenum.org.\");\n...\n# search for \"e2u+sip\" in default tree (configured as parameter)\nenum_pv_query(\"$fU\");\n...\n# search for \"e2u+voice:sip\" in e164.arpa\nenum_pv_query(\"$avp(i:100)\",\"e164.arpa.\",\"voice\");\n...\n# search for service type \"sip\" or \"voice:sip\" or \"video:sip\"\n# note the '+' sign in front of the second parameter\nenum_pv_query(\"$fU\",\"e164.arpa.\",\"+sip+voice:sip+video:sip\");\n...\n# quering for service sip and voice:sip\nenum_pv_query(\"$avp(i:100)\",\"e164.arpa.\");\nenum_pv_query(\"$avp(i:100)\",\"e164.arpa.\",\"voice\");\n# or use instead\nenum_pv_query(\"$avp(i:100)\",\"e164.arpa.\",\"+sip+voice:sip\");\n...\n```\n",
   "i_enum_query": "### `i_enum_query([&quot;suffix&quot; [,&quot;service&quot;]])`\n\nThe function performs an enum query and rewrites the Request-URI with\nthe result of the query. This is the Infrastructure-ENUM version of\nenum_query(). The only difference to enum_query() is in the calculation\nof the FQDN where NAPTR records are looked for.\n\nParameters can include pseudo-variables.\n\nSee\nftp://ftp.rfc-editor.org/in-notes/internet-drafts/draft-haberler-carrier-enum-01.txt\nfor the rationale behind this function.\n",
   "is_from_user_enum": "### `is_from_user_enum()`\n\nChecks if the user part of from URI is found in an enum lookup. Returns\n1 if yes and -1 if not.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_from_user_enum()) {\n    ....\n};\n...\n```\n"
  }
 },
 "erlang": {
  "overview": "Erlang is a general-purpose programming language and runtime\nenvironment. Erlang has built-in support for concurrency, distribution\nand fault tolerance. This module provides interact with Erlang node. The\nmodule allows sending, receiving Erlang messages and RPC calls between\neach other.\n",
  "parameters": {
   "no_cnodes": "### `no_cnodes` (int)\n\nNumber of erlang C node processes to be started to handle the\ncommunication tasks. A C node is a C program written to act as a hidden\nnode in a distributed Erlang system.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"erlang\", \"no_cnodes\", 2)\n...\n                \n```\n",
   "cnode_alivename": "### `cnode_alivename` (str)\n\n*alivename* is the registered name of the Kamailio process.\n\n*Note,* if the `no_cnodes` is greater than 1, then *alivename* of\nKamailio process will be suffixed with number.\n\n```\n...\nmodparam(\"erlang\", \"cnode_alivename\", \"proxy\")\n...\n                \n```\n",
   "cnode_host": "### `cnode_host` (str)\n\nC node *host* is the name of the machine we're running on. If long names\nare to be used, it should be fully qualified.\n\n```\n...\nmodparam(\"erlang\", \"cnode_host\", \"kamailio.lan\")\n...\n                \n```\n",
   "erlang_nodename": "### `erlang_nodename` (str)\n\nThe format of the node name is a *name@host* where name is the name\ngiven by the user and host is the full host name if long names are used,\nor the first part of the host name if short names are used.\n\n```\n...\nmodparam(\"erlang\", \"erlang_nodename\", \"node1@erlang.lan\")\n...\n                \n```\n",
   "cookie": "### `cookie` (str)\n\nEach node has its own magic cookie. When a nodes tries to connect to\nanother node, the magic cookies are compared If they do not match, the\nconnected node rejects the connection.\n\n```\n...\nmodparam(\"erlang\", \"cookie\", \"secretcookie\")\n...\n                \n```\n",
   "trace_level": "### `trace_level` (int)\n\nUsed to set tracing on the distribution. The parameter is different\nverbosity level. A higher level means more information. Useful in\ndevelopment, but in production should be disabled.\n\nThe different tracelevels has the following messages:\n\nDefault value is 0, no verbose is set.\n\nTo see trace log on stdout, Kamailio must be started with\n\n-E\n\noption.\n\n```\n...\nmodparam(\"erlang\", \"trace_level\", 5)\n...\n                \n```\n",
   "rpc_reply_with_struct": "### `rpc_reply_with_struct` (int)\n\nPrepend Erlang atom struct in RPC Kamailio reply where RPC struct is\ngenerated. Some libraries for converting erlang term in JSON require\natom struct as first element in tuple to convert list of properties into\njavscript object.\n\nDefault value is 0 (disabled).\n"
  },
  "functions": {
   "erl_rpc": "### `erl_rpc(mod, fun, args, reply)`\n\nThis function supports calling Erlang functions on remote nodes.\n\nThe parameter *mod* and *fun* are module and function name respectively.\nIt can be a static string or a dynamic string value with config\nvariables.\n\nThe parameter *args* is list of arguments passed to function, so it must\nbe *list*, or *xbuff* that contains list.\n\nThe parameter *reply* is result from RPC call. It must be *xbuff* to\naccept any result.\n\nFunction returns false on error to send or wrong arguments passed to\nfunction. If executing remote function caused error function still\nreturns true but error is encoded into *repl* parameter.\n\n```\n...\n# example of call erlang:list_to_tuple([\"one\",\"two\"])\n# on remote node\n\n$erl_list(L) = \"two\";\n$erl_list(L) = \"one\";\n\n# put list into list\n$erl_list(args) = $erl_list(L);\n\nerl_rpc(\"erlang\", \"list_to_tuple\", \"$erl_list(args)\", \"$erl_xbuff(repl)\");\n\nxlogl(\"L_DEBUG\",\"type(repl): $erl_xbuff(repl=>type), format(repl): $erl_xbuff(repl=>format)\\n\");\n\n> log output:\n...\nDEBUG: <script>: 386:type(repl): tuple, format(repl): {\"one\", \"two\"}\n...\n                \n```\n",
   "erl_reg_send": "### `erl_reg_send(server, msg)`\n\nThis function sends an Erlang term to a registered process.\n\nThe argument *server* is the registered name of the intended recipient\nprocess on remote node.\n\nThe argument *msg* is containing the message to be sent.\n\n```\n...\n# example of send message to registered process\n# {notifier,'node1@erlang.lan'} ! {example,message}\n\n$erl_atom(example) = \"example\";\n$erl_atom(message) = \"message\";\n\n$erl_tuple(M) = $erl_atom(message);\n$erl_tuple(M) = $erl_atom(example);\n\nerl_reg_send(\"notifier\",\"$erl_tuple(M)\");\n...\n                \n```\n",
   "erl_send": "### `erl_send(pid, msg)`\n\nThis function sends an Erlang term to a process. This function can be\nused from ANY_ROUTE. The argument *pid* is the Erlang process id of the\nintended recipient process on remote node. The argument *msg* is\ncontaining the message to be sent.\n\n```\n...\n# example of send message to process\n# Pid ! {example,message}\n\n$erl_atom(notifier) = \"notifier\";\n$erl_list(args) = $erl_atom(notifier);\n\nerl_rpc(\"erlang\", \"whereis\", \"$erl_list(args)\", \"$erl_xbuff(pid)\");\n\n$erl_atom(example) = \"example\";\n$erl_atom(message) = \"message\";\n\n$erl_tuple(M) = $erl_atom(message);\n$erl_tuple(M) = $erl_atom(example);\n\nerl_send(\"$erl_xbuff(pid)\",\"$erl_tuple(M)\");\n...\n                \n```\n",
   "erl_reply": "### `erl_reply(msg)`\n\nFunction to send message from event route (pseudo process). Function\nsends reply message *msg* to the sender process.\n\n```\n...\n# event route acts as registered process\nevent_route[erlang:greetings] {\n\n    xlogl(\"L_INFO\",\"Received message: $erl_xbuff(msg=>format)\\n\");\n\n    $erl_atom(hello) = \"hello\";\n    $erl_tuple(reply) = \"Erlang\";\n    $erl_tuple(reply) = $erl_atom(hello);\n\n    # reply greeting\n    erl_reply(\"$erl_tuple(reply)\");\n}\n...\n\n%% in erlang shell\n\n(node1@erlang.lan)24> {greetings,'proxy@kamailio.lan'} ! {hello,\"Kamailio\"}.\n{hello,\"Kamailio\"}\n(node1@erlang.lan)25> flush().\nShell got {hello,\"Erlang\"}\nok\n\n> logged info message:\nINFO: <script>: 951:Received message: {\"hello\", \"Kamailio\"}\n>\n                \n```\n"
  }
 },
 "evapi": {
  "overview": "The EVAPI module can be used to create an event message flow from\nKamailio to any application that can connect to a TCP socket. The remote\napplication can also issue messages received by Kamailio.\n\nThere is no protocol definition, it is all up to the author of the\nrouting script. Events can be generated for any event in Kamailio. For\n3rd party transaction control, a transaction can be automatically\nsuspended when sending the event, to be resumed at a later point, maybe\ntriggered by an incoming message on the event socket.\n",
  "parameters": {
   "workers": "### `workers` (int)\n\nNumber of worker processes to be started to handle incoming messages\nfrom remote applications. If the value is 0, the handling of the\nincoming message is done by the evapi dispatcher process.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"evapi\", \"workers\", 2)\n...\n```\n",
   "bind_addr": "### `bind_addr` (str)\n\nLocal IP and port to listen on for incoming TCP connections.\n\n*Default value is \"127.0.0.1:8448\".*\n\n```\n...\nmodparam(\"evapi\", \"bind_addr\", \"1.2.3.4:8228\")\n...\n```\n",
   "netstring_format": "### `netstring_format` (int)\n\nControl if messages on the socket (to and from clients) are encapsulated\nin netstring format.\n\n*Default value is 1 (netstring format).*\n\n```\n...\nmodparam(\"evapi\", \"netstring_format\", 0)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues are: 'evapi:connection-new', 'evapi:connection-closed',\n'evapi:message-received'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"evapi\", \"event_callback\", \"ksr_evapi_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_evapi_event(evname)\n    KSR.info(\"===== evapi module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "max_clients": "### `max_clients` (int)\n\nMaximum number of clients that can connect to evapi socket.\n\n*Default value is 8.*\n\n```\n...\nmodparam(\"evapi\", \"max_clients\", 4)\n...\n```\n",
   "wait_idle": "### `wait_idle` (int)\n\nHow many micro-seconds to wait on idle, when no evapi messages are in\nthe processing queue.\n\n*Default value is 500 000 (0.5 seconds).*\n\n```\n...\nmodparam(\"evapi\", \"wait_idle\", 100000)\n...\n```\n",
   "wait_increase": "### `wait_increase` (int)\n\nIncrease wait_idle by itself till its value becomes initial value\nmultiplied with wait_increase. The increase is done only consecutive\ncycles without any evapi message. When a new evapi message is received,\nwait_idle is reset to initial value. If wait_increase is set to 1, then\nwait_idle is used with its initial value always.\n\n*Default value is 3.*\n\n```\n...\nmodparam(\"evapi\", \"wait_increase\", 1)\n...\n```\n"
  },
  "functions": {
   "evapi_relay": "### `evapi_relay(evdata)`\n\nRelay the event data given as parameter to connected applications.\n\nThe format on the network is netstring with evdata payload if\nnetstring_format parameter is set to 1 or bare evdata if\nnetstring_format parameter is set to 0.\n\nThe function is passing the task to evapi dispatcher process, therefore\nthe SIP worker process is not blocked. Also, it doesn't wait for any\nresponse, therefore the processing of the configuration continues very\nfast when executing evapi_relay().\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nevapi_relay(\"{ \\\"event\\\": \\\"test\\\",\\n \\\"data\\\": { \\\"fU\\\": \\\"$fU\\\" }\\n}\");\n...\n```\n\nThe above example will send the following message over tcp:\n\n```\n...\n47:{\n \"event\": \"test\",\n \"data\": { \"fU\": \"test\" }\n},\n...\n```\n",
   "evapi_async_relay": "### `evapi_async_relay(evdata)`\n\nRelay the event data given as parameter to connected applications.\nBefore evaluating the parameter, the request processing is suspended\nusing tm module (using the t_suspend()/t_continue() framework). The\nrouting of the SIP request can be continued once\nevent_route[evapi:message-received] is triggered. After\nevapi_async_relay() returns true, no relaying should happen in\nrequest_route(), it should be followed by exit;.\n\nThe format on the network is netstring with evdata payload if\nnetstring_format parameter is set to 1 or bare evdata if\nnetstring_format parameter is set to 0.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nevapi_async_relay(\"{ \\\"event\\\": \\\"suspend\\\",\\n \\\"data\\\":\"\n        \" { \\\"index\\\": \\\"$T(id_index)\\\", \\\"label\\\": \\\"$T(id_label)\\\" }\\n}\");\n...\n```\n",
   "evapi_multicast": "### `evapi_multicast(evdata, etag)`\n\nRelay the event data given as parameter to connections that match the\ntag provided by etag value. The etag can be a variable. For more see\nevapi_relay() and evapi_set_tag().\n\n```\n...\nevapi_multicast(\"{ \\\"event\\\": \\\"test\\\",\\n \\\"data\\\": { \\\"fU\\\": \\\"$fU\\\" }\\n}\", \"tagx\");\n...\n```\n",
   "evapi_async_multicast": "### `evapi_async_multicast(evdata, etag)`\n\nAsync relay the event data given as parameter to connections that match\nthe tag provided by etag value. The etag can be a variable. For more see\nevapi_async_relay() and evapi_set_tag().\n\n```\n...\nevapi_async_multicast(\"{ \\\"event\\\": \\\"suspend\\\",\\n \\\"data\\\":\"\n    \" { \\\"index\\\": \\\"$T(id_index)\\\", \\\"label\\\": \\\"$T(id_label)\\\" }\\n}\", \"tagx\");\n...\n```\n",
   "evapi_unicast": "### `evapi_unicast(evdata, etag)`\n\nRelay the event data given as parameter to the first connection that\nmatch the tag provided by etag value. The etag can be a variable. For\nmore see evapi_relay() and evapi_set_tag().\n\n```\n...\nevapi_unicast(\"{ \\\"event\\\": \\\"test\\\",\\n \\\"data\\\": { \\\"fU\\\": \\\"$fU\\\" }\\n}\", \"tagx\");\n...\n```\n",
   "evapi_async_unicast": "### `evapi_async_unicast(evdata, etag)`\n\nAsync relay the event data given as parameter to the first connection\nthat match the tag provided by etag value. The etag can be a variable.\nFor more see evapi_async_relay() and evapi_set_tag().\n\n```\n...\nevapi_async_unicast(\"{ \\\"event\\\": \\\"suspend\\\",\\n \\\"data\\\":\"\n    \" { \\\"index\\\": \\\"$T(id_index)\\\", \\\"label\\\": \\\"$T(id_label)\\\" }\\n}\", \"tagx\");\n...\n```\n",
   "evapi_close": "### `evapi_close()`\n\nClose evapi current client connection.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nevent_route[evapi:connection-new] {\n  if($evapi(srcaddr)!=\"127.0.0.1\") {\n    evapi_close();\n    exit;\n  }\n}\n...\n```\n",
   "evapi_set_tag": "### `evapi_set_tag(tname)`\n\nSet tag name for current client connection. The parameters has to be a\nstring up to 64 characters. It can also be a variable holding such\nstring.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nevent_route[evapi:connection-new] {\n  if($evapi(srcaddr)==\"127.0.0.1\") {\n    evapi_set_tag(\"local\");\n    exit;\n  }\n}\n...\n```\n"
  }
 },
 "evrexec": {
  "overview": "The module executes event route blocks or KEMI functions on dedicated\nprocesses at startup, upon an RPC command or data received on a custom\nUDP socket.\n\nFor startup event route, the execution can be delayed for a specified\ninterval of time. The actions in the event route should be a loop or\nother tasks that run forever.\n",
  "parameters": {
   "exec": "### `exec` (str)\n\nThe definition of an exec task. The value of the parameter must have the\nfollowing format:\n\n- \"name=_string_;wait=_number_;workers=_number_;sockaddr=_udp_socket_\"\n\nThe parameter can be set multiple times to get more exec tasks in same\nconfiguration file.\n\n- *name* - name of the event route to be executed. When used with a KEMI\n  embedded language, this has to be the name of a function from the KEMI\n  script. The function must have a string parameter, which will retrieve\n  the index of the works in string format.\n\n- *workers* - if set to 0 or 1 the task is executed in a dedicated\n  process. Any number > 1 will create more dedicated processes, each of\n  them executing the startup task. For UDP data execution (when\n  'sockaddr' is set), only 1 worker process is created.\n\n- *wait* - timer interval in micro-seconds to wait inside the dedicated\n  process before executing the task.\n\n- *sockaddr* - full UDP socket address in format 'udp:ip:port' (example:\n  'udp:127.0.0.1:54321'). Received data is made available in the event\n  route via $evr(data).\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"evrexec\", \"exec\", \"name=evrexec:timer;wait=1000;workers=1;\")\nmodparam(\"evrexec\", \"exec\", \"name=evrexec:udp;sockaddr=udp:127.0.0.1:4444;workers=1;\")\n...\nevent_route[evrexec:timer] {\n  $var(x) = 0;\n  while(1) {\n    xlog(\"$$var(x) is $var(x)\\n\");\n    $var(x) = $var(x) + 1;\n    sleep(\"600\");\n  }\n}\n\nevent_route[evrexec:udp] {\n  xinfo(\"udp socket data: [$evr(data)] from [$evr(srcip)]\\n\");\n}\n\n...\n```\n"
  },
  "functions": {}
 },
 "exec": {
  "overview": "The exec module allows external commands to be executed from a Kamailio\nscript. The commands may be any valid shell commands--the command string\nis passed to the shell using \u201cpopen\u201d command. Kamailio passes additional\ninformation about the request in environment variables:\n\n- SIP_HF_<hf_name> contains value of each header field in request. If\n  a header field occurred multiple times, values are concatenated and\n  comma-separated. <hf_name> is in capital letters. Ff a header-field\n  name occurred in compact form, <hf_name> is canonical.\n\n- SIP_TID is transaction identifier. All request retransmissions or\n  CANCELs/ACKs associated with a previous INVITE result in the same\n  value.\n\n- SIP_DID is dialog identifier, which is the same as to-tag. Initially,\n  it is empty.\n\n- SIP_SRCIP is source IP address from which request came.\n\n- SIP_ORURI is the original request URI.\n\n- SIP_RURI is *current* request URI (if unchanged, equal to original).\n\n- SIP_USER is userpart of *current* request URI.\n\n- SIP_OUSER is userpart of original request URI.\n\nNOTE: The environment variables must be specified with double $ (e.g.,\n$$SIP_OUSER) in the parameters given to exec functions. Otherwise they\nwill be evaluated as Kamailio pseudo-variables, throwing errors.\n\nWARNING: if the exec functions are passed variables that might include\nmalicious input, then remote attackers may abuse the exec functions to\nexecute arbitrary code. Specifically, this may result in OS command\ninjection. In such cases, input validation is required to prevent the\nvulnerability. The following is an example of how input validation and\nexec module functions may be used together to prevent exploitation:\n\n```\n...\nif !($rU =~ \"^[0-9]{1,15}$\") {\n    xlog(\"Malformed R-URI username: '$rU'\\n\");\n    exit;\n}\nexec_msg(\"echo TEST >> /tmp/$(rU).txt\");\n...\n    \n```\n",
  "parameters": {
   "setvars": "### `setvars` (integer)\n\nTurn off to disable setting environment variables for executed commands.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"exec\", \"setvars\", 1)\n...\n```\n",
   "time_to_kill": "### `time_to_kill` (integer)\n\nSpecifies the longest time a program is allowed to execute. If the time\nis exceeded, the program is killed.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"exec\", \"time_to_kill\", 20)\n...\n```\n"
  },
  "functions": {
   "exec_dset": "### `exec_dset(command)`\n\nExecutes an external command. Current URI is passed to the command as\nparameter. Output of the command is considered URI set (separated by\nlines).\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables;\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_dset(\"print-contact.sh '$ct'\");\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nexec_dset(\"echo TEST > /tmp/test.txt\");\nexec_dset(\"echo TEST > /tmp/$(rU).txt\");\n...\n```\n",
   "exec_msg": "### `exec_msg(command)`\n\nExecutes an external command. The whole message is passed to it in\ninput, no command-line parameters are added, output of the command is\nnot processed.\n\nThe \u201cexamples\u201d directory in the source tarball contains several examples\nthat shows how to use this function.\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables.\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_msg(\"print-contact.sh '$ct'\");\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nexec_msg(\"echo TEST > /tmp/test.txt\");\nexec_msg(\"echo TEST > /tmp/$(rU).txt\");\n...\n```\n",
   "exec_avp": "### `exec_avp(command [, avplist])`\n\nExecutes an external command. Each line from output of the command is\nsaved in an AVP from 'avplist'. If 'avplist' is missing, the AVPs are\nnamed 1, 2, 3, ...\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables;\n\n- *avplist* - comma separated list with AVP names to store the result\n  in;\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_avp(\"print-contact.sh '$ct'\");\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nexec_avp(\"echo TEST\");\nexec_avp(\"echo TEST\", \"$avp(s:test)\");\n...\n```\n",
   "exec_cmd": "### `exec_cmd(command)`\n\nExecutes an external command. It is a lightweight version, which does\nnot pass the SIP message as parameter, does not set the environment\nvariables and it does not use the output of the command.\n\nMeaning of the parameters is as follows:\n\n- *command* - Command to be executed. It can include pseudo-variables.\n\nWARNING: if the var you are passing out has a bash special character in\nit, the var needs to be placed inside quotes, for example:\nexec_msg(\"print-contact.sh '$ct'\");\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nexec_cmd(\"echo TEST > /tmp/test.txt\");\nexec_cmd(\"echo TEST > /tmp/$(rU).txt\");\n...\n```\n"
  }
 },
 "file_out": {
  "overview": "This is a small module to support fast streaming output to files and\nprocess this changes depending on an interval. It implements only one\nfunction that streams a chunk of text to the current output file handle.\n\nThe module can be used to write logs for up to 10 different log files.\nEach log file can be configured to have a different name and extension.\nThe processed string can contain pseudo-variables. The module will\nreplace the pseudo-variables with the actual values. The module will\nalso rotate the log files at a specified interval. The interval is\nspecified in seconds.\n\nKnown limitations on the rotation interval are:\n\n- If there is no messages coming, the rotation will not be done until\n  the next message arrives.\n",
  "parameters": {
   "base_folder": "### `base_folder` (string)\n\nAbsolute path to the folder where log files should be saved.\n\n*Default value is \u201c/var/log/kamailio/file_out\u201d.*\n\n```\n...\nmodparam(\"file_out\", \"base_folder\", \"/tmp/file_out\") # trailing slash will be added.\n...\n                \n```\n",
   "file": "### `file` (string)\n\nThe definition of a file and its properties. The value of the parameter\nmay have the following format:\n\n- \"name=accounting;extension=.out;interval=20;prefix=accounting:\"\n\n*The parameter can be set multiple times to define more files in same\nconfiguration file.*\n\n- name (Required) - the name of the file\n\n  *No default value. This parameter is required.*\n\n- extension (Optional) - the extension of the file\n\n  *Default value is \u201c.out\u201d.*\n\n- interval (Optional) - the interval in seconds of the file rotation\n\n  *Default value is \u201c600\u201d (10min).*\n\n- prefix (Optional) - the prefix for log messages\n\n  *Default value is \u201c\"\"\u201d (empty string).*\n\n<!-- -->\n\n\n```\n...\nmodparam(\"file_out\", \"file\", \"name=missed_calls;interval=30;extension=.json\")\nmodparam(\"file_out\", \"file\", \"name=accounting;extension=.txt\")\n...\n                \n```\n",
   "worker_usleep": "### `worker_usleep` (int)\n\nThe time in microseconds which worker will sleep for until next\niteration.\n\n*Default value is \u201c10000\u201d (10 ms).*\n\n```\n...\nmodparam(\"file_out\", \"worker_usleep\", \"1000\")\n...\n                \n```\n"
  },
  "functions": {
   "file_out": "### `file_out(filename, string)`\n\nThis function is used to write a string to a file. The file is\ndetermined by the filename parameter. The string parameter is the string\nto be written to the file. Filename is the name of the file defined in\nthe configuration file as name=filename.\n\n```\n...\nmodparam(\"file_out\", \"file\", \"name=accounting;interval=200\")\nmodparam(\"file_out\", \"file\", \"name=missed_calls;extension=.json;interval=300\")\n\nrequest_route {\n    file_out(\"accounting\", \"Writing to accounting.out file $rm from $fu\");\n    file_out(\"missed_calls\", \"Writing to missed_calls.out file $rm from $fu\");\n}\n...\n                \n```\n"
  }
 },
 "gcrypt": {
  "overview": "This module provides various cryptography tools for use in Kamailio\nconfiguration file using libgcrypt.\n",
  "parameters": {
   "init_vector": "### `init_vector` (str)\n\nThe initialization vector used for the cryptographic operations. This\nneeds to be a string value with 16 bytes lengths.\n\n*Default value is set in the C code.*\n\n```\n...\nmodparam(\"gcrypt\", \"init_vector\", \"abcdefghijklmnop\")\n...\n```\n",
   "aes_mode": "### `aes_mode` (int)\n\nSet it to 1 in order to do AES CBC encryption mode. By default, it does\nAES ECB mode.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"gcrypt\", \"aes_mode\", 1)\n...\n```\n",
   "register_callid": "### `register_callid` (int)\n\nSet it to 1 in order to register a callback to core for generation of\ncallid values for requests generated by Kamailio tm module.\n\nThis callid generator uses libcrypt random and hashing functions for\ngenerating RFC 4122 version 4 UUID with high quality entropy. It is\nuseful when wanting to have new callids that cannot be predicted from\nprevious values.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"gcrypt\", \"register_callid\", 1)\n...\n```\n"
  },
  "functions": {
   "gcrypt_aes_encrypt": "### `gcrypt_aes_encrypt(text, key, res)`\n\nEncrypts the text with the key using AES256 ECB encryption algorithm.\nThe result is encoded in base64 format and stored in res. The parameter\nres must be a read-write variables. The parameters text and key can be\nstatic strings or strings with variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ngcrypt_aes_encrypt(\"$rb\", \"my-secret-key\", \"$var(encrypted)\");\n...\n```\n",
   "gcrypt_aes_decrypt": "### `gcrypt_aes_decrypt(text, key, res)`\n\nDecrypts the text with the key using AES256 ECB encryption algorithm.\nThe text has to be encoded in base64 format. The parameter res must be a\nread-write variables. The parameters text and key can be static strings\nor strings with variables (dynamic strings).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\ngcrypt_aes_decrypt(\"$var(encrypted)\", \"my-secret-key\", \"$var(text)\");\n...\n```\n"
  }
 },
 "geoip": {
  "overview": "This module allows real-time queries against the Max Mind GeoIP database\nto be performed from the config script. It uses the old version of API,\nstill very common on OS distributions. For using the new version of\nGeoIP API, see geoip2 module.\n\nThe Max Mind GeoIP database is a map of IP network address assignments\nto geographical locales that can be useful -- though approximate -- in\nidentifying the physical location with which an IP host address is\nassociated on a relatively granular level.\n\nThis database itself can be obtained on a free or commercial basis from\n<http://www.maxmind.com/app/ip-location>. The library that interfaces\nwith the Max Mind API, as well as scripts to automate downloading of the\non-disk version of the open-source database is also packaged by the\nDebian Linux distribution and its derivatives as *libgeoip*, and\nprobably by other distributions as well.\n\nDebian Linux squeeze includes already a database as dependency, but as\nthis contain the wrong data, it will not work correctly with the module.\nMore accurate, the module expect the *GeoIP City Edition*, and will not\nwork with the *GeoIP Country Edition*. In newer Debian Linux releases\nthe package *geoip-database-contrib* should contain the necessary\ndatabase. You can download the Lite edition of the DB from\n<http://www.maxmind.com/app/geolitecity>.\n\nThis module exports a new class of pseudo-variables - $gip(pvc=>key) -\nto enable access to the results of a query to the database.\n\nMany queries can be done and store results in different containers to be\nable to use in parallel. Database is loaded at startup in cache.\n",
  "parameters": {
   "path": "### `path` (string)\n\nPath to the GeoIP database file.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"geoip\", \"path\", \"/usr/local/share/GeoLiteCity.dat\")\n...\n```\n"
  },
  "functions": {
   "geoip_match": "### `geoip_match(ipaddr, pvc)`\n\nMatch ipaddr against the GeoIP database and set the pvc container. The\nfunction has to be called before accessing a key via: $gip(pvc=>key).\n\n```\n...\nif(geoip_match(\"$si\", \"src\"))\n    xlog(\"SIP message from: $gip(src=>cc)\\n\");\n...\n```\n"
  }
 },
 "geoip2": {
  "overview": "This module allows real-time queries against the Max Mind GeoIP2\ndatabase to be performed from the config script.\n\nThe Max Mind GeoIP2 database is a map of IP network address assignments\nto geographical locales that can be useful -- though approximate -- in\nidentifying the physical location with which an IP host address is\nassociated on a relatively granular level.\n\nThis database itself can be obtained on a free or commercial basis from\n<http://dev.maxmind.com/geoip/>. The library libmaxminddb that\ninterfaces with the Max Mind API, as well as scripts to automate\ndownloading of the on-disk version are available at\n<http://dev.maxmind.com/geoip/geoip2/downloadable/>.\n\nThis module exports a new class of pseudo-variables -\n$gip2(pvc=>key) - to enable access to the results of a query to the\ndatabase.\n\nMany queries can be done and store results in different containers to be\nable to use in parallel. Database is loaded at startup in cache. The\ncache can be reloaded with an RPC command. In this case make sure that\nyou do not overwrite the file in place, but replace it, e.g. with a\n\u201cmove\u201d command.\n",
  "parameters": {
   "path": "### `path` (string)\n\nPath to the GeoIP2 database file.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"geoip2\", \"path\", \"/usr/local/share/GeoIP/GeoLite2-City.mmdb\")\n...\n```\n",
   "resid": "### `resid` (str)\n\nPreregister result container id during initialization, enabling the use\nof the module in KEMI scripts. In native Kamailio.cfg file, registration\nis done when parsing config and finding variables.\n\n*Default value is \u201c\u201d (empty).*\n\n```\n...\nmodparam(\"geoip2\", \"resid\", \"src\")\n...\nif(geoip2_match(\"$si\", \"src\")) {\n   ...\n}\n...\n```\n"
  },
  "functions": {
   "geoip2_match": "### `geoip2_match(ipaddr, pvc)`\n\nMatch ipaddr against the GeoIP database and set the pvc container. The\nfunction has to be called before accessing a key via: $gip2(pvc=>key).\nAt least one function needs to be present that access the pvc container,\notherwise this function will not work.\n\n```\n...\nif(geoip2_match(\"$si\", \"src\"))\n    xlog(\"SIP message from: $gip2(src=>cc)\\n\");\n...\n```\n",
   "geoip2_distance": "### `geoip2_distance(ip_addr, latitude, longitude)`\n\nThe function calculates the distance in miles between the geocoordinates\nof the IP address passed as parameter (the coordinates are calculated\ninside the function) and the geocoordinates *latitude* and *longitude*\n\n```\n...\n    $var(client_ip) = \"109.184.18.64\";\n    $var(lat_pos) = \"53.200660\";\n    $var(lon_pos) = \"45.004640\";\n    $var(dist) = geoip2_distance($var(client_ip), $var(lat_pos), $var(lon_pos));\n\n    xlog(\"distance is $var(dist)\\n\");\n...\n```\n"
  }
 },
 "group": {
  "overview": "This module provides functionality for two different methods of group\nmembership checking.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nURL of the database table to be used.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"group\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "table": "### `table` (string)\n\nName of the table holding strict definitions of groups and their\nmembers.\n\n*Default value is \u201cgrp\u201d.*\n\n```\n...\nmodparam(\"group\", \"table\", \"grp_table\")\n...\n```\n",
   "user_column": "### `user_column` (string)\n\nName of the \u201ctable\u201d column holding usernames.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"group\", \"user_column\", \"user\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nName of the \u201ctable\u201d column holding domains.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"group\", \"domain_column\", \"realm\")\n...\n```\n",
   "group_column": "### `group_column` (string)\n\nName of the \u201ctable\u201d column holding group names.\n\n*Default value is \u201cgrp\u201d.*\n\n```\n...\nmodparam(\"group\", \"group_column\", \"grp\")\n...\n```\n",
   "use_domain": "### `use_domain` (integer)\n\nIf enabled (set to a non zero value) then the domain will be used also\nused for strict group matching; otherwise only the username part will be\nused.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"group\", \"use_domain\", 1)\n...\n```\n",
   "re_table": "### `re_table` (string)\n\nName of the table holding definitions for regular-expression based\ngroups. If no table is defined, the regular-expression support is\ndisabled.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"group\", \"re_table\", \"re_grp\")\n...\n```\n",
   "re_exp_column": "### `re_exp_column` (string)\n\nName of the \u201cre_table\u201d column holding the regular expression used for\nuser matching.\n\n*Default value is \u201creg_exp\u201d.*\n\n```\n...\nmodparam(\"group\", \"re_exp_column\", \"re\")\n...\n```\n",
   "re_gid_column": "### `re_gid_column` (string)\n\nName of the \u201cre_table\u201d column holding the group IDs.\n\n*Default value is \u201cgroup_id\u201d.*\n\n```\n...\nmodparam(\"group\", \"re_gid_column\", \"grp_id\")\n...\n```\n",
   "multiple_gid": "### `multiple_gid` (integer)\n\nIf enabled (non zero value) the regular-expression matching will return\nall group IDs that match the user; otherwise only the first will be\nreturned.\n\n*Default value is \u201c1\u201d (enabled).*\n\n```\n...\nmodparam(\"group\", \"multiple_gid\", 0)\n...\n```\n"
  },
  "functions": {
   "is_user_in": "### `is_user_in(URI, group)`\n\nThis function is to be used for script group membership. The function\nreturns true if username in the given URI is a member of the given group\nand false if not.\n\nMeaning of the parameters is as follows:\n\n- *URI* - URI whose username and optionally domain to be used, this can\n  be one of:\n\n  - Request-URI - Use Request-URI username and (optionally) domain.\n\n  - To - Use To username and (optionally) domain.\n\n  - From - Use From username and (optionally) domain.\n\n  - Credentials - Use digest credentials username.\n\n  - $avp(name) - Use the URI from the AVP specified by this\n    pseudo-variable.\n\n\n- *group* - Name of the group to check.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (is_user_in(\"Request-URI\", \"ld\")) {\n    ...\n};\n...\n```\n",
   "get_user_group": "### `get_user_group(URI, AVP)`\n\nThis function is to be used for regular expression based group\nmembership. The function returns true if username in the given URI\nbelongs to at least one group; the group ID(s) are returned as AVPs.\n\nMeaning of the parameters is as follows:\n\n- *URI* - URI to be matched against the regular expressions:\n\n  - Request-URI - Use Request-URI\n\n  - To - Use To URI.\n\n  - From - Use From URI\n\n  - Credentials - Use digest credentials username and realm.\n\n  - $avp(name) - Use the URI from the AVP specified by this\n    pseudo-variable.\n\n\n- *AVP* - $avp(name) - the matched group IDs are returned in this AVP.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (get_user_group(\"Request-URI\", \"$avp(i:10)\")) {\n    xgdb(\"User $ru belongs to $(avp(i:10)[*]) group(s)\\n\");\n    ....\n};\n...\n```\n"
  }
 },
 "gzcompress": {
  "overview": "This module is able to detect compressed body in received SIP message\nand decompress it as well as compress the body for outgoing SIP message.\nIt works also for received HTTP request and replied HTTP response\n(Kamailio cannot work in HTTP proxy mode).\n\nThe decision of whether to do compression or decompression is made by\ndetecting a special SIP header (default 'Content-Encoding') that matches\na given value - both header name and value can be set via module\nparameters. If a SIP message is received with clear body and you want to\ncompress the body for outgoing, add the header in config file. The\nheader can be added to the local generated replies as well.\n\nIn other words, if the header is present in incoming SIP message, its\nbody is decompressed. If the header is present in outgoing SIP message,\nits body is compressed. Therefore inside configuration file, the body is\nin original format(e.g., plain text). In this way, the existing\nfunctions to handle content of the body work as usual (e.g., to strip\ncodecs in sdp via sdpops or do substitutions via textops).\n\nThe functions used to compress and decompress are from zlib library\n(http://zlib.net).\n\nNOTE: for the moment the module cannot be used with topoh module,\noverlapping in core event callbacks (will be fixed soon).\n\nThe immediate benefit of compressing the body is to reduce the size of\nthe SIP message, increasing the chances to stay under MTU for UDP\npackets. From observation, the compressed body is in between 50% to 67%\nsmaller than the original size (e.g., a body of 431 bytes was compressed\nto 230).\n\nA use case can be when having peering traffic between two Kamailio\nservers. Before relaying to the other Kamailio, use in config file:\nappend_hf(\"Content-Encoding: deflate\\r\\n\").\n",
  "parameters": {
   "header_name": "### `header_name` (str)\n\nName of the header that indicates compression or decompression has to be\ndone.\n\n*Default value is \"Content-Encoding\".*\n\n```\n...\nmodparam(\"gzcompress\", \"header_name\", \"Encoded\")\n...\n```\n",
   "header_value": "### `header_value` (str)\n\nValue of the header that indicates compression or decompression has to\nbe done.\n\n*Default value is \"deflate\".*\n\n```\n...\nmodparam(\"gzcompress\", \"header_value\", \"gzip\")\n...\n```\n",
   "sanity_checks": "### `sanity_checks` (integer)\n\nIf set to 1, gzcompress module will bind to sanity module in order to\nperform sanity checks over received SIP request. Default sanity checks\nare done. It is useful to check if received request is well formatted\nbefore proceeding to encoding/decoding.\n\n*Default value is 0 (do not bind to sanity module).*\n\n```\n...\nmodparam(\"gzcompress\", \"sanity_checks\", 1)\n...\n```\n"
  },
  "functions": {}
 },
 "h350": {
  "overview": "The Kamailio H350 module enables a Kamailio SIP proxy server to access\nSIP account data stored in an LDAP [[RFC4510]](#RFC4510) directory\ncontaining H.350 [[H.350]](#H350) *commObjects*. ITU-T Recommendation\nH.350 standardizes LDAP object classes to store Real-Time Communication\n(RTC) account data. In particular, *H.350.4* [[H.350.4]](#H350-4)\ndefines an object class called *sipIdentity* that includes attribute\nspecifications for SIP account data like SIP URI, SIP digest\nusername/password, or service level. This allows to store SIP account\ndata in a vendor neutral way and lets different entities, like SIP\nproxies, provisioning, or billing applications, access the data in a\nstandardized format.\n\nThe *ViDe H.350 Cookbook* [[vide-h.350-cb]](#vide-H350-cookbook) is a\ngood reference for deploying an H.350 directory. Besides general\ninformation on H.350, LDAP, and related standards, this document\nexplains how to set up an H.350/LDAP directory and discusses different\ndeployment scenarios.\n\nThe H350 module uses the Kamailio LDAP module to import H.350 attribute\nvalues into the Kamailio routing script variable space. The module\nexports functions to parse and store the H.350 attribute values from the\nKamailio routing script. It allows a script writer to implement H.350\nbased SIP digest authentication, call forwarding, SIP URI alias to AOR\nrewriting, and service level parsing.\n",
  "parameters": {
   "ldap_session": "### ldap_session (string)\n\nName of the LDAP session to be used for H.350 queries, as defined in the\nLDAP module configuration file.\n\nDefault value: \"\"\n\n```\nmodparam(\"h350\", \"ldap_session\", \"h350\");\n            \n```\n",
   "base_dn": "### base_dn (string)\n\nBase LDAP DN to start LDAP search for H.350 entries. For best\nperformance, this should be set to the direct ancestor of the H.350\nobjects.\n\nDefault value: \"\"\n\n```\nmodparam(\"h350\", \"base_dn\", \"ou=h350,dc=example,dc=com\");\n            \n```\n",
   "search_scope": "### search_scope (string)\n\nLDAP search scope for H.350 queries, one of \"one\", \"base\", or \"sub\".\n\nDefault value: \"one\"\n\n```\nmodparam(\"h350\", \"search_scope\", \"sub\");\n            \n```\n"
  },
  "functions": {
   "h350_sipuri_lookup": "### h350_sipuri_lookup(sip_uri)\n\nThis function performs an LDAP search query for an H.350 commObject with\na SIPIdentitySIPURI of `sip_uri`. The `sip_uri` parameter first gets\nescaped according the rules for LDAP filter strings. The result of the\nLDAP search is stored internally and can be accessed either by one of\nthe *h350_result** or one of the *ldap_result** functions from the\nKamailio LDAP module.\n\nThe function returns `-1` (FALSE) for internal errors, and `-2` (FALSE)\nif no H.350 commObject was found with a matching `sip_uri`. `n` > 0\n(TRUE) is returned if `n` H.350 commObjects were found.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\nsip_uri  \nH.350 SIPIdentitySIPURI to search for in directory. Included Kamailio\nvariables do get expanded.\n\n<!-- -->\n\n\n`n` > 0 (TRUE):\n\n- `n` H.350 commObjects found.\n\n`-1` (FALSE):\n\n- Internal error occurred.\n\n`-2` (FALSE):\n\n- No H.350 commObject found.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n#\n# H.350 lookup for callee\n#\n\nif (!h350_sipuri_lookup(\"sip:$rU@$rd\"))\n{\n    switch ($retcode)\n    {\n    case -2:\n        xlog(\"L_INFO\",\n             \"h350 callee lookup: no entry found in H.350 directory\");\n        exit;\n    case -1:\n        sl_send_reply(\"500\", \"Internal server error\");\n        exit;\n    }\n}\n\n# now h350_result* or ldap_result* functions can be used\n            \n```\n",
   "h350_auth_lookup": "### h350_auth_lookup(auth_username, \"username_avp_spec/pwd_avp_spec\")\n\nThis function performs an LDAP search query for SIP digest\nauthentication credentials in an H.350 directory. The H.350 directory is\nsearched for a commObject with SIPIdentityUserName of `auth_username`.\nIf such a commObject is found, the SIP digest authentication username\nand password are stored in AVPs `username_avp_spec` and `pwd_avp_spec`,\nrespectively. *pv_\\*_authorize* functions from AUTH module can then be\nused to perform SIP digest authentication.\n\nThe function returns `1` (TRUE) if an H.350 commObject was found, `-1`\n(FALSE) in case of an internal error, and `-2` (FALSE) if no matching\ncommObject was found.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\nauth_username  \nH.350 SIPIdentityUserName to search for in directory. Included Kamailio\nvariables do get expanded.\n\nusername_avp_spec  \nSpecification for authentication username AVP, e.g. `$avp(s:username)`.\n\npwd_avp_spec  \nSpecification for authentication password AVP, e.g. `$avp(s:pwd)`.\n\n<!-- -->\n\n\n`1` (TRUE):\n\n- H.350 commObject found and SIP digest authentication credentials\n  stored in `username_avp_spec` and `pwd_avp_spec`.\n\n`-1` (FALSE):\n\n- Internal error occurred.\n\n`-2` (FALSE):\n\n- No H.350 commObject found.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n# -- auth params --\nmodparam(\"auth\", \"username_spec\", \"$avp(s:auth_user)\")\nmodparam(\"auth\", \"password_spec\", \"$avp(s:auth_pwd)\")\nmodparam(\"auth\", \"calculate_ha1\", 1)\n\n# -- h350 params --\nmodparam(\"h350\", \"ldap_session\", \"h350\")\nmodparam(\"h350\", \"base_dn\", \"ou=h350,dc=example,dc=com\")\nmodparam(\"h350\", \"search_scope\", \"one\")\n\n\nroute[1]\n{\n    #\n    # H.350 based SIP digest authentication\n    #\n\n    # challenge all requests not including an Auth header\n    if (!(is_present_hf(\"Authorization\") ||\n          is_present_hf(\"Proxy-Authorization\")))\n    {\n        if (is_method(\"REGISTER\"))\n        {\n            www_challenge(\"example.com\", \"0\");\n            exit;\n        }\n        proxy_challenge(\"example.com\", \"0\");\n        exit;\n    }\n\n    # get digest password from H.350 using auth username ($au)\n    if (!h350_auth_lookup(\"$au\",\n                          \"$avp(s:auth_user)/$avp(s:auth_pwd)\"))\n    {\n        switch ($retcode)\n        {\n        case -2:\n            sl_send_reply(\"401\", \"Unauthorized\");\n            exit;\n        case -1:\n            sl_send_reply(\"500\", \"Internal server error\");\n            exit;\n        }\n    }\n\n    # REGISTER requests\n    if (is_method(\"REGISTER\"))\n    {\n        if (!pv_www_authorize(\"example.com\"))\n        {\n            if ($retcode == -5)\n            {\n                sl_send_reply(\"500\", \"Internal server error\");\n                exit;\n            }\n            else {\n                www_challenge(\"example.com\", \"0\");\n                exit;\n            }\n        }\n\n        consume_credentials();\n        xlog(\"L_INFO\",\n             \"REGISTER request successfully authenticated\");\n        return(1);\n    }\n\n    # non-REGISTER requests\n    if (!pv_proxy_authorize(\"example.com\"))\n    {\n        if ($retcode == -5)\n        {\n            sl_send_reply(\"500\", \"Internal server error\");\n            exit;\n        }\n        else {\n            proxy_challenge(\"example.com\", \"0\");\n            exit;\n        }\n    }\n\n    consume_credentials();\n    xlog(\"L_INFO\", \"$rm request successfully authenticated\");\n    return(1);\n}\n            \n```\n",
   "h350_result_call_preferences": "### h350_result_call_preferences(avp_name_prefix)\n\nThis function parses the callPreferenceURI attribute of an H.350\ncommObject, which must have been fetched through *h350_\\*_lookup* or\n*ldap_search*. callPreferenceURI is a multi-valued attribute that stores\ncall preference rules like e.g. forward-on-busy or\nforward-unconditionally. *Directory services architecture for call\nforwarding and preferences* [[H.350.6]](#H350-6) defines a format for\nsimple call forwarding rules:\n\n> `target_uri type[:argument]`\n\n\n\nIn a SIP environment, `target_uri` is typically the call forwarding\nrule's target SIP URI, although it could be any type of URI, e.g. an\nHTTP pointer to a CPL script. Four different values are specified for\n`type`: `b` for \"forward on busy\", `n` for \"forward on no answer\", `u`\nfor \"forward unconditionally\", and `f` for \"forward on destination not\nfound\". The optional `argument` is a string indicating the time in\nmilliseconds after which the call forwarding should occur.\n\n```\n# Example 1:\n# forward to sip:voicemail@example.com on no answer after 15 seconds:\n\ncallPreferenceURI: sip:voicemail@example.com n:15000\n\n# Example 2:\n# unconditionally forward to sip:alice@example.com:\n\ncallPreferenceURI: sip:alice@example.com u\n\n# Example 3:\n# forward to sip:bob@example.com and sip:alice@example.com\n# (forking) on destination not found:\n\ncallPreferenceURI: sip:bob@example.com f\ncallPreferenceURI: sip:alice@example.com f\n            \n```\n\n*h350_result_call_preferences* stores these call forwarding rules as\nAVPs according to the following rules:\n\n> ```\n> #\n> # AVP storing a forwarding rule's target URI\n> #\n\n> AVP name  = avp_name_prefix + '_' + type\n> AVP value = target_uri\n\n> #\n> # AVP storing a forwarding rule's argument\n> #\n\n> AVP name  = avp_name_prefix + '_' + type + '_t'\n> AVP value = argument / 1000\n            \n> ```\n\n\n\nExample 1 from above would result in two AVPs:\n`$avp(&quot;s:prefix_n&quot;) = &quot;sip:voicemail@example.com&quot;` and\n`$avp(&quot;s:prefix_n_t&quot;) = 15`.\n\nExample 2: `$avp(&quot;s:prefix_u&quot;) = &quot;sip:alice@example.com&quot;`.\n\nExample 3: `$avp(&quot;s:prefix_f[1]&quot;) = &quot;sip:bob@example.com&quot;` and\n`$avp(&quot;s:prefix_f[2]]&quot;) = &quot;sip:alice@example.com&quot;`.\n\nThese AVPs can then be used to implement the desired behavior in the\nKamailio routing script.\n\nThis function returns the number of successfully parsed simple call\nforwarding rules (TRUE), in case the H.350 callPreferenceURI attribute\ncontained one or multiple values matching the simple call forwarding\nrule syntax described above. It returns `-1` (FALSE) for internal\nerrors, and `-2` (FALSE) if none of the rules matched or if no\ncallPreferenceURI attribute was found.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\navp_name_prefix  \nName prefix for call forwarding rule AVPs, as described above.\n\n<!-- -->\n\n\n`n` > 0 (TRUE):\n\n- `n` simple call forwarding rules found.\n\n`-1` (FALSE):\n\n- Internal error occurred.\n\n`-2` (FALSE):\n\n- No simple call forwarding rule found, or callPreferenceURI not\n  present.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n#\n# H.350 lookup for callee\n#\n\n... h350_sipuri_lookup(\"sip:$rU@$rd\") ...\n\n#\n# store H.350 call preferences in AVP\n#\n\nif (!h350_result_call_preferences(\"callee_pref_\") && ($retcode == -1))\n{\n    sl_send_reply(\"500\", \"Internal server error\");\n    exit;\n}\n\n# $avp(s:callee_pref_u)   == CFU URI(s)\n# $avp(s:callee_pref_n)   == CFNR URI(s)\n# $avp(s:callee_pref_n_t) == CFNR timeout in seconds\n# $avp(s:callee_pref_b)   == CFB URI(s)\n# $avp(s:callee_pref_f)   == CFOFFLINE URI(s)\n\n#\n# Example for forward-unconditionally (CFU)\n#\n\nif (is_avp_set(\"$avp(s:callee_pref_u)\"))\n{\n    # replace R-URI with CFU URI, g will fetch all CFU URIs\n    # --> request can fork\n    if (avp_pushto(\"$ru\", \"$avp(s:callee_pref_u)/g\"))\n    {\n            avp_delete(\"$avp(s:callee_pref_u)\");\n    } else\n    {\n            sl_send_reply(\"500\", \"Internal server error\");\n            exit;\n    }\n    sl_send_reply(\"181\", \"Call is being forwarded\");\n    t_relay();\n    exit;\n}\n            \n```\n",
   "h350_result_service_level": "### h350_result_service_level(avp_name_prefix)\n\n*Directory services architecture for SIP* [[H.350.4]](#H350-4) defines\na multi-valued LDAP attribute named SIPIdentityServiceLevel, which can\nbe used to store SIP account service level values in an LDAP directory.\nThis function parses the SIPIdentityServiceLevel attribute and stores\nall service level values as AVPs for later retrieval in the Kamailio\nrouting script. The function accesses the H.350 commObject fetched by a\ncall to *h350_\\*_lookup* or *ldap_search*.\n\nThe resulting AVPs have a name of the form\n`avp_name_prefix + SIPIdentityServiceLevel attribute value`, and an\ninteger value of `1`.\n\n```\nSIPIdentityServiceLevel: longdistance\nSIPIdentityServiceLevel: international\nSIPIdentityServiceLevel: 900\n\nafter calling h350_result_service_level(\"sl_\"), the following AVPs\nwill be available in the routing script:\n\n$avp(\"s:sl_longdistance\") = 1\n$avp(\"s:sl_international\") = 1\n$avp(\"s:sl_900\") = 1\n            \n```\n\nThis function returns the number of added AVPs (TRUE), `-1` (FALSE)for\ninternal errors, and `-2` (FALSE)if no SIPIdentityServiceLevel attribute\nwas found.\n\nThe function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\navp_name_prefix  \nName prefix for service level AVPs, as described above.\n\n<!-- -->\n\n\n`n` > 0 (TRUE):\n\n- `n` AVPs added.\n\n`-1` (FALSE):\n\n- Internal error occurred.\n\n`-2` (FALSE):\n\n- No SIPIdentityServiceLevel attribute found.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n#\n# H.350 SIP digest authentication for caller\n#\n\n... h350_auth_lookup(\"$au\", ...) ...\n\n#\n# store caller's service level as AVP\n#\n\nif (!h350_result_service_level(\"caller_sl_\") && ($retcode == -1))\n{\n    sl_send_reply(\"500\", \"Internal server error\");\n    exit;\n}\n\n#\n# make routing decision based on service level AVPs\n#\n\nif (is_avp_set(\"$avp(s:caller_sl_international)\"))\n{\n    t_relay();\n}\nelse {\n    sl_send_reply(\"403\", \"Forbidden\");\n}\nexit;\n            \n```\n"
  }
 },
 "htable": {
  "overview": "The module adds a hash table container to the configuration language.\nThe hash table is stored in shared memory and the access to it can be\ndone via pseudo-variables: $sht(htname=>name). The module supports\ndefinition of many hash tables and can load values at startup from a\ndatabase table.\n\nA typical use case for the SIP server is to implement a cache system in\nconfiguration file - if a value is not found in hash table, load it from\ndatabase and store it in hash table so next time the access to it is\nvery fast. In the definition of the table you can define the default\nexpiration time of cached items. The expiration time can be adjusted per\nitem via assignment operation at runtime.\n\nReplication between multiple servers is performed automatically (if\nenabled) via the DMQ module.\n\nYou can read more about hash tables at:\nhttp://en.wikipedia.org/wiki/Hash_table.\n\nThe \u201cname\u201d can be a static string or can include pseudo- variables that\nwill be replaced at runtime.\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=8;\")\n...\n$sht(a=>test) = 1;\n$sht(a=>$ci::srcip) = $si;\n...\n```\n\nThe next example shows a way to protect against dictionary attacks. If\nsomeone fails to authenticate 3 times, it is forbidden for 15 minutes.\nAuthentication against database is expensive as it does a select on the\n\u201csubscriber\u201d table. By disabling the DB auth for 15 minutes, resources\non the server are saved and time to discover the password is increased\nsubstantially. Additional alerting can be done by writing a message to\nsyslog or sending email, etc.\n\nTo implement the logic, two hash table variables are used: one counting\nthe failed authentications per user and one for storing the time of the\nlast authentication attempt. To ensure a unique name per user, the hash\ntable uses a combination of authentication username and text\n\u201c::auth_count\u201d and \u201c::last_auth\u201d.\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=8;\")\n...\nif(is_present_hf(\"Authorization\"))\n{\n    if($sht(a=>$au::auth_count)==3)\n    {\n        $var(exp) = $Ts - 900;\n        if($sht(a=>$au::last_auth) > $var(exp))\n        {\n            sl_send_reply(\"403\", \"Try later\");\n            exit;\n        } else {\n            $sht(a=>$au::auth_count) = 0;\n        }\n    }\n    if(!www_authenticate(\"$td\", \"subscriber\"))\n    {\n        switch ($retcode) {\n            case -1:\n                sl_send_reply(\"403\", \"Forbidden\");\n            exit;\n            case -2:\n                if($sht(a=>$au::auth_count) == $null)\n                    $sht(a=>$au::auth_count) = 0;\n                $sht(a=>$au::auth_count) = $sht(a=>$au::auth_count) + 1;\n                if($sht(a=>$au::auth_count) == 3)\n                    xlog(\"auth failed 3rd time - src ip: $si\\n\");\n                $sht(a=>$au::last_auth) = $Ts;\n            break;\n        }\n        www_challenge(\"$td\"/*realm*/,\"0\"/*qop*/);\n        exit;\n    }\n    $sht(a=>$au::auth_count) = 0;\n} else {\n    www_challenge(\"$td\",\"0\");\n    exit;\n}\n...\n```\n\nThe module also provides a way to store multiple values for a single\nkey. This is emulated by storing individual keys as 'key_name[n]',\nwhere n is incremented for each key. The total number of keys is stored\nin a dedicated key, by default: 'key_name::size'.\n\nThe array is built when the table is loaded in memory and afterwards all\nthe keys are treated as individual keys. If a particular entry in the\narray is deleted, it is the administrator's responsibility to update the\nsize of the array and any other elements (if required).\n\n```\n# Example of dbtext with multiple keys\n$ cat /usr/local/etc/kamailio/dbtext/htable\n1:key:1:0:value3:0\n2:key:1:0:value2:0\n3:key:1:0:value1:0\n\n# The array key will be loaded in memory in the following format:\n$ kamcmd htable.dump htable\n{\n        entry: 35\n        size: 1\n        slot: {\n                item: {\n                        name: key[0]\n                        value: value1\n                }\n        }\n}\n{\n        entry: 50\n        size: 1\n        slot: {\n                item: {\n                        name: key::size\n                        value: 3\n                }\n        }\n}\n{\n        entry: 67\n        size: 1\n        slot: {\n                item: {\n                        name: key[1]\n                        value: value2\n                }\n        }\n}\n{\n        entry: 227\n        size: 1\n        slot: {\n                item: {\n                        name: key[2]\n                        value: value3\n                }\n        }\n}\n\n# Now let's delete a particular entry in the array: key[0].\n$ kamcmd htable.delete htable key[0]\n\n# The array key will look like this after a key was deleted:\n$ kamcmd htable.dump htable\n{\n        entry: 50\n        size: 1\n        slot: {\n                item: {\n                        name: key::size\n                        value: 3\n                }\n        }\n}\n{\n        entry: 67\n        size: 1\n        slot: {\n                item: {\n                        name: key[1]\n                        value: value2\n                }\n        }\n}\n{\n        entry: 227\n        size: 1\n        slot: {\n                item: {\n                        name: key[2]\n                        value: value3\n                }\n        }\n}\n```\n",
  "parameters": {
   "htable": "### `htable` (str)\n\nThe definition of a hash table. The value of the parameter may have the\nfollowing format:\n\n- \"htname=>size=_number_;autoexpire=_number_;dbtable=_string_\"\n\nThe parameter can be set multiple times to get more hash tables in same\nconfiguration file.\n\n- *htname* - string specifying the name of the hash table. This string\n  is used by *$sht(...)* to refer to the hash table.\n\n- *size* - number to control how many slots (buckets) to create for the\n  hash table. Larger value means more slots with higher probability for\n  less collisions. The actual number slots (or buckets) created for the\n  table is 2^size. The possible range for this value is from 2 to 31,\n  smaller or larger values will be increased to 3 (8 slots) or decreased\n  to 14 (16384 slots). Note that each slot can store more than one item,\n  when there are collisions of hash ids computed for keys. The items in\n  the same slot are stored in a linked list. In other words, the size is\n  not setting a limit of how many items can be stored in a hash table,\n  as long as there is enough free shared memory, new items can be added.\n\n- *autoexpire* -time in seconds to delete an item from a hash table if\n  no update was done to it. If it is missing or set to 0, the items\n  won't expire.\n\n- *dbtable* - name of database to be loaded at startup in hash table. If\n  empty or missing, no data will be loaded.\n\n- *cols* - the column names of the database table. They must be enclosed\n  in quotes in order to form a valid SIP parameter value and be\n  separated by comma. The first column corresponds to key_name. When\n  specified, there must be at least two columns. If this attribute is\n  not specified, then the global module parameters for column names are\n  used. If more than one value columns are specified, the hash table\n  will pack the column values in a comma separated string, which will be\n  associated with the key (string transformation {s.select,...} can be\n  used in configuration file to extract a specific column value). When\n  cols attribute is present, writing back to database table is disabled.\n\n- *dbmode* - if set to 1, the content of hash table is written to\n  database table when the SIP server is stopped (i.e., ensure\n  persistency over restarts). Default value is 0 (no write back to db\n  table).\n\n- *initval* - the integer value to be returned instead of $null when a\n  requested key is not set.\n\n- *updateexpire* - if set to 1 (default), the time until expiration of\n  an item is reset when that item is updated. Certain uses of htable may\n  dictate that updates should not reset the expiration timeout, however,\n  in which case this attribute can be set to 0.\n\n- *dmqreplicate* - if set to 1, any actions (set, update, delete etc.)\n  performed upon entries in this table will be replicated to other nodes\n  (htable peers). Please note, module parameter \u201cenable_dmq\u201d must also\n  be set in order for this to apply (see below). Default is 0 (no\n  replication).\n\n- *coldelim* - the character delimeter to use when packing the htable.\n  When set, this parameter changes the column delimeter between columns\n  in a multiple column hash table. This can be useful when loading JSON\n  data types into a hash table as they conflict with the default \u201c,\u201d\n  delimeter, allowing these values to be parsed in the routing config.\n  See the example below on parsing a JSON array from an htable with \u201c;\u201d\n  as the column delimeter.\n\n  ```\n  ...\n  modparam(\"htable\", \"htable\", \"customer=>size=8;dbtable=customer;cols='dids,description';coldelim=';'\")\n  ...\n  $avp(customer) = $sht(customer=>1);\n  $var(customer_dids) = $(avp(customer){s.select,0,;});\n  $var(customer_desc) = $(avp(customer){s.select,1,;});\n  ...\n  ```\n\n- *colnull* - the character to use when packing a NULL value into the\n  htable from the database. This parameter can be set to the empty\n  string or a single character. This can be used to simplify checking a\n  single column in a row for emptiness, in the routing config. The\n  example below shows how one would do that.\n\n  ```\n  ...\n  modparam(\"htable\", \"htable\", \"customer=>size=8;dbtable=customer;cols='name,description';colnull=''\")\n  ...\n  $avp(customer) = $sht(customer=>1);\n  $var(customer_name) = $(avp(customer){s.select,0,;});\n  if (!strempty($var(customer_name))) {\n  ...\n  }\n  ```\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"htable\", \"htable\", \"a=>size=4;autoexpire=7200;dbtable=htable_a;\")\nmodparam(\"htable\", \"htable\", \"b=>size=5;\")\nmodparam(\"htable\", \"htable\", \"c=>size=4;autoexpire=7200;initval=1;dmqreplicate=1;\")\n...\n```\n",
   "db_url": "### `db_url` (str)\n\nThe URL to connect to database for loading values in hash table at start\nup.\n\n*Default value is NULL (do not connect).*\n\n```\n...\nmodparam(\"htable\", \"db_url\", \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n...\n```\n",
   "key_name_column": "### `key_name_column` (str)\n\nThe name of the column containing the hash table key name.\n\n*Default value is 'key_name'.*\n\n```\n...\nmodparam(\"htable\", \"key_name_column\", \"kname\")\n...\n```\n",
   "key_type_column": "### `key_type_column` (str)\n\nThe name of the column containing the hash table key type.\n\n*Default value is 'key_type'.*\n\n```\n...\nmodparam(\"htable\", \"key_type_column\", \"ktype\")\n...\n```\n",
   "value_type_column": "### `value_type_column` (str)\n\nThe name of the column containing the hash table value type.\n\n*Default value is 'value_type'.*\n\n```\n...\nmodparam(\"htable\", \"value_type_column\", \"vtype\")\n...\n```\n",
   "key_value_column": "### `key_value_column` (str)\n\nThe name of the column containing hash table key value.\n\n*Default value is 'key_value'.*\n\n```\n...\nmodparam(\"htable\", \"key_value_column\", \"kvalue\")\n...\n```\n",
   "expires_column": "### `expires_column` (str)\n\nThe name of the column containing the expires value.\n\n*Default value is 'expires'.*\n\n```\n...\nmodparam(\"htable\", \"expires_column\", \"expiry\")\n...\n```\n",
   "array_size_suffix": "### `array_size_suffix` (str)\n\nThe suffix to be added to store the number of items in an array (see key\ntype).\n\n*Default value is '::size'.*\n\n```\n...\nmodparam(\"htable\", \"array_size_suffix\", \"-count\")\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nHow many rows to fetch at once from database.\n\n*Default value is 100.*\n\n```\n...\nmodparam(\"htable\", \"fetch_rows\", 1000)\n...\n```\n",
   "timer_interval": "### `timer_interval` (integer)\n\nInterval in seconds to check for expired htable values.\n\n*Default value is 20.*\n\n```\n...\nmodparam(\"htable\", \"timer_interval\", 10)\n...\n```\n",
   "db_expires": "### `db_expires` (integer)\n\nIf set to 1, the module loads/saves the value for expire of the items in\nhash table from/to database. It applies only to hash tables that have\nthe auto-expires attribute defined. If set to 0, only the key name and\nthe value are loaded, the expires for each item being set to 0.\n\nNote that the module is not reloading automatically the items from\ndatabase when they expire, the reloading can be done only via RPC\ncommand.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"htable\", \"db_expires\", 1)\n...\n```\n",
   "enable_dmq": "### `enable_dmq` (integer)\n\nIf set to 1, will enable DMQ replication of actions performed upon\nentries in all tables having \"dmqreplicate\" parameter set. Any update\naction performed via pseudo-variables and RPC commands will be repeated\non all other nodes. Therefore, it is important to ensure the table\ndefinition (size, autoexpire etc.) is identical across all instances.\n\n*Important: If this parameter is enabled, the DMQ module must be loaded\nfirst - otherwise, startup will fail.*\n\nCurrently, values are not replicated on load from DB as it is expected\nthat in these cases, all servers will load their values from the same\nDB.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"htable\", \"enable_dmq\", 1)\n...\n```\n",
   "dmq_init_sync": "### `dmq_init_sync` (integer)\n\nIf set to 1, will request synchronization from other nodes at startup.\nIt applies to all tables having the \"dmqreplicate\" parameter set. As\nabove, it is important to ensure the definition (size, autoexpire etc.)\nof replicated tables is identical across all instances.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"htable\", \"dmq_init_sync\", 1)\n...\n```\n",
   "timer_procs": "### `timer_procs` (integer)\n\nIf set to 1 or greater, the module will create its own timer processes\nto scan for expired items in hash tables. If set to zero, it will use\nthe core timer for this task. Set it to 1 if you store a lot of items\nwith autoexpire property.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"htable\", \"timer_procs\", 4)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues can be: 'htable:mod-init', 'htable:expired:htname' ('htname'\nbeing the name of hash table).\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"htable\", \"event_callback\", \"ksr_htable_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_htable_event(evname)\n    KSR.info(\"===== htable module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "event_callback_mode": "### `event_callback_mode` (int)\n\nControl when event_route[htable:init] is executed: 0 - after all\nmodules were initialized; 1 - in first worker process.\n\nSet it to 1 if used in a KEMI script or when needing to use database\n(e.g., via sqlops) inside event_route[htable:init].\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"htable\", \"event_callback_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "sht_print": "### `sht_print()`\n\nDump content of hash table to L_ERR log level. Intended for debug\npurposes.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\n```\n...\nsht_print();\n...\n```\n",
   "sht_rm": "### `sht_rm(htname, itname)`\n\nDelete the item with the name 'itname' from hash table 'htname'. This\nAPI function is equivalent to '$sht(htname=>itname) = $null'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_rm(\"ha\", \"test\"\");\n...\n```\n",
   "sht_rm_name_re": "### `sht_rm_name_re(htable=&gt;regexp)`\n\nDelete all entries in the htable that match the name against regular\nexpression.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\n```\n...\nsht_rm_name_re(\"ha=>.*\");\n...\n```\n",
   "sht_rm_value_re": "### `sht_rm_value_re(htable=&gt;regexp)`\n\nDelete all entries in the htable that match the value against regular\nexpression.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\n```\n...\nsht_rm_value_re(\"ha=>.*\");\n...\n```\n",
   "sht_rm_name": "### `sht_rm_name(htable, op, val)`\n\nDelete all entries in the htable that match the name against the val\nparameter.\n\nThe op parameter can be:\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with'.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_rm_name(\"ha\", \"re\", \".*\");\n...\n```\n",
   "sht_rm_value": "### `sht_rm_value(htable, op, val)`\n\nDelete all entries in the htable that match the value against the val\nparameter.\n\nThe op parameter can be:\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with'.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_rm_value(\"ha\", \"re\", \".*\");\n...\n```\n",
   "sht_setxs": "### `sht_setxs(htname, itname, itval, exval)`\n\nSet the item with the name 'itname' from hash table 'htname' to string\nvalue 'itval' and expire property to 'exval'.\n\nThe parameters can be with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_setxs(\"ha\", \"test\", \"abc\", \"10\");\n...\n```\n",
   "sht_setxi": "### `sht_setxi(htname, itname, itval, exval)`\n\nSet the item with the name 'itname' from hash table 'htname' to integer\nvalue 'itval' and expire property to 'exval'.\n\nThe parameters can be with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_setxs(\"ha\", \"test\", \"100\", \"10\");\n...\n```\n",
   "sht_reset": "### `sht_reset(htable)`\n\nDelete all entries in the htable. The name of the hash table can be a\ndynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_reset(\"ha$var(x)\");\n...\n```\n",
   "sht_lock": "### `sht_lock(htable=&gt;key)`\n\nLock the slot in htable corresponding to the key item. Note that the\nlocking is re-entrant for the process, therefore the lock and unlock\nshould be done by the same process.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_lock(\"ha=>test\");\n...\n```\n",
   "sht_unlock": "### `sht_unlock(htable=&gt;key)`\n\nUnlock the slot in htable corresponding to the key item. Note that the\nlocking is re-entrant for the process, therefore the lock and unlock\nshould be done by the same process.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_lock(\"ha=>test\");\n$sht(ha=>test) = $sht(ha=>test) + 10;\nsht_unlock(\"ha=>test\");\n...\n```\n",
   "sht_iterator_start": "### `sht_iterator_start(iname, hname)`\n\nStart an iterator for hash table named by the value of parameter hname.\nThe parameter iname is used to identify the iterator. There can be up to\n4 iterators at the same time, with different name.\n\nBoth parameters can be dynamic strings with variables.\n\nIMPORTANT: the slot of the hash table is left locked when retrieving in\nitem. Therefore be sure you do not update the content of the hash table\nin between sht_iterator_start() and sht_iterator_end(), because it may\nend up in dead lock.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_iterator_start(\"i1\", \"h1\");\n...\n```\n",
   "sht_iterator_end": "### `sht_iterator_end(iname)`\n\nClose the iterator identified by iname parameter and release the hash\ntable slot acquired by the iterator. The iname value must be the same\nused for sht_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsht_iterator_end(\"i1\");\n...\n```\n",
   "sht_iterator_next": "### `sht_iterator_next(iname)`\n\nMove the iterator to the next item in hash table. It must be called also\nafter sht_iterator_start() to get the first item in the hash table.\nItems are returned as they are found in the hash table slot, starting\nwith the first slot.\n\nThe return code is false when there is no (more) item in the hash table.\n\nThe item name and value are accessible via variables: $shtitkey(iname)\nand $shtitval(iname).\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sht_iterator_start(\"i1\", \"h1\");\n    while(sht_iterator_next(\"i1\")) {\n        xlog(\"h1[$shtitkey(i1)] is: $shtitval(i1)\\n\");\n    }\n    sht_iterator_end(\"i1\");\n...\n```\n",
   "sht_iterator_rm": "### `sht_iterator_rm(iname)`\n\nRemove the current item in the iterator and move the iterator to the\nnext one.\n\nThe return code is 1 (true) if the item was removed and next item\nexists; -2 (false) if the item was removed and there is no next item\n(end of items); other negative value (false) can be returned on error\n(e.g., iterator or item not found).\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sht_iterator_start(\"i1\", \"h1\");\n    while(sht_iterator_next(\"i1\")) {\n        while($shtitkey(i1) =~ \"xyz\" and sht_iterator_rm(\"i1\")) {\n            xdbg(\"item removed\\n\");\n        }\n    }\n    sht_iterator_end(\"i1\");\n...\n```\n",
   "sht_iterator_sets": "### `sht_iterator_sets(iname, sval)`\n\nSet the value of the current item to the string in the sval.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sht_iterator_start(\"i1\", \"h1\");\n    sht_iterator_next(\"i1\");\n    sht_iterator_sets(\"i1\", \"$ci\");\n    sht_iterator_end(\"i1\");\n...\n```\n",
   "sht_iterator_seti": "### `sht_iterator_seti(iname, ival)`\n\nSet the value of the current item to the integer in the ival.\n\nThe parameters can be dynamic strings or integers with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sht_iterator_start(\"i1\", \"h1\");\n    sht_iterator_next(\"i1\");\n    sht_iterator_seti(\"i1\", \"20\");\n    sht_iterator_end(\"i1\");\n...\n```\n",
   "sht_iterator_setex": "### `sht_iterator_setex(iname, exval)`\n\nSet the expire of the current item to the integer in the exval.\n\nThe parameters can be dynamic strings or integers with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sht_iterator_start(\"i1\", \"h1\");\n    sht_iterator_next(\"i1\");\n    sht_iterator_setex(\"i1\", \"120\");\n    sht_iterator_end(\"i1\");\n...\n```\n",
   "sht_match_name": "### `sht_match_name(htable, op, mval)`\n\nReturn greater than 0 (true) if the htable has an item that matches the\nname against the mval parameter.\n\nThe op parameter can be:\n\n- *eq* - match the val parameter as string equal expression.\n\n- *ne* - match the val parameter as string not-equal expression.\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with' expression.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(sht_match_name(\"ha\", \"eq\", \"alice\")) {\n  ...\n}\n...\n```\n",
   "sht_has_name": "### `sht_has_name(htable, op, mval)`\n\nAlias for sht_match_name().\n",
   "sht_match_str_value": "### `sht_match_str_value(htable, op, mval)`\n\nReturn greater than 0 (true) if the htable has an item that matches the\nstring value against the mval parameter.\n\nThe op parameter can be:\n\n- *eq* - match the val parameter as string equal expression.\n\n- *ne* - match the val parameter as string not-equal expression.\n\n- *re* - match the val parameter as regular expression.\n\n- *sw* - match the val parameter as 'starts with' expression.\n\nAll parameters can be static strings or contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(sht_match_str_value(\"ha\", \"eq\", \"alice\")) {\n  ...\n}\n...\n```\n",
   "sht_has_str_value": "### `sht_has_str_value(htable, op, mval)`\n\nAlias for sht_match_str_value().\n"
  }
 },
 "http_async_client": {
  "overview": "This module performs asynchronous HTTP queries.\n",
  "parameters": {
   "workers": "### `workers` (integer)\n\nNumber of worker processes to be started to send HTTP requests and\nasynchronously handle responses.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"http_async_client\", \"workers\", 2)\n...\n```\n",
   "connection_timeout": "### `connection_timeout` (integer)\n\nDefines in milliseconds how long Kamailio waits for a response from HTTP\nserver.\n\n*Default value is 500ms.*\n\n```\n...\nmodparam(\"http_async_client\", \"connection_timeout\", 1000)\n...\n```\n",
   "hash_size": "### `hash_size` (integer)\n\nThe size of the hash table internally used to keep the requests. A\nlarger table is much faster but consumes more memory. The hash size must\nbe a power of two, otherwise it will be rounded down to the nearest\npower of two.\n\n*Default value is 2048.*\n\n```\n...\nmodparam(\"http_async_client\", \"hash_size\", 1024)\n...\n```\n",
   "tls_version": "### `tls_version` (integer)\n\nFor HTTPS connections, what's the preferred SSL version.\nhttp://curl.haxx.se/libcurl/c/CURLOPT_SSLVERSION.html\n\n*Default value is 0 (default SSL version).*\n\n```\n...\nmodparam(\"http_async_client\", \"tls_version\", 6)\n...\n```\n",
   "tls_verify_host": "### `tls_verify_host` (integer)\n\nFor HTTPS connections, whether the client should verify the server host.\nhttp://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html\n\n*Default value is 2 (enabled).*\n\n```\n...\nmodparam(\"http_async_client\", \"tls_verify_host\", 0)\n...\n```\n",
   "tls_verify_peer": "### `tls_verify_peer` (integer)\n\nFor HTTPS connections, whether the client should verify the server\nidentity. http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html\n\n*Default value is 1 (enabled).*\n\n```\n...\nmodparam(\"http_async_client\", \"tls_verify_peer\", 0)\n...\n```\n",
   "curl_verbose": "### `curl_verbose` (integer)\n\nIf defined to a non-zero value, extra information from cURL (request and\nresponse headers) will be included in the kamailio logs, with LM_INFO\npriority.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"http_async_client\", \"curl_verbose\", 1)\n...\n```\n",
   "curl_follow_redirect": "### `curl_follow_redirect` (integer)\n\nIf defined to a non-zero value, will tell curl to follow HTTP 3xx\nredirects.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"http_async_client\", \"curl_follow_redirect\", 1)\n...\n```\n",
   "memory_manager": "### `memory_manager` (string)\n\nChoose the memory manager used by curl:\n\n- *shm*: curl will use kamailio's SHM pool and memory manager\n\n- *sys*: curl will use the system memory and memory manager (malloc,\n  free, ...)\n\n*Note:* if this module is used in conjunction with another module using\nlibcurl (http_client, utils, xcap, xcap_client), it must be loaded as\nfirst one for this parameter to have effect, otherwise curl will likely\nuse the system memory allocator by default. On the other hand if the\nmodule is loaded before any other module using libcurl, all the modules\nwill use the memory manager specified by this parameter.\n\n*Default value \"shm\"*\n\n```\n...\nmodparam(\"http_async_client\", \"memory_manager\", \"sys\")\n...\n```\n",
   "tls_client_cert": "### `tls_client_cert` (string)\n\nFor HTTPS connections, the file path of the TLS client certificate to be\nused. http://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html\n\n*Default value is NULL (not used). Default type is PEM.*\n\n```\n...\nmodparam(\"http_async_client\", \"tls_client_cert\", \"/etc/kamailio/ssl/clientcert.pem\")\n...\n```\n",
   "tls_client_key": "### `tls_client_key` (string)\n\nFor HTTPS connections, the file path of the TLS client certificate key.\nhttp://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html\n\n*Default value is NULL (not used).*\n\n```\n...\nmodparam(\"http_async_client\", \"tls_client_key\", \"/etc/kamailio/ssl/clientcert.key\")\n...\n```\n",
   "tls_ca_path": "### `tls_ca_path` (string)\n\nThe path of the directory holding the CA certificates.\nhttp://curl.haxx.se/libcurl/c/CURLOPT_CAPATH.html\n\n*Default value is NULL..*\n\n```\n...\nmodparam(\"http_async_client\", \"tls_ca_path\", \"/etc/kamailio/ssl/ca/\")\n...\n```\n",
   "tcp_keepalive": "### `tcp_keepalive` (integer)\n\nIf defined to a non-zero value, TCP keepalive will be enabled on cURL\nconnections.\n\n*Requires libcurl >= 7.25.0*\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"http_async_client\", \"tcp_keepalive\", 1)\n...\n```\n",
   "tcp_ka_idle": "### `tcp_ka_idle` (integer)\n\nTCP keep-alive idle time wait value (in seconds).\n\n*Default value is 0 (use cURL default value, 60s).*\n\n```\n...\nmodparam(\"http_async_client\", \"tcp_ka_idle\", 30)\n...\n```\n",
   "tcp_ka_interval": "### `tcp_ka_interval` (integer)\n\nTCP keep-alive interval (in seconds).\n\n*Default value is 0 (use cURL default value, 60s).*\n\n```\n...\nmodparam(\"http_async_client\", \"tcp_ka_interval\", 120)\n...\n```\n"
  },
  "functions": {
   "http_async_query": "### `http_async_query(url, route_name)`\n\nSends HTTP(S) request asynchronously to the URL given in \u201curl\u201d\nparameter, which is a string that may contain pseudo variables.\n\nParameter \u201croute_name\u201d defines the route to be executed upon reception\nof HTTP reply, on error or on timeout. If a transaction exists before\ncalling *http_async_query()*, it will be paused and resumed in this\nroute, while the routing script execution will be stopped. If executed\nin a transactionless context, or if *$http_req(suspend)* is used not to\nsuspend the transaction, the routing script execution will continue and\nthe query result will be available in \u201croute_name\u201d.\n\nReturn value: 0 (stop script execution) on success in transaction\ncontext, 1 (continue script execution) in transaction-less context (or\nif $http_req(suspend) is used), -1 on error.\n\nThis function can be used from ANY_ROUTE.\n\nThis method is executed asynchronously. The HTTP return code, body and\nerror are returned in the module-specific $http_* PVs (see below).\nSee example on how to retrieve return values.\n\n```\n...\n# create a transaction to be paused, and resumed in route[HTTP_REPLY]\nt_newtran();\n# GET\nhttp_async_query(\"http://example.com/test.php?r_uri=$rU&f_uri=$fU\", \"HTTP_REPLY\");\n...\n# POST\n$http_req(body) = \"{'r_uri':'\" + $rU + \"', 'f_uri':'\" + $fU + \"'}\";\nhttp_async_query(\"http://example.com/test.php\", \"HTTP_REPLY\");\n...\nroute[HTTP_REPLY] {\n    if ($http_ok) {\n        xlog(\"L_INFO\", \"route[HTTP_REPLY]: status $http_rs\\n\");\n        xlog(\"L_INFO\", \"route[HTTP_REPLY]: body   $http_rb\\n\");\n    } else {\n        xlog(\"L_INFO\", \"route[HTTP_REPLY]: error  $http_err)\\n\");\n    }\n}\n...\n        \n```\n"
  }
 },
 "http_client": {
  "overview": "This module implements protocol functions that use the libcurl library\nto fetch data from external HTTP servers or post data to HTTP servers.\nThe module is using a concept of \"connections\" to define properties of\nHTTP sessions in a simple way. A connection has one or multiple servers\nand a set of settings that apply to the specific connection.\n\nThe http_client module has multiple settings, some of them apply to a\ndefined connection. You can set timeouts, max data sizes for download\nand much more either using modparam settings or parameters to the\nconnection definition.\n\nThe connections can either be defined with the \"httpcon\" module\nparameter or in a separate configuration file, as specified by the\n\"config_file\" module parameter.\n\nLike in SIP, the HTTP URL may need encoding to be transported safely\nover the network. Check the string encoding functions in the\nTransformation Cookbook (as used in the http_client_query() example\nbelow).\n\nThe function http_client_query() allows Kamailio to issue an HTTP GET\nrequest and get access to parts of the reply. This function has been\nported from the utils module and now use the same libcurl functions. We\nrecommend using the new functionality provided by this module.\n\nThe http_client module uses the CURL library setting up connections. The\nCURL library by default use the system configured DNS resolvers, not the\nKamailio resolver.\n\nThe module is limited to using HTTP and HTTPS protocols.\n",
  "parameters": {
   "httpredirect": "### `httpredirect` (int)\n\nIf set to 1, enabled, http_client will follow HTTP 302 Redirects. If set\nto 0, http_client will not follow redirects. Default is 1, enabled.\n\nThe latest redirect URL will be stored in the *$curlredirect*\npseudovariable.\n\n```\n...\nmodparam(\"http_client\", \"httpredirect\", 0)\n...\n                \n```\n",
   "httpproxy": "### `httpproxy` (string)\n\nURL for a HTTP proxy to use as a default proxy for all connections.\n\nThis setting is also available on a per connection basis in the\nhttp_client configuration file.\n\n```\n...\nmodparam(\"http_client\", \"httpproxy\", \"https://superproxy.example.com\")\n...\n                \n```\n",
   "httpproxyport": "### `httpproxyport` (string)\n\nPort number for a HTTP proxy to use as a default proxy port for all\nconnections.\n\nThis setting is also available on a per connection basis in the\nhttp_client configuration file.\n\n```\n...\nmodparam(\"http_client\", \"httpproxyport\", 8042)\n...\n                \n```\n",
   "useragent": "### `useragent` (string)\n\nUseragent to use in the HTTP protocol for requests. Defaults to the\nKamailio SIP useragent string - including software version and platform.\n\n```\n...\nmodparam(\"http_client\", \"useragent\", \"Secret HTTP REST grabber 0.42\")\n...\n                \n```\n",
   "maxdatasize": "### `maxdatasize` (int)\n\nDefines the maximum size in bytes for a response. Note that this is\nallocated from pkg memory (process memory) dynamically.\n\n*Default value is zero, i.e., the limit on the datasize is disabled.*\n\n```\n...\nmodparam(\"http_client\", \"maxdatasize\", 2000)\n...\n                \n```\n",
   "connection_timeout": "### `connection_timeout` (int)\n\nDefines how long Kamailio waits for response from servers. Value is\nexpressed in seconds or milliseconds, depending on parameter\ntimeout_mode.\n\n*Default value is 4 seconds.*\n\n```\n...\nmodparam(\"http_client\", \"connection_timeout\", 2)\n...\n                \n```\n",
   "timeout_mode": "### `timeout_mode` (int)\n\nDefines if timeouts are enabled, and in which unit timeout values are\nexpressed.\n\nValid values are:\n\n- 0 - Timeouts are disabled.\n\n- 1 - Timeout values are in seconds (default).\n\n- 2 - Timeout values are in milliseconds.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"http_client\", \"timeout_mode\", 1)\n...\n                    \n```\n",
   "client_cert": "### `client_cert` (string)\n\nFile name for a TLS client certificate. The certificate needs to be\nencoded in PEM format.\n\n*Default value is empty string, i.e. no client certificate used. Note\nthat if you specify a client cert, you also need to specify the\n`client_key`.*\n\n```\n...\nmodparam(\"http_client\", \"client_cert\", \"/var/certs/sollentuna.example.com.cert\")\n...\n                \n```\n",
   "client_key": "### `client_key` (string)\n\nFile name for a TLS client key. The key needs to be encoded in PEM\nformat.\n\n*Default value is empty string, i.e. no client certificate or key is\nused. Note that if you specify a client key, you also need to specify\nthe `client_cert`.*\n\n```\n...\nmodparam(\"http_client\", \"client_key\", \"/var/certs/sollentuna.example.com.key\")\n...\n                \n```\n",
   "cacert": "### `cacert` (string)\n\nFile name for the trusted TLS CA cert used to verify servers. The\ncertificates need to be encoded in PEM format.\n\n*Default value is empty string, i.e. no CA certificate is used to verify\nthe host. If `tlsverifyhost` is on, all TLS connections will fail\nwithout any CA certificate to validate with.*\n\n```\n...\nmodparam(\"http_client\", \"cacert\", \"/var/certs/ca/edvina-sip-ca.pem\")\n...\n                \n```\n",
   "cipher_suites": "### `cipher_suites` (string)\n\nList of allowed cipher suites. See\nhttp://curl.haxx.se/libcurl/c/CURLOPT_SSL_CIPHER_LIST.html for details\nof the cipher list curl option.\n\n*Default value is empty string, i.e. the default list of ciphers in\nlibcurl will be used.*\n\n```\n...\nmodparam(\"http_client\", \"cipher_suites\", \"ecdhe_ecdsa_aes_128_gcm_sha_256,rsa_aes_128_gcm_sha_256\")\n...\n                \n```\n",
   "verify_peer": "### `verify_peer` (int)\n\nIf set to 0, TLS verification of the server certificate is disabled.\nThis means that the connection will get encrypted, but there's no\nauthentication. There's no proof that the transmission of data is to the\nhost that is meant to receive data.\n\nIf set to 1, default setting, and one or more CA certificates is\nconfigured, the server TLS certificate will be validated. If validation\nfails, the connection fails.\n\nSee the curl documentation for more details.\nhttp://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html\n\n```\n...\nmodparam(\"http_client\", \"verify_peer\", 1)\n...\n                \n```\n",
   "verify_host": "### `verify_host` (int)\n\nIf set to 0, domain verification of the server certificate is disabled.\nThis means that the connection will get encrypted but there is no check\nthat data will be sent to the host that is meant to receive it. Disable\nwith caution.\n\nIf set to 2, default setting, the hostname in the URL will be verified\nagainst the Common Name or Subject Alt Name in the certificate. If\nvalidation fails, the connection fails.\n\nSee the curl documentation for more details.\nhttp://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html\n\n```\n...\nmodparam(\"http_client\", \"verify_host\", 2)\n...\n                \n```\n",
   "tlsversion": "### `tlsversion` (int)\n\nSets the preferred TLS/SSL version.\n\nValid values are:\n\n- 0 - Use libcurl default\n\n- 1 - \"TLSv1\"\n\n- 2 - \"SSLv2\"\n\n- 3 - \"SSLv3\"\n\n- 4 - \"TLSv1.0\"\n\n- 5 - \"TLSv1.1\"\n\n- 6 - \"TLSv1.2\"\n\nSSL versions are now disabled by default. See the curl documentation for\nmore details. http://curl.haxx.se/libcurl/c/CURLOPT_SSLVERSION.html\n\n```\n...\nmodparam(\"http_client\", \"tlsversion\", 6)\n...\n                \n```\n",
   "authmethod": "### `authmethod` (int)\n\nSets the preferred authentication mode for HTTP/HTTPS requests. The\nvalue is a bitmap and multiple methods can be used. Note that in this\ncase, the CURL library will make an extra request to discover\nserver-supported authentication methods. You may want to use a specific\nvalue.\n\nValid values are:\n\n- 1 - BASIC authentication\n\n- 2 - HTTP Digest authentication\n\n- 4 - GSS-Negotiate authentication\n\n- 8 - NTLM authentication\n\n- 16 - HTTP Digest with IE flavour\n\nDefault value is 3 - BASIC and Digest authentication.\n\nThis is also configurable per connection in the http_client\nconfiguration file.\n\n```\n...\n# Use the best of BASIC and Digest authentication.\nmodparam(\"http_client\", \"authmethod\", 3)\n...\n                \n```\n",
   "keep_connections": "### `keep_connections` (int)\n\nIf an HTTP server is accessed multiple times keeping the connection open\nfor reuse saves a significant amount of time, especially if TLS is used.\nIf this function is enabled, the Curl library will try to reuse existing\nopen connections. The HTTP server will have to support this feature and\nkeep connections open for it to work properly.\n\nValid values are:\n\n- 0 - Close connections after request (default)\n\n- 1 - Reuse connections\n\nThis is also configurable per connection in the http_client\nconfiguration file.\n\n```\n...\nmodparam(\"http_client\", \"keep_connections\", 1)\n...\n                \n```\n",
   "query_result": "### `query_result` (int)\n\nControl what is returned by the http_client_query(...) in the result\nvariable.\n\nValid values are:\n\n- 0 - Return the entire HTTP result body\n\n- 1 - Return the first line from HTTP result body\n\nDefault value: 1 (return first line).\n\n```\n...\nmodparam(\"http_client\", \"query_result\", 0)\n...\n                \n```\n",
   "query_maxdatasize": "### `query_maxdatasize` (int)\n\nControl the size in bytes of the data to be returned by the\nhttp_client_query(...) in the result variable.\n\nDefault value: 0 (disabled, unlimited size).\n\n```\n...\nmodparam(\"http_client\", \"query_maxdatasize\", 2048)\n...\n                \n```\n",
   "httpcon": "### `httpcon` (string)\n\nDefines a connection and credentials for the connection for use in a\nconnection-oriented function call in this module.\n\n*Syntax:*\n<connection-name>=><schema>://[<username>:<password>@]<hostname/address>[;param=value]\n\nThe address in the URL is the base for the URL in the `http_connect()`\ncall. The address given in the function call will be appended to the\nbase URL in the connection definition.\n\nThe HTTP connection will be defined using default values in modparam's\nabove the definition of the httpcon in the configuration file. Also note\nthat connections can be defined in a separate text file if you have many\nparameters per connection, or want to use a per-connection setting that\ncan be set in that file but not in the httpcon modparam, like\nauthmethod.\n\n*By default, no connections are defined.*\n\nParameters\n\n- *useragent* Useragent used for HTTP requests. Overrides useragent\n  modparam.\n\n- *verify_peer* Set to 1 to enable or 0 to disable server certificate\n  verification. Overrides verify_peer modparam.\n\n- *verify_host* Set to 2 to enable or 0 to disable server hostname\n  verification. Overrides verify_host modparam.\n\n- *client_cert* Client certificate used for this connection. Overrides\n  the default client_cert modparam.\n\n- *client_key* Client key used for this connection. Overrides the\n  default client_key modparam.\n\n- *cipher_suites* Client certificate used for this connection. Overrides\n  the default cipher_suite modparam.\n\n- *timeout* Timeout used for this connection. Overrides the default\n  connection_timeout for the module.\n\n- *tlsversion* TLS version used for this connection. Overrides the\n  default tlsversion for the module.\n\n- *maxdatasize* The maximum datasize for a response. Overrides the\n  maxdatasize modparam setting.\n\n- *httpredirect* Set to 1 for following HTTP 302 redirect. 0 to disable.\n  Overrides the default httpredirect modparam.\n\n- *failover* The name of another *httpcon* connection to use with the\n  same arguments in case a connection with this http_con fails. Failure\n  is either a connection failure or a response code of 500 or above.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"http_client\", \"httpcon\", \"apione=>http://atlanta.example.com\")\nmodparam(\"http_client\", \"httpcon\", \"apitwo=>http://atlanta.example.com/api/12\")\nmodparam(\"http_client\", \"httpcon\", \"apithree=>http://annabella:mysecret@atlanta.example.com/api/12\")\nmodparam(\"http_client\", \"httpcon\", \"apifour=>http://stockholm.example.com/api/getstuff;timeout=12;failover=apione\")\n...\n                \n```\n",
   "config_file": "### `config_file` (string)\n\nThe file name of a configuration file containing definitions of http\nconnections. This is an alternative to the \"httpcon\" module parameter -\nespecially when the number of options per line gets too big.\n\nIf the file or directory name starts with a '.' the path will be\nrelative to the working directory (*at runtime*). If it starts with a\n'/' it will be an absolute path and if it starts with anything else the\npath will be relative to the main config file directory (e.g.: for\nkamailio -f /etc/kamailio/kamailio.cfg it will be relative to\n/etc/kamailio/).\n\nThe following parameters can be set in the config file, for each\nconnection. If a parameter is not specified, the default values set by\nthe modparams will be used.\n\n- url\n\n- username\n\n- password\n\n- authmethod\n\n- keep_connections\n\n- useragent\n\n- verify_peer\n\n- verify_host\n\n- client_cert\n\n- client_key\n\n- cipher_suites\n\n- tlsversion - Valid values are:\n\n  - \"DEFAULT\"\n\n  - \"TLSv1\"\n\n  - \"SSLv22\n\n  - \"SSLv3\"\n\n  - \"TLSv1.0\"\n\n  - \"TLSv1.1\"\n\n  - \"TLSv1.2\"\n\n\n- timeout\n\n- maxdatasize\n\n- http_follow_redirect\n\n- httpproxy\n\n- httpproxyport\n\n- failover\n\nSee the \"httpcon\" module parameter for explanation of these settings.\n\nBy default no config file is specified.\n\nAll the parameters that take filenames as values will be resolved using\nthe same rules as for the tls config filename itself: starting with a\n'.' means relative to the working directory, a '/' means an absolute\npath and anything else a path relative to the directory of the current\nKamailio main config file.\n\nTo set a string value to null, in order to override default settings,\nyou can specify a value of \"\" - two quotation marks. In order to disable\na http proxy setting you can set the port to zero.\n\n```\n...\nmodparam(\"http_client\", \"config_file\", \"httpconnections.cfg)\n...\n                \n\n[authapiserver]\nurl = https://api.runbo.example.com/v4.2/auth\ntimeout = 1\nmaxdatasize = 4\ntlsversion = TLSv1.2\nverify_peer = yes\nclient_key = default_key.pem\nclient_cert = default_cert.pem\nhttp_follow_redirect = no\n\n    \n```\n",
   "netinterface": "### `netinterface` (string)\n\nSet local network interface to be used for HTTP queries. It can be\ninterface name or IP address. For more details see:\nhttps://curl.haxx.se/libcurl/c/CURLOPT_INTERFACE.html .\n\n*Default value not set.*\n\n```\n...\nmodparam(\"http_client\", \"netinterface\", \"eth0\")\n...\n                \n```\n"
  },
  "functions": {
   "http_connect": "### `http_connect(connection, url, [content_type, data,] result)`\n\nSends HTTP GET or POST request to a given connection. For a POST\nrequest, content-type can be specified.\n\n- *connection* - the name of an existing HTTP connection, defined by a\n  httpcon modparam.\n\n  *url* - the part of the URL to add to the predefined URL in the\n  connection definition.\n\n  *content_type* - Used only when posting data with HTTP POST. An\n  Internet Media type, like \"application/json\" or \"text/plain\". Will be\n  added to the HTTP request as a header.\n\n  *data* - Data or a pseudo variable holding data to be posted. (may\n  contain pseudo variable)\n\n  *result* - The name of a pseudo variable that will have the data of\n  the response from the HTTP server.\n\nThe return value is the HTTP return code (if >=100) or the CURL error\ncode if below 100. See the $curlerror pseudovariable below for more\ninformation about CURL error codes.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n```\n...\nmodparam(\"http_client\", \"httpcon\", \"apiserver=>https://kamailio.org/api/\");\n...\n# POST Request\n$var(res) = http_connect(\"apiserver\", \"/mailbox\", \"application/json\", \"{ ok, {200, ok}}\", \"$avp(gurka)\");\nxlog(\"L_INFO\", \"API-server HTTP connection: $avp(gurka) Result code $var(res)\\n\");\n\n$var(res) = http_connect(\"apiserver\", \"/callroute\", \"application/json\", \"$var(jsondata)\", \"$avp(route)\");\nxlog(\"L_INFO\", \"API-server HTTP connection: $avp(route) Result code $var(res)\\n\");\n...\n                \n```\n",
   "http_connect_raw": "### `http_connect_raw(connection, url, content_type, data, result)`\n\nSends HTTP POST request to a given connection. Similar to http_connect.\nThe only difference is that the data parameter will not be parsed for\npseudo variables, therefore it can safely be used for content that may\ncontain \"$\" character like JSON.\n\n- *connection* - the name of an existing HTTP connection, defined by a\n  httpcon modparam.\n\n  *url* - the part of the URL to add to the predefined URL in the\n  connection definition.\n\n  *content_type* - Used only when posting data with HTTP POST. An\n  Internet Media type, like \"application/json\" or \"text/plain\". Will be\n  added to the HTTP request as a header.\n\n  *data* - Data or a pseudo variable holding data to be posted. (will\n  not be parsed for pseudo variable)\n\n  *result* - The name of a pseudo variable that will have the data of\n  the response from the HTTP server.\n\nThe return value is the HTTP return code (if >=100) or the CURL error\ncode if below 100. See the $curlerror pseudovariable below for more\ninformation about CURL error codes.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n```\n...\nmodparam(\"http_client\", \"httpcon\", \"apiserver=>https://kamailio.org/api/\");\n...\n# POST Request\n$var(res) = http_connect_raw(\"apiserver\", \"/mailbox\", \"application/json\", \"{ ok, {200, ok}}\", \"$avp(gurka)\");\nxlog(\"L_INFO\", \"API-server HTTP connection: $avp(gurka) Result code $var(res)\\n\");\n\n$var(res) = http_connect_war(\"apiserver\", \"/callroute\", \"application/json\", \"$var(jsondata)\", \"$avp(route)\");\nxlog(\"L_INFO\", \"API-server HTTP connection: $avp(route) Result code $var(res)\\n\");\n...\n                \n```\n",
   "http_get_redirect": "### `http_get_redirect(connection, result)`\n\nWhen a http connection gets a redirect and the connection is configured\nto follow redirects (301,302) then the target URL, the result of the\nredirects can be retrieved with this function after a successful\nconnection.\n\n- *connection* - the name of an existing HTTP connection, defined by a\n  httpcon modparam.\n\n  *result* - The name of a pseudo variable that will contain the last\n  used URL.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"http_client\", \"httpredirect\", 1);\n...\nhttp_get_redirect(\"apiserver\", \"$var(targeturl)\");\n...\n                \n```\n",
   "http_client_query": "### `http_client_query(url, [post-data], [hdrs], result)`\n\nSends HTTP GET or POST request according to URL given in \u201curl\u201d\nparameter, which is a string that may contain pseudo variables.\n\nIf you want to make a POST-Request, you have to define the \u201cpost\u201d-data,\nthat should be submitted in that request as the second parameter.\n\nCustom headers may be specified via \u201chdrs\u201d parameter (e.g.,\nContent-Type).\n\nEither of \u201cpost-data\u201d or \u201chdrs\u201d can be also set to empty string in order\nto be ignored.\n\nIf HTTP server returns a class 2xx, 3xx or 4xx reply, the first line or\nthe entire reply body (if any) is stored in \u201cresult\u201d parameter, which\nmust be a writable pseudo variable. See the query_result parameter for\ncontrolling what value to be stored in the result variable.\n\nFunction returns reply code of HTTP reply or -1 if something went wrong.\n\nThis function can be used from ANY_ROUTE.\n\nNote that this function is based on the http_query function in the utils\nmodule. It is changed to use the same base library and settings as the\nrest of the functions in this module.\n\n```\n...\n# GET-Request\nhttp_client_query(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n       \"$var(result)\");\nswitch ($rc) {\n    ...\n}\n...\n# POST-Request\nhttp_client_query(\"http://api.com/index.php\",\n    \"r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n    \"$var(result)\");\n}\n...\n# POST-Request\nhttp_client_query(\"http://api.com/index.php\", \"src=$si\",\n    \"Content-Type: text/plain\", \"$var(result)\");\n...\n                \n```\n",
   "http_client_get": "### `http_client_get(url, body, hdrs, respv)`\n\nPerform a HTTP GET request to \"url\", storing the response body in the\n\"respv\" variable. The \"body\" and \"hdrs\" can be empty strings to skip\nsetting them. The first three parameters can contain variables that are\nevaluated at runtime. The \"respv\" has to be the name of a writable\nvariable.\n\nNote: usually HTTP GET requests should have no body, according to specs\nthe body in HTTP GET does not affect the response, but is not\nexplicitely forbidden.\n\n```\n...\nhttp_client_get(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n       \"\", \"X-Token: abc\", \"$var(result)\");\nswitch ($rc) {\n    ...\n}\n...\n                \n```\n"
  }
 },
 "imc": {
  "overview": "This module offers support for instant message conference using SIP\nMESSAGE requests. It follows the architecture of IRC channels. The\nconferences are managed by commands that can be sent embedded in the\nMESSAGE body, because there are just a few SIP UA implementations which\nhave GUI for IM conferencing.\n\nBy sending a SIP MESSAGE a configured SIP URI to the IM conferencing\nmanager, the user can send commands to manage conference rooms. Once the\nconference room is created, users can send commands directly to\nconference's URI.\n\nTo ease the integration in the configuration file, the interpreter of\nthe IMC commands are embedded in the module. From a configuration point\nof view, there is only one function which has to be executed for both\nmessages and commands.\n",
  "parameters": {
   "db_url": "### `db_url` (str)\n\nThe database url.\n\n*The default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"imc\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_mode": "### `db_mode`(integer)\n\nThe module supports 2 modes of operation, high speed memory based\nstorage (mode 0), and database only (mode 2) where all data is stored in\na database, allowing scalability at the expense of speed. Mode 1 is\nreserved.\n\n*Default value is \u201c0\u201d*\n\n```\n...\nmodparam(\"imc\", \"db_mode\", 2)\n...\n```\n",
   "rooms_table": "### `rooms_table` (str)\n\nThe name of the table storing IMC rooms.\n\n*The default value is \"imc_rooms\".*\n\n```\n...\nmodparam(\"imc\", \"rooms_table\", \"rooms\")\n...\n```\n",
   "members_table": "### `members_table` (str)\n\nThe name of the table storing IMC members.\n\n*The default value is \"imc_members\".*\n\n```\n...\nmodparam(\"imc\", \"members_table\", \"members\")\n...\n```\n",
   "hash_size": "### `hash_size` (integer)\n\nThe power of 2 to get the size of the hash table used for storing\nmembers and rooms.\n\n*The default value is 4 (resulting in hash size 16).*\n\n```\n...\nmodparam(\"imc\", \"hash_size\", 8)\n...\n```\n",
   "imc_cmd_start_char": "### `imc_cmd_start_char` (str)\n\nThe character which indicates that the body of the message is a command.\n\n*The default value is \"#\".*\n\n```\n...\nmodparam(\"imc\", \"imc_cmd_start_char\", \"#\")\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy` (str)\n\nThe SIP address used as next hop when sending the message. Very useful\nwhen using Kamailio with a domain name not in DNS, or when using a\nseparate Kamailio instance for imc processing. If not set, the message\nwill be sent to the address in destination URI.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"imc\", \"outbound_proxy\", \"sip:kamailio.org;transport=tcp\")\n...\n```\n",
   "extra_hdrs": "### `extra_hdrs` (str)\n\nExtra headers (each ending with \\r\\n) to be added in messages sent out\nfrom imc server.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"imc\", \"extra_hdrs\", \"P-Flags: 3\\r\\n\")\n...\n```\n",
   "create_on_join": "### `create_on_join` (integer)\n\nIf set to 1 and user requests to join a non-existing room, the room will\nbe automatically created. If set to 0, joining a non-existing room\nreturns an error.\n\n*The default value is 1.*\n\n```\n...\nmodparam(\"imc\", \"create_on_join\", 0)\n...\n```\n",
   "check_on_create": "### `check_on_create` (integer)\n\nIf set to 1, the chat server will report an error if the user attempts\nto create a room that already exists.\n\n*The default value is 0.*\n\n```\n...\nmodparam(\"imc\", \"check_on_create\", 1)\n...\n```\n"
  },
  "functions": {
   "imc_manager": "### `imc_manager()`\n\nTHis function handles incoming MESSAGE requests. If detects if the body\nof the message is a conference command it executes it, otherwise it\nsends the message to all the members in the room.\n\nThis function can be used from REQUEST_ROUTE. See command description\nfor error codes returned by this function.\n\n```\n...\n# the rooms will be named chat-xyz to avoid overlapping\n# with usernames\nif(is_method(\"MESSAGE)\n    && (uri=~ \"sip:chat-[0-9]+@\" || (uri=~ \"sip:chat-manager@\"))\n{\n    if(imc_manager())\n        sl_send_reply(\"200\", \"ok\");\n    else\n        sl_send_reply(\"500\", \"command error\");\n    exit;\n}\n...\n```\n",
   "imc_room_active": "### `imc_room_active(room)`\n\nReturn 1 (true) if the room is active, -1 (false) if the room is not\nfound. The parameter is the SIP URI to identify the room, it can contain\nvariables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    if(imc_room_active(\"sip:chat-sip@$fd\")) {\n        ...\n    }\n...\n```\n",
   "imc_room_member": "### `imc_room_member(room, user)`\n\nReturn 1 (true) if the user is member of the room, -1 (false) if the\nuser is not member of the room. The parameters are the SIP URIs to\nidentify the room and the user, they can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    if(imc_room_member(\"sip:chat-sip@$fd\", \"sip:$rU@$rd\")) {\n        ...\n    }\n...\n```\n"
  }
 },
 "ims_auth": {
  "overview": "This module contains all authentication related functions for an IMS\nenvironment. The module does not depend on the base Kamailio auth\nmodules as other auth modules do. Instead ims_auth is dependent on the\nCDP (C Diameter Peer) modules for communicating with HSS as specified in\n3GPP specs.\n",
  "parameters": {
   "name": "### `name` (string)\n\nThis is the name of the SCSCF as identified in communication with the\nHSS (Server-Name AVP of MAR).\n\n*Default value is 'sip:scscf.ims.smilecoms.com:6060'.*\n\n```\n...\nmodparam(\"ims_auth\", \"name\", \"sip:scscf3.ims.smilecoms.com:6060\")\n...\n```\n",
   "auth_data_hash_size": "### `auth_data_hash_size` (integer)\n\nThis is the size of the hash table used to store auth vectors (AV).\nDefault value is fine for most people. Use the parameter if you really\nneed to change it.\n\nDefault value is \u201c1024\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"auth_data_hash_size\", 1024)\n...\n```\n",
   "auth_vector_timeout": "### `auth_vector_timeout` (integer)\n\nThis is the time, in seconds, that a SENTauth vector is valid for. If\nthere is no response ...\n\nDefault value is \u201c60\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"auth_vector_timeout\", \"domain\")\n...\n```\n",
   "auth_data_timeout": "### `auth_data_timeout` (int)\n\nTime, in seconds, a used auth vector is valid for.\n\nDefault value is \u201c60\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"auth_data_timeout\", 60)\n...\n```\n",
   "av_request_at_once": "### `av_request_at_once` (integer)\n\nHow many auth vectors to request in MAR.\n\nDefault value is 1\n\n```\n...\nmodparam(\"ims_auth\", \"av_request_at_once\", 1)\n...\n```\n",
   "av_request_at_sync": "### `av_request_at_sync` (integer)\n\nHow many auth vectors to request at sync. Default value is 1.\n\n```\n...\nmodparam(\"ims_auth\", \"av_request_at_sync\", 1)\n...\n```\n",
   "registration_default_algorithm": "### `registration_default_algorithm` (string)\n\nThe default authentication algorithm to use for registration if one is\nnot specified.\n\nOptions are:\n\n- *AKAV1-MD5*\n\n- *AKAV2-MD5*\n\n- *MD5*\n\n- HSS-Selected - HSS will decide on auth algorithm\n\nDefault value is \u201cAKAv1-MD5\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"registration_default_algorithm\", \"HSS-Selected\")\n...\n```\n",
   "registration_qop": "### `registration_qop` (string)\n\nThe QOP options to put in the authorisation challenges.\n\nDefault value of this parameter is \u201cauth,auth-int\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"registration_qop\", \"auth-int\")\n...\n```\n",
   "cxdx_forced_peer": "### `cxdx_forced_peer` (string)\n\nFQDN of Diameter Peer (HSS) to use for communication (MAR). If you use\nthis, the routing defined in your diameter xml configuration file (CDP)\nwill be ignored and as a result you will lose the benefits of load\nbalancing and failover.\n\nDefault value is \u201c\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"cxdx_forced_peer\", \"hss.ims.smilecoms.com\")\n...\n```\n",
   "cxdx_dest_realm": "### `cxdx_dest_realm` (string)\n\nDestination realm to be used in Diameter messages to HSS\n\nDefault value is \u201cims.smilecoms.com\u201d.\n\n```\n...\nmodparam(\"ims_auth\", \"cxdx_dest_realm\", \"ims.smilecoms.com\")\n...\n```\n",
   "cxdx_dest_host": "### `cxdx_dest_host` (string)\n\nDestination Host to be used in Diameter-MAR messages to HSS\n\nDefault value is \u201c\u201d (not set).\n\n```\n...\nmodparam(\"ims_auth\", \"cxdx_dest_host\", \"hss.ims.ng-voice.com\")\n...\n```\n",
   "max_nonce_reuse": "### `max_nonce_reuse` (integer)\n\nDefines, how many times a nonce can be reused (provided nc is\nincremented)\n\nDefault value is \u201c0\u201d (don't allow reuse).\n\n```\n...\nmodparam(\"ims_auth\", \"max_nonce_reuse\", 1)\n...\n```\n",
   "add_authinfo_hdr": "### `add_authinfo_hdr` (integer)\n\nShould an Authentication-Info header be added on 200 OK responses?\n\nDefault value is \u201c1\u201d (add Authentication-Info header).\n\n```\n...\nmodparam(\"ims_auth\", \"add_authinfo_hdr\", 0)\n...\n```\n",
   "ignore_failed_auth": "### `ignore_failed_auth` (integer)\n\nIgnore invalid passwords (only IMPI/IMPU is checked).\n\nIt should be used only for testing, e.g. load balancing with SIPP where\nwe don't want to worry about auth.\n\nDefault value is \u201c0\u201d (don't ignore the failed authentication).\n\n```\n...\nmodparam(\"ims_auth\", \"ignore_failed_auth\", 1)\n...\n```\n",
   "av_check_only_impu": "### `av_check_only_impu` (integer)\n\nWhen storing the authentication vectors for an account, use either\nIMPI/IMPU (=0, default) or IMPU (=1).\n\nIn case the IMPI is different from the IMPU, this option needs to be\nenabled to allow registration from classic \"SIP-clients\", such as Snom\nphones and others, as they do not send an authentication username in the\nfirst REGISTER.\n\nDefault value is \u201c0\u201d (store authentication vectors based on IMPI/IMPU).\n\n```\n...\nmodparam(\"ims_auth\", \"av_check_only_impu\", 1)\n...\n```\n"
  },
  "functions": {
   "ims_www_authorize": "### `ims_www_authorize(realm, table)`\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`www_challenge` which will challenge the user again.\n\nNegative codes may be interpreted as follows:\n\n- *-1 (generic error)* - some generic error occurred and no reply was\n  sent out;\n\n- *-2 (invalid password)* - valid user, but wrong password;\n\n- *-3 (invalid user)* - authentication user does not exist.\n\nMeaning of the parameters is as follows:\n\n- *realm* - Realm is a opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. In case of REGISTER requests To header\n  field domain (e.g., variable $td) can be used (because this header\n  field represents the user being registered), for all other messages\n  From header field domain can be used (e.g., variable $fd).\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!www_authorize(\"kamailio.org\", \"subscriber\")) {\n    www_challenge(\"\"REG_MAR_REPLY\"\", \"kamailio.org\", \"1\");\n};\n...\n```\n",
   "ims_www_authenticate": "### `ims_www_authenticate(realm)`\n\nIt is the same function as www_authenticate(realm, table). This name is\nkept for backward compatibility, since it was named this way first time\nby it actually does user authentication.\n",
   "ims_www_challenge": "### `ims_www_challenge(route_block, realm, algorithm)`\n\nSame as 4.3 except here there is the additional option to specify the\nauthorisation algorithm\n\n- *algorithm* - The algorithm to be used when challenging the client.\n  Can be AKAv1-MD5, AKAv2-MD5, MD5, or HSS-Selected. If left as an empty\n  string, the default algorithm will be chosen according to the\n  parameter registration_default_algorithm (see section 3.7)\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n if (!ims_www_authenticate(NETWORKNAME)) {\n                #user has not been authenticated. Lets send a challenge via 401 Unauthorized\n                if ($? == -2) {\n                        t_reply(\"403\", \"Authentication Failed\");\n                        exit;\n                } else if ($? == -3) {\n                        t_reply(\"400\", \"Bad Request\");\n                        exit;\n                } else if ($? == -9) {\n                        xlog(\"L_DBG\", \"Authentication re-sync requested\\n\");\n                        ims_www_resync_auth(\"REG_RESYNC_REPLY\", \"$td\");\n                        exit;\n                } else {\n                        xlog(\"L_DBG\",\"About to challenge! auth_ims\\n\");\n                        ims_www_challenge(\"REG_MAR_REPLY\", \"$td\", \"MD5\");\n                        exit;\n                }\n        }\n```\n",
   "ims_proxy_challenge": "### `ims_proxy_challenge(route_block, realm, table)`\n\nName alias: proxy_authorize(realm, table)\n\nThe function verifies credentials according to\n[RFC2617](http://www.ietf.org/rfc/rfc2617.txt). If the credentials are\nverified successfully then the function will succeed and mark the\ncredentials as authorized (marked credentials can be later used by some\nother functions). If the function was unable to verify the credentials\nfor some reason then it will fail and the script should call\n`proxy_challenge` which will challenge the user again.\n\nNegative return codes have the same meaning as for www_authenticate().\n\nMeaning of the parameters is as follows:\n\n- Route block to resume after async MAR Diameter reply.\n\n- *realm* - Realm is a opaque string that the user agent should present\n  to the user so he can decide what username and password to use.\n  Usually this is domain of the host the server is running on.\n\n  It must not be empty string \u201c\u201d. Apart of a static string, typical\n  value is From header field domain (e.g., variable $fd).\n\n  If an empty string \u201c\u201d is used then the server will generate it from\n  the request. From header field domain will be used as realm.\n\n  The string may contain pseudo variables.\n\n- *table* - Table to be used to lookup usernames and passwords (usually\n  subscribers table).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!proxy_authorize(\"$fd\", \"subscriber)) {\n    proxy_challenge(\"REG_MAR_REPLY\",\"$fd\", \"1\");  # Realm will be autogenerated\n};\n...\nroute[REG_MAR_REPLY]\n{\n     #this is async so to know status we have to check the reply avp\n     xlog(\"L_DBG\",\"maa_return code is $avp(s:maa_return_code)\\n\");\n\n     switch ($avp(s:maa_return_code)){\n             case 1: #success\n                     xlog(\"L_DBG\", \"MAR success - 401/407 response sent from module\\n\");\n                     break;\n             case -1: #failure\n                     xlog(\"L_ERR\", \"MAR failure - error response sent from module\\n\");\n                     break;\n             case -2: #error\n                     xlog(\"L_ERR\", \"MAR error - sending error response now\\n\");\n                     t_reply(\"500\", \"MAR failed\");\n                     break;\n             default:\n                     xlog(\"L_ERR\", \"Unknown return code from MAR, value is [$avp(s:uaa_return_code)]\\n\");\n                     t_reply(\"500\", \"Unknown response code from MAR\");\n                     break;\n     }\n     exit;\n}\n...\n```\n",
   "ims_proxy_authenticate": "### `ims_proxy_authenticate(realm, table)`\n\nIt is same function as proxy_authenticate(realm, table). This name is\nkept for backward compatibility, since it was named this way first time\nbut it actually does user authentication.\n"
  }
 },
 "ims_charging": {
  "overview": "This module contains all methods related to the IMS charging control\nfunctions performed by a network element (e.g. a S-CSCF) over the Ro\ninterface. This module is dependent on the CDP (C Diameter Peer) modules\nfor communicating with a Charging-Server as specified in 3GPP\nspecification TS xx.xxx.\n\nPlease also refer to RFC 4006 (Diameter Credit-Control Application)\n",
  "parameters": {
   "hash_size": "### `hash_size`(int)\n\nThe size of the hash table internally used to keep the\nDiameter-Ro-Session. A larger table is much faster but consumes more\nmemory. The hash size must be a power of two number.\n\nIMPORTANT: If Ro-Session's information should be stored in a database, a\nconstant hash_size should be used, otherwise the restoring process will\nnot take place. If you really want to modify the hash_size you must\ndelete all table's rows before restarting the server.\n\n*Default value is 4096.*\n\n```\n...\nmodparam(\"ims_charging\", \"hash_size\", 1024)\n...\n        \n```\n",
   "db_mode": "### `db_mode` (int)\n\nShould a database be used to store dialog information.\n\nAvailable database modes: 0 for no database, 1 for real-time mode and 2\nfor shutdown mode.\n\n*Default value is 0 - no database is used.*\n\n```\n...\nmodparam(\"ims_charging\", \"db_mode\", 0)\n...\n        \n```\n",
   "db_url": "### `db_url` (string)\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d*\n\n```\n...\nmodparam(\"ims_charging\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n        \n```\n",
   "interim_update_credits": "### `interim_update_credits`(int)\n\nHow much credit should be requested interim request? At the start of the\ncall, we request the amount of seconds as per Command. For each interim\nrequest, we would request credit for \"interim_update_credits\".\n\n*Default value is 30.*\n\n```\n...\nmodparam(\"ims_charging\", \"interim_update_credits\", 600)\n...\n        \n```\n",
   "timer_buffer": "### `timer_buffer`(int)\n\nHow many seconds before expiry of our credit should we request more\ncredit?\n\n*Default value is 8.*\n\n```\n...\nmodparam(\"ims_charging\", \"timer_buffer\", 10)\n...\n        \n```\n",
   "ro_forced_peer": "### `ro_forced_peer`(string)\n\nFQDN of Diameter Peer (OCS) to use for communication (CCR). If you use\nthis, the routing defined in your diameter xml configuration file (CDP)\nwill be ignored and as a result you will lose the benefits of load\nbalancing and failover.\n\n*Default value is ''.*\n\n```\n...\nmodparam(\"ims_charging\", \"ro_forced_peer\", \"ocs.ims.smilecoms.com\")\n...\n        \n```\n",
   "ro_auth_expiry": "### `ro_auth_expiry`(integer)\n\nThis is the expiry length in seconds of the initiated Diameter sessions.\n\n*Default value is 7200.*\n\n```\n...\nmodparam(\"ims_charging\", \"ro_auth_expiry\", 14400)\n...\n        \n```\n",
   "cdp_event_latency": "### `cdp_event_latency`(integer)\n\nThis is a flag to determine whether or slow CDP responses should be\nreported in the log file. 1 is enabled and 0 is disabled.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"ims_charging\", \"cdp_event_latency\", 1)\n...\n        \n```\n",
   "cdp_event_threshold": "### `cdp_event_threshold`(integer)\n\nThis time in milliseconds is the limit we should report a CDP response\nas slow. i.e. if a CDP response exceeds this limit it will be reported\nin the log file. This is only relevant is cdp_event_latency is enabled\n(set to 0).\n\n*Default value is 500.*\n\n```\n...\nmodparam(\"ims_charging\", \"cdp_event_threshold\", 500)\n...\n        \n```\n",
   "cdp_event_latency_log": "### `cdp_event_latency_log`(integer)\n\nThis time log level at which we should report slow CDP responses. 0 is\nERROR, 1 is WARN, 2 is INFO and 3 is DEBUG. This is only relevant is\ncdp_event_latency is enabled (set to 0)\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_charging\", \"cdp_event_latency_log\", 1)\n...\n        \n```\n",
   "single_ro_session_per_dialog": "### `single_ro_session_per_dialog`(integer)\n\nThis tells the module whether it should do a single ro session per\ndialog no matter how many times Ro_send_CCR is called from the config\nfile or initiate an ro session each time Ro_send_CCR is called. It is\nuseful for IMS charging where you might want to charge for on-net\noriginating and off-net originating calls but always have only a single\nro session.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_charging\", \"single_ro_session_per_dialog\", 1)\n...\n        \n```\n",
   "origin_host": "### `origin_host`(string)\n\nOrigin host to be used in Diameter messages to charging-server.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"ims_charging\", \"origin_host\", \"scscf.kamailio-ims.org\")\n...\n        \n```\n",
   "origin_realm": "### `origin_realm`(string)\n\nOrigin Realm to be used in Diameter messages to charging-server.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"ims_charging\", \"origin_realm\", \"kamailio-ims.org\")\n...\n        \n```\n",
   "destination_host": "### `destination_host`(string)\n\nDestination host to be used in Diameter messages to charging-server.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"ims_charging\", \"destination_host\", \"ocs.kamailio-ims.org\")\n...\n        \n```\n",
   "destination_realm": "### `destination_realm`(string)\n\nDestination realm to be used in Diameter messages to charging-server.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"ims_charging\", \"destination_realm\", \"kamailio-ims.org\")\n...\n        \n```\n",
   "service_context_id_root": "### `service_context_id_root`(string)\n\nThis defines a root-element of the Service-Context-Id AVP used in the\ndiameter-message\n\nThe Service-Context-Id AVP is of type UTF8String (AVP Code 461) and\ncontains a unique identifier of the Diameter credit-control service\nspecific document that applies to the request (as defined in section RFC\n4006 4.1.2). This is an identifier allocated by the service provider, by\nthe service element manufacturer, or by a standardization body, and MUST\nuniquely identify a given Diameter credit-control service specific\ndocument. The format of the Service-Context-Id is:\n\n```\n\"service-context\" \"@\" \"domain\" service-context = Token\n      \n```\n\nThe Token is an arbitrary string of characters and digits.\n\n'domain' represents the entity that allocated the Service-Context-Id. It\ncan be ietf.org, 3gpp.org, etc., if the identifier is allocated by a\nstandardization body, or it can be the FQDN of the service provider\n(e.g., provider.example.com) or of the vendor (e.g., vendor.example.com)\nif the identifier is allocated by a private entity.\n\nService-specific documents that are for private use only (i.e., to one\nprovider's own use, where no interoperability is deemed useful) may\ndefine private identifiers without need of coordination. However, when\ninteroperability is wanted, coordination of the identifiers via, for\nexample, publication of an informational RFC is RECOMMENDED in order to\nmake Service-Context-Id globally available.\n\n*Default value is \"32260@3gpp.org\".*\n\n```\n...\nmodparam(\"ims_charging\", \"service_context_id_root\", \"calls@kamailio-ims.org\")\n...\n        \n```\n",
   "service_context_id_ext": "### `service_context_id_ext`(string)\n\nThis defines the extension of the Service-Context-Id AVP used in the\ndiameter-message.\n\n*Default value is \"ext\".*\n\n```\n...\nmodparam(\"ims_charging\", \"service_context_id_ext\", \"ext2\")\n...\n        \n```\n",
   "service_context_id_mnc": "### `service_context_id_mnc`(string)\n\nThis defines Mobile-Network-Code (MNC) of the Service-Context-Id AVP\nused in the diameter-message.\n\n*Default value is \"01\".*\n\n```\n...\nmodparam(\"ims_charging\", \"service_context_id_mnc\", \"42\")\n...\n        \n```\n",
   "voice_service_identifier": "### `voice_service_identifier`(string)\n\nThis defines the service identifier to be used for charging voice.\n\n*Default value is \"1000\".*\n\n```\n...\nmodparam(\"ims_charging\", \"voice_service_identifier\", \"1000\")\n...\n        \n```\n",
   "voice_rating_group": "### `voice_rating_group`(string)\n\nThis defines the rating group to be used for charging voice.\n\n*Default value is \"100\".*\n\n```\n...\nmodparam(\"ims_charging\", \"voice_rating_group\", \"100\")\n...\n        \n```\n",
   "video_service_identifier": "### `video_service_identifier`(string)\n\nThis defines the service identifier to be used for charging video.\n\n*Default value is \"1001\".*\n\n```\n...\nmodparam(\"ims_charging\", \"video_service_identifier\", \"1000\")\n...\n        \n```\n",
   "video_rating_group": "### `video_rating_group`(string)\n\nThis defines the rating group to be used for charging video.\n\n*Default value is \"200\".*\n\n```\n...\nmodparam(\"ims_charging\", \"video_rating_group\", \"100\")\n...\n        \n```\n",
   "service_context_id_mcc": "### `service_context_id_mcc`(string)\n\nThis defines Mobile-Country-Code (MCC) of the Service-Context-Id AVP\nused in the diameter-message.\n\nsee https://en.wikipedia.org/wiki/Mobile_country_code_(MCC) for\ndetails.\n\n*Default value is \"001\".*\n\n```\n...\nmodparam(\"ims_charging\", \"service_context_id_mcc\", \"262\")\n...\n        \n```\n",
   "service_context_id_release": "### `service_context_id_release`(string)\n\nThis defines Release of the Service-Context-Id AVP used in the\ndiameter-message.\n\n*Default value is \"8\" (Release 8).*\n\n```\n...\nmodparam(\"ims_charging\", \"service_context_id_release\", \"262\")\n...\n        \n```\n",
   "custom_user_avp": "### `custom_user_avp` (avp string)\n\nWhen this parameter is set and the contents of the AVP is not empty, the\nUser-AVP in the Ro-Charging-Request will be based on the this parameter\nrather than on the P-Asserted or From-Header.\n\nThis parameter allows you to setup an AVP with which you can customise\nthe user to be used in the Diameter-Request.\n\n*Default value: if not set, P-Asserted-Identity with a fallback to the\nFrom-Header is used.*\n\n```\n...\nmodparam(\"ims_charging\", \"custom_user_avp\", \"$avp(from_user)\")\n...\n        \n```\n",
   "app_provided_party_avp": "### `app_provided_party_avp` (avp string)\n\nWhen this parameter is set and the contents of the AVP is not empty, an\nApplication-Provided-Called Party-Address AVP will be addedd to charging\nrelated requests. This is required for special cases e.g. related to\nroaming for some diameter server.\n\n*Default value: if not set, the\nApplication-Provided-Called-Party-Address AVP will be not set.*\n\n```\n...\nmodparam(\"ims_charging\", \"app_provided_party_avp\", \"$avp(app_user)\")\n...\n        \n```\n",
   "vendor_specific_chargeinfo": "### `vendor_specific_chargeinfo` (int)\n\nThis parameter can be used to activate or deactivate the addition of\nVendor-Specific-Termination-Clause and\nVendor-Specific-Termination-Reason AVPs to the requests. To activate set\nthis parameter to 1.\n\n*Default value is \"0\" (deactivated).*\n\n```\n...\nmodparam(\"ims_charging\", \"vendor_specific_chargeinfo\", 1)\n...\n        \n```\n",
   "vendor_specific_id": "### `vendor_specific_id` (int)\n\nTo set the ID of the Vendor-Specific information, not implemented right\nnow.\n\n*Default value is \"10\".*\n\n```\n...\nmodparam(\"ims_charging\", \"vendor_specific_id\", 10)\n...\n        \n```\n",
   "strip_plus_from_e164": "### `strip_plus_from_e164` (int)\n\nStrip + from subscription id when E.164 format is used. This is\naccording to spec, but this parameter is to keep existing behavior as\nthe default.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_charging\", \"strip_plus_from_e164\", 1)\n...\n        \n```\n",
   "use_pani_from_term_invite": "### `use_pani_from_term_invite` (int)\n\nP-Access-Network-Info is normally relevant for the \"orig\" scenario where\nit's extracted from INVITE. This setting instruct Kamailio to include it\nin \"term\" scenario too, where it might have been added to the INVITE\nbased on info from a REGISTER. Normally used to start a charging session\nwhen the user is roaming.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_charging\", \"use_pani_from_term_invite\", 1)\n...\n        \n```\n",
   "node_func": "### `node_func` (int)\n\nDefines what should be sent as Node-Functionality (862) in the Diameter\nRo request. Possible values are: 0 (S-CSCF), 1 (P-CSCF), 2 (I-CSCF), 3\n(MRFC), 4 (MGCF), 5 (BFCF) or 6 (AS)\n\n*Default value is 0 (S-CSCF).*\n\n```\n...\nmodparam(\"ims_charging\", \"node_func\", 1)\n...\n        \n```\n"
  },
  "functions": {
   "Ro_CCR": "### `Ro_CCR(route_name, direction, reservation_units, incoming_trunk_id, outgoing_trunk_id)`\n\nPerform a CCR on Diameter Ro interface for Charging\n\nMeaning of the parameters is as follows:\n\n- *route_name* route to be executed upon reception of charging requests\n\n- *direction* \"orig\"inating or \"term\"inating\n\n- *reservation_units* how many units (at the moment seconds) should be\n  reserved at the moment.\n\n- *incoming_trunk_id* Identifies the trunk group from which this\n  originates.\n\n- *outgoing_trunk_id* Identifies the trunk group where this will be\n  terminated.\n\nThis function can be used from REQUEST_ROUTE.\n\nThis method is executed asynchronously. See example on how to retrieve\nreturn value.\n\n```\n...\n  xlog(\"L_DBG\",\"Sending initial CCR Request for call\\n\");\n    Ro_CCR(\"RO_ASYNC_TERM_REPLY\", \"term\", 30, \"1\", \"1\");\n}\n\nroute[CHARGING_CCR_REPLY]\n  xlog(\"L_DBG\",\"cca_return code is $avp(s:cca_return_code)\\n\");\n  switch ($avp(s:cca_return_code)) {\n    case 1: #success\n        xlog(\"L_DBG\", \"CCR success - will route message\\n\");\n        route(Finalize_Orig);\n        break;\n    case -1: #failure\n        xlog(\"L_ERR\", \"CCR failure - error response sent from module\\n\");\n        sl_send_reply(\"402\",\"Payment required\");\n        break;\n    case -2: #error\n        xlog(\"L_ERR\", \"CCR error - error response sent from module\\n\");\n        sl_send_reply(\"500\", \"Charging Error\");\n        break;\n    default:\n        xlog(\"L_ERR\", \"Unknown return code from CCR: [$avp(s:cca_return_code)] \\n\");\n        break;\n  }\n  exit;\n  }\n...\n        \n```\n",
   "Ro_set_session_id_avp": "### `Ro_set_session_id_avp()`\n\nSets the Ro session ID to an AVP for use in the config file\n\nThis function can be used from REQUEST_ROUTE or ONREPLY_ROUTE.\n\n```\n...\n            Ro_set_session_id_avp();\n            xlog(\"L_DBG\",\"Ro session AVP has been set: $avp(ro_session_id)\\n\");\n...\n        \n```\n"
  }
 },
 "ims_diameter_server": {
  "overview": "This module implements a generic Diameter Server.\n\nThis module translates incoming Diameter Messages into a JSON structure\nand will pass this on to the routing engine for further operations.\n\nThe module expects a reply (again in JSON), which then is translated\ninto a Diameter Response.\n\nAdditionally, it allows you to send Diameter-Requests to another peer.\n\nThe JSON contains an array with all AVP's in the Diameter-Message and\nits attributes. The format is identical for both requests and replies.\n\n```\n[\n   {\n      \"avpCode\":277,\n      \"vendorId\":0,\n      \"Flags\":64,\n      \"int32\":0\n   },\n   {\n      \"avpCode\":260,\n      \"vendorId\":0,\n      \"Flags\":64,\n      \"list\":[\n         {\n            \"avpCode\":266,\n            \"vendorId\":0,\n            \"Flags\":64,\n            \"int32\":10415\n         },\n         {\n            \"avpCode\":258,\n            \"vendorId\":0,\n            \"Flags\":64,\n            \"int32\":16777216\n         }\n      ]\n   },\n   {\n      \"avpCode\":1,\n      \"vendorId\":0,\n      \"Flags\":64,\n      \"string\":\"alice@kamailio.org\"\n   },\n   {\n      \"avpCode\":618,\n      \"vendorId\":10415,\n      \"Flags\":64,\n      \"list\":[\n         {\n            \"avpCode\":621,\n            \"vendorId\":10415,\n            \"Flags\":64,\n            \"string\":\"pcscf.kamailio.org\"\n         }\n      ]\n   },\n   {\n      \"avpCode\":268,\n      \"vendorId\":0,\n      \"Flags\":64,\n      \"int32\":2001\n   }\n]\n    \n```\n\nThe module could be used (for example) for:\n\n- a Home-Subscriber-Server (it was written do be used as one)\n\n- a Charging-Server (Ro/Rf)\n\n- for testing Diameter-Applications\n\n- a PCRF/PCEF Emulator/Gateway\n\n- a Diameter-Routing-Agent (DRA)\n\n- ...\n",
  "parameters": {},
  "functions": {
   "diameter_request": "### `diameter_request([peer], appid, commandcode, message)`\n\nThis method will send a Diameter Request.\n\nMeaning of the parameters is as follows:\n\n- *peer* - send the diameter request directly to a diameter peer\n  [optional]. If this parameter is omitted, the default routing is\n  used (see CDP).\n\n- *appid* - Diameter-Application, e.g.:\n\n  Typical App-ID's are:\n\n  - 16777216 - Diameter Cx/Dx\n\n  - 16777217 - Diameter Sh\n\n  - 4 - Diameter Ro (Online Charging)\n\n  - ...\n\n\n- *commandcode* - Diameter-Command-Code, e.g.:\n\n  - 300 - Diameter Cx/Dx User-Assignment Request (UAR)\n\n  - 301 - Diameter Cx/Dx Server-Assignment Request (SAR)\n\n  - ...\n\n\n- *message* - the Diameter Message (as JSON), which should be sent.\n\nThis function can be used from any route.\n\n```\n...\ndiameter_request(\"16777216\", \"300\", \"{ some json }\");\n...\n        \n```\n",
   "diameter_request_async": "### `diameter_request_async([peer], appid, commandcode, message)`\n\nThis method will send a Diameter Request asynchronously. The Reply to\nthis request will be visible in the event-route \"diameter:response\".\n\nThe meaning of the parameters are identical to the diameter_request\nfunction.\n\nThis function is only available, if the diameter:response event-route is\ndefined.\n"
  }
 },
 "ims_icscf": {
  "overview": "This module provides all functionality to build an IMS ICSCF.\n",
  "parameters": {
   "route_lir_user_unknown": "### `route_lir_user_unknown` (string)\n\nThis is the route which is executed if HSS returns \"user unknown\" in LIR\n\n*Default value is ''.*\n\n```\n...\nmodparam(\"ims_icscf\",\"route_lir_user_unknown\", \"lir_term_user_unknown\")\n...\n        \n```\n",
   "route_uar_user_unknown": "### `route_uar_user_unknown` (string)\n\nThis is the route which is executed if HSS returns \"user unknown\" in\nUAR.\n\n*Default value is ''.*\n\n```\n...\nmodparam(\"ims_icscf\",\"route_uar_user_unknown\", \"uar_term_user_unknown\")\n...\n        \n```\n",
   "scscf_entry_expiry": "### `scscf_entry_expiry` (integer)\n\nThis is the time in s after which S-CSCF entries in the I-CSCF's SCSCF\nlist will expire.\n\n*Default value is 300.*\n\n```\n...\nmodparam(\"ims_icscf\",\"scscf_entry_expiry\", 300)\n...\n        \n```\n",
   "cxdx_forced_peer": "### `cxdx_forced_peer` (string)\n\nFQDN of Diameter Peer (HSS) to use for communication (UAR, LIR). If you\nuse this, the routing defined in your diameter xml configuration file\n(CDP) will be ignored and as a result you will lose the benefits of load\nbalancing and failover.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"ims_icscf\", \"cxdx_forced_peer\", \"hss.ims.smilecoms.com\")\n...\n    \n```\n",
   "cxdx_dest_realm": "### `cxdx_dest_realm` (string)\n\nDestination realm to be used in Diameter messages to HSS\n\n*Default value is \"ims.smilecoms.com\".*\n\n```\n...\nmodparam(\"ims_icscf\", \"cxdx_dest_realm\", \"ims.smilecoms.com\")\n...\n    \n```\n",
   "use_preferred_scscf_uri": "### `use_preferred_scscf_uri` (int)\n\nWhether or not this ICSCF has a preferred S-CSCF to use when the HSS\nreturns a list of SCSCFs. 0 means this I-CSCF has no preferred SCSCF. 1\nmeans it has a preferred S-CSCF.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_icscf\", \"use_preferred_scscf_uri\", 1)\n...\n    \n```\n",
   "preferred_scscf_uri": "### `preferred_scscf_uri` (string)\n\nIf use_preferred_scscf_uri is set then this is the URI of the preferred\nSCSCF.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"ims_icscf\", \"preferred_scscf_uri\", \"sip:scscf.ims.smilecoms.com:6060\")\n...\n    \n```\n"
  },
  "functions": {
   "I_scscf_select": "### `I_scscf_select(initial)`\n\nThis function is used to retrieve the next unused SCSCF from the list\nfor this request (based on callid).\n\nA positive return code (1) means an SCSCF was found and is armed for\nrouting.\n\nMeaning of the parameters is as follows:\n\n- *initial* - Signal whether or not this is an original or subsequent.\n\nThis function can be used from REQUEST_ROUTE | FAILURE_ROUTE.\n\n```\n...\nif (I_scscf_select(\"0\")) {\n     #there is an S-CSCF list - no need to do a UAR\n     t_on_reply(\"register_reply\");\n     t_on_failure(\"register_failure\");\n     t_relay();\n}\n...\n        \n```\n",
   "I_scscf_drop": "### `I_scscf_drop()`\n\nDrop the list of SCSCFs for this request (based on callid).\n\nThis function can be used from REQUEST_ROUTE | FAILURE_ROUTE |\nREPLY_ROUTE\n\n```\n...\nI_scscf_drop();\n...\n```\n\n.\n",
   "I_perform_user_authorization_request": "### `I_perform_user_authorization_request(route_block, capabalities)`\n\nPerform a UAR on Diameter CXDX interface. This function will build a\nlist of SCSCFs to be used and populate the SCSCF list for the request.\nOn a successful return of this message you can get the next available\nSCSCF by using the I_scscf_select function in 4.1.\n\n- Route block to resume after async UAR Diameter reply.\n\n- capabilities - whether to request capabilities or not \"1\" - with\n  capabilities, \"0\" - no capabilities.\n\nThis function can be used from REQUEST_ROUTE.\n\np.s. this is executed asynchronously. See example on how to retrieve\nreturn value\n\n```\n...\nI_perform_user_authorization_request(\"REG_UAR_REPLY\",\"0\"); #0=REG/DEREG; 1=REG+Capabilities\nexit;\n...\nroute[REG_UAR_REPLY]\n{\n    #this is async so to know status we have to check the reply avp\n    switch ($avp(s:uaa_return_code)){\n            case 1: #success\n                    if (I_scscf_select(\"0\")){\n                            t_on_failure(\"register_failure\");\n                            t_on_reply(\"register_reply\");\n                            #now relay to appropriate SCSCF\n                            if (!t_relay()) {\n                                    t_reply(\"500\", \"Error forwarding to SCSCF\");\n                            }\n                    } else {#select failed\n                            I_scscf_drop();\n                            t_reply(\"500\", \"Server error on SCSCF Select (UAR)\");\n                    }\n                    break;\n            case -1: #failure\n                    xlog(\"L_ERR\", \"UAR failure - error response sent from module\\n\");\n                    break;\n            case -2: #error\n                    xlog(\"L_ERR\", \"UAR error - sending error response now\\n\");\n                    t_reply(\"500\", \"UAR failed\");\n                    break;\n            default:\n                    xlog(\"L_ERR\", \"Unknown return code from UAR, value is [$avp(s:uaa_return_code)]\\n\");\n                    t_reply(\"500\", \"Unknown response code from UAR\");\n                    break;\n    }\n}\n...\n        \n```\n",
   "I_perform_location_information_request": "### `I_perform_location_information_request(route_block)`\n\nPerform a LIR on Diameter CXDX interface.\n\n- Route block to resume after async LIR Diameter reply.\n\nThis function can be used from REQUEST_ROUTE.\n\np.s. this is executed asynchronously. See example on how to retrieve\nreturn value\n\n```\n...\nI_perform_location_information_request(\"SESSION_LIR_REPLY\",\"0\");\nexit;\n...\nroute[SESSION_LIR_REPLY]\n{\n    if ($avp(lia_return_code) == 1) {\n            if (I_scscf_select(\"0\")) {\n                    append_branch();\n                    t_on_reply(\"initial_request_reply\");\n                    t_on_failure(\"initial_request_failure\");\n                    if (!t_relay()) {\n                            t_reply(\"500\",\"Error forwarding towards S-CSCF\");\n                            break;\n                    }\n                    break;\n            } else {\n                    xlog(\"L_DBG\", \"dropping scscf list on initial request\\n\");\n                    I_scscf_drop();\n                    t_reply(\"500\", \"Server error on LIR select S-CSCF\");\n                    break;\n            }\n    } else {\n            t_reply(\"500\", \"Server error on LIR\");\n            break;\n    }\n    break;\n}\n...\n        \n```\n"
  }
 },
 "ims_ipsec_pcscf": {
  "overview": "This module contains methods for IPSec initialisation/deinitialisation\nrelated for usage of Kamailio as a Proxy-CSCF.\n",
  "parameters": {
   "ipsec_listen_addr": "### `ipsec_listen_addr` (string)\n\nIP address which the Proxy-CSCF will use for incoming/outgoing SIP\ntraffic over IPSec.\n\n*Default value is empty string (null) - IPv4 listen interface will not\nbe added*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_listen_addr\", \"\")\n...\n        \n```\n",
   "ipsec_listen_addr6": "### `ipsec_listen_addr6` (string)\n\nIPv6 address which the Proxy-CSCF will use for incoming/outgoing SIP\ntraffic over IPSec.\n\n*Default value is empty string (null) - IPv6 listen interface will not\nbe added*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_listen_addr6\", \"\")\n...\n        \n```\n",
   "ipsec_client_port": "### `ipsec_client_port` (int)\n\nPort number which will be bound for incoming (server) IPSec traffic.\n\n*Default value is 5062.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_client_port\", 5062)\n...\n        \n```\n",
   "ipsec_server_port": "### `ipsec_server_port` (int)\n\nPort number which will be bound for incoming (server) IPSec traffic.\n\n*Default value is 5063.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_server_port\", 5063)\n...\n        \n```\n",
   "ipsec_max_connections": "### `ipsec_max_connections` (int)\n\nMaximum simultaneous IPSec connections\n\n*Default value is 2.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_max_connections\", 10)\n...\n        \n```\n",
   "ipsec_reuse_server_port": "### `ipsec_reuse_server_port` (int)\n\nReuse (1) or not (0) the P-CSCF IPSec information for Re-registration\nfor one UA. When set to 0 - During Re-registration P-CSCF will create\nnew IPSec tunnels. When set to 1 - During Re-registration P-CSCF will\nreuse the old IPSec tunnels.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_reuse_server_port\", 1)\n...\n        \n```\n",
   "ipsec_spi_id_start": "### `ipsec_spi_id_start` (int)\n\nEach IPSec tunnel has a unique system-wide identifier. This and the\nfollowing option allows to tune the SPIs used by Kamailio in order to\navoid collisions with other IPSec useres. If Kamailio is the only\nprocess on the system which uses IPSec, don't bother with this option.\n\n*Default value is 100.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_spi_id_start\", 100)\n...\n        \n```\n",
   "ipsec_spi_id_range": "### `ipsec_spi_id_range` (int)\n\nHow many SPIs to be allocated for the process. E.g. if\nipsec_spi_id_start = 100 and ipsec_spi_id_range = 1000, SPIs between 100\nand 1100 will be used.\n\n*Default value is 1000.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_spi_id_range\", 1000)\n...\n        \n```\n",
   "ipsec_preferred_alg": "### `ipsec_preferred_alg` (string)\n\nA name of an authentication algorithm which the Proxy-CSCF will *prefer*\nwhen creating IPSec tunnels.\n\n*Default value is empty string (null) - the last algorithm in the\nSec-Agree header will be used.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_preferred_alg\", \"hmac-sha-1-96\")\n...\n        \n```\n",
   "ipsec_preferred_ealg": "### `ipsec_preferred_ealg` (string)\n\nA name of an encrytion algorithm which the Proxy-CSCF will *prefer* when\ncreating IPSec tunnels.\n\n*Default value is empty string (null) - the last algorithm in the\nSec-Agree header will be used. Note that the possibility of it being the\n\"null\" algorithm is not insignificant.*\n\n```\n...\nmodparam(\"ims_ipsec_pcscf\", \"ipsec_preferred_ealg\", \"aes-cbc\")\n...\n        \n```\n"
  },
  "functions": {
   "ipsec_create": "### `ipsec_create(domain)`\n\nThis function creates IPSec SA and Policy based on the parameters sent\nin Security-Client header in the REGISTER message. It's called when OK\nis received. The function also adds Security-Server header to the\nREGISTER.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n  *flags* - bitwise flag: 0x01 - if set - delete unused tunnels before\n  every registration. This is an optional parameter, default value - 0.\n\n<!-- -->\n\n\n```\n...\nipsec_create(\"location\");\n# or\nipsec_create(\"location\", \"1\");\n...\n        \n```\n",
   "ipsec_forward": "### `ipsec_forward(domain, flags)`\n\nThe function processes redirects outgoing message via the IPSec tunnel\ninitiated with ipsec_create().\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n  *flags* - bitwise flag:\n\n  - *0x01* (1) - set force socket for request messages. Useful for ipsec\n    and TCP.\n\n  - *0x02* (2) - reverse search for a contact in the memory. Useful when\n    contact alias is disabled.\n\n  - *0x04* (4) - use destination URI for IPSec tunnel search. Useful for\n    routing requests within dialog.\n\n  - *0x08* (8) - use new R-URI for IPSec tunnel search.\n\n  - *0x10* (16) - do not look for alias parameter to set received\n    details.\n\n  - *0x20* (32) - do not reset the destination URI.\n\n  - *0x40* (64) - use user equipment client port as target for TCP\n    requests.\n\n  - *0x80* (128) - set transport parameter in the new dst uri for TCP\n    requests.\n\n  - *0x100* (256) - use Via attributes (port and protocol) for routing\n    UDP reply.\n\n  - *0x200* (512) - try TCP if corresponding UDP socket is not found.\n\n\n  This is an optional parameter, default value - 0.\n\n<!-- -->\n\n\n```\n...\nipsec_forward(\"location\");\n# or\nipsec_forward(\"location\", \"1\");\n...\n        \n```\n",
   "ipsec_destroy": "### `ipsec_destroy(domain [, aor])`\n\nThe function destroys IPSec tunnel, created with ipsec_create.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n  *aor* - SIP URI to match the record. If not provided, then R-URI is\n  used.\n\n<!-- -->\n\n\n```\n...\nipsec_destroy(\"location\");\n...\n        \n```\n",
   "ipsec_destroy_by_contact": "### `ipsec_destroy_by_contact(domain, aor, recv_host, recv_port)`\n\nThe function destroys IPSec tunnel, created with ipsec_create.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n  *aor* - SIP URI to match the record.\n\n  *recv_host* - received host to match the record.\n\n  *recv_port* - received port to match the record.\n\nThe last three parameters have to be string valies and can contain\nvariables.\n\n```\n...\nipsec_destroy_by_contact(\"location\", \"...\", \"...\", \"...\");\n...\n        \n```\n"
  }
 },
 "ims_isc": {
  "overview": "This module provides the functionality for an IMS S-CSCF to implement\nthe ISC interface between S-CSCF and SIP Application Server.\n",
  "parameters": {
   "my_uri": "### `my_uri` (string)\n\nThis is the SIP URI of server on which the SCSCF is hosted.\n\n*Default value is 'sip:scscf.ims.smilecoms.com:6060'.*\n\n```\n...\nmodparam(\"ims_isc\", \"my_uri\", \"sip:scscf.ims.smilecoms.com:6060\")\n...\n        \n```\n",
   "expires_grace": "### `expires_grace` (integer)\n\nThis is the expires value to add to the expires during 3rd party\nregistration to prevent expiration in Application Server.\n\n*Default value is 120.*\n\n```\n...\nmodparam(\"ims_isc\", \"expires_grace\", 120)\n...\n        \n```\n",
   "isc_fr_timeout": "### `isc_fr_timeout` (integer)\n\nThis is the time in ms that we will wait for an AS response before we\nconsider it dead. It has to be lower than the SIP transaction timeout to\nprevent downstream timeouts. But not too small as ASs tend to take a\nlong time to respond.\n\n*Default value is 5000.*\n\n```\n...\nmodparam(\"ims_isc\", \"isc_fr_timeout\", 5000)\n...\n        \n```\n",
   "isc_fr_inv_timeout": "### `isc_fr_inv_timeout` (integer)\n\nThis is the time in ms that we will wait for an AS INVITE response\nbefore we consider it dead. It has to be lower than the SIP transaction\ntimeout to prevent downstream timeouts. But not too small as ASs tend to\ntake a long time to respond.\n\n*Default value is 20000*\n\n```\n...\nmodparam(\"ims_isc\", \"isc_fr_inv_timeout\", 20000)\n...\n        \n```\n",
   "add_p_served_user": "### `add_p_served_user` (integer)\n\nThis boolean indicates if a P-Served-User should be added on the ISC\ninterface, according to RFC 5502.\n\n*Default value is 0 (false)*\n\n```\n...\nmodparam(\"ims_isc\", \"add_p_served_user\", 1)\n# p-served user header will be enabled\n...\n        \n```\n"
  },
  "functions": {
   "isc_match_filter_reg": "### `isc_match_filter_reg(reg_state,domain)`\n\nThis function checks if a REGISTER messages matches Initial Filter\nCriteria - if so it inserts the necessary route headers and modifies the\ndestination URI to forward to the relevant Application Server.\n\nA positive return code (1) means that the REGISTER message has matched\nto Initial Filter Criteria and is armed for routing.\n\nThis function handles also the Service Info (if sent by the HSS), the\nInsertRegisterRequest flag (if sent by the HSS) or the\nInsertRegisterResponse flag (if sent by the HSS). Either the Service\nInfo OR the original REGISTER request OR the original REGISTER response\nis added to the body of the REGISTER message, before it is forwarded to\nthe relevant Application Server. Multipart body is not supported in this\ncase.\n\nMeaning of the parameters is as follows:\n\n- *reg_state* if the user was previously registered 0 - for initial\n  registration, 1 for re/de-registration.\n\n- *domain* that usrloc_scscf uses to store user information.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nisc_match_filter_reg(\"1\",\"location\");\n...\n        \n```\n",
   "isc_match_filter": "### `isc_match_filter(direction,domain)`\n\nThis function checks if a non-REGISTER messages matches Initial Filter\nCriteria - if so it inserts the necessary route headers and modifies the\ndestination URI to forward to the relevant Application Server.\n\nA positive return code (1) means that the message has matched to Initial\nFilter Criteria and is armed for routing.\n\nMeaning of the parameters is as follows:\n\n- *direction* the direction of this message - orig, term, etc.\n\n- *domain* that usrloc_scscf uses to store user information.\n\nThis function can be used from REQUEST_ROUTE | FAILURE_ROUTE.\n\n```\n...\nisc_match_filter(\"orig\",\"location\");\n...\n        \n```\n",
   "isc_from_as": "### `isc_from_as(direction)`\n\nThis function checks if this message has come from an Application\nServer.\n\nA positive return code (1) means that the message has come from an\nApplication Server.\n\nMeaning of the parameters is as follows:\n\n- *direction* the direction of this message - orig, term, etc.\n\nThis function can be used from REQUEST_ROUTE | FAILURE_ROUTE.\n\n```\n...\nif (!isc_from_as(\"orig\")) {\n    remove_hf(\"P-Asserted-Identity\");\n}\n...\n        \n```\n"
  }
 },
 "ims_ocs": {
  "overview": "This module provides a simple Online Charging Server Module for working\nwith the ims_charging module. It communicates with the ims_charging\nmodule via the Diameter-Ro Interface.\n\nThis module is dependent on the CDP (C Diameter Peer) modules for\ncommunicating with a Charging-Server as specified in 3GPP specification\nTS xx.xxx.\n\nPlease also refer to RFC 4006 (Diameter Credit-Control Application).\n\nThe module works will create fake SIP messages and provide them to an\nevent route for further operations. It up to the script writer to do the\nprocessing.\n",
  "parameters": {},
  "functions": {
   "ccr_result": "### `ccr_result(resultcode, grantedunits, finalunit)`\n\nThis method sets the response code of the Diameter Request.\n\nMeaning of the parameters is as follows:\n\n- *resultcode* - the Diameter Response code for the request. Typical\n  response codes are:\n\n  - \u201c2001\u201d - Ok\n\n  - \u201c5030\u201d - User unknown\n\n  - \u201c5031\u201d - Rating failed\n\n  - \u201c4010\u201d - End-User Service denied (e.g. Service blocked)\n\n  - \u201c5006\u201d - Resources exceeded (e.g. too many concurrent calls)\n\n\n- *grantedunits* - the number of granted units for this particular user\n\n- *finalunit* - indication, that all following requests will be denied\n  (this is the final unit for the session)\n\nThis function can be used from the event route.\n\n```\n...\nccr_result(\"2001\", \"600\", \"0\");\n...\n$var(result) = 2001;\n$var(granted) = $hdr(P-Requested-Units);\n$var(final) = 0;\nccr_result(\"$var(result)\", \"$var(granted)\", \"$var(final)\");\n...\nccr_result(\"2001\", \"$hdr(P-Requested-Units)\", \"0\");\n...\n```\n"
  }
 },
 "ims_qos": {
  "overview": "This module contains all method related to the IMS policy and charging\ncontrol functions performed by an Application Function (e.g. P-CSCF)\nover the Rx interface. This module is dependent on the CDP (C Diameter\nPeer) modules for communicating with PCRF as specified in 3GPP\nspecification TS 29.214.\n",
  "parameters": {
   "rx_dest_realm": "### `rx_dest_realm` (string)\n\nThis is the name of the Diameter realm of the Diameter server (typically\na PCRF).\n\n*Default value is 'ims.smilecoms.com'.*\n\n```\n...\nmodparam(\"ims_qos\", \"rx_dest_realm\", \"ims.smilecoms.com\")\n...\n        \n```\n",
   "rx_forced_peer": "### `rx_forced_peer` (string)\n\nFQDN of the Diameter server (typically a PCRF) to communicate with. If\nnot set then realm routing is used. If you use this, the routing defined\nin your diameter xml configuration file (CDP) will be ignored and as a\nresult you will lose the benefits of load balancing and failover.\n\n*Default value is ''.*\n\n```\n...\nmodparam(\"ims_qos\", \"rx_forced_peer\", \"pcrf.ims.smilecoms.com\")\n...\n        \n```\n",
   "rx_auth_expiry": "### `rx_auth_expiry` (integer)\n\nThis is the expiry length in seconds of the initiated Diameter sessions.\n\n*Default value is 7200.*\n\n```\n...\nmodparam(\"ims_qos\", \"rx_auth_expiry\", 14400)\n...\n        \n```\n",
   "cdp_event_latency": "### `cdp_event_latency` (integer)\n\nThis is a flag to determine whether or slow CDP responses should be\nreported in the log file. 1 is enabled and 0 is disabled.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"ims_qos\", \"cdp_event_latency\", 1)\n...\n        \n```\n",
   "cdp_event_threshold": "### `cdp_event_threshold` (integer)\n\nThis time in milliseconds is the limit we should report a CDP response\nas slow. i.e. if a CDP response exceeds this limit it will be reported\nin the log file. This is only relevant is cdp_event_latency is enabled\n(set to 0).\n\n*Default value is 500.*\n\n```\n...\nmodparam(\"ims_qos\", \"cdp_event_threshold\", 500)\n...\n        \n```\n",
   "cdp_event_latency_log": "### `cdp_event_latency_log` (integer)\n\nThis time log level at which we should report slow CDP responses. 0 is\nERROR, 1 is WARN, 2 is INFO and 3 is DEBUG. This is only relevant is\ncdp_event_latency is enabled (set to 0)\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_qos\", \"cdp_event_latency_log\", 1)\n...\n        \n```\n",
   "authorize_video_flow": "### `authorize_video_flow` (integer)\n\nThis is a flag that specifies whether or not to authorize video flows. 1\nmeans video flows will be authorized over Rx and 0 means video flows\nwill not be authorized over Rx\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"ims_qos\", \"authorize_video_flow\", 0)\n...\n        \n```\n",
   "cdp_event_list_size_threshold": "### `cdp_event_list_size_threshold` (integer)\n\nThis is a threshold on the size of the cdp event list. Once the queue\nexceeds this length a warning is logged. 0 disables this feature\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_qos\", \"cdp_event_list_size_threshold\", 10)\n...\n        \n```\n",
   "audio_default_bandwidth": "### `audio_default_bandwidth` (integer)\n\nThis parameters defines the default bandwidth for Audio, if no\n\"b=AS\"-Parameter is found in the SDP.\n\n*Default value is 64 (64 kBit)*\n\n```\n...\nmodparam(\"ims_qos\", \"audio_default_bandwidth\", 32)\n...\n        \n```\n",
   "video_default_bandwidth": "### `video_default_bandwidth` (integer)\n\nThis parameters defines the default bandwidth for Video, if no\n\"b=AS\"-Parameter is found in the SDP.\n\n*Default value is 128 (128 kBit)*\n\n```\n...\nmodparam(\"ims_qos\", \"video_default_bandwidth\", 256)\n...\n        \n```\n",
   "early_qosrelease_reason": "### `early_qosrelease_reason` (String)\n\nThis sets the default Reason, when a call is terminated in early stage\ndue to QoS-failure.\n\n*Default value is \"QoS released\", a call in early stage would be\nreleased with \"488 QoS released\".*\n\n```\n...\nmodparam(\"ims_qos\", \"early_qosrelease_reason\", \"Sorry - QoS failed\")\n...\n        \n```\n",
   "confirmed_qosrelease_headers": "### `confirmed_qosrelease_headers` (String)\n\nThese headers are added to the BYE-Message, when a confirmed call is\nterminated due to a QoS failure.\n\n*Default value is \"\", no Extra-Headers*\n\n*The headers must end with CRLF.*\n\n```\n...\nmodparam(\"ims_qos\", \"confirmed_qosrelease_headers\", \"X-Reason: QoS failed\\r\\n\")\n...\n        \n```\n",
   "regex_sdp_ip_prefix_to_maintain_in_fd": "### `regex_sdp_ip_prefix_to_maintain_in_fd` (String)\n\nThe flow-description AVP is typically populated using IP:port\ninformation present in the SDP. Certain (buggy) UEs can change ports\nmidway during calls which causes the flow-description to no longer match\nthe traffic. This parameter allows the flow-description AVP to use to\nthe any keyword instead of certain IP:port combinations in the SDP. The\nparameter is a regex that if set adds an extra filter for all IPs that\ndo not match the regex with the any keyword in the flow-description AVP\n\n*Default value is \"\", no extra filters added*\n\n```\n...\nmodparam(\"ims_qos\", \"regex_sdp_ip_prefix_to_maintain_in_fd\", \"10.21.0.1\")\n...\n        \n```\n",
   "terminate_dialog_on_rx_failure": "### `terminate_dialog_on_rx_failure` integer\n\nIf set then active dialogs associated with an Rx session are torn down\nin the Rx session fails\n\n*Default value is 1, dialogs are torn down*\n\n```\n...\nmodparam(\"ims_qos\", \"terminate_dialog_on_rx_failure\", 0)\n...\n        \n```\n",
   "delete_contact_on_rx_failure": "### `delete_contact_on_rx_failure` integer\n\nIf set then contacts associated with signalling Rx sessions are deleted\nif the Rx session fails\n\n*Default value is 1, contacts are deleted*\n\n```\n...\nmodparam(\"ims_qos\", \"delete_contact_on_rx_failure\", 0)\n...\n        \n```\n",
   "include_rtcp_fd": "### `include_rtcp_fd` integer\n\nIf set then a flow description is added for media flows - next available\nodd port is used as the default for RTCP traffic\n\n*Default value is 0, RTCP flow description not added*\n\n```\n...\nmodparam(\"ims_qos\", \"include_rtcp_fd\", 1)\n...\n        \n```\n",
   "af_signaling_ip": "### `af_signaling_ip` (String)\n\nSet P-CSCF IPv4 address to generate the flows for the UE - PCSCF\nsignaling path. Used only for AAR register, Flow-Description AVP (507)\n\n*Default value is 127.0.0.1*\n\n```\n...\nmodparam(\"ims_qos\", \"af_signaling_ip\", \"127.0.0.1\")\n...\n        \n```\n",
   "af_signaling_ip6": "### `af_signaling_ip6` (String)\n\nSet P-CSCF IPv6 address to generate the flows for the UE - PCSCF\nsignaling path. Used only for AAR register, Flow-Description AVP (507)\n\n*Default value is \"\"*\n\n```\n...\nmodparam(\"ims_qos\", \"af_signaling_ip6\", \"fd16::205:2dee:ce4a:ab22\")\n...\n        \n```\n",
   "media_type": "### `media_type` (String)\n\nDescribe Media Type AVP(520) for AAR register\n\n*Default value is 'control'*\n\n```\n...\nmodparam(\"ims_qos\", \"media_type\", \"audio\")\n...\n        \n```\n",
   "flow_protocol": "### `flow_protocol` (String)\n\nDescribe Flow protocol for Flow-Description AVP (507). Used only for AAR\nregister\n\n*Default value is 'IP'*\n\n```\n...\nmodparam(\"ims_qos\", \"flow_protocol\", \"UDP\")\n...\n        \n```\n",
   "omit_flow_ports": "### `omit_flow_ports` integer\n\nIf set to 1 ommit ports for Flow-Description AVP (507). Used only for\nAAR register\n\n*Default value is 0, Add ports to Flow-Description AVP (507)*\n\n```\n...\nmodparam(\"ims_qos\", \"omit_flow_ports\", 1)\n...\n        \n```\n",
   "rs_default_bandwidth": "### `rs_default_bandwidth` integer\n\nDescribe default RS-Bandwidth AVP(522) for AAR\n\n*Default value is 0*\n\n```\n...\nmodparam(\"ims_qos\", \"rs_default_bandwidth\", 600)\n...\n        \n```\n",
   "rr_default_bandwidth": "### `rr_default_bandwidth` integer\n\nDescribe default RR-Bandwidth AVP(521) for AAR\n\n*Default value is 0*\n\n```\n...\nmodparam(\"ims_qos\", \"rr_default_bandwidth\", 2000)\n...\n        \n```\n",
   "suspend_transaction": "### `suspend_transaction` integer\n\nIf enabled, suspends the tm transaction while doing the AAR.\n\n*Default value is 1 (enabled)*\n\n```\n...\nmodparam(\"ims_qos\", \"suspend_transaction\", 0)\n...\n        \n```\n",
   "recv_mode": "### `recv_mode` integer\n\nIf set to 0, rx_aar_register() takes the received-from address values\n(IP, port, proto) from the IP frame. If set to 1, it takes them from Via\nheader.\n\n*Default value is 0*\n\n```\n...\nmodparam(\"ims_qos\", \"recv_mode\", 1)\n...\n        \n```\n",
   "dialog_direction": "### `dialog_direction` integer\n\nIf set to 1, DLG_MOBILE_ORIGINATING is set to\nrx_add_media_component_description_avp() instead of DLG_MOBILE_REGISTER\n(which corresponds to value 3).\n\n*Default value is 3*\n\n```\n...\nmodparam(\"ims_qos\", \"dialog_direction\", 1)\n...\n        \n```\n"
  },
  "functions": {
   "Rx_AAR_Register": "### `Rx_AAR_Register(route_block, domain)`\n\nPerform an AAR on Diameter RX interface to subscribe to signalling\nstatus. This purpose of this is tell a Diameter server (typically a\nPCRF) to inform the requesting Diameter client on changes to the status\nof signalling bearer for the same framed IP address. For more details\nsee 3GGP TS 29.214.\n\nMeaning of the parameters is as follows:\n\n- Route block to resume after async UAR Diameter reply.\n\n- *domain* that usrloc_pcscf uses to store user information.\n\nReturn codes:\n\n- *-1* - error: There was an error, so we must either ignore it (no\n  subscription) or send 403 (depends on behaviour you want)\n\n  *0* - Success: AAR-Request sent, reply is processed asynchronously.\n\n  *1* - Success: No need to send AAR-Request, as a subscription still\n  exists (continue as normal)\n\nThis function can be used from REQUEST_ROUTE.\n\np.s. this is executed asynchronously. See example on how to retrieve\nreturn value\n\n```\n...\nif(Rx_AAR_Register(\"REG_AAR_REPLY\",\"location\")==0){\n    exit;\n}\n...\nroute[REG_AAR_REPLY]\n{\n    switch ($avp(s:aar_return_code)) {\n        case 1:\n            xlog(\"L_DBG\", \"Diameter: AAR success on subscription to signalling\\n\");\n            break;\n        default:\n            xlog(\"L_ERR\", \"Diameter: AAR failed on subscription to signalling\\n\");\n            t_reply(\"403\", \"Can't register to QoS for signalling\");\n            exit;\n    }\n...\n```\n",
   "Rx_AAR": "### `Rx_AAR(route_block, direction, subscription_id, subscription_id_type)`\n\nPerform an AAR on Diameter RX interface to request resource\nauthorisation from a Diameter server (typically a PCRF). For more\ndetails see 3GGP TS 29.214.\n\nMeaning of the parameters is as follows:\n\n- *Route block* to resume after async UAR Diameter reply.\n\n- *direction* of this message - orig, term, etc.\n\n- *subscription_id* to hard code subscription ID for AAR. Used for some\n  broken PCRFs. Leave blank to use default\n\n- *subscription_id_type* to hard code subscription ID type for AAR. Only\n  applicable if subscription_id is set. Set to -1 to use default. This\n  is as per RFC 4006: END_USER_E164 0, END_USER_IMSI 1, END_USER_SIP_URI\n  2, END_USER_NAI 3, END_USER_PRIVATE 4\n\nThis function can be used only from ONREPLY_ROUTE, only for replies to\nINVITE, UPDATE, PRACK. The reply and request must have SDP, for this\nfunction to work properly.\n\np.s. this is executed asynchronously. See example on how to retrieve\nreturn value\n\n```\n...\nif(Rx_AAR(\"ORIG_SESSION_AAR_REPLY\",\"orig\",\"\",-1)==0){\n    exit;\n}\n...\nroute[ORIGN_SESSION_AAR_REPLY]\n{\n    if ($avp(s:aar_return_code) != 1) {\n        xlog(\"L_ERR\", \"IMS: AAR failed Orig\\n\");\n        dlg_terminate(\"all\", \"Sorry no QoS available\");\n    } else {\n        xlog(\"L_DBG\", \"Diameter: Orig AAR success on media authorization\\n\");\n    }\n}\n...\n```\n"
  }
 },
 "ims_registrar_pcscf": {
  "overview": "This module contains all methods related for usage of Kamailio as a\nProxy-CSCF.\n",
  "parameters": {
   "pcscf_uri": "### `pcscf_uri` (string)\n\nURI of this Proxy-CSCF.\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"pcscf_uri\", \"pcscf.mnc001.mcc001.3gppnetwork.org\")\n...\n        \n```\n",
   "pending_reg_expires": "### `pending_reg_expires` (int)\n\nHow long (in seconds), until pending (uncomplete) Registrations expire\n\n*Default value is 30.*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"pending_reg_expires\", 15)\n...\n        \n```\n",
   "received_avp": "### `received_avp` (string)\n\nAVP, holding the received information (optional)\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"received_avp\", \"$avp(i:42)\")\n...\n        \n```\n",
   "is_registered_fallback2ip": "### `is_registered_fallback2ip` (int)\n\nDefines, whether a contact should be searched by its Contact: only or\nalternatively by the received IP-Address.\n\nThe option may have the following values:\n\n- *0* Search by Contact-Header only\n\n- *1* Search by Contact-Header, if this fails, search by Received\n  Information (IP, Port, Proto)\n\n- *2* Search by Received Information (IP, Port, Proto), if this fails,\n  Search by Contact Header\n\nThis Parameter is primarily used by the \"is_registered\" function.\n\n*Default value is 0 (Contact only).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"is_registered_fallback2ip\", 2)\n...\n        \n```\n",
   "publish_reginfo": "### `publish_reginfo` (int)\n\nIf set to \"1\", the module will send PUBLISH regarding changes of the\nregistration (e.g. due to Rx-Information) towards the network core.\n\n*Default value is 0 (Do not send PUBLISH).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"publish_reginfo\", 1)\n...\n        \n```\n",
   "subscribe_to_reginfo": "### `subscribe_to_reginfo` (int)\n\nIf set to \"1\", the module will send a SUBSCRIBE for the registration\nstatus towards the network core.\n\n*Default value is 0 (Do not send SUBSCRIBE).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"subscribe_to_reginfo\", 1)\n...\n        \n```\n",
   "subscription_expires": "### `subscription_expires` (int)\n\nHow long should the subscription of reg-info towards the packet-core be\nvalid?\n\n*Default value is 3600.*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"subscription_expires\", 7200)\n...\n        \n```\n",
   "ignore_contact_rxport_check": "### `ignore_contact_rxport_check` (int)\n\nValidate, if the port, from which the request was received, is the same\nas used during registration.\n\nThis Parameter is primarily used by the \"is_registered\" function.\n\n*Default value is 0 (do not ignore Ports).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"ignore_contact_rxport_check\", 1)\n...\n        \n```\n",
   "ignore_reg_state": "### `ignore_reg_state` (int)\n\nValidate, if the found contact is really and completely registered.\n\nThis Parameter is primarily used by the \"is_registered\" function.\n\n*Default value is 0 (do not ignore registration state).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"ignore_reg_state\", 1)\n...\n        \n```\n",
   "force_icscf_uri": "### `force_icscf_uri` (string)\n\nInstead of doing a DNS-Lookup on the domain, always send the requests to\na specific I-CSCF.\n\n*Default value is not set, do the DNS-Lookup.*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"force_icscf_uri\", \"sip:icscf.mnc001.mcc001.3gppnetwork.org\")\n...\n        \n```\n",
   "reginfo_queue_size_threshold": "### `reginfo_queue_size_threshold` (int)\n\nAs reginfo operations are processed asynchronously, this parameter\ndefines at what length of the queue, the length should be logged (in\norder to determine overload)\n\n*Default value is 0 (do not log queue length).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"reginfo_queue_size_threshold\", 42)\n...\n        \n```\n",
   "delete_delay": "### `delete_delay` (int)\n\nIf set greater than 0, the delete of a pcontact record is delayed with\nits value instead of being done immediately.\n\n*Default value is 0 (delete immediately).*\n\n```\n...\nmodparam(\"ims_registrar_pcscf\", \"delete_delay\", 10)\n...\n        \n```\n"
  },
  "functions": {
   "pcscf_save": "### `pcscf_save(domain)`\n\nThe function processes a reply to a *REGISTER* message. It can add,\nremove or modify location records (in usrloc) depending on Contact and\nExpires HFs in the REGISTER message.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n<!-- -->\n\n\n```\n...\npcscf_save(\"location\");\n...\n```\n",
   "pcscf_save_pending": "### `pcscf_save_pending(domain)`\n\nSame as pcscf_save(), but it will store the registration in a \"Pending\"\nstate.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\nThe return code may have the following values:\n\n- *( 1)* OK\n\n- *(-1)* Parsing of contact data failed\n\n- *(-2)* Deregistration in progress\n\nFor db_mode = DB_ONLY (3) setting for ims_usrloc_pcscf module modparam\nfollowing logic is implemented:\n\n- To avoid race time conditions between a REREGISTER and the expiry\n  handler state machine in the scscf an approach is chosen to refuse a\n  REREGISTER in time window of 20 seconds after pcontact expiry on the\n  pcscf (thus allowing expiry handling to finish). REREGISTER is refused\n  in this scenario with return code -2.\n\n- In case a REREGISTER arrives at pcscf and the respective pcontact is\n  expired longer than time window of 20 seconds registration also is\n  refused with return code -2 and additionaly PUBLISH is sent to scscf\n  with expiry = 0.\n\n- The rc -2 shall be handled in register.cfg script as follows:\n\n  pcscf_save_pending(\"location\");\n\n  switch ($retcode) {\n\n  case -1:\n\n  .......\n\n  case -2:\n\n  send_reply(\"500\", \"Deregister in progress - Please try again\");\n\n  exit;\n\n  break;\n\n  }\n",
   "pcscf_follows_service_routes": "### `pcscf_follows_service_routes(domain)`\n\nReturns true, if the request is following the \"learned\" service-routes\nduring registration.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n",
   "pcscf_force_service_routes": "### `pcscf_force_service_routes(domain)`\n\nRemove existing route-headers and force the Service-Routes, that were\nlearned during registration.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n",
   "pcscf_is_registered": "### `pcscf_is_registered(domain)`\n\nReturns true, if the request is coming from a \"registered\" endpoint.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n"
  }
 },
 "ims_usrloc_pcscf": {
  "overview": "This module serves as a storage engine for PCSCF contacts, much like the\nstandard Kamailio module, usrloc, is a storage engine for standard SIP\ncontacts. The concept of a contact in IMS, PCSCF specifically, is very\ndifferent to that of std. SIP and as a result we have built this new\nmodule. A lot of the design has been borrowed from the std. usrloc\nmodule. For example. An IMS contact, in PCSCF, needs things like:\n\n- Diameter Rx session for signalling bearer status. i.e. this is\n  effectively QoS from the network to make sure the signalling link can\n  be 'trusted'\n\n- IPSEC Security Association for secure signalling between UE and PCSCF\n  (first point of contact)\n\n- IMPU, each contact can have a number of associated public identities\n  (IMPU).\n",
  "parameters": {
   "hash_size": "### hash_size (int)\n\nThe number of entries of the hash table used by to store the contact\nrecords is 2^hash_size. For hash_size=4, the number of entries of the\nhash table is 16.\n\n*Default value is 9.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"hash_size\", 10)\n...\n```\n",
   "timer_interval": "### timer_interval (int)\n\nNumber of seconds between two timer runs. The module uses timer to\ndelete expired contacts.\n\n*Default value is 60.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"timer_interval\", 30)\n...\n```\n",
   "db_url": "### db_url (int)\n\nDatabase URL\n\n*Default value is \"mysql://kamailio:kamailiorw@localhost/kamailio\".*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"db_url\",\n       \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_mode": "### db_mode (int)\n\nThis is the database mode to be used for the PCSCF usrloc data\npersistent storage. Currently this module supports the Write-Through\nscheme only.\n\n- 0 - This disables DB mode. Only memory will be used for usrloc and\n  data will not survive a restart.\n\n- 1 - Write-Through Scheme. All changes to usrloc are immediately\n  reflected in the database. This is slow but very reliable. This mode\n  will ensure that no registration data is lost as a result of a restart\n  or crash.\n\n- 3 - DB_ONLY Scheme. All changes to usrloc are immediately reflected in\n  the database and additionally PCSCF usrloc data are downloaded from db\n  and inserted into PCSCF usrloc cache if required - i.e. If contact\n  data cannot be found in cache a db query for the contact is done in\n  table location and when contact is found there its respective data are\n  inserted in PCSCF usrloc cache. Also an audit had been added for\n  removal of long expired PCSCF usrloc data in table location. This mode\n  will ensure that no registration data is lost as a result of a restart\n  or crash.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"db_mode\", 1)\n...\n```\n",
   "match_contact_host_port": "### match_contact_host_port (int)\n\nIf set to 1 (default), the contact is matched using only host and port\nin the contact URI.\n\n- 0 - When matching contact do full contact match procedure.\n\n- 1 - When matching contact compare only host and port of the contact\n  URI.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"match_contact_host_port\", 0)\n...\n```\n",
   "expires_grace": "### expires_grace (int)\n\nSpecify a grace time for keeping the contacts until they are finally\ndeleted. The value of the parameter is defined in seconds.\n\n*Default value is 3600.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"expires_grace\", 1800)\n...\n```\n",
   "audit_expired_pcontacts_interval": "### audit_expired_pcontacts_interval (int)\n\nNumber of seconds between two audit runs. Note: audit is used for\ndb_mode DB_ONLY (3) only. The module uses this audit to delete expired\ncontacts found in db table location which are expired at least as the\naudit_expired_pcontacts_timeout value. Such expired contacts in location\nmay appear when these contacts are not present in usrloc cache because\nPCSCF crashed before contact expiry.\n\n*Default value is 60.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"audit_expired_pcontacts_interval\", 120)\n...\n```\n",
   "audit_expired_pcontacts_timeout": "### audit_expired_pcontacts_timeout (int)\n\nNumber of seconds the contacts must be already expired before the audit\nstarts working on them. It is recommended to set only values greater\nthan the Default value 40. The module uses this audit to delete expired\ncontacts found in db table location which are expired at least as many\nseconds as the sum of this timeout parameter value plus the value of the\nexpires_grace parameter.\n\n*Default value is 40.*\n\n```\n...\nmodparam(\"ims_usrloc_pcscf\", \"audit_expired_pcontacts_timeout\", 120)\n...\n```\n"
  },
  "functions": {}
 },
 "ims_usrloc_scscf": {
  "overview": "This module serves as a storage engine for SCSCF contacts, much like the\nstandard Kamailio module that is usrloc, is a storage engine for\nstandard SIP contacts.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\ndatabase URL for storing impu/contacts records\n\n```\n        modparam(\"ims_usrloc_scscf\", \"db_url\", \"mysql//username:password@localhost/scscf\")\n        \n```\n",
   "db_mode": "### `db_mode` (string)\n\nThis is the database mode to be used for the SCSCF usrloc data\npersistent storage. Currently this module supports the Write-Back scheme\nonly.\n\n- 0 - This disables database completely. Only memory will be used.\n  Contacts will not survive restart.\n\n- 1 - Write-Backend scheme. All changes are made to memory and database\n  synchronization is done in the timer\n\n*Default value is 0.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"db_mode\", 1)\n        \n```\n",
   "maxcontact": "### maxcontact (int)\n\nThe parameter can be used to limit the number of contact for each impu\n\n*Default value is 0(max)*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"maxcontact\", 10)\n        \n```\n",
   "maxcontact_3gpp": "### maxcontact_3gpp (int)\n\nThe parameter can be used to limit the number of 3GPP contact for each\nimpu\n\n*Default value is 0.(max)*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"maxcontact_3gpp\", 0)\n        \n```\n",
   "maxcontact_behaviour": "### maxcontact_behaviour (int)\n\nBehaviour of usrloc , after impu reach max contacts limit.\n\n- 0 - Disabled\n\n- 1 - Reject after reaching limit.\n\n- 2 - Overwrite\n\n*Default value is 0.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"maxcontact_behaviour\", 2)\n        \n```\n",
   "max_subscribes": "### max_subscribes(int)\n\nMax number of subscribes allowed per watcher for each IMPU\n\n*Default value is 0.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"max_subscribes\", 2)\n        \n```\n",
   "sub_dialog_hash_size": "### sub_dialog_hash_size(int)\n\nSubscriber dialog hash table size\n\n*Default value is 10.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"sub_dialog_hash_size\", 512)\n      \n```\n",
   "timer_procs": "### timer_procs(int)\n\nprocess number of handling registeration\n\n*Default value is 0*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"timer_procs\", 5)\n        \n```\n",
   "timer_interval": "### timer_interval (int)\n\nNumber of seconds between two timer runs. The module uses a timer to\ndelete expired contacts, synchronize with database and other tasks, that\nneed to be run periodically\n\n*Default value is 90*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"timer_interval\", 120)\n        \n```\n",
   "desc_time_order": "### desc_time_order (int)\n\nIf the user's contacts should be kept timestamp ordered; otherwise the\ncontact will be ordered based on q value. Non 0 value means true.\n\n*Default value is timestamp ordering not enabled*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"desc_time_order\", 1)\n        \n```\n",
   "matching_mode": "### matching_mode (int)\n\nWhat contact matching algorithm to be used.\n\n- 0 - Contact Only matching\n\n- 1 - Contact and Callid Matching\n\n- 2 - Contact and Path header matching\n\n- 3 - Only contact IP and Port Matching\n\n*Default value is 0.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"matching_mode\", 0)\n       \n```\n",
   "cseq_delay": "### cseq_delay (int)\n\nDelay (in seconds) for accepting as retransmissions register requests\nwith same Call-ID and Cseq.\n\n*Default value is 20.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"cseq_delay\", 20)\n        \n```\n",
   "fetch_rows": "### fetch_rows(int)\n\nThe number of the rows to be fetched at once from database when loading\nthe location records.\n\n*Default value is 2000.*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"fetch_rows\", 3000)\n        \n```\n",
   "hash_size": "### hash_size (int)\n\nThe number of entries of the hash table used by usrloc\n\n*Default value 512*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"hash_size\", 512)\n        \n```\n",
   "subs_hash_size": "### subs_hash_size (int)\n\nThe number of entries of the hash table used by usrloc to store the ims\nsubscribe records\n\n*Default value 512*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"subs_hash_size\", 512)\n        \n```\n",
   "contacts_hash_size": "### contacts_hash_size (integer)\n\nThe number of entries of the hash table used by usrloc to store the\ncontact records\n\n*Default value is 512*\n\n```\n...\n        modparam(\"ims_usrloc_scscf\", \"contacts_hash_size\", 512)\n        \n```\n",
   "nat_bflag": "### nat_bflag (integer)\n\nNAT marker to handle natted registration\n\n*Default value is 0*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"nat_bflag\", 3)\n       \n```\n",
   "contact_delete_delay": "### contact_delete_delay (int)\n\nIf contact is put into delay delete state, this is how long we delay\nbefore deleting\n\n*Default value is 30*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"contact_delete_delay\", 32)\n         \n```\n",
   "support_wildcardPSI": "### support_wildcardPSI (int)\n\nWildcard Public-Service-Identity (RFC5002). it will be actived by\nsetting 1\n\n*Default value is 0.(disabled)*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"support_wildcardPSI\", 0)\n        \n```\n",
   "unreg_validity": "### unreg_validity (int)\n\nDefault validity time in seconds for unregister assignment to SCSCF\n\n*Default value is 1800*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"unreg_validity\", 0)\n        \n```\n",
   "user_data_xsd": "### user_data_xsd (string)\n\n*Default value is 1800*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"user_data_xsd\", \"/usr/local/etc/kamailio/CxDataType_Rel6.xsd\")\n        \n```\n",
   "realm": "### realm (string)\n\n*Default value is NULL*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"realm\", \"kamailio-ims.org\")\n        \n```\n",
   "skip_realm": "### skip_realm (int)\n\nSkipping defined network name in the `realm` for NOTIFY's Message body\nreginfo tag.\n\n*Default value is 0*\n\n```\n        modparam(\"ims_usrloc_scscf\", \"skip_realm\", 1)\n        \n```\n"
  },
  "functions": {}
 },
 "influxdbc": {
  "overview": "This module provides a client connector for InfluxDB.\n",
  "parameters": {
   "server": "### `server` (int)\n\nAddress of InfluxDB server.\n\n*Default value is empty.*\n\n```\n...\nmodparam(\"influxdbc\", \"server\", \"127.0.0.1\")\n...\n```\n",
   "port": "### `port` (int)\n\nAddress of InfluxDB server.\n\n*Default value is 8086.*\n\n```\n...\nmodparam(\"influxdbc\", \"port\", 8808)\n...\n```\n",
   "database": "### `database` (int)\n\nDatabase of InfluxDB server.\n\n*Default value is empty.*\n\n```\n...\nmodparam(\"influxdbc\", \"database\", \"stats\")\n...\n```\n"
  },
  "functions": {
   "influxdbc_measure": "### `influxdbc_measure(name)`\n\nStart a measure group with the given name.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    influxdbc_measure(\"stats\");\n    ...\n}\n...\n```\n",
   "influxdbc_measureend": "### `influxdbc_measureend()`\n\nEnd the current measure group.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    influxdbc_measureend();\n    ...\n}\n...\n```\n",
   "influxdbc_sub": "### `influxdbc_sub(name)`\n\nStart a measure subgroup with the given name.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    influxdbc_sub(\"grp1\");\n    ...\n}\n...\n```\n",
   "influxdbc_subend": "### `influxdbc_subend()`\n\nEnd the current measure subgroup.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    influxdbc_subend();\n    ...\n}\n...\n```\n",
   "influxdbc_push": "### `influxdbc_push()`\n\nPush accumulated values to the server.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    influxdbc_push();\n    ...\n}\n...\n```\n",
   "influxdbc_long": "### `influxdbc_long(name, value)`\n\nSave the pair with provided name and value. Both parameters can have\nvariables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    influxdbc_long(\"active\", \"$shv(active)\");\n    ...\n}\n...\n```\n"
  }
 },
 "ipops": {
  "overview": "The IPops module offers operations for handling IP addresses, both IPv4\nand IPv6.\n\nIPv6 is defined in [RFC 2460](http://tools.ietf.org/html/rfc2460). The\nsame IPv6 address can be represented by different ASCII strings, so\nbinary comparison is required. For example, the following IPv6 addresses\nare equivalent:\n\n- 2001:DB8:0000:0000:0008:0800:200C:417A\n\n- 2001:DB8:0:0:8:800:200C:417A\n\n- 2001:DB8::200C:417A\n\nWhen using IPv6 in an URI (i.e. a SIP URI) the IP address must be\nwritten in \"IPv6 reference\" format (which is the textual representation\nof the IPv6 enclosed between [ ] symbols). An example is\n\u201csip:alice@[2001:DB8:0:0:8:800:200C:417A]\u201d. This allows separation of\naddress and port number with a :, like\n\u201c[2001:DB8:0:0:8:800:200C:417A]:5060\u201d. This module also allows\ncomparing an IPv6 address with its IPv6 reference representation.\n",
  "parameters": {},
  "functions": {
   "is_ip": "### `is_ip (ip)`\n\nReturns TRUE if the argument is a valid IPv4, IPv6 or IPv6 reference.\nFALSE otherwise.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP address to\n  evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (is_ip($rd)) {\n  xlog(\"L_INFO\", \"RURI domain is an IP address (not a host name/domain)\\n\");\n}\n...\n        \n```\n",
   "is_pure_ip": "### `is_pure_ip (ip)`\n\nReturns TRUE if the argument is a valid IPv4 or IPv6. FALSE otherwise.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\n$var(ip) = \"::1\";\nif (is_pure_ip($var(ip))) {\n  xlog(\"L_INFO\", \"it's IPv4 or IPv6\\n\");\n}\n...\n        \n```\n",
   "is_ipv4": "### `is_ipv4 (ip)`\n\nReturns TRUE if the argument is a valid IPv4. FALSE otherwise.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (is_ipv4(\"1.2.3.4\")) {\n  xlog(\"L_INFO\", \"it's IPv4\\n\");\n}\n...\n        \n```\n",
   "is_ipv6": "### `is_ipv6 (ip)`\n\nReturns TRUE if the argument is a valid IPv6. FALSE otherwise.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (is_ipv6(\"1080:0:0:0:8:800:200C:417A\")) {\n  xlog(\"L_INFO\", \"it's IPv6\\n\");\n}\n...\n        \n```\n",
   "is_ipv6_reference": "### `is_ipv6_reference (ip)`\n\nReturns TRUE if the argument is a valid IPv6 reference. FALSE otherwise.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (is_ipv6_reference(\"[1080:0:0:0:8:800:200C:417A]\")) {\n  xlog(\"L_INFO\", \"it's IPv6 reference\\n\");\n}\n...\n        \n```\n",
   "ip_type": "### `ip_type (ip)`\n\nReturns the type of the given IP.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\nReturn value:\n\n- *1* - IPv4\n\n- *2* - IPv6\n\n- *3* - IPv6 reference\n\n- *-1* - invalid IP\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nip_type($var(myip));\nswitch($rc) {\n  case 1:\n    xlog(\"L_INFO\", \"it's IPv4\\n\");\n    break;\n  case 2:\n    xlog(\"L_INFO\", \"it's IPv6\\n\");\n    break;\n  case 3:\n    xlog(\"L_INFO\", \"it's IPv6 reference\\n\");\n    break;\n  case -1:\n    xlog(\"L_INFO\", it's type invalid\\n\");\n    break;\n}\n...\n        \n```\n",
   "detailed_ip_type": "### `detailed_ip_type (ip, result)`\n\nReturns the detailed type of the given IP () (see\nhttp://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.txt,\nhttp://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.txt,\nRFC 5735 and RFC 6598: PRIVATE, SHARED, LOOPBACK, IPV4MAP, DISCARD etc).\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\n- *result* - String or pseudo-variable containing the detailed type of\n  the IP.\n\n  - IPv4\n    - PUBLIC, RIVATE, SHARED, LOOPBACK, LINK-LOCAL, RESERVED, TEST-NET,\n    6TO4-RELAY, MULTICAST, BROADCAST\n  - IPv6\n    - UNSPECIFIED, LOOPBACK, IPV4MAP, RESERVED, DISCARD,\n    GLOBAL-UNICAST, TEREDO, BMWG, DOCUMENTATION, ORCHID, 6TO4,\n    UNIQUE-LOCAL-UNICAST, LINK-LOCAL-UNICAST, MULTICAST\n\nReturn value:\n\n- *1* - successful operation\n\n- *negative value* - error occurred\n\nThis function can be used from ALL ROUTES\n\n```\n...\n    detailed_ip_type(\"192.168.1.2\",\"$var(result)\");\n    xlog(\"L_ERR\",\"IP address is of detailed type: $var(result) \");\n...\n        \n```\n",
   "detailed_ipv4_type": "### `detailed_ipv4_type (ip, result)`\n\nReturns the detailed type of the given IP () (see RFC 5735 and RFC\n6598).\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\n- *result* - String or pseudo-variable containing the detailed type of\n  the IP.\n\n  - IPv4\n    - PUBLIC, PRIVATE, SHARED, LOOPBACK, LINK-LOCAL, RESERVED,\n    TEST-NET, 6TO4-RELAY, MULTICAST, BROADCAST\n\nReturn value:\n\n- *1* - successful operation\n\n- *negative value* - error occurred\n\nThis function can be used from ALL ROUTES\n\n```\n...\n    detailed_ipv4_type(\"192.168.1.2\",\"$var(result)\");\n    xlog(\"L_ERR\",\"IP address is of detailed type: $var(result) \");\n...\n        \n```\n",
   "detailed_ipv6_type": "### `detailed_ipv6_type (ip, result)`\n\nReturns the detailed type of the given IP () (see\nhttp://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.txt,\nhttp://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.txt).\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\n- *result* - String or pseudo-variable containing the detailed type of\n  the IP.\n\n  - IPv6\n    - UNSPECIFIED, LOOPBACK, IPV4MAP, RESERVED, DISCARD,\n    GLOBAL-UNICAST, TEREDO, BMWG, DOCUMENTATION, ORCHID, 6TO4,\n    UNIQUE-LOCAL-UNICAST, LINK-LOCAL-UNICAST, MULTICAST\n\nReturn value:\n\n- *1* - successful operation\n\n- *negative value* - error occurred\n\nThis function can be used from ALL ROUTES\n\n```\n...\n    detailed_ipv6_type(\"2001:8d8:7c0:402:217:72:194:30\",\"$var(result)\");\n    xlog(\"L_ERR\",\"IP address is of detailed type: $var(result) \");\n\n    detailed_ipv6_type(\"[2001:8d8:7c0:402:217:72:194:30]\",\"$var(result)\");\n    xlog(\"L_ERR\",\"IP address is of detailed type: $var(result) \");\n...\n        \n```\n",
   "compare_ips": "### `compare_ips (ip1, ip2)`\n\nReturns TRUE if both IP addresses are the same. FALSE otherwise. This\nfunction also allows comparing an IPv6 address against an IPv6\nreference.\n\nParameters:\n\n- *ip1* - String or pseudo-variable containing the first IP to compare.\n\n- *ip2* - String or pseudo-variable containing the second IP to compare.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (compare_ips(\"1080:0000:0000:0000:0008:0800:200C:417A\", \"[1080::8:800:200C:417A]\")) {\n  xlog(\"L_INFO\", \"both are the same IP\\n\");\n}\n...\n        \n```\n",
   "compare_pure_ips": "### `compare_pure_ips (ip1, ip2)`\n\nReturns TRUE if both IP's are the same. FALSE otherwise. This function\ndoes NOT allow comparing an IPv6 against an IPv6 reference.\n\nParameters:\n\n- *ip1* - String or pseudo-variable containing the first IP address to\n  compare.\n\n- *ip2* - String or pseudo-variable containing the second IP address to\n  compare.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (compare_pure_ips($si, \"1080::8:800:200C:417A\")) {\n  xlog(\"L_INFO\", \"both are the same IP\\n\");\n}\n...\n        \n```\n",
   "is_ip_rfc1918": "### `is_ip_rfc1918 (ip)`\n\nReturns TRUE if the argument is a private IPv4 according to RFC 1918.\nFALSE otherwise.\n\nParameters:\n\n- *ip* - String or pseudo-variable containing the IP to evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (is_ip_rfc1918(\"10.0.123.123\")) {\n  xlog(\"L_INFO\", \"it's a private IPv4\\n\");\n}\n...\n        \n```\n",
   "is_in_subnet": "### `is_in_subnet (ip, subnets_list)`\n\nReturns TRUE if the first argument is an IP address within the (CIDR\nnotation) subnets list in the second argument. FALSE otherwise.\n\nParameters:\n\n- *ip* - string or pseudo-variable containing the ip to evaluate.\n\n- *subnet* - string or pseudo-variable containing the (CIDR notation)\n  subnets list to evaluate.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (is_in_subnet(\"10.0.123.123\", \"10.0.123.1/24\")) {\n  xlog(\"L_INFO\", \"it's in the subnet\\n\");\n}\n...\nif (is_in_subnet(\"10.0.123.123\", \"10.0.0.0/16,192.168.0.0/24\")) {\n  xlog(\"L_INFO\", \"it's in the subnets\\n\");\n}\n...\n        \n```\n",
   "dns_sys_match_ip": "### `dns_sys_match_ip(hostname, ipaddr)`\n\nReturns TRUE if ipaddr is associated by DNS to hostname. FALSE\notherwise. It does not use the internal DNS resolver, but directly\ngetaddrinfo(...). All addresses returned for the hostname are checked.\nNote that some hosts may return different lists of IP addresses for each\nquery, if the DNS server is configured in that way (e.g., for providing\nload balancing through DNS).\n\nParameters:\n\n- *hostname* - string or pseudo-variable containing the hostname. The\n  resulting IP addresses from DNS query are compared with ipaddr.\n\n- *ipaddr* - string or pseudo-variable containing the ip address.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (!dns_sys_match_ip(\"myhost.com\", \"1.2.3.4\")) {\n    xdbg(\"ip address not associated with hostname\\n\");\n}\n...\n        \n```\n",
   "dns_int_match_ip": "### `dns_int_match_ip(hostname, ipaddr)`\n\nReturns TRUE if ipaddr is associated by DNS to hostname. FALSE\notherwise. It uses internal DNS resolver. At this moment, the function\nmight not check all the IP addresses as returned by dns_sys_match_ip(),\nbecause the internal resolver targets to discover the first address to\nbe used for relaying SIP traffic. Thus is better to use\ndns_sys_match_ip() if the host you want to check has many IP addresses,\nin different address families (IPv4/6).\n\nParameters:\n\n- *hostname* - string or pseudo-variable containing the hostname. The\n  resulting IP addresses from DNS query are compared with ipaddr.\n\n- *ipaddr* - string or pseudo-variable containing the ip address.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (!dns_int_match_ip(\"myhost.com\", \"1.2.3.4\")) {\n    xdbg(\"ip address not associated with hostname\\n\");\n}\n...\n        \n```\n",
   "dns_query": "### `dns_query(hostname, pvid)`\n\nStore the IP addresses and their type that correspond to hostname in a\nconfig variable $dns(pvid=>key).\n\nParameters:\n\n- *hostname* - string or pseudo-variable containing the hostname. The\n  resulting IP addresses from DNS query are compared with ipaddr.\n\n- *pvid* - container id for script variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(dns_query(\"test.com\", \"xyz\"))\n{\n    xlog(\" number of addresses: $dns(xyz=>count)\\n\");\n    xlog(\" ipv4 address found: $dns(xyz=>ipv4)\\n\");\n    xlog(\" ipv6 address found: $dns(xyz=>ipv6)\\n\");\n    $var(i) = 0;\n    while($var(i)<$dns(xyz=>count)) {\n        xlog(\" #[$var(i)] type ($dns(xyz=>type[$var(i)]))\"\n             \" addr [$dns(xyz=>addr[$var(i)])]\\n\");\n        $var(i) = $var(i) + 1;\n    }\n}\n...\n        \n```\n",
   "srv_query": "### `srv_query(srvcname, pvid)`\n\nQueries DNS SRV records to resolve a service/protocol name into a list\nof priorities, weights, ports, and targets sorted by priority and weight\nas outlined in [RFC 2782](http://tools.ietf.org/html/rfc2782).\n\nParameters:\n\n- *srvcname* - string or pseudo-variable containing the\n  service/protocol. For example, \"_sip._tcp.example.com\".\n\n- *pvid* - container id for script variable.\n\nOutput:\n\nReturns a positive number indicating success or a negative number when\nan error is encountered. It can be used from ANY_ROUTE.\n\nThe $srvquery pseudo-variable (PV) is loaded with the results of the\nquery. Multiple queries can be stored in the PV using the pvid key. Each\nquery contains zero-indexed arrays sorted by priority and weight that\ncontain:\n\n- *count* - number of records found\n\n- *port [index]* - port number\n\n- *priority [index]* - priority number as defined by [RFC\n  2782](http://tools.ietf.org/html/rfc2782)\n\n- *target [index]* - target host name\n\n- *weight [index]* - weight number as defined by [RFC\n  2782](http://tools.ietf.org/html/rfc2782)\n\n<!-- -->\n\n\n```\n...\nif (srv_query (\"_sip._udp.example.com\", \"udp\") > 0) {\n  $var(cnt) = $srvquery(udp=>count);\n  $var(i) = 0;\n  while ($var(i) < $var(cnt)) {\n    xlog (\"port[$var(i)] $srvquery(udp=>port[$var(i)])\\n\");\n    xlog (\"priority[$var(i)] $srvquery(udp=>priority[$var(i)])\\n\");\n    xlog (\"target[$var(i)] $srvquery(udp=>target[$var(i)])\\n\");\n    xlog (\"weight[$var(i)] $srvquery(udp=>weight[$var(i)])\\n\");\n    $var(i) = $var(i) + 1;\n  }\n}\n...\n        \n```\n",
   "naptr_query": "### `naptr_query(domain, pvid)`\n\nQueries DNS NAPTR records to resolve a domain name into a list of\norders, preferences, flags, services, regex, replaces sorted by orders\nand preferences as outlined in [RFC\n2915](http://tools.ietf.org/html/rfc2915).\n\nParameters:\n\n- *domain* - string or pseudo-variable containing the domain. For\n  example, \"example.com\".\n\n- *pvid* - container id for script variable.\n\nOutput:\n\nReturns a positive number indicating success or a negative number when\nan error is encountered. It can be used from ANY_ROUTE.\n\nThe $naptrquery pseudo-variable (PV) is loaded with the results of the\nquery. Multiple queries can be stored in the PV using the pvid key. Each\nquery contains zero-indexed arrays sorted by order and preference that\ncontain:\n\n- *count* - number of records found\n\n- *order [index]* - order as defined by [RFC\n  2915](http://tools.ietf.org/html/rfc2915)\n\n- *pref [index]* - preference as defined by [RFC\n  2915](http://tools.ietf.org/html/rfc2915)\n\n- *flags [index]* - flags\n\n- *services [index]* - services\n\n- *regex [index]* - regular expression\n\n- *replace [index]* - replace\n\n<!-- -->\n\n\n```\n...\nif (naptr_query (\"example.com\", \"res\") > 0) {\n  $var(cnt) = $naptrquery(res=>count);\n  $var(i) = 0;\n  while ($var(i) < $var(cnt)) {\n    xlog (\"order[$var(i)] $naptrquery(udp=>order[$var(i)])\\n\");\n    xlog (\"pref[$var(i)] $naptrquery(udp=>pref[$var(i)])\\n\");\n    xlog (\"flags[$var(i)] $naptrquery(udp=>flags[$var(i)])\\n\");\n    xlog (\"services[$var(i)] $naptrquery(udp=>services[$var(i)])\\n\");\n    xlog (\"regex[$var(i)] $naptrquery(udp=>regex[$var(i)])\\n\");\n    xlog (\"replace[$var(i)] $naptrquery(udp=>replace[$var(i)])\\n\");\n    $var(i) = $var(i) + 1;\n  }\n}\n...\n        \n```\n",
   "dns_set_local_ttl": "### `dns_set_local_ttl(vttl)`\n\nSet local ttl for DNS query results. If vttl is 0, then the value of the\nresult and the core parameters are used.\n\nParameters:\n\n- *vttl* - TTL value in seconds. It can be static integer or a variable\n  holding an integer value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n  dns_set_local_ttl(\"7200\");\n  dns_query(\"test.com\", \"xyz\")\n  dns_set_local_ttl(\"0\");\n...\n        \n```\n"
  }
 },
 "jansson": {
  "overview": "This module provides operations on JSON strings using JANSSON library.\nIt has support for JSON-PATH operations.\n",
  "parameters": {},
  "functions": {
   "jansson_get": "### `jansson_get(path, src, dst)`\n\nCopy the value at the location 'path' from the json object 'src' and\nstore it in variable 'dst'. The path can also be a simple field name (a\nkey), if it does not include any path separator. To retrieve the value\nof a field that includes path separators in the name, use\njansson_get_field().\n\nThe 'src' can be a static string or a dynamic string with variables.\n\nThe path string supports dot delimited notation (e.g. foo.bar.baz),\narray notation (e.g. [0]), or a combination of the two (e.g.\nfoo.bar[0][1].baz).\n\nReturns FALSE if the data can not be parsed, TRUE otherwise.\n\nThe function can put a string, integer, null, or new json string into\ndestination. If the path can't be found in the JSON data structure, the\npvar is not changed. If it had a previous value, that value remains\nunchanged.\n\n*Note:* For JSON-Integer values exceeding the C-Integer boundaries, a\nString representing the number is returned.\n\n```\n...\nif(!jansson_get(\"inner.deep.list[3]\", \"$var(myjson)\", \"$var(n)\")) {\n    xlog(\"L_ERR\", \"Can't parse json data\");\n}\nxlog(\"L_INFO\", \"foo is $var(n)\");\n...\njansson_get(\"test\", \"{\\\"test\\\":\\\"abc\\\",\\\"idx\\\":20}\", \"$var(n)\")\n...\n        \n```\n",
   "jansson_pv_get": "### `jansson_pv_get(key/path, srcvar, dst)`\n\nSimilar to jansson_get(), but the 'srcvar' parameter can be only a\nvariable name.\n\n```\n...\nif(!jansson_pv_get(\"inner.deep.list[3]\", \"$var(myjson)\", \"$var(n)\")) {\n    xlog(\"L_ERR\", \"Can't parse json data\");\n}\nxlog(\"L_INFO\", \"foo is $var(n)\");\n...\n        \n```\n",
   "jansson_set": "### `jansson_set(type, key/path, value, result)`\n\nInsert 'value' as 'type' at location 'path' into 'result'.\n\nThe path string works the same as in jansson_get.\n\nValid 'type' parameters are 'integer', 'real', 'string', 'object',\n'array', 'true', 'false', and 'null' as well as abbreviated names such\nas 'int', 'str', and 'obj'. 'value' is ignored when type is 'true',\n'false', or 'null'.\n\n*Note:* If you want to insert a JSON-Integer value exceeding the\nC-Integer boundaries (e.g. C-type long), then the number can be provided\nas a string.\n\n```\n...\n# create a new json object and put a string in it at key \"mystr\"\njansson_set(\"string\", \"mystr\", \"my input string\", \"$var(myjson)\");\n# $var(myjson) =='{\"mystr\":\"my input string\"}'\n\n# add other values\njansson_set(\"integer\", \"count\", 9000, \"$var(myjson)\");\njansson_set(\"true\", \"mybool\", 0, \"$var(myjson)\");\njansson_set(\"real\", \"pi\", \"3.14159\", \"$var(myjson)\");\n# $var(myjson) == '{\"mystr\":\"my input string\", \"count\":9000, \"mybool\":true, \"pi\":3.14159}'\n\n# add a nested object\njansson_set(\"obj\", \"myobj\", '{\"foo\":\"bar\"}', \"$var(myjson)\");\n# $var(myjson) =='{\"mystr\":\"my input string\", \"count\":9000, \"mybool\":true, \"pi\":3.14159, \"myobj\":{\"foo\":\"bar\"}}'\n\n# change the nested object\njansson_set(\"str\", \"myobj.foo\", \"baz\", \"$var(myjson)\");\n# $var(myjson) == '{\"mystr\":\"my input string\", \"count\":9000, \"mybool\":true, \"pi\":3.14159, \"myobj\":{\"foo\":\"baz\"}}'\n...\n        \n```\n",
   "jansson_append": "### `jansson_append(type, key/path, value, result)`\n\nLike jansson_set but can be used to append to arrays. It can also be\nused to combine two json objects.\n\nNote that when appending a json object to another json object, if there\nis a key that is shared between the two objects, that value will be\noverwritten by the new object.\n\n```\n...\n# create a new json array and append values to it\n$var(myarray) = '[]';\njansson_append(\"int\", \"\", 0, \"$var(myarray)\");\njansson_append(\"int\", \"\", 1, \"$var(myarray)\");\njansson_append(\"int\", \"\", 2, \"$var(myarray)\");\njansson_append(\"int\", \"\", 3, \"$var(myarray)\");\njansson_append(\"int\", \"\", 4, \"$var(myarray)\");\n# $var(myarray) == '[0,1,2,3,4]'\n\n# add that array to an object\njansson_set(\"array\", \"list\", $var(myarray), \"$var(myjson)\");\n# $var(myjson) == '{\"list\":[0,1,2,3,4]}'\n\n# append another value to the list\njansson_append(\"int\", \"list\", 5, \"$var(myjson)\");\n# $var(myjson) == '{\"list\":[0,1,2,3,4,5]}'\n\n# combining two json objects\n$var(newobj) = '{\"b\":2, \"c\":3}';\njansson_append('obj', \"\", '{\"a\":1, \"b\":100}', \"$var(newobj)\");\n# $var(newobj) == '{\"a\":1,\"b\":100\",\"c\":3}';\n...\n        \n```\n",
   "jansson_array_size": "### `jansson_array_size(key/path, src, dst)`\n\nPuts the size of the array in 'src' at location 'path' into the pvar\n'dst'.\n\nThis is particularly useful for looping through an array. See example.\n\n```\n...\n$var(array) = \"{\\\"loopme\\\":[0,1,2,3,4,5]}\";\n$var(count) = 0;\njansson_array_size(\"loopme\", $var(array), \"$var(size)\");\nwhile($var(count) < $var(size)) {\n    jansson_get(\"loopme[$var(count)]\", $var(array), \"$var(v)\");\n    xlog(\"loopme[$var(count)] == $var(v)\\n\");\n    $var(count) = $var(count) + 1;\n}\n...\n        \n\n...\n$var(count) = 0;\n$var(appendme) = '[0,1]';\n$var(mylist) = '[2,3,4,5]';\njansson_array_size(\"\", $var(mylist), \"$var(appendme_size)\");\nwhile($var(count) < $var(appendme_size)) {\n    jansson_get(\"[$var(count)]\", $var(mylist), \"$var(tmp)\");\n    jansson_append('int', \"\", $var(tmp), \"$var(appendme)\");\n    $var(count) = $var(count) + 1;\n}\n...\n        \n```\n",
   "jansson_xdecode": "### `jansson_xdecode(json, xavp)`\n\nParse a JSON string in 'json' and store the elements in xapv 'xavp'.\nTop-level JSON must be an object or an array of objects. Nested arrays\nand objects are not decoded but stored as string.\n\n```\n...\njansson_xdecode('{\"foo\":\"bar\"}', \"js\");\nxlog(\"foo is $xavp(js=>foo)\");\n...\n        \n```\n",
   "jansson_xencode": "### `jansson_xencode(xavp, pv)`\n\nEncode the items in the xavp 'xavp' as JSON and store the result in a\npv. Nested xavp's are not supported.\n\n```\n...\n$xavp(a=>foo) = \"bar\";\njansson_xencode(\"a\", \"$var(js)\");\n# $var(js) = '{\"foo\":\"bar\"}'\n...\n        \n```\n",
   "jansson_get_field": "### `jansson_get_field(field_name, src, dst)`\n\nCopy the value of the field 'field_name' from json object 'src' and\nstore it in pvar 'dst'. The field name is not evaluated as JSON path,\ntherefore it has a different behaviour than jansson_get() and can be\nused when the field name contains path delimiters.\n\nNote that till version 5.7.x, this function was similar to\njansson_get(), after that its behaviour changed to work as described\nabove. Also, the order of parameters changed.\n\n```\n...\njansson_get_field(\"foo\", \"{'foo':'bar'}\", \"$var(foo)\");\nxlog(\"foo is $var(foo)\");\njansson_get_field(\"foo.foz\", \"{'foo.foz':'bar.buz'}\", \"$var(foofoz)\");\nxlog(\"foo.foz is $var(foofoz)\");\n...\n        \n```\n"
  }
 },
 "janssonrpcc": {
  "overview": "This module provides access to JSON-RPC 2.0 services (operating over\nTCP/Netstrings) in accordance with http://www.jsonrpc.org/specification.\nIt uses JANSSON library for JSON document management.\n\nIt uses t_suspend() and t_continue() from the TM module for asynchronous\nprocessing.\n\nNote that after invoking an asynchronous operation, the processing will\ncontinue later, in another application process. Therefore, do not rely\non variables stored in private memory, use shared memory if you want to\nget values after the processing is resumed (e.g., $shv(...) or htable\n$sht(...)).\n",
  "parameters": {
   "min_srv_ttl": "### `min_srv_ttl` (integer)\n\nThe minimum acceptable TTL in seconds for SRV DNS entries. This means\nthat TTLs from the DNS will be ignored if they are lower than this\nvalue. It cannot be set lower than 1 second.\n\n*Default is 5 seconds.*\n\n```\n...\nmodparam(\"janssonrpcc\", \"min_srv_ttl\", 30)\n...\n            \n```\n\nThis will set any SRV TTL lower than 30 seconds to 30 seconds.\n",
   "result_pv": "### `result_pv` (string)\n\nThe PV spec where to store the result of a call to janssonrpc_request().\nIt can be any writable PV.\n\n*Default value is \u201c$var(jsrpc_result)\u201d.*\n\n```\n...\nmodparam(\"janssonrpcc\", \"result_pv\", \"$var(result)\")\n...\n            \n```\n",
   "server": "### `server` (string)\n\nThe server providing the remote jsonrpc service. Format can be\n\"conn=example;addr=localhost;port=9999;priority=10;weight=20\" or\n\"conn=bar;srv=_sip._tcp.example.net\".\n\n- conn\n  - name for a collection of servers (required).\n- srv\n  - DNS SRV domain name (optional).\n- addr\n  - host address (required, except when using srv).\n- port\n  - host port (required, except when using srv).\n- priority\n  - server are grouped by priority. Servers with higher priority (lower\n  number) are used first. Default is 0. (optional when using addr,\n  invalid otherwise).\n- weight\n  - functions the same as a DNS SRV weight. Requests are distributed\n  between servers of the same priority proportional to their weight.\n  Default is 1. (optional when using addr, invalid otherwise).\n\n<!-- -->\n\n\n```\n...\nmodparam(\"janssonrpcc\", \"server\", \"conn=tests;srv=_test1._tcp.example.net\");\nmodparam(\"janssonrpcc\", \"server\", \"conn=tests;srv=_test2._tcp.example.net\");\nmodparam(\"janssonrpcc\", \"server\", \"conn=local;addr=localhost;port=8080;priority=10;weight=10\");\nmodparam(\"janssonrpcc\", \"server\", \"conn=user_db;addr=rpc.prod.example.net;port=5060;priority=10;weight=10\");\n...\n                \n```\n",
   "retry_codes": "### `retry_codes` (string)\n\nA comma delimited list of error codes or error code ranges to\nautomatically schedule a request retry if received.\n\nThis will only be used if there is no route specified for the request.\n\nAn error code can be any integer, but is typically a negative number.\n\nAn error code range is delimited by \"*..*\" . For example,\n\"-32099..-32000\".\n\nSpaces are ignored.\n\n```\n...\nmodparam(\"janssonrpcc\", \"retry_codes\", \"-32603, -32000..-32099\");\n...\n                \n```\n",
   "keep_alive": "### `keep_alive` (integer)\n\nnumber of seconds to send a tcp keep-alive to the server connection\n\nDefault is 0 (disabled)\n\n```\n...\nmodparam(\"janssonrpcc\", \"keep_alive\", 10)\n...\n                \n```\n"
  },
  "functions": {
   "janssonrpc_notification": "### `janssonrpc_notification(conn, method, parameters)`\n\n- conn\n  - name for a collection of servers (required)\n- method\n  - jsonrpc method (required)\n- params\n  - jsonrpc request params (required) Use $null or empty string to not\n  send any parameters in the jsonrpc notification.\n\nUnlike janssonrpc_request (below), notifications do not receive a\nresponse. Script processing continues in the usual fashion as soon as\nthe notification has been sent.\n\nIf no servers can be reached, a message is sent to the logs.\n\nThe 'method' and 'params' can be a static string or dynamic string value\nwith config variables.\n\n```\n...\njanssonrpc_notification(\"user_db\", \"update_user\", '{\"id\": 1234, \"name\": \"Daniel\"}');\n...\n                \n```\n",
   "janssonrpc_request": "### `janssonrpc_request(conn, method, params[, options]])`\n\nThe conn, method, params, and options can be a static string or a\ndynamic string value with config variables.\n\n- conn\n  - name for a collection of servers (required)\n\n- method\n  - jsonrpc method (required)\n\n- params\n  - jsonrpc request params (required) Use $null or empty string to not\n  send any parameters in the jsonrpc request.\n\n- *options*\n\n  Options for the janssonrpc_request function. Format can be\n  \"route=RESPONSE;retry=2;timeout=100\". All these parameters are\n  optional.\n\n  - retry\n    - number of times you retry a failed request. -1 means retry\n    forever. Default is 0. Request will be retried if they either\n    timeout or fail to send. Retries utilize exponential back off\n    between successive retries, up to 60 seconds. The equation for time\n    between retries is:\n    time = n^2 * timeout (for time < 60 seconds)\n\n    where n is the number of times a request has been tried.\n\n  - timeout\n    - request timeout in milliseconds. Default is 500.\n\n  - route\n    - resume script execution at this route.\n\nWhen a response is received, processing continues for the SIP request in\nthe route specified.\n\nIf no route is specified, then any errors are logged and successes are\nignored. The function will also not interrupt script execution.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution is lost. Only shared variables ($shv, $avp, etc) should\nbe used for any value that will be needed when the script is resumed.\n\nThe result is stored in the pseudo-variable specified in the module\nparameter 'result_pv'. This pseudo-variable is set *after* the response\nis received.\n\n```\n...\njanssonrpc_request(\"user_db\", \"get_user\", '{\"id\": 1234}', \"route=RESPONSE;retry=1\");\n    ...\n\nroute[RESPONSE] {\n    xlog(\"Result received: $var(result)\");\n    ...\n}\n...\n                \n```\n"
  }
 },
 "json": {
  "overview": "This is a simple module allowing to retrieve values from a JSON string.\n\nFor more complex operations with JSON documents, see the JANSSON module.\n",
  "parameters": {},
  "functions": {
   "json_get_field": "### `json_get_field(json_string, field_name, destination)`\n\nCopy field 'field_name' from json object 'json_string' and store it in\npvar 'destination'.\n\nNote that the result is the string representation of that JSON filed.\nFor example, if you want to retrieve a field that has a string value,\nthen the result is the value enclosed in quotes. If the field value is a\nstructure, then the result is the string-formatted representation of\nthat structure.\n\n```\n...\njson_get_field(\"{'foo':'bar'}\", \"foo\", \"$var(foo)\");\nxlog(\"foo is $var(foo)\");\n...\n        \n```\n",
   "json_get_string": "### `json_get_string(json_string, field_name, destination)`\n\nCopy field 'field_name' from json object 'json_string' and store it in\npvar 'destination'.\n\n```\n...\njson_get_string(\"{'foo':'bar'}\", \"foo\", \"$var(foo)\");\nxlog(\"foo is $var(foo)\");\n...\n        \n```\n"
  }
 },
 "jsonrpcc": {
  "overview": "This module provides access to json-rpc services (operating over\nTCP/Netstrings).\n\nThis module uses t_suspend() and t_continue() from the TM module.\n\nNote that after invoking an asynchronous operation, the processing will\ncontinue later, in another application process. Therefore, do not rely\non variables stored in private memory, use shared memory if you want to\nget values after the processing is resumed (e.g., $shv(...) or htable\n$sht(...)).\n",
  "parameters": {
   "servers": "### `servers` (string)\n\nThe servers providing the remote jsonrpc service. Format is\n\"host1:port1,priority1 host2:port2,priority2\". Requests to servers of\nthe same priority will be distributed evenly (round robin). Server\ngroups with higher priority are used first.\n\n```\n...\nmodparam(\"jsonrpcc\", \"servers\", \"localhost:9999,2 10.10.0.1:9999,2 backup.server:9999,1\")\n...\n                \n```\n",
   "max_conn_attempts": "### `max_conn_attempts` (int)\n\nMax number of connection attempts for a server. -1 will keep\nreconnecting forever, 0 will skip any attempt to reconnect.\n\n```\n...\nmodparam(\"jsonrpcc\", \"max_conn_attempts\", 10)\n...\n                \n```\n"
  },
  "functions": {
   "jsonrpc_notification": "### `jsonrpc_notification(method, parameters)`\n\nInvokes the remote 'method' with the given 'parameters' as a\nnotification. Unlike jsonrpc_request (below), notifications do not\nreceive a response. Script processing continues in the usual fashion as\nsoon as the notification has been sent.\n\nThe method and parameters can be a static string or dynamic string value\nwith config variables.\n\n```\n...\njsonrpc_notification(\"update_user\", \"{'id': 1234, 'name': 'Petros'}\")\n...\n                \n```\n",
   "jsonrpc_request": "### `jsonrpc_request(method, parameters, return_route, error_route, result_var)`\n\nInvokes the remote 'method' with the given 'parameters'. When the\nresponse is received, continues processing of the SIP request with the\nroute[return_route]. If a timeout occurs, no servers can be reached,\nor a jsonrpc error message is received, continues process at\nroute[error_route]. In this case, the result_var will contain one of\n\"timeout\", \"failure\", or the error message received back from the\njsonrpc server.\n\nThe method, parameters, return_route, and error_route can be a static\nstring or a dynamic string value with config variables.\n\nSince the SIP request handling is resumed in another process, the config\nfile execution is lost. As mentioned above, only shared variables\n($shv, etc) should be used for any value that will be needed when the\nscript is resumed.\n\nThe result is stored in the pseudo-variable 'result_var'. Since this\nvariable is set *after* the response is received, it is possible to use\na $var for this parameter.\n\n```\n...\njsonrpc_request(\"get_user\", \"{'id': 1234}\", \"RESPONSE\", \"ERROR\", \"$var(result)\");\n...\nroute[RESPONSE] {\n    xlog(\"Result received: $var(result)\");\n    ...\n}\n...\nroute[ERROR] {\n    xlog(\"Error received: $var(result)\");\n    ...\n}\n...\n                \n```\n"
  }
 },
 "jsonrpcs": {
  "overview": "This module provides a JSON-RPC v2 server, tailored for the needs of\nKamailio. It implements the Kamailio RPC interface over JSON-RPC.\n\nThe specification for JSON-RPC is available at:\n<http://www.jsonrpc.org/specification>.\n\nThe transports supported by the module are: FIFO file, datagram (UDP)\nover unix socket files or network sockets, HTTP and HTTPS.\n\nThe JSONRPCS module requires the xHTTP module to handle HTTP/S requests.\nRead the documentation of the xHTTP module for more details.\n",
  "parameters": {
   "pretty_format": "### `pretty_format` (int)\n\nPretty format for JSON-RPC response document if set to 1. To disable,\nset to 0.\n\n*Default value is '1' (on).*\n\n```\n...\nmodparam(\"jsonrpcs\", \"pretty_format\", 0)\n...\n```\n",
   "transport": "### `transport` (int)\n\nControl what transports are enabled. The value can be:\n\n- *0* - all transports that can be enabled. For http, the xhttp module\n  must be loaded. For FIFO, the fifo_name parameter must be set. For\n  DATAGRAM, the dgram_socket parameter must be set. For TCP, the\n  tcp_socket parameter must be set.\n\n- *1* - only HTTP transport\n\n- *2* - only FIFO transport\n\n- *4* - only DATAGRAM transport\n\n- *8* - only TCP transport\n\nThe value can be also a combination of specific transports. Make the sum\nof the desired transports to enable them. For example, enabling FIFO and\nDATAGRAM can be done setting transport=6.\n\n*Default value is '6' (fifo and datagram transport).*\n\n```\n...\nmodparam(\"jsonrpcs\", \"transport\", 1)\n...\n```\n",
   "fifo_name": "### `fifo_name` (str)\n\nThe name of the FIFO file to be created for listening and reading\nexternal commands. If the given path is not absolute, the fifo file is\ncreated relative to run_dir (global parameter).\n\n*Default value is \"kamailio_rpc.fifo\".*\n\n```\n...\nmodparam(\"jsonrpcs\", \"fifo_name\", \"/tmp/kamailio_jsonrpc.fifo\")\n...\n```\n",
   "fifo_mode": "### `fifo_mode` (int)\n\nPermission to be used for creating the listening FIFO file. It follows\nthe UNIX conventions.\n\n*Default value is 0660 (rw-rw----).*\n\n```\n...\nmodparam(\"jsonrpcs\", \"fifo_mode\", 0600)\n...\n```\n",
   "fifo_group": "### `fifo_group` (int or str)\n\nSystem Group to be used for creating the listening FIFO file.\n\n*Default value is the inherited one (process group).*\n\n```\n...\nmodparam(\"jsonrpcs\", \"fifo_group\", 0)\nmodparam(\"jsonrpcs\", \"fifo_group\", \"root\")\n...\n```\n",
   "fifo_user": "### `fifo_user` (int or str)\n\nSystem User to be used for creating the listening FIFO file.\n\n*Default value is the inherited one (process user).*\n\n```\n...\nmodparam(\"jsonrpcs\", \"fifo_user\", 0)\nmodparam(\"jsonrpcs\", \"fifo_user\", \"root\")\n...\n```\n",
   "fifo_reply_dir": "### `fifo_reply_dir` (str)\n\nDirectory to be used for creating the reply FIFO files.\n\n*Default value is \u201c/tmp/\u201d*\n\n```\n...\nmodparam(\"jsonrpcs\", \"fifo_reply_dir\", \"/home/kamailio/tmp/\")\n...\n```\n",
   "dgram_socket": "### `dgram_socket` (str)\n\nThe name of a Unix socket file or an IP address. The Unix datagram or\nUDP socket will be created using this parameter in order to read the\nexternal commands. Both IPv4 and IPv6 are supported. If the given path\nfor Unix socket is not absolute, then it is created relative to run_dir\n(global parameter).\n\n*Default value is \"kamailio_rpc.sock\".*\n\n```\n...\nmodparam(\"jsonrpcs\", \"dgram_socket\", \"/tmp/kamailio_rpc.sock\")\n...\nmodparam(\"jsonrpcs\", \"dgram_socket\", \"udp:1.2.3.4:8090\")\n...\n```\n",
   "dgram_workers": "### `dgram_workers` (str)\n\nThe number of worker processes to be created. Each worker process will\nbe a datagram server.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"jsonrpcs\", \"dgram_workers\", 4)\n...\n```\n",
   "dgram_mode": "### `dgram_mode` (int)\n\nPermission to be used for creating the listening UNIX datagram socket.\nNot necessary for a UDP socket. It follows the UNIX conventions.\n\n*Default value is 0660 (rw-rw----).*\n\n```\n...\nmodparam(\"jsonrpcs\", \"dgram_mode\", 0600)\n...\n```\n",
   "dgram_group": "### `dgram_group` (int) `dgram_group` (str)\n\nGroup to be used for creating the listening UNIX socket.\n\n*Default value is the inherited one.*\n\n```\n...\nmodparam(\"jsonrpcs\", \"dgram_group\", 0)\nmodparam(\"jsonrpcs\", \"dgram_group\", \"root\")\n...\n```\n",
   "dgram_user": "### `dgram_user` (int) `dgram_group` (str)\n\nUser to be used for creating the listening UNIX socket.\n\n*Default value is the inherited one.*\n\n```\n...\nmodparam(\"jsonrpcs\", \"dgram_user\", 0)\nmodparam(\"jsonrpcs\", \"dgram_user\", \"root\")\n...\n```\n",
   "dgram_timeout": "### `dgram_timeout` (int)\n\nThe reply will expire after trying to send it for socket_timeout\nmilliseconds.\n\n*Default value is 2000.*\n\n```\n...\nmodparam(\"jsonrpcs\", \"dgram_timeout\", 2000)\n...\n```\n",
   "tcp_socket": "### `tcp_socket` (str)\n\nThe name of tcp socket to listen on for RPC commands. Only IPv4/IPv6\nsockets are supported, unix file stream socket not yet.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"jsonrpcs\", \"tcp_socket\", \"tcp:1.2.3.4:5042\")\n...\n```\n"
  },
  "functions": {
   "jsonrpc_dispatch": "### `jsonrpc_dispatch()`\n\nHandle the JSONRPC request and generate a response.\n\n```\n...\n#!KAMAILIO\n\nmemdbg=5\nmemlog=5\n\ndebug=3\nlog_stderror=yes\n\nfork=yes\nchildren=2\n\ntcp_accept_no_cl=yes\n\nloadmodule \"sl.so\"\nloadmodule \"pv.so\"\nloadmodule \"xhttp.so\"\nloadmodule \"jsonrpcs.so\"\n\nmodparam(\"jsonrpcs\", \"transport\", 1)\n\nrequest_route {\n    send_reply(\"404\", \"not found\");\n    exit;\n}\n\nevent_route[xhttp:request] {\n    if(src_ip!=127.0.0.1) {\n        xhttp_reply(\"403\", \"Forbidden\", \"text/html\",\n            \"<html><body>Not allowed from $si</body></html>\");\n        exit;\n    }\n    if ($hu =~ \"^/RPC\") {\n        jsonrpc_dispatch();\n    } else {\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n            \"<html><body>Wrong URL $hu</body></html>\");\n    }\n    return;\n}\n...\n```\n",
   "jsonrpc_exec": "### `jsonrpc_exec(cmd)`\n\nExecute a JSON-RPC command given as a parameter.\n\nThe parameter has to be a valid full JSON-RPC document. It can be a\ndynamic string with variables. The result of the command can be accessed\nvia $jsonrpl(key) pseudo variables.\n\n```\n...\njsonrpc_exec('{\"jsonrpc\": \"2.0\", \"method\": \"dispatcher.reload\", \"id\": 1}');\nxlog(\"jsonrpc response code: $jsonrpl(code) - the body is: $jsonrpl(body)\\n\");\n...\n```\n"
  }
 },
 "jwt": {
  "overview": "This module provides JWT (JSON Web Token) functions to be used in\nKamailio configuration file.\n\nIt relies on libjwt (at least v1.12.0) library\n(https://github.com/benmcollins/libjwt).\n",
  "parameters": {
   "key_mode": "### `key_mode` (int)\n\nMode to use the private and public keys. If set to 0, they are read\nalways from the disk. If set to 1, they are cached in memory with the\nfirst use (no reload support yet).\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"jwt\", \"key_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "jwt_generate": "### `jwt_generate(prvkey, alg, claims[, headers])`\n\nGenerate the JWT, its value can be retrieved in the variable $jwt(val).\n\nThe parameters are:\n\n- prvkey - path to private key\n\n- alg - the algorithm to build the signature, as supported by the libjwt\n  (e.g., RS256, HS256, ES256, ...)\n\n- claims - the list of claims to be added to JWT, in the format\n  \"name1=value1;name2=value2;...\" (same as the SIP parameters format).\n  The string values can be enclosed in single or double quotes. If a\n  value is not eclosed in between quotes, it is added as numeric value\n  if it is successfully converted to a long value, otherwise is added as\n  string value.\n\n- headers - the list of headers to be added to JWT, in the format\n  \"name1=value1;name2=value2;...\" (same as the SIP parameters format).\n  The string values can be enclosed in single or double quotes. If a\n  value is not eclosed in between quotes, it is added as numeric value\n  if it is successfully converted to a long value, otherwise is added as\n  string value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n  jwt_generate(\"/path/to/prvkey.pem\", \"RS256\",\n        \"caller='$fU';callee='$tU';callid='$ci';index=100\");\n...\n```\n",
   "jwt_verify": "### `jwt_verify(pubkeypath, alg, claims, jwtval)`\n\nVerify the JWT.\n\nThe parameters are:\n\n- pubkeypath - path to public key file\n\n- alg - the algorithm to build the signature, as supported by the libjwt\n  (e.g., RS256, HS256, ES256, ...)\n\n- claims - the list of claims to be checked they are in the JWT, in the\n  format \"name1=value1;name2=value2;...\" (same as the SIP parameters\n  format, see also the description of claims parameter for\n  jwt_generate()).\n\n- jwtval - the value of the JWT to verify\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n  if(!jwt_verify(\"/path/to/pubkey.pem\", \"RS256\",\n         \"caller='$fU';callee='$tU';callid='$ci';index=100\",\n        \"$var(jwt)\") {\n    xwarn(\"failed to verify jwt\\n\");\n  }\n...\n```\n",
   "jwt_verify_key": "### `jwt_verify_key(pubkeyval, alg, claims, jwtval)`\n\nVerify the JWT.\n\nThe parameters are:\n\n- pubkeyval - public key value\n\n- alg - the algorithm to build the signature, as supported by the libjwt\n  (e.g., RS256, HS256, ES256, ...)\n\n- claims - the list of claims to be checked they are in the JWT, in the\n  format \"name1=value1;name2=value2;...\" (same as the SIP parameters\n  format, see also the description of claims parameter for\n  jwt_generate()).\n\n- jwtval - the value of the JWT to verify\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n  if(!jwt_verify_key(\"...\", \"RS256\",\n         \"caller='$fU';callee='$tU';callid='$ci';index=100\",\n        \"$var(jwt)\") {\n    xwarn(\"failed to verify jwt\\n\");\n  }\n...\n```\n"
  }
 },
 "kafka": {
  "overview": "This module produces and sends messages to a Kafka server.\n",
  "parameters": {},
  "functions": {}
 },
 "kazoo": {
  "overview": "The Kazoo is a general purpose AMQP connector (tested with\nrabbitmq-server). It exposes publish/consume capabilities into Kamailio.\n\nFrom a high-level, the purpose of the module might be for things like:\n\n- Integrate to an AMQP application to make real-time routing decisions\n  (instead of using, say, a SQL database)\n\n- Provide a real-time integration into your program, instead of your\n  database, so you can overlay additional logic in your preferred\n  language while also utilizing a message bus\n\n- Utilize messaging to have a distributed messaging layer, such that\n  machines processing requests/responses/events can go up/down or share\n  the workload and your Kamailio node will still be happy\n\nsupported operations are:\n\n- publish json payloads to rabbitmq\n\n- publish json payloads to rabbitmq and wait for correlated response\n  message\n\n- subscribe to an exchange with a routing key\n\nThe Kazoo module also has support to publish updates to presence module\nthru the kazoo_pua_publish function\n",
  "parameters": {
   "amqp": "### amqp related\n",
   "execution": "### execution control\n\nexecution control of main loop can be controlled by changing the\nparameter values in this section.\n\nThe main loop has 3 sub-loops were it listen for actions to execute with\na timeout. These group of parameters allow to set the maximum number of\ntimes the sub-loop is executed if it doesn't timeout.\n\nOn busy systems, we may have a condition where a sub-loop never times\nout because it always has data to process. The purpose of these\nparameters is to set a maximum number of times it executes before it\nhandles control to the next sub-loop.\n\n```\n...\nwhile(true) // main  loop\nwhile(ACK or timeout)  // acknowledge from worker process\nwhile(SEND or timeout) // anything to send ?\nwhile(CONSUME or timeout) // any data on consumed exchanges ?\n...\n```\n",
   "timers": "### timers\n\neach functional parameter related to timers come with 2 reflected\nparameters. name_sec and name_micro\n",
   "presence": "### presence related\n"
  },
  "functions": {
   "amqp": "### amqp related\n",
   "presence": "### presence related\n",
   "other": "### other\n"
  }
 },
 "keepalive": {
  "overview": "This module performs destinations monitoring either for itself, or on\nthe behalf of other modules. The monitoring is done by sending SIP\nOPTIONS requests, more or less in the same fashion as the dispatcher\nmodule (which was the initial source for this module).\n\nAs an example of usage by other modules, see *drouting*, which was\nenhanced to use this module to monitor its gateways.\n",
  "parameters": {},
  "functions": {}
 },
 "kemix": {
  "overview": "This module collects extensions and functions to be used with KEMI SIP\nrouting scripting. The target is to implement alternatives to specific\nconcepts designed for the native scripting language (e.g., core keywords\nand core conditions) without pushing code in the core of the\napplication.\n\nIt does not provide functions for the native Kamailio.cfg.\n\nTo see the KEMI functions exported by this module, see:\n\n- <https://kamailio.org/docs/tutorials/devel/kamailio-kemi-framework/>\n",
  "parameters": {},
  "functions": {}
 },
 "kex": {
  "overview": "This module collects extensions from Kamailio core.\n\nKamailio Core Cookbook is available at:\n<https://www.kamailio.org/wikidocs/>\n",
  "parameters": {},
  "functions": {
   "setsflag": "### `setsflag(flag)`\n\nSet the script flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the script flag to be set. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsetsflag(\"1\");\n...\n$var(flag) = 11;\nsetsflag(\"$var(flag)\");\n...\n```\n",
   "issflagset": "### `issflagset(flag)`\n\nReturn true if the script flag is set.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the script flag to be tested. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(issflagset(\"1\"))\n{\n    ...\n}\n...\n```\n",
   "resetsflag": "### `resetsflag(flag)`\n\nReset the script flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the script flag to be reset. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nresetsflag(\"1\");\n...\n```\n",
   "setbflag": "### `setbflag(flag [, branch])`\n\nSet the branch flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the branch flag to be set. Can be integer or\n  pseudo-variable with integer value.\n\n- *branch* - the index of the branch whose flag to be set. Can be\n  integer or pseudo-variable with integer value. If omitted, then branch\n  0 is used (R-URI).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsetbflag(\"1\");\n...\n$var(flag) = 11;\nsetbflag(\"$var(flag)\", \"1\");\n...\n```\n",
   "isbflagset": "### `isbflagset(flag [, branch])`\n\nReturn true if the branch flag is set.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the branch flag to be tested. Can be integer or\n  pseudo-variable with integer value.\n\n- *branch* - the index of the branch whose flag to be set. Can be\n  integer or pseudo-variable with integer value. If omitted, then branch\n  0 is used (R-URI).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(isbflagset(\"1\"))\n{\n    ...\n}\n...\n```\n",
   "resetbflag": "### `resetbflag(flag [, branch])`\n\nReset the branch flag.\n\nMeaning of the parameters is as follows:\n\n- *flag* - the index of the branch flag to be reset. Can be integer or\n  pseudo-variable with integer value.\n\n- *branch* - the index of the branch whose flag to be set. Can be\n  integer or pseudo-variable with integer value. If omitted, then branch\n  0 is used (R-URI).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nresetbflag(\"1\");\n...\n```\n",
   "setdsturi": "### `setdsturi(uri)`\n\nSet the destination address URI (outbound proxy address).\n\nMeaning of the parameters is as follows:\n\n- *uri* - Valid SIP URI representing the address where to send the\n  request. It must be a static string, no variables are evaluated at\n  runtime. If you need to set outbound proxy address via a variable, use\n  assignment to *$du*.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsetdsturi(\"sip:10.0.0.10\");\n...\n```\n",
   "resetdsturi": "### `resetdsturi()`\n\nReset the destination address URI (outbound proxy address).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nresetdsturi();\n...\n```\n",
   "isdsturiset": "### `isdsturiset()`\n\nCheck if the destination address URI (outbound proxy address) is set.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(isdsturiset())\n{\n   ...\n}\n...\n```\n",
   "pv_printf": "### `pv_printf(var, str)`\n\nEvaluates the str and sets the resulting value to variable var. For\nbackward compatibility reasons, the same function can be executed via\n'avp_printf(var, str)'.\n\nMeaning of the parameters is as follows:\n\n- *var* - name of a writable variable\n\n- *str* - string that may contain variables which will be evaluated at\n  runtime.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npv_printf(\"$ru\", \"sip:$rU@$fd\");\npv_printf(\"$avp(x)\", \"From: $fU - To: $tU\");\n...\n```\n",
   "is_myself": "### `is_myself(uri)`\n\nCheck if the parameter matches the 'myself' condition (i.e., is a local\nIP or domain). Note that if the port is missing in the URI, then no port\nmatching is done (in other words, port matching is skipped -- it does\nnot use default SIP ports 5060 or 5061 for matching).\n\nMeaning of the parameters is as follows:\n\n- *uri* - Valid SIP URI or IP address to check against the list of local\n  IP addresses or domains, matching as well the port and protocol if\n  they are provided. The parameter value can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(is_myself(\"$fu\")) {\n    ...\n}\n...\n```\n",
   "is_myhost": "### `is_myhost(uri)`\n\nCheck if the host part of the parameter matches a local domain or IP\naddress.\n\nMeaning of the parameters is as follows:\n\n- *uri* - Valid SIP URI, hostname of IP address to check against the\n  list of local IP addresses or domains. If it is a SIP URI, the port\n  and protocol are ignored. The parameter value can contain\n  pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(is_myhost(\"$tu\")) {\n    ...\n}\n...\n```\n",
   "setdebug": "### `setdebug(level)`\n\nSet the debug log level per process.\n\nMeaning of the parameters is as follows:\n\n- *level* - the debug log level to be set. Can be integer or\n  pseudo-variable with integer value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsetdebug(\"1\");\n...\n$var(level) = 2;\nsetdebug(\"$var(level)\");\n...\n```\n",
   "resetdebug": "### `resetdebug()`\n\nReset the local debug log level back to the value of core parameter\n'debug'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nresetdebug();\n...\n```\n",
   "km_append_branch": "### `km_append_branch([uri])`\n\nThis function was replaced by append_branch() from corex module,\nstarting with version 4.0.0.\n"
  }
 },
 "lcr": {
  "overview": "The Least Cost Routing (LCR) module implements capability to serially\nforward a request to one or more gateways so that the order in which the\ngateways is tried is based on admin defined \"least cost\" rules.\n\nThe LCR module supports many independent LCR instances (gateways and\nleast cost rules). Each such instance has its own *LCR instance\nidentifier*. Identifiers of normal LCR instances are positive integers.\nGateways may belong to special LCR instance with identifier 0 meaning\nthat such gateways belong to all normal LCR instances.\n\nFor the purpose of facilitating least cost routing of requests, each\ngateway of an LCR instance is associated with one or more <prefix, from\nuri pattern, from uri userpart, request uri pattern, priority, weight>\ntuples. A gateway matches a request if user part of Request-URI matches\n\"prefix\", caller URI matches \"from_uri\" pattern, caller URI userpart\nmatches mtree with \"mt_value\", and callee URI matches \"request_uri\"\npattern in a tuple that is associated with the gateway.\n\nWhen the function *load_gws()* is called, matching gateways (that are\nnot currently designated as defunct) are ordered for forwarding purposes\nas follows:\n\n1. according to longest Request-URI user part match\n\n2. according to tuple's priority\n\n3. according to tuple's randomized weight\n\nor, if priority_ordering parameter is set to value 1, as follows:\n\n1. according to tuple's priority\n\n2. according to tuple's randomized weight\n\nA tuple can be marked as a \"stopper\" tuple. If a \"stopper\" tuple\nmatches, then matching stops at it and all other tuples with shorter\nprefixes are not considered.\n\nPrefix is a string of characters or NULL. From-URI pattern and\nRequest-URI pattern are regular expressions (see 'man pcresyntax' for\nsyntax), an empty string, or NULL. An empty or NULL From-URI pattern,\nRequest-URI pattern or prefix matches anything. Smaller priority value\nmeans higher priority (highest priority value being 0 and lowest being\n255).\n\nWeight is an integer value from 1 to 254. Weight implementation is fast,\nbut unfair favoring larger weight values at the expense smaller ones.\nFor example, if two gateways have weights 1 and 2, probability that the\ngateway with weight 1 is tried first is 1/4, not 1/3. Two scripts are\nprovided in lcr/utils directory that can be used to check the\nprobabilities resulting from a given set of weight values. Same can be\ndone with command 'kamctl eval_weights'.\n\nThe function *next_gw()* can then be used to select one gateway at a\ntime for forwarding. Upon each call, unless \"dont_strip_or_prefix_flag\"\nflag is set, user part of the original Request-URI is first stripped by\nthe number of characters as specified by the gateway's strip count and\nthen prefixed by the gateway's prefix. Upon each call, if a gateway's\nhostname is NULL, Request-URI will be rewritten based on gateway's URI\nscheme, IP address, port, parameters, and transport protocol. If\nhostname is not NULL and IP address is NULL, Request-URI will be\nrewritten based on the gateway's URI scheme, hostname, port, parameters\nand transport protocol. If both hostname and IP address are not NULL,\nRequest-URI will be rewritten based on gateway's URI scheme, hostname,\nand parameters, and destination URI is set based on gateway's URI\nscheme, IP address, port, and transport protocol.\n\nValid URI scheme values are NULL = sip, 1 = sip and 2 = sips. Currently\nvalid transport protocol values are NULL and 0 = none, 1 = udp, 2 = tcp,\n3 = tls, and 4 = sctp.\n\nAs a side effect of gateway selection, selected gateway's tag and flags\n(that may contain information about the gateway and its capabilities)\nare stored to tag_avp and flags_avp, respectively, if the corresponding\nmodule parameter has been defined. In the same way, rule_id_avp, if\ndefined, contains the id of the rule that selected the gateway.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nURL of the database table to be used.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"lcr\",\"db_url\",\"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "lcr_gw_table": "### `lcr_gw_table` (string)\n\nName of the table holding gateways definitions.\n\n*Default value is \u201clcr_gw\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_gw_table\",\"gw\")\n...\n```\n",
   "id_column": "### `id_column` (string)\n\nName of the auto-increment, primary key column. Common to all lcr module\ntables.\n\n*Default value is \u201cid\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"id_column\", \"row_id\")\n...\n```\n",
   "lcr_id_column": "### `lcr_id_column` (string)\n\nName of the column holding the identifier of an LCR instance. Common to\nall lcr module tables. In lcr_rule and lcr_rule_target tables, value of\nthe column is integer from 1 to lcr_count. In lcr_gw table, value of the\ncolumn is from 0 to lcr_count.\n\n*Default value is \u201clcr_id\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_id_column\", \"lcr_identifier\")\n...\n```\n",
   "gw_name_column": "### `gw_name_column` (string)\n\nName of the column holding gateway's name for documentation purpose.\n\n*Default value is \u201cgw_name\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"gw_name_column\", \"name\")\n...\n```\n",
   "ip_addr_column": "### `ip_addr_column` (string)\n\nName of the column holding the IPv4 or IPv6 address of the gateway.\n\n*Default value is \u201cip_addr\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"ip_addr_column\", \"ip\")\n...\n```\n",
   "hostname_column": "### `hostname_column` (string)\n\nName of the column holding gateway's hostname that is used in\nRequest-URI hostpart, when request is sent to the gateway.\n\n*Default value is \u201chostname\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"hostname_column\", \"host\")\n...\n```\n",
   "port_column": "### `port_column` (string)\n\nName of the column holding the port number of the gateway.\n\n*Default value is \u201cport\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"port_column\", \"port\")\n...\n```\n",
   "params_column": "### `params_column` (string)\n\nName of the column holding gateway's parameters that is used in\nRequest-URI, when request is sent to the gateway.\n\n*Default value is \u201cparams\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"params_column\", \"parameters\")\n...\n```\n",
   "uri_scheme_column": "### `uri_scheme_column` (string)\n\nName of the column holding the uri scheme of the gateway.\n\n*Default value is \u201curi_scheme\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"uri_scheme_column\", \"uri_scheme\")\n...\n```\n",
   "transport_column": "### `transport_column` (string)\n\nName of the column holding the transport protocol to be used for the\ngateway.\n\n*Default value is \u201ctransport\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"transport_column\", \"trans\")\n...\n```\n",
   "strip_column": "### `strip_column` (string)\n\nName of the column holding the number of characters to be stripped from\nthe front of Request-URI user part before inserting tag.\n\n*Default value is \u201cstrip\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"strip_column\", \"strip_count\")\n...\n```\n",
   "tag_column": "### `tag_column` (string)\n\nName of the column holding gateway specific tag string that is added to\nRequest URI userpart after stripping.\n\n*Default value is \u201ctag\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"tag_column\", \"gw_tag\")\n...\n```\n",
   "flags_column": "### `flags_column` (string)\n\nName of the column holding gateway specific flag values.\n\n*Default value is \u201cflags\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"flags_column\", \"gw_flags\")\n...\n```\n",
   "defunct_column": "### `defunct_column` (string)\n\nName of the column holding UNIX timestamp telling the time until which\nthe gw is considered as defunct. If timestamp value is 4294967295 (= max\nUNIX timestamp value) or greater, gw is considered currently unused and\nis not loaded into memory at all.\n\n*Default value is \u201cdefunct\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"defunct_column\", \"defunct_until\")\n...\n```\n",
   "lcr_rule_table": "### `lcr_rule_table` (string)\n\nName of the table holding the LCR rules.\n\n*Default value is \u201clcr_rule\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_rule_table\", \"rules\")\n...\n```\n",
   "prefix_column": "### `prefix_column` (string)\n\nName of the column in lcr_rule and lcr_gw tables holding prefix of\nRequest-URI user part and prefix of gateway, respectively.\n\n*Default value is \u201cprefix\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"prefix_column\", \"number_prefix\")\n...\n```\n",
   "from_uri_column": "### `from_uri_column` (string)\n\nName of the column holding the From (caller's) URI.\n\n*Default value is \u201cfrom_uri\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"from_uri_column\", \"caller_uri\")\n...\n```\n",
   "mt_tvalue_column": "### `mt_tvalue_column` (string)\n\nName of the column holding mtree tvalue.\n\n*Default value is \u201cmt_tvalue\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"mt_tvalue_column\", \"tree_value\")\n...\n```\n",
   "request_uri_column": "### `request_uri_column` (string)\n\nName of the column holding the regular expression to match against the\ncomplete request URI (including the \"sip:\" prefix).\n\n*Default value is \u201crequest_uri\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"request_uri_column\", \"callee_uri\")\n...\n```\n",
   "stopper_column": "### `stopper_column` (string)\n\nName of the column holding rule's stopper attribute.\n\n*Default value is \u201cstopper\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"stopper_column\", \"stop\")\n...\n```\n",
   "enabled_column": "### `enabled_column` (string)\n\nName of the column telling is the rule is currently enabled or disabled.\n\n*Default value is \u201cenabled\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"enabled_column\", \"in_use\")\n...\n```\n",
   "lcr_rule_target_table": "### `lcr_rule_target_table` (string)\n\nName of the table holding information about the LCR rule targets\n(gateways).\n\n*Default value is \u201clcr_rule_target\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_rule_target_table\", \"rules\")\n...\n```\n",
   "rule_id_column": "### `rule_id_column` (string)\n\nName of lcr_rule_target_table column containing an id of lcr_rule table.\n\n*Default value is \u201crule_id\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"rule_id_column\", \"rule\")\n...\n```\n",
   "gw_id_column": "### `gw_id_column` (string)\n\nName of lcr_rule_target_table column containing an id of lcr_gw table.\n\n*Default value is \u201cgw_id\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"gw_id_column\", \"gw\")\n...\n```\n",
   "priority_column": "### `priority_column` (string)\n\nName of the column holding the priority of the rule target.\n\n*Default value is \u201cpriority\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"priority_column\", \"priority\")\n...\n```\n",
   "weight_column": "### `weight_column` (string)\n\nName of the column holding weight of rule target.\n\n*Default value is \u201cweight\u201d.*\n\n```\n...\nmodparam(\"lcr\",\"weight_column\", \"target_weight\")\n...\n```\n",
   "lcr_count": "### `lcr_count` (integer)\n\nMaximum value of lcr_id.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_count\", 10)\n...\n```\n",
   "gw_uri_avp": "### `gw_uri_avp` (AVP string)\n\nInternal AVP that load_gws() function uses to store information of\nmatching gateways.\n\n*There is NO default value, thus this variable must be defined in\nsip-router.cfg.*\n\n```\n...\nmodparam(\"lcr\", \"gw_uri_avp\", \"$avp(lcr_gwuri)\")\n...\n```\n",
   "ruri_user_avp": "### `ruri_user_avp` (AVP string)\n\nInternal AVP that next_gw function uses to store Request-URI user for\nsubsequent next_gw calls.\n\n*There is NO default value, thus this variable must be defined in\nsip-router.cfg.*\n\n```\n...\nmodparam(\"lcr\", \"ruri_user_avp\", \"$avp(lcr_ruri_user)\")\n...\n```\n",
   "tag_avp": "### `tag_avp` (AVP string)\n\nIf defined, an AVP where successful next_gw and from_gw functions store\ngateway's tag.\n\n*There is NO default value, i.e, if not defined, gateway's tag is not\nstored anywhere.*\n\n```\n...\nmodparam(\"lcr\", \"tag_avp\", \"$avp(lcr_tag)\")\n...\n```\n",
   "flags_avp": "### `flags_avp` (AVP string)\n\nIf defined, an AVP where successful next_gw and from_gw functions store\ngateway's flags.\n\n*There is NO default value, i.e, if not defined, gateway's flags are not\nstored anywhere.*\n\n```\n...\nmodparam(\"lcr\", \"flags_avp\", \"$avp(lcr_flags)\")\n...\n```\n",
   "rule_id_avp": "### `rule_id_avp` (AVP string)\n\nIf defined, an AVP where successful next_gw and from_gw functions store\nmatching rule's id.\n\n*There is NO default value, i.e, if not defined, matching rule's id is\nnot stored anywhere.*\n\n```\n...\nmodparam(\"lcr\", \"rule_id_avp\", \"$avp(lcr_ruleid)\")\n...\n            \n```\n",
   "mt_pv_values": "### `mt_pv_values` (AVP string)\n\nIf defined and mt_value is given for a rule, load_gws() matches caller\nURI userpart to a mtree given as mtree parameter.\n\nIf defined, must have the same value as mtree module pv_values\nparameter.\n\n*There is NO default value.*\n\n```\n...\nmodparam(\"lcr\", \"mt_pv_values\", \"$avp(lcr_mt_values)\")\n...\n```\n",
   "mtree": "### `mtree` (string)\n\nName of mtree to which load_gws() matches caller URI userpart.\n\n*Default value is \"lcr\".*\n\n```\n...\nmodparam(\"lcr\", \"mtree\", \"caller_tree\")\n...\n```\n",
   "defunct_capability": "### `defunct_capability` (integer)\n\nTells if defunct capability of (non-responsive) gateways is supported.\nNon-zero value turns on defunct capability.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"lcr\", \"defunct_capability\", 1)\n...\n```\n",
   "lcr_id_avp": "### `lcr_id_avp` (AVP string)\n\nInternal AVP that load_gws() function uses to store LCR instance\nidentifier of loaded gateways. Only needed if gateway defunct capability\nhas been activated.\n\n*There is NO default value.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_id_avp\", \"$avp(lcr_id)\")\n...\n```\n",
   "defunct_gw_avp": "### `defunct_gw_avp` (AVP string)\n\nInternal AVP that next_gw() function uses to store internal index of the\nselected gateway for later use by defunct_gw() function. Only needed if\ngateway defunct capability has been activated.\n\n*There is NO default value.*\n\n```\n...\nmodparam(\"lcr\", \"defunct_gw_avp\", \"$avp(lcr_defunct_gw)\")\n...\n```\n",
   "lcr_rule_hash_size": "### `lcr_rule_hash_size` (integer)\n\nDefines the size of hash table used to store LCR rules. Hashing is done\nbased on rule's prefix. Larger value means less collisions with other\nprefixes. Hash size value should be a power of 2.\n\n*Default value is 128.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_rule_hash_size\", 1024)\n...\n```\n",
   "lcr_gw_count": "### `lcr_gw_count` (integer)\n\nDefines the maximum number of gateways in lcr_gw table.\n\n*Default value is 128.*\n\n```\n...\nmodparam(\"lcr\", \"lcr_gw_count\", 1024)\n...\n```\n",
   "dont_strip_or_prefix_flag": "### `dont_strip_or_prefix_flag` (integer)\n\nDefines the flag number used to tell if stripping and tagging is done\nfor the selected gateway.\n\n*Default value is -1 meaning that the flag is not defined.*\n\n```\n...\nmodparam(\"lcr\", \"dont_strip_or_prefix_flag\", 10)\n...\n```\n",
   "priority_ordering": "### `priority_ordering` (integer)\n\nDefines how matching gateways are ordered (see Overview section).\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"lcr\", \"priority_ordering\", 1)\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nThe number of the rows to be fetched at once from database when loading\ndata from lcr_rule table. This value can be used to tune the load time\nat startup. For 1MB of private memory (default) it should be below 3750.\nIn order for this parameter to have effect, the database driver must\nsupport fetch_result() capability.\n\n*Default value is \u201c1024\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"fetch_rows\", 3000)\n...\n```\n",
   "ping_interval": "### `ping_interval` (integer)\n\nInterval in seconds for sending OPTIONS ping requests to gateways that,\ndue to failures, have been marked as inactive by inactivate_gw()\nfunction call. If an inactive gateway later gives a valid response (see\n`ping_valid_reply_codes`) to a ping request, it is marked again as\nactive.\n\nIf value of this parameter is greater than zero, tm module must have\nbeen loaded and parameters `lcr_id_avp` and `defunct_gw_avp` must have\nbeen defined. Value \u201c0\u201d disables sending of OPTIONS ping requests to\nfailed gateways.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"ping_interval\", 15)\n...\n```\n",
   "ping_inactivate_threshold": "### `ping_inactivate_threshold` (integer)\n\nTells after how many failures (= inactivate_gw() function calls) a\ngateway is marked as inactive.\n\n*Default value is \u201c1\u201d, i.e., gateway is inactivated after first\nfailure.*\n\n```\n...\nmodparam(\"lcr\", \"ping_inactivate_threshold\", 3)\n...\n```\n",
   "ping_valid_reply_codes": "### `ping_valid_reply_codes` (string)\n\nA comma separated list of SIP reply codes, which are accepted as valid\nreplies to OPTIONS ping requests. Reply codes 2xx are by default\naccepted as valid replies and they don't need to be listed here.\n\n*Default value is \u201c\u201d, i.e., only 2xx replies are considered as valid\nreplies.*\n\n```\n...\nmodparam(\"lcr\", \"ping_valid_reply_codes\", \"403,405,501\")\n...\n```\n",
   "ping_from": "### `ping_from` (string)\n\nFrom URI used in OPTIONS ping requests.\n\n*Default value is \u201csip:pinger@localhost\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"ping_from\", \"sip:proxy.operator.com\")\n...\n```\n",
   "ping_socket": "### `ping_socket` (string)\n\nSocket to be used for sending OPTIONS ping request. If not set or set to\n\u201c\u201d, default socket is used.\n\n*Default value is \u201c\u201d.*\n\n```\n...\nmodparam(\"lcr\", \"ping_socket\", \"192.98.102.10:5060\")\n...\n```\n"
  },
  "functions": {
   "load_gws": "### `load_gws(lcr_id[, uri_user[, caller_uri]])`\n\nLoads attributes of matching gateways to gw_uri_avp (see Overview\nsection). Argument lcr_id specifies the used LCR instance. It can be a\npositive integer or a pseudo variable containing an integer value. If\nuri_user is given, it is used, instead of Request-URI user part, to look\nfor matching gateways. Caller's URI may be given by caller_uri argument.\nIf caller_uri argument is omitted, it defaults to empty string. Both\nuri_user and caller_uri argument may be a string or a pseudo variable\ncontaining a string value.\n\nReturns 1 if at least one matching gateway was found, 2 if no matching\ngateways was found, and -1 on error.\n\nExecution time of load_gws() function is O(N) * O(M), where N is number\nof different prefix lengths and M is number of collisions for matching\nprefix(es) in lcr rules hash table of the LCR instance.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!load_gws(1, $rU, $var(caller_uri))) {\n    sl_send_reply(\"500\", \"Server Internal Error - Cannot load gateways\");\n    exit;\n};\n...\n```\n",
   "next_gw": "### `next_gw()`\n\nUpon first call, fetches attribute values stored in first gw_uri_avp,\ndestroys that AVP, and rewrites Request-URI and possibly also\ndestination URI as described in the Overview section. Saves user part of\nRequest-URI into ruri_user_avp for use in subsequent next_gw() calls.\n\nUpon subsequent calls, does the same as in above, but takes user part of\nRequest-URI from ruri_user_avp.\n\nAs a side effect, stores gateway's tag and flags to tag_avp and\nflags_avp, respectively, if the corresponding module parameter has been\ndefined. In the same way, rule_id_avp, if defined, contains the id of\nthe rule that selected the gateway.\n\nReturns 1 on success and -1 if there were no gateways left or if an\nerror occurred (see syslog).\n\nMust be preceded by successful load_gws() call.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (!next_gw()) {\n    sl_send_reply(\"503\", \"Service not available - No gateways\");\n    exit;\n};\n...\n\n...\nif (!next_gw()) {\n    t_reply(\"503\", \"Service not available - No more gateways\");\n    exit;\n};\n...\n```\n",
   "inactivate_gw": "### `inactivate_gw()`\n\nInactivates the gateway denoted by lcr_id_avp and defunct_gw_avp (which\nwere set by previous next_gw() call). Use of this function requires that\n`ping_interval` module parameter has been set to a positive value\nallowing an inactivated gateway to be automatically activated by a\npositive response to OPTIONS ping request.\n\nReturns 1 on success and -1 in case of error (see syslog).\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nfailure_route [GW_FAILURE] {\n...\n    if (t_check_status(\"408|503\")) {\n        inactivate_gw();\n    };\n...\n        \n```\n",
   "defunct_gw": "### `defunct_gw(period)`\n\nDefuncts gateway denoted by lcr_id_avp and defunct_gw_avp (which were\nset by previuos next_gw() call) for a period of seconds given as\nargument. Argument must be a positive integer constant or a pseudo\nvariable with positive integer value. Value of defunct column in\ndatabase is not updated.\n\nReturns 1 on success and -1 in case of error (see syslog).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\ndefunct_gw(60);\n...\n```\n",
   "from_gw": "### `from_gw(lcr_id[, ip_addr, proto[, src_port]])`\n\nChecks if request comes from IP address, transport protocol and source\nport specified for a gateway in LCR instance lcr_id. Fails if the LCR\ninstance includes one or more gateways without IP address. IP address,\ntransport protocol and source port to be checked are either taken from\nsource IP address and port of the request or (if present) from ip_addr,\nproto and src_port arguments.\n\nlcr_id can be an integer constant or a pseudo variable holding an\ninteger value. ip_addr can be a string or a pseudo variable holding a\nstring value. proto can be an integer constant (0 = ANY, 1 = UDP, 2 =\nTCP, 3 = TLS, 4 = SCTP) or a pseudo variable holding such an integer\nvalue. src_port can be an integer or a pseudo variable holding such an\ninteger value.\n\nIf request comes from a gateway, gateway's tag and flags are stored as a\nside effect to tag_avp and flags_avp, respectively, if the corresponding\nmodule parameter has been defined. In the same way, rule_id_avp, if\ndefined, contains the id of the rule that selected the gateway.\n\nReturns 1 on success and -1 on failure or on error.\n\nExecution time of from_gw() function is O(log N), where N is number of\ngateways in the LCR instance.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE.\n\n```\n...\nif (from_gw(1, $avp(real_source_addr), 2, 5060) {\n    ...\n};\n...\n```\n",
   "from_any_gw": "### `from_any_gw([ip_addr, proto[, src_port]])`\n\nChecks if request comes from IP address, transport protocol and source\nport specified for any gateway. Only LCR instances, where all gateways\nhave IP address, are included in the test. IP address, transport\nprotocol and source port to be checked are either taken from source IP\naddress, transport protocol and source port of the request or (if\npresent) from ip_addr, proto and src_port arguments. See from_gw()\nfunction for more info about the arguments.\n\nIf any gateway has the IP address, transport protocol and source port,\nfunction returns LCR identifier of the gateway. Returns -1 on error or\nif the request does not come from a gateway.\n\nIf request comes from a gateway, gateway's tag and flags are stored as a\nside effect to tag_avp and flags_avp, respectively, if the corresponding\nmodule parameter has been defined. In the same way, rule_id_avp, if\ndefined, contains the id of the rule that selected the gateway.\n\nExecution time of from_gw() function is M * O(log N), where M is number\nof LCR instances and N is average number of gateways in LCR instances.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE.\n\n```\n...\n$var(lcr_id) = from_any_gw(\"192.168.1.1\", 3, 5061);\n...\n```\n",
   "to_gw": "### `to_gw(lcr_id[, ip_addr, proto])`\n\nChecks if in-dialog request goes to IP address and transport protocol\nspecified for a gateway in LCR instance lcr_id. Fails if LCR instance\nincludes one or more gateways without IP address. IP address and\ntransport protocol to be checked are either taken from Request-URI or\n(if present) from ip_addr and proto arguments. See from_gw() for more\ninfo regarding the arguments.\n\nReturns 1 on success and -1 on failure and error.\n\nExecution time of to_gw() function is O(log N), where N is number of\ngateways in the LCR instance.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (to_gw(\"1\")) {\n    ...\n    exit;\n};\n...\n```\n",
   "to_any_gw": "### `to_any_gw([ip_addr, proto])`\n\nChecks if in-dialog request goes to IP address and transport protocol of\nany gateway. Only LCR instances, where all gateways have IP address, are\nincluded in the test. IP address and transport protocol to be checked\nare either taken from Request-URI or (if present) from ip_addr and proto\narguments. See from_gw() for more info regarding the arguments.\n\nExecution time of to_any_gw() function is M * O(log N), where M is\nnumber of LCR instances and N is average number of gateways in LCR\ninstances.\n\nIf any gateway has the IP address, returns LCR identifier of the\ngateway. Returns -1 if request does not go to a gateway and on error.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (to_any_gw(\"192.55.66.2\", 1)) {\n    ...\n    exit;\n};\n...\n```\n"
  }
 },
 "ldap": {
  "overview": "The LDAP module implements an LDAP search interface for Kamailio. It\nexports script functions to perform an LDAP search operation and to\nstore the search results as Kamailio AVPs. This allows for using LDAP\ndirectory data in the Kamailio SIP message routing script.\n\nThe following features are offered by the LDAP module:\n\n- LDAP search function based on a LDAP URL\n\n- LDAP result parsing functions to store LDAP data as AVP variables\n\n- Support for accessing multiple LDAP servers\n\n- LDAP SIMPLE authentication\n\n- LDAP server failover and automatic reconnect\n\n- Configurable LDAP connection and bind timeouts\n\n- Module API for LDAP search operations that can be used by other\n  Kamailio modules\n\nThe module implementation makes use of the open source *OpenLDAP*\nlibrary available on most UNIX/Linux platforms. Besides LDAP server\nfailover and automatic reconnect, this module can handle multiple LDAP\nsessions concurrently allowing access to data stored on different LDAP\nservers. Each Kamailio worker process maintains one LDAP TCP connection\nper configured LDAP server. This enables parallel execution of LDAP\nrequests and offloads LDAP concurrency control to the LDAP server(s).\n\nAn LDAP search module API is provided that can be used by other Kamailio\nmodules. A module using this API does not have to implement LDAP\nconnection management and configuration, while still having access to\nthe full OpenLDAP API for searching and result handling.\n\nSince LDAP server implementations are optimized for fast read access\nthey are a good choice to store SIP provisioning data. Performance tests\nhave shown that this module achieves lower data access times and higher\ncall rates than other database modules like e.g. the Kamailio MYSQL\nmodule.\n",
  "parameters": {
   "config_file": "### `config_file` (string)\n\nFull path to LDAP configuration file.\n\nDefault value: `/usr/local/etc/kamailio/ldap.cfg`\n\n```\nmodparam(\"ldap\", \"config_file\", \"/usr/local/etc/kamailio/ldap.ini\")\n          \n```\n",
   "connect_mode": "### `connect_mode` (int)\n\nControl if the module must stop loading when connecting to server fails\nduring start up. Values: 0 - stop loading; 1 - continue even if\nconnecting to database server fails..\n\nDefault value: `0`\n\n```\nmodparam(\"ldap\", \"connect_mode\", 1)\n              \n```\n"
  },
  "functions": {
   "ldap_search": "### ldap_search(ldap_url)\n\nPerforms an LDAP search operation using given LDAP URL and stores result\ninternally for later retrieval by `ldap_result*` functions. If one or\nmore LDAP entries are found the function returns the number of found\nentries which evaluates to TRUE in the Kamailio configuration script. It\nreturns `-1` (`FALSE`) in case no LDAP entry was found, and `-2`\n(`FALSE`) if an internal error like e.g. an LDAP error occurred.\n\n`ldap_url`  \nAn LDAP URL defining the LDAP search operation (refer to [LDAP\nURLs](#ldap-urls) for a description of the LDAP URL format). The\nhostport part must be one of the LDAP session names declared in the LDAP\nconfiguration script.\n\nKamailio pseudo variables and AVPs included in `ldap_url` do get\nsubstituted with their value.\n\nSearch with LDAP session named `sipaccounts`, base\n`ou=sip,dc=example,dc=com`, `one` level deep using search filter\n`(cn=schlatter)` and returning all attributes:\n\n```\nldap://sipaccounts/ou=sip,dc=example,dc=com??one?(cn=schlatter)\n```\n\nSubtree search with LDAP session named `ldap1`, base `dc=example,dc=com`\nusing search filter `(cn=$(avp(s:name)))` and returning\n`SIPIdentityUserName` and `SIPIdentityServiceLevel` attributes\n\n```\nldap://ldap_1/dc=example,dc=com?\n       SIPIdentityUserName,SIPIdentityServiceLevel?sub?(cn=$(avp(s:name)))\n            \n```\n\n<!-- -->\n\n\n`n` > 0 (TRUE):\n\n- Found `n` matching LDAP entries\n\n`-1` (FALSE):\n\n- No matching LDAP entries found\n\n`-2` (FALSE):\n\n- LDAP error (e.g. LDAP server unavailable), or\n\n- internal error\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n...\n# ldap search\nif (!ldap_search(\"ldap://sipaccounts/ou=sip,dc=example,dc=com??one?(cn=$rU)\"))\n{\n    switch ($retcode)\n    {\n    case -1:\n        # no LDAP entry found\n        sl_send_reply(\"404\", \"User Not Found\");\n        exit;\n    case -2:\n        # internal error\n        sl_send_reply(\"500\", \"Internal server error\");\n        exit;\n    default:\n        exit;\n    }\n}\nxlog(\"L_INFO\", \"ldap_search: found [$retcode] entries for (cn=$rU)\");\n\n# save telephone number in $avp(s:tel_number)\nldap_result(\"telephoneNumber/$avp(s:tel_number)\");\n...\n            \n```\n",
   "ldap_result": "### ldap_result(\"ldap_attr_name/avp_spec[/avp_type]\" [, regex_subst])\n\nThis function converts LDAP attribute values into AVPs for later use in\nthe message routing script. It accesses the LDAP result set fetched by\nthe last `ldap_search` call. `ldap_attr_name` specifies the LDAP\nattribute name who's value will be stored in AVP `avp_spec`. Multi\nvalued LDAP attributes generate an indexed AVP. The optional\n`regex_subst` parameter allows to further define what part of an\nattribute value should be stored as AVP.\n\nAn AVP can either be of type string or integer. As default,\n`ldap_result` stores LDAP attribute values as AVP of type string. The\noptional `avp_type` parameter can be used to explicitly specify the type\nof the AVP. It can be either `str` for string, or `int` for integer. If\n`avp_type` is specified as `int` then `ldap_result` tries to convert the\nLDAP attribute values to integer. In this case, the values are only\nstored as AVP if the conversion to integer is successful.\n\nldap_attr_name  \nThe name of the LDAP attribute who's value should be stored, e.g.\n`SIPIdentityServiceLevel` or `telephonenumber`\n\navp_spec  \nSpecification of destination AVP, e.g. `$avp(s:service_level)` or\n`$avp(i:12)`\n\navp_type  \nOptional specification of destination AVP type, either `str` or `int`.\nIf this parameter is not specified then the LDAP attribute values are\nstored as AVP of type string.\n\nregex_subst  \nRegex substitution that gets applied to LDAP attribute value before\nstoring it as AVP, e.g. `&quot;/^sip:(.+)$/\\1/&quot;` to strip off \"sip:\" from the\nbeginning of an LDAP attribute value.\n\n<!-- -->\n\n\n`n` > 0 (TRUE)  \nLDAP attribute `ldap_attr_name` found in LDAP result set and `n` LDAP\nattribute values stored in `avp_spec`\n\n-1 (FALSE)  \nNo LDAP attribute `ldap_attr_name` found in LDAP result set\n\n-2 (FALSE)  \nInternal error occurred\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n...\n\n# ldap_search call\n...\n\n# save SIPIdentityServiceLevel in $avp(s:service_level)\nif (!ldap_result(\"SIPIdentityServiceLevel/$avp(s:service_level)\"))\n{\n    switch ($retcode)\n    {\n    case -1:\n        # no SIPIdentityServiceLevel found\n        sl_send_reply(\"403\", \"Forbidden\");\n        exit;\n    case -2:\n        # internal error\n        sl_send_reply(\"500\", \"Internal server error\");\n        exit;\n    default:\n        exit;\n    }\n}\n\n# save SIP URI domain in $avp(i:10)\nldap_result(\"SIPIdentitySIPURI/$avp(i:10)\", \"/^[^@]+@(.+)$/\\1/\");\n...\n        \n```\n",
   "ldap_result_check": "### ldap_result_check(\"ldap_attr_name/string_to_match\" [, regex_subst])\n\nThis function compares `ldap_attr_name`'s value with `string_to_match`\nfor equality. It accesses the LDAP result set fetched by the last\n`ldap_search` call. The optional `regex_subst` parameter allows to\nfurther define what part of the attribute value should be used for the\nequality match. If `ldap_attr_name` is multi valued, each value is\nchecked against `string_to_match`. If one or more of the values do match\nthe function returns `1` (TRUE).\n\nldap_attr_name  \nThe name of the LDAP attribute who's value should be matched, e.g.\n`SIPIdentitySIPURI`\n\nstring_to_match  \nString to be matched. Included AVPs and pseudo variables do get\nexpanded.\n\nregex_subst  \nRegex substitution that gets applied to LDAP attribute value before\ncomparing it with string_to_match, e.g. `&quot;/^[^@]@+(.+)$/\\1/&quot;` to extract\nthe domain part of a SIP URI\n\n<!-- -->\n\n\n1 (TRUE)  \nOne or more `ldap_attr_name` attribute values match `string_to_match`\n(after `regex_subst` is applied)\n\n-1 (FALSE)  \n`ldap_attr_name` attribute not found or attribute value doesn't match\n`string_to_match` (after `regex_subst` is applied)\n\n-2 (FALSE)  \nInternal error occurred\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n...\n# ldap_search call\n...\n\n# check if 'sn' ldap attribute value equals username part of R-URI,\n# the same could be achieved with ldap_result_check(\"sn/$rU\")\nif (!ldap_result_check(\"sn/$ru\", \"/^sip:([^@]).*$/\\1/\"))\n{\n    switch ($retcode)\n    {\n    case -1:\n        # R-URI username doesn't match sn\n        sl_send_reply(\"401\", \"Unauthorized\");\n        exit;\n    case -2:\n        # internal error\n        sl_send_reply(\"500\", \"Internal server error\");\n        exit;\n    default:\n        exit;\n    }\n}\n...\n            \n```\n",
   "ldap_result_next": "### ldap_result_next()\n\nAn LDAP search operation can return multiple LDAP entries. This function\ncan be used to cycle through all returned LDAP entries. It returns 1\n(TRUE) if there is another LDAP entry present in the LDAP result set and\ncauses `ldap_result*` functions to work on the next LDAP entry. The\nfunction returns -1 (FALSE) if there are no more LDAP entries in the\nLDAP result set.\n\n1 (TRUE)  \nAnother LDAP entry is present in the LDAP result set and result pointer\nis incremented by one\n\n-1 (FALSE)  \nNo more LDAP entries are available\n\n`-2` (FALSE)  \nInternal error\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n...\n# ldap_search call\n...\n\nldap_result(\"telephonenumber/$avp(s:tel1)\");\nif (ldap_result_next())\n{\n    ldap_result(\"telephonenumber/$avp(s:tel2)\");\n}\nif (ldap_result_next())\n{\n    ldap_result(\"telephonenumber/$avp(s:tel3)\");\n}\nif (ldap_result_next())\n{\n    ldap_result(\"telephonenumber/$avp(s:tel4)\");\n}\n...\n            \n```\n",
   "ldap_filter_url_encode": "### ldap_filter_url_encode(string, avp_spec)\n\nThis function applies the following escaping rules to `string` and\nstores the result in AVP `avp_spec`:\n\n| character in `string` | gets replaced with | defined in |\n|-----------------------|--------------------|------------|\n| *                    | \\2a                | RFC 4515   |\n| (                     | \\28                | RFC 4515   |\n| )                     | \\29                | RFC 4515   |\n| \\                    | \\5c                | RFC 4515   |\n| ?                     | %3F                | RFC 4516   |\n\nldap_filter_url_encode() escaping rules\n\nThe string stored in AVP `avp_spec` can be safely used in an LDAP URL\nfilter string.\n\n`string`  \nString to apply RFC 4515 and URL escaping rules to. AVPs and pseudo\nvariables do get expanded. Example: `&quot;cn=$avp(s:name)&quot;`\n\n`avp_spec`  \nSpecification of AVP to store resulting RFC 4515 and URL encoded string,\ne.g. `$avp(s:ldap_search)` or `$avp(i:10)`\n\n<!-- -->\n\n\n`1` (TRUE)  \nRFC 4515 and URL encoded `filter_component` stored as AVP `avp_name`\n\n`-1` (FALSE)  \nInternal error\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and ONREPLY_ROUTE.\n\n```\n...\nif (!ldap_filter_url_encode(\"cn=$avp(s:name)\", \"$avp(s:name_esc)\"))\n{\n    # RFC 4515/URL encoding failed --> silently discard request\n    exit;\n}\n\nxlog(\"L_INFO\", \"encoded LDAP filter component: [$avp(s:name_esc)]\\n\");\n\nif (ldap_search(\n     \"ldap://h350/ou=commObjects,dc=example,dc=com??sub?($avp(s:name_esc))\"))\n    { ... }\n...\n    \n```\n"
  }
 },
 "log_custom": {
  "overview": "This module provides logging to custom systems, replacing the default\ncore logging to syslog. At this moment it can send the logs to an IP and\nport via UDP, once all modules have been initialized.\n",
  "parameters": {},
  "functions": {
   "log_udp": "### `log_udp(text)`\n\nSend the text to the address specified in core parameter\nlog_engine_data. It is provided as sample function mainly for testing,\nbecause all logs messages printed by kamailio should be diverted as\ndescribed in the section 'Core Logging', so you can use xlog functions\nin config file.\n\nThe parameter can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n   log_udp(\"R-URI is $ru\\n\");\n...\n```\n"
  }
 },
 "log_systemd": {
  "overview": "It provides logging to systemd journal from the moment of loading this\nmodule.\n",
  "parameters": {},
  "functions": {
   "sd_journal_print": "### `sd_journal_print(level, text)`\n\nPrint the text in the systemd journal at the provided level parameter.\n\nBoth parameters can contain variables.\n\nFor more, see the manual page for function sd_journal_print() in C\nlibrary libsystemd.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n   sd_journal_print(\"LOG_INFO\", \"R-URI is $ru\\n\");\n...\n```\n",
   "sd_journal_send_xavp": "### `sd_journal_send_xavp(name)`\n\nCreates a structured log event in journald.\n\nThe sd_journal_send_xavp(name) function sends a log event in journald,\nbased on the fields provided in the xavp whose root name is specified as\nparameter. This function is a wrapper for journald's *sd_journal_send()*\nfunction, and allows to specify as many custom fields as desired (see\n*sd_journal_send(3)*).\n\nThe xavp given as parameter must contain child AVPs with names\nconforming to journald's field name policy (only uppercase letters,\nnumbers and underscore), otherwise they will be discarded by journald.\n\nSome field name have a default meaning for journald:\n\n- *MESSAGE*: the human-readable message string for this entry.\n\n- *PRIORTTY*: integer priority value between 0 (\"emerg\") and 7 (\"debug\")\n\n- (...) (see *systemd.journald-fields(7)*)\n\nThis function can be used from ANY_ROUTE.\n\n```\nrequest_route {\n    $xavp(event=>MESSAGE) = $rm + \" request logged with journald\";\n    $xavp(event[0]=>SIP_MESSAGE) = $mb;\n# don't forget the '[0]', otherwise kamailio will create and\n# stack new AVPs (see pseudovariable documentation) over the previous one\n    $xavp(event[0]=>SIP_CALL_ID) = $ci;\n    $xavp(event[0]=>SIP_SRC_PORT) = $sp;\n    $xavp(event[0]=>PRIORITY) = 6;\n    sd_journal_send_xavp(\"event\");\n(...)\n}\n```\n"
  }
 },
 "lost": {
  "overview": "SIP requests may be forwarded based on a location provided by the\nrequest or retrieved from a specific location server using an identity\n(HELD). This module implements the basic functionality to get or parse\nlocation information (civic and geodetic) and to query a mapping service\n(LOST) to get the next hop based on location and service urn either\nspecified or provided with the request.\n\nThis module implements protocol functions that use the http_client API\nto fetch data from external LOST and HELD servers. The module is using\nthe http_client concept of \"connections\" to define properties of HTTP\nsessions. A connection has one or multiple servers and a set of settings\nthat apply to the specific connection.\n\nThe function lost_held_query allows Kamailio to assemble a HELD\nlocationRequest as defined in RFC6155\n([](https://tools.ietf.org/html/rfc6155)) to query location information\nrepresented as PIDF-LO for a given identity (in most cases a SIP URI).\nThe identity may be a specific parameter or taken from the\nP-Asserted-Identity or From header. The locationRequest response is\nparsed and represented as PIDF-LO and location URI to dereference\nlocation via HTTP(S).\n\nThe function lost_held_dereference allows Kamailio to assemble a HELD\ndereference request as defined in RFC6155\n([](https://tools.ietf.org/html/rfc6753)) to dereference location\ninformation represented as PIDF-LO for a given URL. Required parameters\nare an URL, responseTime, and responseType. The response is represented\nas PIDF-LO.\n\nThe function lost_query allows Kamailio to assemble a LOST findService\nrequest as defined in RFC5222 ([](https://tools.ietf.org/html/rfc5255))\nto query routing information for a given (geodetic or civic) location\nand a service URN. Both, PIDF-LO and service URN may be provided as\nfunction parameters, or are taken from the request message if\napplicable. The findServiceResponse is parsed and represented as display\nname and SIP URI typically used as the next hop in a Route header.\n\nThe http_client module uses the CURL library to set up connections. The\nCURL library by default uses the system-configured DNS resolver, not the\nKamailio resolver.\n\nThe module is limited to using HTTP and HTTPS protocols.\n",
  "parameters": {
   "exact_type": "### `exact_type` (int)\n\nIndicates to the location server that the contents of the\n\"location_type\" parameter must be strictly followed. Values are 0\n(false) or 1 (true).\n\nDefault: 0 (false)\n\n```\n    ...\n    modparam(\"lost\", \"exact_type\", 1)\n    ...\n                \n```\n",
   "response_time": "### `response_time` (int)\n\nA time value informs the location server how long the client is prepared\nto wait for a response.\n\nThe value is expressed as an integer, either -1 'emergencyDispatch', 0\n'emergencyRouting', a non-negative integer (>0) in units of\nmilliseconds. Note: The time value is indicative only.\n\nDefault: 0 ('emergencyRouting')\n\n```\n    ...\n    modparam(\"lost\", \"response_time\", 0)\n    ...\n                \n```\n",
   "location_type": "### `location_type` (string)\n\nThe \"locationType\" element contains a list of types that are requested.\nValues are \"any\", \"geodetic\", \"civic\" or \"locationURI\" and combinations.\n\n- *any* - returns location information in all forms available\n\n- *geodetic* - returns a location by value in the form of a geodetic\n  location\n\n- *civic* - returns a location by value in the form of a civic address\n\n- *locationURI* - returns a set of location URIs (location by reference)\n\nDefault: \"geodetic locationURI\".\n\n```\n    ...\n    modparam(\"lost\", \"location_type\", \"civic geodetic locationURI\")\n    ...\n                \n```\n",
   "post_request": "### `post_request` (int)\n\nDereferencing the location can be done using either the HTTP GET or POST\nmethod. This parameter globally defines whether only HTTP POST method\nshould be used. Values are 0 (GET) or 1 (POST).\n\nDefault: 0 (GET)\n\n```\n    ...\n    modparam(\"lost\", \"post_request\", 1)\n    ...\n                \n```\n",
   "location_profile": "### `location_profile` (int)\n\nA Presence Information Data Format Location Object (PIDF-LO) may contain\ngeodetic or civic location profile or combinations. A LoST *findService*\ncontains only one location, which is selected via this parameter as\nfollows:\n\n- *0* - takes the first location of any type\n\n- *1* - takes the last location of any type\n\n- *2* - takes the first geodetic location\n\n- *3* - takes the first civic location\n\nDefault: 0 (first).\n\n```\n    ...\n    modparam(\"lost\", \"location_profile, 2)\n    ...\n                \n```\n",
   "location_3d": "### `location_3d` (int)\n\nA Presence Information Data Format Location Object (PIDF-LO) may contain\none of the shape types as listed in RFC5491\n([](https://tools.ietf.org/html/rfc5491)). A LoST *findService* request\ncurrently contains only a profile for two-dimensional geodetic location\ninformation, which is the default setting for this parameter. The\nparameter can be set to 1 if a LoST server supports 3d, otherwise a 3d\nlocation is reduced to 2d by the module.\n\n- *0* - two-dimensional (2d) shape representations only\n\n- *1* - three-dimensional (3d) volume representations allowed\n\nDefault: 0 (2d representations).\n\n```\n    ...\n    modparam(\"lost\", \"location_3d, 1)\n    ...\n                \n```\n",
   "geoheader_type": "### `geoheader_type` (int)\n\nA Geolocation header may include a list of locationValues pointing to\neither a Presence Information Data Format Location Object (PIDF-LO) in\nthe SIP body using a content-indirection (cid:) URI per RFC4483\n([](https://tools.ietf.org/html/rfc4483)), or an http(s) URI pointing to\nan external source. This parameter supports filtering of the following\ntypes:\n\n- *0 (any)* - any URI (first or last)\n\n- *1 (cid)* - cid URI (aka Location-by-Value)\n\n- *2 (http)* - http URI (aka Location-by-Reference)\n\n- *3 (https)* - https URI (aka Location-by-Reference)\n\nDefault: 0 (any)\n\n```\n    ...\n    modparam(\"lost\", \"geoheader_type\", 1)\n    ...\n                \n```\n",
   "geoheader_order": "### `geoheader_order` (int)\n\nA Geolocation header may include a list of locationValues. This\nparameter sets the order of the URI used to retrieve the location\ninformation, either the first element of a certain type or the last.\nValues are 0 (first) or 1 (last).\n\nDefault: 0 (first)\n\n```\n    ...\n    modparam(\"lost\", \"geoheader_order\", 0)\n    ...\n                \n```\n",
   "recursion": "### `recursion` (int)\n\nA Geolocation header may include a list of locationValues. This\nparameter sets the order of the URI used to retrieve the location\ninformation, either the first element of a certain type or the last.\nValues are 0 (first) or 1 (last).\n\nDefault: 1 (allowed)\n\n```\n    ...\n    modparam(\"lost\", \"recursion\", 0)\n    ...\n                \n```\n",
   "verbose": "### `verbose` (int)\n\nDetailed output of LoST findService, redirect or error response as shown\nbelow. Values are 0 (disabled) or 1 (enabled).\n\n```\n    ### LOST expires:   [2031-01-27T14:54:21+00:00]\n    ### LOST lastUpdated:       [2021-01-29T14:54:21+00:00]\n    ### LOST source:    [ecrf.demo.gridgears.xx]\n    ### LOST sourceId:  [06ac5b1c-d6c8-42bd-a667-5d1b90bb3d95]\n    ### LOST displayName:       [Polizeinotruf (de)]\n    ### LOST serviceNumber:     [112]\n    ### LOST service:   [urn:service:sos]\n    ### LOST uri:       [sip:112@demo.dec112.xx]\n    ### LOST via:       [ecrf.demo.gridgears.xx]\n            \n```\n\nDefault: 0\n\n```\n    ...\n    modparam(\"lost\", \"verbose\", 1)\n    ...\n                \n```\n"
  },
  "functions": {
   "lost_held_query": "### `lost_held_query(con, [id,] pidf-lo, url, error)`\n\nSends a HELD locationRequest to a given connection. The device identity\nis either specified, or the P-A-I header value, or the From header\nvalue.\n\n- *con* - the name of an existing HTTP connection, defined by a httpcon\n  modparam\n\n- *id* - the device id used in the HELD locationRequest\n\n- *pidf-lo* - the PIDF-LO returned in the HELD locationRequest response\n\n- *url* - the location reference returned in the HELD locationRequest\n  response - this reference may be added as Geolocation header value and\n  forwarded downstream. Note: to work properly, it is required to\n  include \"locationURI\" in the location_type parameter.\n\n- *error* - any error code returned in the HELD response\n\nThe return value is 200 on success, 400 if an internal error occurred,\nor 500 if an error code is returned in the HELD locationRequest\nresponse.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n```\n...\nmodparam(\"http_client\", \"httpcon\", \"heldsrv=>http://service.org/api/held\");\n...\n# HELD location request\n$var(id) = \"sip:alice@atlanta\";\n$var(res) = lost_held_query(\"heldsrv\", \"$var(id)\" , \"$var(pidf)\", \"$var(url)\", \"$var(err)\");\nxlog(\"L_INFO\", \"HELD locationRequest: Result code $var(res)\\nUrl: $var(url)\\n$var(pidf)\");\n...\n$var(res) = lost_held_query(\"heldsrv\", \"$var(pidf)\", \"$var(url)\", \"$var(err)\");\nxlog(\"L_INFO\", \"HELD locationRequest: Result code $var(res)\\nUrl: $var(url)\\n$var(pidf)\\n\");\n...\n                \n```\n",
   "lost_held_dereference": "### `lost_held_dereference(url, rtime, rtype, pidf-lo, error)`\n\nSends a HELD POST locationRequest to a given URL. Attributes are\nresponseTime and responseType. The *locationType* property \"exact\" is\nset to \"false\".\n\n- *url* - a URL received via Geolocation header to dereference location\n\n- *rtime* - the response time as defined in [\n  (int)](#lost.p.response_time)\n\n- *rtype* - the response type (location) as defined in [\n  (string)](#lost.p.location_type)\n\n- *pidf-lo* - the PIDF-LO returned in the HELD locationRequest response\n\n- *error* - any error code returned in the HELD response\n\nThe return value is 200..203 on success, 400 if an internal error\noccurred, or 500 if an error code is returned in the HELD response.\nSuccess codes in detail are as follows:\n\n- *200* - received 200 OK, but neither location-info nor locationURI\n  element found\n\n- *201* - received 200 OK with locationURI (aka Location-by-Reference)\n\n- *202* - received 200 OK with location-info element (aka\n  Location-by-Value)\n\n- *203* - received 200 OK with location-info and locationURI element\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n```\n...\n# HELD location dereference\nif ($hdr(Geolocation)=~\"^<http.*$\") {\n    $var(url) = $(hdr(Geolocation){s.select,0,;});\n    $var(res) = lost_held_dereference(\"$(var(url){s.unbracket})\", \"emergencyDispatch\", \"civic geodetic\", \"$var(pidf)\", \"$var(err)\");\n    xlog(\"L_INFO\", \"HELD location dereference: Result code $var(res)\\n$var(pidf)\");\n...\n}\n                \n```\n",
   "lost_query": "### `lost_query(con, [pidf-lo, urn,] uri, name, error)`\n\nSends a LOST findService request to a given connection. PIDF-LO and URN\nare either specified, or, if omitted, parsed from the message body\n(PIDF-LO) and request line (URN). Either \"pidf-lo\" or \"urn\" can be set\nto an empty string to be ignored.\n\n- *con* - the name of an existing HTTP connection defined by a httpcon\n  modparam\n\n- *pidf-lo* - the PIDF-LO used to create the LOST findService request\n\n- *urn* - the URN used to create the LOST findService request\n\n- *uri* - the SIP uri returned in the LOST findServiceResponse\n\n- *name* - the display name returned in the LOST findServiceResponse\n\n- *error* - any error code returned in the LOST findServiceResponse\n\nThe return value is 200 on success, 400 if an internal error occurred,\nor 500 if an error code is returned in the LOST findServiceResponse.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n```\n...\nmodparam(\"http_client\", \"httpcon\", \"heldsrv=>http://service.org/api/held\");\nmodparam(\"http_client\", \"httpcon\", \"lostsrv=>http://service.org/api/lost\");\n...\n# HELD location request\n$var(id) = \"sip:alice@atlanta\";\n$var(res) = lost_held_query(\"heldsrv\", \"$var(id)\" , \"$var(pidf)\", \"$var(url)\", \"$var(err)\");\n...\n# LOST findService request - pidf-lo and urn as parameter\n$var(id) = \"urn:service:sos\";\n$var(res) = lost_query(\"lostsrv\", \"$var(pidf)\", \"$var(urn)\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\nxlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name)\\n\");\n...\n# LOST findService request - pidf-lo as parameter, urn taken from request line\n$var(res) = lost_query(\"lostsrv\", \"$var(pidf)\", \"\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\nxlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name)\\n\");\n...\n# LOST findService request - urn as parameter, pidf-lo taken from message body\n$var(res) = lost_query(\"lostsrv\", \"\", \"$var(urn)\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\nxlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name\\n\");\n...\n# LOST findService request - pidf-lo and urn taken from message\n$var(res) = lost_query(\"lostsrv\", \"$var(uri)\", \"$var(name)\", \"$var(err)\");\nxlog(\"L_INFO\", \"LOST findService: Result code $var(res)\\nUri: $var(uri)\\nName: $var(name)\\n\");\n...\n                \n```\n"
  }
 },
 "lrkproxy": {
  "overview": "This is a module that enables media streams to be relayed via pylrkproxy\nengine that exist in: https://github.com/mojtabaesfandiari/pylrkproxy It\ndoes relaying audio streams between peers in PREROUTING\nnetfilter-hooking section in kernel-space linux. The LRKProxy\narchitecture is composed of two different layers. These layers are\nindependent of each other. For more information about LRKProxy\narchitecture, please visit our paper in ieeexplore:\nhttps://ieeexplore.ieee.org/document/9303608\n",
  "parameters": {},
  "functions": {}
 },
 "lwsc": {
  "overview": "This module provides a websocket client implementation to interact with\nexternal systems, similar to http client. It is not for routing SIP\ntraffic.\n\nIt relies on libwebsockets library (https://libwebsockets.org/).\n",
  "parameters": {
   "protocol": "### `protocol` (str)\n\nThe websocket sub-protocol.\n\n*Default value is \"kmsg\".*\n\n```\n...\nmodparam(\"lwsc\", \"protocol\", \"ksr\")\n...\n```\n",
   "timeout_init": "### `timeout_init` (int)\n\nThe interval in microseconds to wait for websocket connection to be\ninitialized.\n\n*Default value is 2000000 (2 seconds).*\n\n```\n...\nmodparam(\"lwsc\", \"timeout_init\", 4000000)\n...\n```\n",
   "timeout_read": "### `timeout_read` (int)\n\nThe interval in microseconds to wait for the response of the\nlwsc_request() group of functions.\n\n*Default value is 2000000 (2 seconds).*\n\n```\n...\nmodparam(\"lwsc\", \"timeout_init\", 1000000)\n...\n```\n",
   "verbosity": "### `verbosity` (int)\n\nControl the verbosity of debug messages on libwebsockets events, higher\nvalue means more debug messages. It has to be a positive number,\ncurrently 2 or higher results in maximum verbosity.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"lwsc\", \"verbosity\", 1)\n...\n```\n"
  },
  "functions": {
   "lwsc_notify": "### `lwsc_notify(wsurl, data)`\n\nSend data via websockets to the address specified by wsurl. No response\nis expected. Transmission is not guaranteed (e.g., cannot connect to\ntarget).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    jwt_notify(\"ws://10.1.1.10:8080/log\",\n        \"caller=$fU;callee=$tU;callid=$ci\");\n...\n```\n",
   "lwsc_notify_proto": "### `lwsc_notify_proto(wsurl, wsproto, data)`\n\nSend data via websockets to the address specified by wsurl, providing\nwebsocket protocol. No response is expected. Transmission is not\nguaranteed (e.g., cannot connect to target).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- wsproto - websocket protocol\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    jwt_notify_proto(\"ws://10.1.1.10:8080/log\", \"kmsg\"\n        \"caller=$fU;callee=$tU;callid=$ci\");\n...\n```\n",
   "lwsc_request": "### `lwsc_request(wsurl, data)`\n\nSend data via websockets to the address specified by wsurl, a response\nis expected and made available in $lwsc(rdata).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    jwt_request(\"ws://10.1.1.10:8080/log\",\n        \"caller=$fU;callee=$tU;srcip=$si\");\n...\n```\n",
   "lwsc_request_proto": "### `lwsc_request_proto(wsurl, wsproto, data)`\n\nSend data via websockets to the address specified by wsurl, providing\nwebsocket protocol. A response is expected and made available in\n$lwsc(rdata).\n\nThe parameters are:\n\n- wsurl - websocket url\n\n- wsproto - websocket protocol\n\n- data - what to send\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    jwt_request_proto(\"ws://10.1.1.10:8080/log\", \"kmsg\",\n        \"caller=$fU;callee=$tU;srcip=$si\");\n...\n```\n"
  }
 },
 "math": {
  "overview": "This module provides a collection of functions for math operations.\n\nNote that the result values are casted to intger (long value), being the\ntype supported by the config variables.\n",
  "parameters": {},
  "functions": {
   "pow": "### `pow(base, power, res)`\n\nThe exponentiation function, computing the base raised to power, storing\nin res.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    math_pow(\"2\", \"10\", \"$var(res)\");\n    $var(base) = 2;\n    $var(power) = 10;\n    math_pow(\"$var(base)\", \"$var(power)\", \"$var(res)\");\n...\n```\n",
   "math_logN": "### `math_logN(x, res)`\n\nThe function computes the natural logarithm of x and stores the result\nin res.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    math_logN(\"10\", \"$var(res)\");\n    $var(x) = 10;\n    math_logN(\"$var(x)\", \"$var(res)\");\n...\n```\n",
   "math_log2": "### `math_log2(x, res)`\n\nThe function computes the base-2 logarithm of x and stores the result in\nres.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    math_log2(\"16\", \"$var(res)\");\n    $var(x) = 16;\n    math_log2(\"$var(x)\", \"$var(res)\");\n...\n```\n",
   "math_log10": "### `math_log10(x, res)`\n\nThe function computes the base-10 logarithm of x and stores the result\nin res.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    math_log10(\"100\", \"$var(res)\");\n    $var(x) = 100;\n    math_log10(\"$var(x)\", \"$var(res)\");\n...\n```\n",
   "math_sqrt": "### `math_sqrt(x, res)`\n\nThe function computes the square root of x and stores the result in res.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    math_sqrt(\"16\", \"$var(res)\");\n    $var(x) = 16;\n    math_sqrt(\"$var(x)\", \"$var(res)\");\n...\n```\n"
  }
 },
 "matrix": {
  "overview": "The matrix module can be used to arbitrary lookup operations over an\narray. One possible use-case is to define which routing tree should be\nused depending on the preferred carrier of the source number and the\ncarrier id of the destination number. The matrix cells are read from a\ndatabase and can be reloaded using a FIFO command. You do not have to\ndefine all matrix cells. The matrix can be sparse. Currently, the\nimplementation is designed for a small number of columns (they are\nstored in a linked list). This does not scale well and has to be\nreplaced by more an efficient data data structure when needed.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThe URL for the database connection.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"matrix\", \"db_url\", \"mysql://kamailioro:kamailioro@localhost/kamailio\")\n...\n          \n```\n",
   "matrix_table": "### `matrix_table` (string)\n\nThe name of the table containing the matrix data.\n\n*Default value is \u201cmatrix\u201d.*\n\n```\n...\nmodparam(\"matrix\", \"matrix_table\", \"matrix\")\n...\n          \n```\n",
   "matrix_first_col": "### `matrix_first_col` (string)\n\nThe name of the column containing the first row in the matrix.\n\n*Default value is \u201cfirst\u201d.*\n\n```\n...\nmodparam(\"matrix\", \"matrix_first_col\", \"first\")\n...\n          \n```\n",
   "matrix_second_col": "### `matrix_second_col` (string)\n\nThe name of the column containing the second row in the matrix.\n\n*Default value is \u201csecond\u201d.*\n\n```\n...\nmodparam(\"matrix\", \"matrix_second_col\", \"second\")\n...\n          \n```\n",
   "matrix_res_col": "### `matrix_res_col` (string)\n\nThe name of the column containing the result ID to be used.\n\n*Default value is \u201cres\u201d.*\n\n```\n...\nmodparam(\"matrix\", \"matrix_res_col\", \"res\")\n...\n          \n```\n"
  },
  "functions": {
   "matrix": "### `matrix (string first, string second, string dstavp)`\n\nLooks up the desired result ID in the matrix for the given column and\nvalue and saves the result in dstavp. Returns false if the cell is not\ndefined or when an error occurred. Pseudo-variables or AVPs can be used\nfor first and second.\n\n```\n...\nif (!matrix(\"$avp(first)\", \"$avp(second)\", \"$avp(route_tree)\"))\n  $avp(route_tree) = $avp(frst); # default routing as defined for source number\n}\ncr_route(\"$avp(route_tree)\", \"$rd\", \"$rU\", \"$rU\", \"call_id\");\n...\n            \n```\n"
  }
 },
 "maxfwd": {
  "overview": "The module implements all of the operations that handle the Max-Forward\nSIP header field, like adding it (if not present) or decrementing and\nchecking the value of the existent one.\n\nThe SIP Max-Forward header is used to prevent loops in a SIP network.\nEvery server that process and forward a SIP request lowers the\nMax-Forward value with one. When the value reaches zero, the request is\nnot forwarded and an error response is sent to the UAC.\n",
  "parameters": {
   "max_limit": "### `max_limit` (integer)\n\nSet an upper limit for the max-forward value in the outgoing requests.\nIf the header is present, the decremented value is not allowed to exceed\nthis max_limits - if it does, the header value will by decreased to\n\u201cmax_limit\u201d.\n\nNote: This check is done when calling the maxfwd_process() function.\n\nThe range of values stretches from 1 to 256, which is the maximum\nMAX-FORWARDS value allowed by RFC 3261. The value can be changed at\nruntime.\n\n*Default value is \u201c70\u201d.*\n\n```\n...\nmodparam(\"maxfwd\", \"max_limit\", 32)\n...\n```\n"
  },
  "functions": {
   "maxfwd_process": "### `maxfwd_process(max_value)`\n\nIf no Max-Forward header is present in the received request, a header\nwill be added having the original value equal with \u201cmax_value\u201d. If a\nMax-Forward header is already present, its value will be decremented (if\nnot 0). The parameter can be a variable.\n\nReturn codes:\n\n- *2 (true)* - header was not found and a new header was successfully\n  added.\n\n- *1 (true)* - header was found and its value was successfully\n  decremented (had a non-0 value).\n\n- *-1 (false)* - the header was found and its value is 0 (cannot be\n  decremented).\n\n- *-2 (false)* - error during processing.\n\nThe return code may be extensively tested via script variable \u201cretcode\u201d\n(or \u201c$?\u201d).\n\nMeaning of the parameters is as follows:\n\n- *max_value* - Value to be added if there is no Max-Forwards header\n  field in the message.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n# initial sanity checks -- messages with\n# max_forwards==0, or excessively long requests\nif (!maxfwd_process(\"10\") && $retcode==-1) {\n    sl_send_reply(\"483\",\"Too Many Hops\");\n    exit;\n};\n...\n```\n",
   "mf_process_maxfwd_header": "### `mf_process_maxfwd_header(max_value)`\n\nSame as maxfwd_process(max_value).\n",
   "process_maxfwd": "### `process_maxfwd(max_value)`\n\nSame as maxfwd_process(max_value).\n",
   "is_maxfwd_lt": "### `is_maxfwd_lt(max_value)`\n\nChecks if the Max-Forward header value is less than the \u201cmax_value\u201d\nparameter value. It considers also the value of the new inserted header\n(if locally added). The parameter can be a variable.\n\nReturn codes:\n\n- *1 (true)* - header was found or set and its value is strictly less\n  than \u201cmax_value\u201d.\n\n- *-1 (false)* - the header was found or set and its value is greater or\n  equal to \u201cmax_value\u201d.\n\n- *-2 (false)* - header was not found or not set.\n\n- *-3 (false)* - error during processing.\n\nThe return code may be extensively tested via script variable \u201cretcode\u201d\n(or \u201c$?\u201d).\n\nMeaning of the parameters is as follows:\n\n- *max_value* - value to check the Max-Forward.value against (as less\n  than).\n\n<!-- -->\n\n\n```\n...\n# next hop is a gateway, so make no sense to\n# forward if MF is 0 (after decrement)\nif ( is_maxfwd_lt(\"1\") ) {\n    sl_send_reply(\"483\",\"Too Many Hops\");\n    exit;\n};\n...\n```\n",
   "maxfwd_at_least": "### `maxfwd_at_least(max_value)`\n\nSame as is_maxfwd_lt(max_value).\n",
   "mf_lowlimit": "### `mf_lowlimit(max_value)`\n\nSame as is_maxfwd_lt(max_value).\n"
  }
 },
 "mediaproxy": {
  "overview": "Mediaproxy is an SIP Router module that is designed to allow automatic\nNAT traversal for the majority of existing SIP clients. This means that\nthere will be no need to configure anything in particular on the NAT box\nto allow these clients to work behind NAT when using the mediaproxy\nmodule.\n",
  "parameters": {
   "disable": "### `disable` (int)\n\nBoolean flag that specifies if mediaproxy should be disabled. This is\nuseful when you want to use the same kamailio configuration in two\ndifferent context, one using mediaproxy, the other not. In the case\nmediaproxy is disabled, calls to its functions will have no effect,\nallowing you to use the same configuration without changes.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"disable\", 1)\n...\n        \n```\n",
   "mediaproxy_socket": "### `mediaproxy_socket` (string)\n\nIt is the path to the filesystem socket where the mediaproxy dispatcher\nlistens for commands from the module.\n\n*Default value is \u201c/run/mediaproxy/dispatcher.sock\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"mediaproxy_socket\", \"/run/mediaproxy/dispatcher.sock\")\n...\n        \n```\n",
   "mediaproxy_timeout": "### `mediaproxy_timeout` (int)\n\nHow much time (in milliseconds) to wait for an answer from the\nmediaproxy dispatcher.\n\n*Default value is \u201c500\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"mediaproxy_timeout\", 500)\n...\n        \n```\n",
   "signaling_ip_avp": "### `signaling_ip_avp` (string)\n\nSpecification of the AVP which holds the IP address from where the SIP\nsignaling originated. If this AVP is set it will be used to get the\nsignaling IP address, else the source IP address from where the SIP\nmessage was received will be used. This AVP is meant to be used in cases\nwhere there are more than one proxy in the call setup path and the proxy\nthat actually starts mediaproxy doesn't receive the SIP messages\ndirectly from the UA and it cannot determine the NAT IP address from\nwhere the signaling originated. In such a case attaching a SIP header at\nthe first proxy and then copying that header's value into the\nsignaling_ip_avp on the proxy that starts mediaproxy will allow it to\nget the correct NAT IP address from where the SIP signaling originated.\n\n*Default value is \u201c$avp(signaling_ip)\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"signaling_ip_avp\", \"$avp(nat_ip)\")\n...\n        \n```\n",
   "media_relay_avp": "### `media_relay_avp` (string)\n\nSpecification of the AVP which holds an optional application defined\nmedia relay IP address of a particular media relay that is preferred to\nbe used for the current call. If an IP address is written to this AVP\nbefore calling use_media_proxy(), it will be preferred by the dispatcher\nover the normal selection algorithm.\n\n*Default value is \u201c$avp(media_relay)\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"media_relay_avp\", \"$avp(media_relay)\")\n...\n        \n```\n",
   "ice_candidate": "### `ice_candidate` (string)\n\nIndicates the type of ICE candidate that will be added to the SDP. It\ncan take 3 values: 'none', 'low-priority' or 'high-priority'. If 'none'\nis selected no candidate will be added to the SDP. If 'low-priority' is\nselected then a low priority candidate will be added and if\n'high-priority' is selected a high priority one.\n\n*Default value is \u201cnone\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"ice_candidate\", \"low-priority\")\n...\n        \n```\n",
   "ice_candidate_avp": "### `ice_candidate_avp` (string)\n\nSpecification of the AVP which holds the ICE candidate that will be\ninserted in the SDP. The value specified in this AVP will override the\nvalue in ice_candidate module parameter. If the AVP is not set, the\ndefault value will be used.\n\n*Default value is \u201c$avp(ice_candidate)\u201d.*\n\n```\n...\nmodparam(\"mediaproxy\", \"ice_candidate_avp\", \"$avp(ice_candidate)\")\n...\n        \n```\n"
  },
  "functions": {
   "engage_media_proxy": "### `engage_media_proxy()`\n\nTrigger the use of MediaProxy for all the dialog requests and replies\nthat have an SDP body. This needs to be called only once for the first\nINVITE in a dialog. After that it will use the dialog module to trace\nthe dialog and automatically call use_media_proxy() on every request and\nreply that belongs to the dialog and has an SDP body. When the dialog\nends it will also call automatically end_media_session(). All of these\nare called internally on dialog callbacks, so for this function to work,\nthe dialog module must be loaded and configured.\n\nThis function is an advanced mechanism to use a media relay without\nhaving to manually call a function on each message that belongs to the\ndialog. However this method is less flexible, because once things were\nset in motion by calling this function on the first INVITE, it cannot be\nstopped, not even by calling end_media_session(). It will only stop when\nthe dialog ends. Until then it will modify the SDP content of every\nin-dialog message to make it use a media relay. If one needs more\ncontrol over the process, like starting to use mediaproxy only later in\nthe failure route, or stopping to use mediaproxy in the failure route,\nthen the use_media_proxy and end_media_session functions should be used,\nand manually called as appropriate. Using this function should NOT be\nmixed with either of use_media_proxy() or end_media_session().\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (method==INVITE && !has_totag()) {\n    # We can also use a specific media relay if we need to\n    #$avp(media_relay) = \"1.2.3.4\";\n    engage_media_proxy();\n}\n...\n        \n```\n",
   "use_media_proxy": "### `use_media_proxy()`\n\nWill make a call to the dispatcher and replace the IPs and ports in the\nSDP body with the ones returned by the media relay for each supported\nmedia stream in the SDP body. This will force the media streams to be\nrouted through the media relay. If a mix of supported and unsupported\nstreams are present in the SDP, only the supported streams will be\nmodified, while the unsupported streams will be left alone.\n\nThis function should NOT be mixed with engage_media_proxy().\n\nThis function has the following return codes:\n\n- +1 - successfully modified message (true value)\n\n- -1 - error in processing message (false value)\n\n- -2 - missing SDP body, nothing to process (false value)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif (method==INVITE) {\n    # We can also use a specific media relay if we need to\n    #$avp(media_relay) = \"1.2.3.4\";\n    use_media_proxy();\n}\n...\n        \n```\n",
   "end_media_session": "### `end_media_session()`\n\nWill call on the dispatcher to inform the media relay to end the media\nsession. This is done when a call ends, to instruct the media relay to\nrelease the resources allocated to that call as well as to save logging\ninformation about the media session. Called on BYE, CANCEL or failures.\n\nThis function should NOT be mixed with engage_media_proxy().\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif (method==BYE) {\n    end_media_session();\n}\n...\n        \n```\n"
  }
 },
 "memcached": {
  "overview": "The module provides access to the distributed hash table *memcached*.\nThis hash table is stored in memory and can can be accessed via a\npseudo-variable: $mct(key). Entries are stored and retrieved from an\nexternal server application.\n\nThe \u201ckey\u201d can be a static string and also any existing pseudo-variable.\nFurther interfaces to the functionality provided from memcached are also\nprovided, like access to the atomic increment and decrement operations.\n\n```\n...\n$mct(test) = 1;\nxlog(\"stored value is $mct(test)\");\n$mct(test) = $null; # delete it\nxlog(\"stored value is $mct(test)\"); # will return <null> or empty string\n...\n            \n\n...\n$mct(cnt) = 1;\n$mcinc(cnt) = 1; # increment by 1\nxlog(\"counter is now $mct(cnt)\");\n$mcdec(cnt) = 1; # decrement by 1\nxlog(\"counter is now $mct(cnt)\");\n...\n            \n\n...\n$mct(test=>10) = 1;\nxlog(\"stored value is $mct(test)\");\n# sleep 10 seconds\nxlog(\"stored value is $mct(test)\"); # will return <null>\n...\n                        \n\n...\n$mct(test) = 1;\nxlog(\"stored value is $mct(test)\");\n$mctex(test) = 10; # set expire time to 10 seconds\n# sleep 10 seconds\nxlog(\"stored value is $mct(test)\"); # will return <null>\n...\n            \n```\n\nThis module is an addition to the existing *htable* functionality, not a\nreplacement. In smaller architectures or installations where only one\ninstance needs access to the hash table the htable module is easier to\nsetup, as no dedicated server needs to be provided. But when a\ndistributed storage facility is necessary, or one want to separate the\nstorage from the SIP server, this module could be used.\n",
  "parameters": {
   "servers": "### `servers` (str)\n\nThe servers to connect to. At the moment only one server is supported.\n\n*Default value is \u201clocalhost:11211\u201d.*\n\n```\n...\nmodparam(\"memcached\", \"servers\", \"localhost:11211\")\n...\n            \n```\n",
   "expire": "### `expire` (integer)\n\nThe default expire value of entries in memcached in seconds. The maximal\nvalue is 2592000 (about 30 days). A value of zero means that no\nautomatic expiration is done, memcached will then delete the least used\nitems when the cache gets full.\n\nPlease note that memcached implements lazy caching, that means items are\nonly deleted when they requested (they are of course not delivered to\nthe client), or on insertion of new entries when the cache is full.\nItems can also be deleted before there expire time when the available\nspace in memory is exhausted.\n\nIt is possible to override this default value when adding a key with the\n*mct* pseudo-variable, or later on by setting a different timeout for an\nexisting key with the *mctex* pseudo-variable.\n\n*Default value is \u201c10800\u201ds (3h).*\n\n```\n...\nmodparam(\"memcached\", \"expire\", 10800)\n...\n```\n",
   "mode": "### `mode` (integer)\n\nThe used storage mode for the memcached module for write access to the\nhash table. A value of \u201c0\u201d means to set (overwrite) the old value, with\na value of \u201c1\u201d the module will not overwrite it. Here every entry to the\nhash table could be written only once, subsequent inserts will fail.\n\n*Default value is \u201c0\u201d (overwrite).*\n\n```\n...\nmodparam(\"memcached\", \"mode\", 0)\n...\n```\n",
   "timeout": "### `timeout` (integer)\n\nThe timeout for the memcache servers access in milliseconds.\n\n*Default value is \u201c5000\u201d (5s).*\n\n```\n...\nmodparam(\"memcached\", \"timeout\", 10000)\n...\n            \n```\n",
   "memory": "### `memory` (integer)\n\nThe memory mode for the memcached client library. The library can use\nthe system memory manager or the internal memory manager from Kamailio.\nThe system memory manager configuration is the default, most\nimplementations (like other projects) probably use this approach as\nwell. The internal memory configuration should be faster and protects\nbetter against memory leaks that could bring down your server, as the\navailable memory pool is limited by the Kamailio configuration.\n\n*Default value is \u201c0\u201d (use system memory manager).*\n\n```\n...\nmodparam(\"memcached\", \"memory\", 1)\n...\n            \n```\n",
   "stringify": "### `stringify` (integer)\n\nThe string mode for the memcached module. By default the module checks\nthe flags for each returned value from the memcached library to decide\nto evaluate it as string or numerical value. If you need\ninteroperability with existing applications that are not able to set\nthis flag, you can force the module to evaluate all values as strings.\n\n*Default value is \u201c0\u201d (don't force string values).*\n\n```\n...\nmodparam(\"memcached\", \"stringify\", 1)\n...\n            \n```\n"
  },
  "functions": {}
 },
 "microhttpd": {
  "overview": "This module implements an embedded HTTP server using libmicrohttpd.\n",
  "parameters": {
   "listen_addr": "### `listen_addr` (int)\n\nIPv4 address to listen for HTTP connection. If not set, then it listens\non all local addresses (port has to be specified by listen_port\nparameter).\n\n*Default value is \"\" (empty - not set).*\n\n```\n...\nmodparam(\"microhttpd\", \"listen_addr\", \"127.0.0.1\")\n...\n```\n",
   "listen_port": "### `listen_port` (int)\n\nPort to listen for HTTP connection.\n\n*Default value is 8280.*\n\n```\n...\nmodparam(\"microhttpd\", \"listen_port\", 8284)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[microhttpd:request] block.\n\nThe function has one string parameter with the value\n\"microhttpd:request\".\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"microhttpd\", \"event_callback\", \"ksr_microhttpd_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_microhttpd_event(evname)\n    KSR.info(\"===== microhttpd module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n"
  },
  "functions": {
   "mhttpd_reply": "### `mhttpd_reply(code, reason, ctype, body)`\n\nSend back a reply with content-type and body.\n\n```\n...\nevent_route[microhttpd:request] {\n    mhttpd_reply(\"200\", \"OK\", \"text/html\",\n        \"<html><body>OK</body></html>\");\n}\n...\n```\n"
  }
 },
 "misc_radius": {
  "overview": "The *misc_radius* module implements various RADIUS related functions.\nFunctions exist for loading caller's or callee's attributes into AVPs,\nchecking if user belongs to a group, and checking if a specific URI\nbelongs to a user. It thus replaces old avp_radius, group_radius, and\nuri_radius modules.\n\nAll functions of this module load AVPs from SIP-AVP reply items received\nfrom RADIUS upon a successful request. Value of the SIP-AVP reply item\nmust be a string of form:\n\n- *value = SIP_AVP_NAME SIP_AVP_VALUE*\n\n- *SIP_AVP_NAME = STRING_NAME | '#'ID_NUMBER*\n\n- *SIP_AVP_VALUE = ':'STRING_VALUE | '#'NUMBER_VALUE*\n\n<!-- -->\n\n\n```\n....\n\"email:joe@yahoo.com\"\n    -> STRING NAME AVP (email) with STRING VALUE (joe@yahoo.com)\n\"#14:joe@yahoo.com\"\n    -> ID AVP (14) with STRING VALUE (joe@yahoo.com)\n\"age#28\"\n    -> STRING NAME AVP (age) with INTEGER VALUE (28)\n\"#14#28\"\n    -> ID AVP (14) with INTEGER VALUE (28)\n....\n```\n\nUnlike in old avp_radius module, functions\nradius_load_calle[re]_avps() do not prefix string names of AVPs by\nstring \u201ccaller_\u201d or \u201ccallee_\u201d depending if caller's or callee's\nattributes were loaded. If you need these prefixes, make your RADIUS\nserver to prepend them into attribute names when it constructs reply\nitems.\n\nA new feature of misc_radius module is that it is now possible to\ninclude user defined extra RADIUS attributes in all requests send by\nfunctions of this module.\n",
  "parameters": {
   "radius_config": "### `radius_config` (string)\n\nThis is the location of the configuration file of radius client\nlibraries.\n\nDefault value is \u201c/usr/local/etc/radiusclient-ng/radiusclient.conf\u201d.\n\n```\n...\nmodparam(\"misc_radius\", \"radius_config\", \"/etc/radiusclient.conf\")\n...\n```\n",
   "caller_service_type": "### `caller_service_type` (integer)\n\nThis is the value of the Service-Type radius attribute to be used, when\ncaller's attributes are loaded.\n\nDefault value is dictionary value of \u201cSIP-Caller-AVPs\u201d Service-Type.\n\n```\n...\nmodparam(\"misc_radius\", \"caller_service_type\", 18)\n...\n```\n",
   "callee_service_type": "### `callee_service_type` (integer)\n\nThis is the value of the Service-Type radius attribute to be used, when\ncallee's attributes are loaded.\n\nDefault value is dictionary value of \u201cSIP-Callee-AVPs\u201d Service-Type.\n\n```\n...\nmodparam(\"misc_radius\", \"callee_service_type\", 19)\n...\n```\n",
   "group_service_type": "### `group_service_type` (integer)\n\nThis is the value of Service-Type RADIUS attribute to be used, when\nradius_is_user_in() function is called.\n\nDefault value is dictionary value of \u201cGroup-Check\u201d Service-Type.\n\n```\n...\nmodparam(\"misc_radius\", \"group_service_type\", 20)\n...\n```\n",
   "uri_service_type": "### `uri_service_type` (integer)\n\nThis is the value of Service-Type RADIUS attribute to be used, when\nradius_does_uri[_user]_exist() function is called.\n\nDefault value is dictionary value of \u201cCall-Check\u201d Service-Type.\n\n```\n...\nmodparam(\"misc_radius\", \"uri_service_type\", 21)\n...\n```\n",
   "caller_extra": "### `caller_extra` (string)\n\nSemi-colon separated list of extra RADIUS attribute name=pseudo variable\npairs. When radius_load_caller_avps() is called, the listed extra\nattributes are included RADIUS request with current values of\ncorresponding pseudo variables.\n\nThere is no default value, i.e., by default no extra attributes are\nincluded.\n\n```\n...\nmodparam(\"misc_radius\", \"caller_extra\", \"Calling-Station-Id=$fu\")\n...\n```\n",
   "callee_extra": "### `callee_extra` (string)\n\nSemi-colon separated list of extra RADIUS attribute name=pseudo variable\npairs. When radius_load_callee_avps() is called, the listed extra\nattributes are included RADIUS request with current values of\ncorresponding pseudo variables.\n\nThere is no default value, i.e., by default no extra attributes are\nincluded.\n\n```\n...\nmodparam(\"misc_radius\", \"callee_extra\", \"SIP-URI-User=$rU;SIP-URI-Host=$rd\")\n...\n```\n",
   "group_extra": "### `group_extra` (string)\n\nSemi-colon separated list of extra RADIUS attribute name=pseudo variable\npairs. When radius_is_user_in() is called, the listed extra attributes\nare included RADIUS request with current values of corresponding pseudo\nvariables.\n\nThere is no default value, i.e., by default no extra attributes are\nincluded.\n\n```\n...\nmodparam(\"misc_radius\", \"group_extra\", \"My-Special=$avp(i:100)\")\n...\n```\n",
   "uri_extra": "### `uri_extra` (string)\n\nSemi-colon separated list of extra RADIUS attribute name=pseudo variable\npairs. When radius_does_uri[_user]_exist() function is called, the\nlisted extra attributes are included in RADIUS request with current\nvalues of corresponding pseudo variables.\n\nThere is no default value, i.e., by default no extra attributes are\nincluded.\n\n```\n...\nmodparam(\"misc_radius\", \"uri_extra\", \"Called-Station-Id=$tu\")\n...\n```\n",
   "use_sip_uri_host": "### `use_sip_uri_host` (integer)\n\nIf zero, radius_does_uri_exist() function sends to RADIUS server\nuserpart@hostpart in UserName attribute. If non-zero,\nradius_does_uri_exist() function sends to RADIUS server userpart in\nUserName attribute and hostpart in SIP-URI-Host attribute.\n\nDefault value is 0 (only use UserName attribute).\n\n```\n...\nmodparam(\"misc_radius\", \"use_sip_uri_host\", 1)\n...\n```\n",
   "common_response": "### `common_response` (integer)\n\nSet it to 1 if you need common radius response attributes to be added as\nAVPs in `radius_load_caller_avps` and `radius_load_callee_avps` with\nname as radius attribute name and value as radius attribute value.\n\nDefault value is \u201c0\u201d.\n\n```\n...\nmodparam(\"misc_radius\", \"common_response\", 1)\n...\nradius_load_caller_avps($fU);\n...\n\n...\n    Sending Access-Accept of id 60 to 192.168.25.32 port 59736\n    Session-Timeout = 4261674\n    next-hop-ip = \"SIP/00111222333444@cisco-out\"\n    SIP-AVP = \"email:sr-users@lists.kamailio.org session-timeout#161 next-hop-ip:h323/0001111@myvoip-gate.kamailio.org\"\n    session-protocol = \"SIP\"\n...\n\n$avp(Session-Timeout) has integer value 4261674\n$avp(next-hop-ip) has string value \"SIP/005555777888@cisco-out\"\n$avp(session-protocol) has string value \"SIP\"\n$avp(SIP-AVP) has string value  \"email:sr-users@lists.kamailio.org session-timeout#161 next-hop-ip:h323/0001111@myvoip-gate.kamailio.org\"\n\n...\n    When receiving negative response, check appropriate avp's:\n    $avp(Reply-Message) = \"Not enough money on deposit '-89.83'. Rejected\"\n    $avp(Filter-Id) = \"neg_deposit\"\n...\n```\n"
  },
  "functions": {
   "radius_load_caller_avps": "### `radius_load_caller_avps(caller)`\n\nThe functions loads caller's attributes from radius and stores them into\nAVPs. Parameter \u201ccaller\u201d is a string that may contain pseudo variables.\nIt indicates the user, whose attributes are loaded.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nradius_load_caller_avps(\"$fU@$fd\"); # take caller from From URI\n...\nradius_load_caller_avps(\"$au@$ar\"); # take caller from Authorization\n...                 # or Proxy-Authorization header\n```\n",
   "radius_load_callee_avps": "### `radius_load_callee_avps(callee)`\n\nThe functions loads callee's attributes from radius and stores them into\nAVPs. Parameter \u201ccallee\u201d is a string that may contain pseudo variables.\nIt indicates the user, whose attributes are loaded.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nradius_load_callee_avps(\"$rU@$rd\"); # take callee from Request-URI\n...\n```\n",
   "radius_is_user_in": "### `radius_is_user_in(user, group)`\n\nThe functions checks from RADIUS, if user given in first argument\nbelongs to group given in second argument. Both arguments are strings,\nbut user string may also contain pseudo variables. In case of positive\nresult, loads AVPs from SIP-AVP reply items, if any.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n```\n...\nradius_is_user_in(\"$rU@$rd\", \"1\");  # take user from Request-URI\n...\nradius_is_user_in(\"$au@$ar\", \"group_x\");# take user from credentials\n...\n```\n",
   "radius_does_uri_exist": "### `radius_does_uri_exist([uri])`\n\nChecks from RADIUS if userpart@hostpart of Request-URI or of an URI\nstored in optional pseudo variable argument belongs to a local user. In\ncase of positive result, loads AVPs from SIP-AVP reply items, if any.\n\nThis function can be used from REQUEST_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (radius_does_uri_exist()) ...    # check Request-URI\n...\nif (radius_does_uri_exist(\"$avp(i:99)\")) ...    # check URI in $avp(i:99)\n...\n```\n",
   "radius_does_uri_user_exist": "### `radius_does_uri_user_exist([user])`\n\nSimilar to radius_does_uri_exist, but check is done based only on\nRequest-URI userpart or userpart stored in optional pseudo variable\nargument. Userpart should thus be unique among all user URIs, such as an\nE.164 number. In case of positive result, loads AVPs from SIP-AVP reply\nitems, if any.\n\nThis function can be used from REQUEST_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (radius_does_uri_user_exist()) ...   # check Request-URI userpart\n...\nif (radius_does_uri_exist(\"$fU\")) ...   # check From URI userpart\n...\n```\n"
  }
 },
 "misctest": {
  "overview": "This is a debugging/test module. It implements functions (both script\nand rpcs) that can be used to stress the memory allocator or force\nmemory leaks.\n\n<div class=\"warning\">\n\n\nThis module should never be used in a production environment.\n\n</div>\n",
  "parameters": {
   "memory": "### `memory` (int)\n\nInitialize for memory testing. Set it to 1 to prepare the memory\ntesting.\n\nDefault: 0 (off).\n\n```\n...\nmodparam(\"misctest\", \"memory\", 1)\n...\n            \n```\n",
   "mem_check_content": "### `mem_check_content` (int)\n\nWhen doing the tests, check also for the possibility of the memory being\noverwritten. When activated, the allocated memory will be filled with a\nspecial pattern, that will be checked on free.\n\nDefault: 0 (off).\n\nIt can be changed also at runtime, via the rpc interface.\n\n```\n...\nmodparam(\"misctest\", \"mem_check_content\", 1)\n...\n            \n\n...\n$ kamcmd cfg.seti misctest mem_check_content 1\n...\n            \n```\n",
   "message": "### `message` (int)\n\nInitialize and perform message testing.\n\nDefault: 0 (off).\n\n```\n...\nmodparam(\"misctest\", \"message\", 1)\n...\n            \n```\n",
   "message_data": "### `message_data` (str)\n\nSet SIP message data for testing.\n\nDefault: NULL (not set).\n\n```\n...\nmodparam(\"misctest\", \"message_data\", \"...\")\n...\n            \n```\n",
   "message_file": "### `message_file` (str)\n\nSet path to file from where to read SIP message data for testing.\n\nDefault: NULL (not set).\n\n```\n...\nmodparam(\"misctest\", \"message_file\", \"/tmp/sip-data.txt\")\n...\n            \n```\n"
  },
  "functions": {
   "mt_mem_alloc": "### `mt_mem_alloc(size)`\n\nAllocates size bytes.\n\n<div class=\"note\">\n\n\nThis is a debugging function for simulating memory leaks or stressing\nthe memory allocator. It should not be used in production setups\n\n</div>\n\n\n```\n...\nmem_alloc(1048576); # 1MB\n...\n            \n```\n",
   "mt_mem_free": "### `mt_mem_free()`\n\nFrees all the memory allocated with mem_alloc() up to this point.\n\n<div class=\"note\">\n\n\nThis is a debugging function for simulating memory leaks or stressing\nthe memory allocator. It should not be used in production setups\n\n</div>\n\n\n```\n...\nmem_free();\n...\n            \n```\n"
  }
 },
 "mohqueue": {
  "overview": "The mohqueue module diverts INVITE requests into a [Music On Hold\n(MOH)](http://en.wikipedia.org/wiki/Music_on_hold) queue where the\ncaller can listen to recorded audio until an operator is available to\ntake the call. When an operator is available, a function can be used to\ntransfer the oldest call in a queue to an operator using an unattended\ntransfer (REFER) to a specified URI. If successful, the call is removed\nfrom the queue.\n\nWhile in queue, recorded audio is streamed to the caller in an endless\nloop using the rtpproxy module and application. Each queue can be\nconfigured to use different audio files.\n\nThe queues are defined in the database which allows for dynamic\nconfiguration of the queues. Each queue is assigned a specific URI to\nrespond to and a location for the audio files.\n\nAs each call arrives the database is updated to show the call status\nwhich allows outside processes to inspect the queue. It can also be\ninspected using a function to see how many calls are currently in queue.\n\nWhile in queue, all SIP messages for a call must pass through the\nmohqueue module so that it can accurately detect the call status.\n",
  "parameters": {
   "db_url": "### `db_url` (str)\n\nThe URL to connect to the database for the mohqueue tables.\n\n*Default is the same value used by Kamailio.*\n\n```\n...\nmodparam (\"mohqueue\", \"db_url\", \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n...\n        \n```\n",
   "db_qtable": "### `db_qtable` and `db_ctable` (str)\n\n`db_qtable` is the name of the table that defines the queues and\n`db_ctable` is the table that maintains the call status.\n\n*Default is \"MOHQUEUES\" for `db_qtable` and \"MOHQCALLS\" for\n`db_ctable`.*\n\n```\n...\nmodparam (\"mohqueue\", \"db_qtable\", \"mqueues\")\nmodparam (\"mohqueue\", \"db_ctable\", \"mcalls\")\n...\n        \n```\n",
   "mohdir": "### `mohdir` (str)\n\nPath to the directory where the audio files are stored. Audio files are\nusually relative to this directory although the value can be overridden\nby a directory specified in the queues table.\n\n*Default is None. If not set by the module it must be defined in the\nqueues table.*\n\n```\n...\nmodparam (\"mohqueue\", \"mohdir\", \"/var/kamailio/MOH\")\n...\n        \n```\n",
   "moh_maxcalls": "### `moh_maxcalls` (integer)\n\nDefines the maximum number of calls that can be placed in queue. It is\nthe sum of all calls in all queues. It must be in the range of 1 to\n5000. *NOTE:* it may be limited by the processing power of the server or\nthe number of available rtpproxy ports.\n\n*Default value is 50.*\n\n```\n...\nmodparam (\"mohqueue\", \"moh_maxcalls\", 200)\n...\n        \n```\n"
  },
  "functions": {
   "mohq_process": "### `mohq_process ()`\n\nChecks to see if the current SIP message involves a queue. If it does it\nwill process the message and return a TRUE value.\n\nIn order for mohqueue to detect changes in the call it is necessary that\nall messages involving the call be processed through this function. The\neasiest way is to accomplish this is to place it at the beginning of the\nmain route of the script.\n\nmohqueue calls are identified by an RURI that matches a queue URI. Once\na call is placed in queue it checks the `To` header field along with the\nRURI to find a match, except in the case of a CANCEL which matches only\non the RURI.\n\nThis function has no parameters and must be called from a request route.\n\n*Return code:*\n\n- TRUE=successful and call in queue\n- FALSE=failed, unrecognized URI or unable to place in queue\n\n<!-- -->\n\n\n```\n...\nrequest_route {\n  # main route with limited processing\n...\n  # MOH queue?\n  if (mohq_process ()) {\n    xlog (\"L_DBG\", \"Handled by mohqueue\");\n    exit;\n  }\n  # An error or not a MOH queue message; continue processing\n...\n}\n...\n        \n```\n",
   "mohq_send": "### `mohq_send (queue_name)`\n\nNormally calls enter the queue with an initial INVITE message that 1)\nhas a RURI that matches a queue URI and 2) is passed through\n`mohq_process ()`, which is the preferred method.\n\nThis function is used when you wish to send a call into a queue that\ndoes not match the queue URI.\n\nIt has only one parameter, the name of the queue, and must be called\nfrom the request route with an initial INVITE message. The queue name\ncan be passed as a literal or pseudo-variable.\n\n*Return code:*\n\n- TRUE=successful and call in queue\n- FALSE=failed, unable to place in queue\n\n<!-- -->\n\n\n```\n...\n  # call is initial INVITE and ready for queue?\n  if (some test) {\n    if (mohq_send (\"main\")) {\n      xlog (\"L_DBG\", \"Sent call to main mohqueue\");\n      exit;\n    }\n    # failed to enter queue!\n    ...\n  }\n...\n        \n```\n",
   "mohq_retrieve": "### `mohq_retrieve (queue_name, URI)`\n\nRetrieves the oldest call in a queue and redirects it to a URI. Although\nthe function returns, the transfer of the call may not have completed\nsince the new URI (operator) must answer the call.\n\nIt has two parameters, the queue name and the URI to REFER the call to,\nboth which can be passed as literals or pseudo-variables. It can be\ncalled from any route.\n\n*Return code:*\n\n- TRUE=successful, transfer started\n- FALSE=failed, parameters are incorrect or there are no calls in queue\n\n<!-- -->\n\n\n```\n...\n#!define MOHQNAME \"operators\"\n#!define CGROUP   \"sip:operators@10.211.64.5\"\n...\n  # redirect oldest call to operator call group\n  if (mohq_retrieve (MOHQNAME, CGROUP)) {\n      xlog (\"L_DBG\", \"Retrieved call from mohqueue\");\n      exit;\n  }\n  # queue is empty or something went wrong\n...\n        \n```\n",
   "mohq_count": "### `mohq_count (queue_name, pvar)`\n\nFinds the number of calls that are in a queue. It will not count calls\nthat are in the process of entering or exiting the queue.\n\nThe function has two parameters, the name of the queue and the\npseudo-variable which receives the count. The queue name can be passed\nas a literal or a pseudo-variable. It can be called from any route.\n\n*Return code:*\n\n- TRUE=successful, pseudo-variable contains count\n- FALSE=failed, parameters are incorrect\n\n<!-- -->\n\n\n```\n...\n$var(mohq) = \"operators\";\n...\n  # more than 10 calls?\n  mohq_count (\"$var(mohq)\", \"$var(mohqcnt)\");\n  if ($var(mohqcnt) > 10) {\n    xlog (\"L_WARN\", \"$var(mohq) queue has $var(mohqcnt) calls!\");\n  }\n...\n        \n```\n"
  }
 },
 "mqtt": {
  "overview": "The MQTT module allows bidirectional publish/subscribe communication by\nconnecting Kamailio to a MQTT Broker.\n\nMessages can be published from any point in the routing script. Also the\nsubscriptions can be fully controlled by scripting commands.\n",
  "parameters": {
   "host": "### `host` (str)\n\nMQTT Broker IP/Hostname.\n\n*No default, this parameter is mandatory.*\n\n```\n...\nmodparam(\"mqtt\", \"host\", \"1.2.3.4\")\n...\n```\n",
   "port": "### `port` (int)\n\nMQTT Broker port number.\n\n*Default value is 1883.*\n\n```\n...\nmodparam(\"mqtt\", \"port\", 1883)\n...\n```\n",
   "keepalive": "### `keepalive` (int)\n\nThe number of seconds after which the broker should send a PING message\nto the kamailio if no other messages have been exchanged in that time.\n\n*Default value is 5.*\n\n```\n...\nmodparam(\"mqtt\", \"keepalive\", 5)\n...\n```\n",
   "id": "### `id` (str)\n\nString to use as the mqtt client id. If NULL, a random client id will be\ngenerated.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"mqtt\", \"id\", \"kamailio123\")\n...\n```\n",
   "username": "### `username` (str)\n\nThe username to send as a string or NULL to disable authentication.\n\n*Default value is NULL (no authentication). Must be used together with\n`password`.*\n\n```\n...\nmodparam(\"mqtt\", \"username\", \"kamailio-user\")\n...\n```\n",
   "password": "### `password` (str)\n\nThe password to send as a string or NULL to disable authentication.\n\n*Default value is NULL (no authentication). Must be used together with\n`username`.*\n\n```\n...\nmodparam(\"mqtt\", \"password\", \"supers3cre7\")\n...\n```\n",
   "will_topic": "### `will_topic` (str)\n\nThe topic on which to publish the mqtt will.\n\n*Default value is NULL. Must be used together with `will`.*\n\n```\n...\nmodparam(\"mqtt\", \"will_topic\", \"kamailio123\")\n...\n```\n",
   "will": "### `will` (str)\n\nThe mqtt will payload to be published.\n\n*Default value is NULL. Must be used together with `will_topic`.*\n\n```\n...\nmodparam(\"mqtt\", \"will\", \"gone\")\n...\n        \n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues are: 'mqtt:connected', 'mqtt:disconnected', 'mqtt:message'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"mqtt\", \"event_callback\", \"ksr_mqtt_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_mqtt_event(evname)\n    KSR.info(\"===== mqtt module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n\n-- event callback function implemented in Python\nfunction ksr_mqtt_event(self, msg, evname)\n    KSR.info(\"===== mqtt module triggered event: %s\\n\" % evname);\n    return 1;\nend\n...\n```\n",
   "ca_file": "### `ca_file` (str)\n\nPath to a file containing the PEM encoded trusted CA certificate files.\n\n*Default value is NULL. Set either this parameter or `ca_path` if you\nwant to connect via TLS.*\n\n```\n...\nmodparam(\"mqtt\", \"ca_file\", \"/etc/ssl/certs/myca.pem\")\n...\n        \n```\n",
   "ca_path": "### `ca_path` (str)\n\nUsed to define a directory that contains PEM encoded CA certificates\nthat are trusted. For `ca_path` to work correctly, the certificates\nfiles must have \".pem\" as the file ending and you must run \"openssl\nrehash /your/ca_path\" each time you add/remove a certificate.\n\n*Default value is NULL. Set either this parameter or `ca_file` if you\nwant to connect via TLS. `ca_file` and `ca_path` are mutual exclusive.*\n\n```\n...\nmodparam(\"mqtt\", \"ca_path\", \"/etc/ssl/certs\")\n...\n        \n```\n",
   "tls_method": "### `tls_method` (str)\n\nThe version of the SSL/TLS protocol to use as a string. If NULL, the\ndefault value is used. The default value and the available values depend\non the version of openssl that libmosquitto was compiled against.\n\nPossible values:\n\n- tlsv1.3 is available with openssl >= 1.1.1 together with libmosquitto\n  v1.6.8 and newer.\n\n- For openssl >= 1.0.1, the available options are tlsv1.2, tlsv1.1 and\n  tlsv1, with tlv1.2 as the default.\n\n- For openssl < 1.0.1, only tlsv1 is available.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"mqtt\", \"tls_method\", \"tlsv1.3\")\n...\n        \n```\n",
   "tls_alpn": "### `tls_alpn` (str)\n\nUsed to set the TLS ALPN option for cases where one TLS port is used to\nshare multiple services. Prominent example is AWS IoT, where you have to\nset the `tls_alpn` to \"mqtt\" to be able to connect via MQTT.\n\n*Default value is NULL, where no ALPN is set on the TLS connection.*\n\n```\n...\nmodparam(\"mqtt\", \"tls_alpn\", \"mqtt\")\n...\n        \n```\n",
   "certificate": "### `certificate` (str)\n\nPath to a file containing the PEM encoded certificate file for a TLS\nclient connection.\n\n*Default value is NULL. If NULL, `private_key` must also be NULL and no\nclient certificate will be used.*\n\n```\n...\nmodparam(\"mqtt\", \"certificate\", \"/etc/ssl/certs/myclient.pem\")\n...\n        \n```\n",
   "private_key": "### `private_key` (str)\n\nPath to a file containing the PEM encoded private key for a TLS client\nconnection.\n\n*Default value is NULL. If NULL, `certificate` must also be NULL and no\nclient certificate will be used.*\n\n```\n...\nmodparam(\"mqtt\", \"private_key\", \"/etc/ssl/private/myclient.key\")\n...\n        \n```\n",
   "cipher_list": "### `cipher_list` (str)\n\nA string describing the ciphers available for use. See the\n[cipher(1)](https://www.openssl.org/docs/manmaster/man1/ciphers.html)\nOpenSSL man page. If NULL, the libssl default ciphers will be used.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"mqtt\", \"cipher_list\", \"HIGH\")\n...\n        \n```\n",
   "verify_certificate": "### `verify_certificate` (str)\n\nConfigure verification of the server certificate. If value is set to 0,\nit is impossible to guarantee that the host you are connecting to is not\nimpersonating your server.\n\nThis can be useful in initial server testing, but makes it possible for\na malicious third party to impersonate your server through DNS spoofing,\nfor example.\n\nDo not disable verification in a real system as it makes the connection\nencryption pointless.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"mqtt\", \"verify_certificate\", \"0\")\n...\n        \n```\n"
  },
  "functions": {
   "mqtt_subscribe": "### `mqtt_subscribe(topic, qos)`\n\nSubscribe to the given topic. Mqtt qos levels 0, 1 and 2 can be used.\n\nThe function is passing the task to mqtt dispatcher process, therefore\nthe SIP worker process is not blocked.\n\nIncoming messages for this topic are then handled by the same process\nand exposed to the event_route[mqtt:message].\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmqtt_subscribe(\"kamailio/script\", 0);\n...\n```\n",
   "mqtt_unsubscribe": "### `mqtt_unsubscribe(topic)`\n\nUnsubscribe to a previously subscribed topic. The mqtt broker will stop\nforwarding messages for this topic.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmqtt_unsubscribe(\"kamailio/script\");\n...\n```\n",
   "mqtt_publish": "### `mqtt_publish(topic, message, qos)`\n\nSend out a message to a topic with a specified mqtt qos level (0, 1, 2).\nAgain the actual sending is done in a mqtt dispatcher process and will\nnot block the SIP worker.\n\n```\n...\nmqtt_publish(\"kamailio/event\", \"some message\", 0);\n...\n```\n"
  }
 },
 "mqueue": {
  "overview": "The mqueue module offers a generic message queue system in shared memory\nfor inter-process communication using the config file. One example of\nusage is to send time consuming operations to one or several timer\nprocesses that consumes items in the queue, without affecting SIP\nmessage handling in the socket-listening process.\n\nThere can be many defined queues. Access to queued values is done via\npseudo variables.\n",
  "parameters": {
   "db_url": "### `db_url` (str)\n\nThe URL to connect to database for loading values in mqueue table at\nstart up and/or saving values at shutdown.\n\n*Default value is NULL (do not connect).*\n\n```\n...\nmodparam(\"mqueue\", \"db_url\", \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n\n# Example of table in sqlite, you have the set the fields to support the length according to the data that will be present in the mqueue\nCREATE TABLE mqueue_name (\nid INTEGER PRIMARY KEY AUTOINCREMENT,\nkey character varying(64) DEFAULT \"\" NOT NULL,\nval character varying(4096) DEFAULT \"\" NOT NULL\n);\n...\n```\n",
   "mqueue": "### `mqueue` (string)\n\nDefinition of a memory queue\n\n*Default value is \u201cnone\u201d.*\n\nValue must be a list of parameters: attr=value;...\n\n- Mandatory attributes:\n\n  - *name*: name of the queue.\n\n- Optional attributes:\n\n  - *size*: size of the queue. Specifies the maximum number of items in\n    queue. If exceeded the oldest one is removed. If not set the queue\n    will be limitless.\n\n  - *dbmode*: If set to 1, the content of the queue is read from\n    database at startup and is written to database table when the SIP\n    server is stopped (i.e., ensure persistency over restarts). If set\n    to 2, it is read at startup but not written at shutdown. If set to\n    3, it is written at shutdown but not read at startup. Default value\n    is 0 (no db table interaction).\n\n  - *addmode*: how to add new (key,value) pairs.\n\n    - *0*: Will push all new (key,value) pairs at the end of the queue.\n      (default)\n\n    - *1*: Will keep oldest (key,value) pair in the queue, based on the\n      key.\n\n    - *2*: Will keep newest (key,value) pair in the queue, based on the\n      key.\n\nThe parameter can be set many times, each holding the definition of one\nqueue.\n\n```\n...\nmodparam(\"mqueue\", \"mqueue\", \"name=myq;size=20;\")\nmodparam(\"mqueue\", \"mqueue\", \"name=myq;size=10000;addmode=2\")\nmodparam(\"mqueue\", \"mqueue\", \"name=qaz\")\nmodparam(\"mqueue\", \"mqueue\", \"name=qaz;addmode=1\")\n...\n```\n",
   "mqueue_name": "### `mqueue_name` (string)\n\nDefinition of a memory queue, just by name.\n\n*Default value is \u201cnone\u201d.*\n\nValue must be a string.\n\nThe parameter can be set many times, each holding the definition of one\nqueue. The max size of each queue defined this way will be equal to\nmqueue_size(if mqueue_size configured), or limitless (if mqueue_size not\nconfigured).\n\n```\n...\nmodparam(\"mqueue\", \"mqueue_name\", \"my_own_queue\")\n...\n        \n```\n",
   "mqueue_size": "### `mqueue_size` (int)\n\nDefinition of the size of all memory queues defined via \"mqueue_name\"\nparameter.\n\n*Default value is \u201c0\u201d.*\n\nValue must be an int.\n\nThe parameter should be set before defining any \"mqueue_name\". If not\nset, the queues defined via \"mqueue_name\" will be limitless.\n\n```\n...\nmodparam(\"mqueue\", \"mqueue_size\", 1024)\n...\n        \n```\n",
   "mqueue_addmode": "### `mqueue_addmode` (int)\n\nSets the mode to be used when adding a new (key,value) pair in the\nmqueue.\n\n- *0* Add all new (key,value) at the end of mqueue\n\n- *1* Unique key, keep oldest (key,value)\n\n- *2* Unique key, keep newest(key,value)\n\n*Default value is \u201c0\u201d.*\n\nValue must be an int.\n\nThe parameter should be set before defining any \"mqueue_name\". If not\nset, the queues defined via \"mqueue_name\" will have default addmode 0.\n\n```\n...\nmodparam(\"mqueue\", \"mqueue_addmode\", 2)\n...\n        \n```\n"
  },
  "functions": {
   "mq_add": "### `mq_add(queue, key, value)`\n\nAdd a new item (key, value) in the queue. If max size of queue is\nexceeded, the oldest one is removed.\n\n```\n...\nmq_add(\"myq\", \"$rU\", \"call from $fU\");\n...\n```\n",
   "mq_fetch": "### `mq_fetch(queue)`\n\nTake oldest item from queue and fill $mqk(queue) and $mqv(queue)\npseudo variables.\n\nReturn: true on success (1); false on failure (-1) or no item fetched\n(-2).\n\n```\n...\nwhile(mq_fetch(\"myq\"))\n{\n   xlog(\"$mqk(myq) - $mqv(myq)\\n\");\n}\n...\n```\n",
   "mq_pv_free": "### `mq_pv_free(queue)`\n\nFree the item fetched in pseudo-variables. It is optional, a new fetch\nfrees the previous values.\n\n```\n...\nmq_pv_free(\"myq\");\n...\n```\n",
   "mq_size": "### `mq_size(queue)`\n\nReturns the current number of elements in the mqueue.\n\nIf the mqueue is empty, the function returns -1. If the mqueue is not\nfound, the function returns -2.\n\n```\n...\n$var(q_size) = mq_size(\"queue\");\nxlog(\"L_INFO\", \"Size of queue is: $var(q_size)\\n\");\n...\n```\n"
  }
 },
 "msilo": {
  "overview": "This module provides offline message storage for Kamailio SIP Server\nPlatform. It stores received messages for an offline user and sends them\nwhen the user comes back online. It can also send reminders and\nauto-expire messages.\n\nFor each message, the module stores \u201cRequest-URI\u201d (\u201cR-URI\u201d) only if it\nis a complete address of record (\u201cusername@hostname\u201d), URI from \u201cTo\u201d\nheader, URI from \u201cFrom\u201d header, incoming time, expiration time, content\ntype and body of the message. If \u201cR-URI\u201d is not an address of record (it\nmight be the contact address for current SIP session) the URI from \u201cTo\u201d\nheader will be used as R-URI.\n\nWhen the expiration time is passed, the message is discarded from\ndatabase. Expiration time is computed based on incoming time and one of\nthe module's parameters.\n\nEvery time when a user registers with Kamailio, the module is looking in\ndatabase for offline messages intended for that user. All of them will\nbe sent to contact address provided in REGISTER request and then be\ndeleted.\n\nIt may happen that the SIP user registering use a SIP User Agent that\nhas no support for MESSAGE requests. In this case the \u201cfailure_route\u201d\nshould be used to re-store the undelivered requests.\n\nAnother functionality provided by the MSILO module is to send messages\nat a certain time -- the reminder functionality. Using config logic, a\nreceived message can be stored and delivered at a time specified while\nstoring with the 'snd_time_avp'.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nDatabase URL.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_table": "### `db_table` (string)\n\nThe name of table where to store the messages.\n\n*Default value is \u201csilo\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"db_table\", \"silo\")\n...\n```\n",
   "sc_mid": "### `sc_mid` (string)\n\nThe name of the column in silo table used to store the message id.\n\nDefault value is \u201cmid\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_mid\", \"other_mid\")\n...\n```\n",
   "sc_from": "### `sc_from` (string)\n\nThe name of the column in silo table, storing the source address.\n\nDefault value is \u201csrc_addr\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_from\", \"source_address\")\n...\n```\n",
   "sc_to": "### `sc_to` (string)\n\nThe name of the column in silo table, storing the destination address.\n\nDefault value is \u201cdst_addr\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_to\", \"destination_address\")\n...\n```\n",
   "sc_uri_user": "### `sc_uri_user` (string)\n\nThe name of the column in silo table, storing the user name.\n\nDefault value is \u201cusername\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_uri_user\", \"user\")\n...\n```\n",
   "sc_uri_host": "### `sc_uri_host` (string)\n\nThe name of the column in silo table, storing the domain.\n\nDefault value is \u201cdomain\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_uri_host\", \"domain\")\n...\n```\n",
   "sc_body": "### `sc_body` (string)\n\nThe name of the column storing the message body in silo table.\n\nDefault value is \u201cbody\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_body\", \"message_body\")\n...\n```\n",
   "sc_ctype": "### `sc_ctype` (string)\n\nThe name of the column in silo table, storing content type.\n\nDefault value is \u201cctype\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_ctype\", \"content_type\")\n...\n```\n",
   "sc_exp_time": "### `sc_exp_time` (string)\n\nThe name of the column in silo table, storing the expire time of the\nmessage.\n\nDefault value is \u201cexp_time\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_exp_time\", \"expire_time\")\n...\n```\n",
   "sc_inc_time": "### `sc_inc_time` (string)\n\nThe name of the column in silo table, storing the incoming time of the\nmessage.\n\nDefault value is \u201cinc_time\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_inc_time\", \"incoming_time\")\n...\n```\n",
   "sc_snd_time": "### `sc_snd_time` (string)\n\nThe name of the column in silo table, storing the send time for the\nreminder.\n\nDefault value is \u201csnd_time\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_snd_time\", \"send_reminder_time\")\n...\n```\n",
   "sc_stored_hdrs": "### `sc_stored_hdrs` (string)\n\nThe name of the column in silo table, storing the extra headers.\n\nDefault value is \u201cextra_hdrs\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_stored_hdrs\", \"extra_headers\")\n...\n```\n",
   "sc_callid": "### `sc_callid` (string)\n\nThe name of the column in silo table, storing status.\n\nDefault value is \u201cstatus\u201d.\n\n```\n...\nmodparam(\"msilo\", \"sc_status\", \"st\")\n...\n```\n",
   "from_address": "### `from_address` (string)\n\nThe SIP address used to inform users that destination of their message\nis not online and the message will be delivered next time when that user\ngoes online. If the parameter is not set, the module will not send any\nnotification. This parameter may contain pseudo-variables.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"from_address\", \"sip:registrar@example.org\")\nmodparam(\"msilo\", \"from_address\", \"sip:$rU@example.org\")\n...\n```\n",
   "contact_hdr": "### `contact_hdr` (string)\n\nThe value of the \u201cContact\u201d header (including header name and ending\n\\r\\n) to be added in notification messages. It can contain\npseudo-variables.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"contact_hdr\", \"Contact: <sip:null@example.com>\\r\\n\")\n...\n```\n",
   "extra_hdrs": "### `extra_hdrs` (string)\n\nExtra headers (each ending with \\r\\n) to be added in messages sent from\nsilo by m_dump. It can contain pseudo-variables.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"extra_hdrs\", \"X-Extra: $tu\\r\\nY-Extra: foo\\r\\n\")\n...\n```\n",
   "offline_message": "### `offline_message` (string)\n\nThe body of the notification message. It can contain pseudo-variables.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"offline_message\", \"*** User $rU is offline!\")\nmodparam(\"msilo\", \"offline_message\", \"<em>I am offline!</em>\")\n...\n```\n",
   "content_type_hdr": "### `content_type_hdr` (string)\n\nThe value of the Content-Type header (including header name and ending\n\\r\\n) to be added in notification messages. It must reflect what the\n'offline_message' contains. It can contain pseudo-variables.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"content_type_hdr\", \"Content-Type: text/plain\\r\\n\")\nmodparam(\"msilo\", \"content_type_hdr\", \"Content-Type: text/html\\r\\n\")\n...\n```\n",
   "reminder": "### `reminder` (string)\n\nThe SIP address used to send reminder messages. If this value is not\nset, the reminder feature is disabled.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"reminder\", \"sip:registrar@example.org\")\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy` (string)\n\nThe SIP address used as next hop when sending the message. Very useful\nwhen using Kamailio with a domain name not in DNS, or when using a\nseparate Kamailio instance for msilo processing. If not set, the message\nwill be sent to the address in destination URI.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"outbound_proxy\", \"sip:kamailio.org;transport=tcp\")\n...\n```\n",
   "expire_time": "### `expire_time` (int)\n\nExpire time of stored messages - seconds. When this time passed, the\nmessage is silently discarded from database.\n\n*Default value is \u201c259200 (72 hours = 3 days)\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"expire_time\", 36000)\n...\n```\n",
   "check_time": "### `check_time` (int)\n\nTimer interval to check if dumped messages are sent OK - seconds. The\nmodule keeps each request send by itself for a new online user and if\nthe reply is 2xx then the message is deleted from database.\n\n*Default value is \u201c60\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"check_time\", 10)\n...\n```\n",
   "send_time": "### `send_time` (int)\n\nTimer interval in seconds to check if there are reminder messages. The\nmodule takes all reminder messages that must be sent at that moment or\nbefore that moment.\n\nIf the value is 0, the reminder feature is disabled.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"send_time\", 60)\n...\n```\n",
   "clean_period": "### `clean_period` (int)\n\nNumber of \u201ccheck_time\u201d cycles when to check if there are expired\nmessages in database.\n\n*Default value is \u201c10\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"clean_period\", 3)\n...\n```\n",
   "use_contact": "### `use_contact` (int)\n\nTurns on/off the usage of the \u201cContact\u201d address to send notification\nback to sender whose message is stored by MSILO.\n\n*Default value is \u201c1 (0 = off, 1 = on)\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"use_contact\", 0)\n...\n```\n",
   "snd_time_avp": "### `snd_time_avp` (str)\n\nThe name of an AVP which may contain the time when to send the received\nmessage as reminder. The AVP is used only by m_store().\n\nIf the parameter is not set, the module does not look for this AVP. If\nthe value is set to a valid AVP name, then the module expects in the AVP\nto be a time value in format \u201cYYYYMMDDHHMMSS\u201d (e.g., 20060101201500).\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"snd_time_avp\", \"$avp(i:123)\")\n...\n```\n",
   "add_date": "### `add_date` (int)\n\nWhether to add as prefix the date when the message was stored.\n\n*Default value is \u201c1\u201d (1==on/0==off).*\n\n```\n...\nmodparam(\"msilo\", \"add_date\", 0)\n...\n```\n",
   "max_messages": "### `max_messages` (int)\n\nMaximum number of stored message for an AoR. Value 0 equals to no limit.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"msilo\", \"max_messages\", 0)\n...\n```\n",
   "add_contact": "### `add_contact` (int)\n\nWhether to add contact header to generated messages. The contact address\nis the From URI.\n\n*Default value is \u201c0\u201d (1==on; 0==off as per RFC3428).*\n\n```\n...\nmodparam(\"msilo\", \"add_contact\", 1)\n...\n```\n",
   "extra_hdrs_avp": "### `extra_hdrs_avp` (str)\n\nName of an AVP which may contain extra headers that are stored with the\nmessage when m_store() is called. These extra headers (if any) are then\nincluded in MESSAGE request generated by m_dump().\n\nIf the parameter is not set, m_store() does not look for extra headers\nfrom any AVP.\n\n*Default value is \u201cnull\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"extra_hdrs_avp\", \"$avp(msilo_extra_hdrs)\")\n...\n```\n",
   "skip_notification_flag": "### `skip_notification_flag` (int)\n\nFlag to mark the message for which no notification should be sent back\nto sender when storing in msilo. Valid value is in between 0 and 31.\n\n*Default value is \u201c-1\u201d (feature disabled).*\n\n```\n...\nmodparam(\"msilo\", \"skip_notification_flag\", 18)\n...\nsetflag(18);\nm_store(...);\n...\n```\n",
   "use_mode": "### `use_mode` (int)\n\nIf set to 1, the call-id header of incoming MESSAGE is stored and reused\nlater for delivery MESSAGE.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"msilo\", \"use_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "m_store": "### `m_store([owner])`\n\nThe method stores certain parts of the current SIP request (it should be\ncalled when the request type is MESSAGE and the destination user is\noffline or his UA does not support MESSAGE requests). If the user is\nregistered with a UA which does not support MESSAGE requests you should\nnot use mode=\u201c0\u201d if you have changed the request uri with the contact\naddress of user's UA.\n\nMeaning of the parameters is as follows:\n\n- *owner* - is a string that must contain a SIP URI in whose inbox the\n  message will be stored. It can have any pseudo variable. If \"owner\" is\n  missing, the SIP address is taken from R-URI.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nm_store();\nm_store(\"$tu\");\n...\n```\n",
   "m_store_addrs": "### `m_store_addrs(owner, srcaddr, dstaddr)`\n\nSimilar to m_store(), but instead of getting source user address from\nFrom-URI and destination user address from To_URI, this function allows\nto give them via parameters.\n\nMeaning of the parameters is as follows:\n\n- *owner* - is a string that must contain a SIP URI in whose inbox the\n  message will be stored. It can have any pseudo variable.\n\n- *srcaddr* - is a string that must contain a SIP URI corresponding to\n  From user. It can have any pseudo variable.\n\n- *dstaddr* - is a string that must contain a SIP URI correspinding to\n  To user. It can have any pseudo variable.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nm_store_addrs(\"sip:$rU@a.com\", \"sip:$fU@a.com\", \"sip:$tU@a.com\");\n...\n```\n",
   "m_dump": "### `m_dump([owner])`\n\nThe method sends stored messages for the SIP user that has registered to\nthe contact address in the registration. The method should be called\nwhen a REGISTER request is received and the \u201cExpire\u201d header has a value\ngreater than zero.\n\nMeaning of the parameters is as follows:\n\n- *owner* - is a string that must contain a SIP URI whose inbox will be\n  dumped. It can have any pseudo variable. If \"owner\" is missing, the\n  SIP address is taken from To URI.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nm_dump();\nm_dump(\"$fu\");\n...\n```\n"
  }
 },
 "msrp": {
  "overview": "This module provides a MSRP routing engine, a.k.a. MSRP relay. MSRP\n(Message Session Relay Protocol) is defined by RFC4975, and the\nextensions for an MSRP relay are covered in RFC4976.\n\nA typical use of MSRP is instant messaging sessions initiated via SIP.\nUnlike page-mode instant messaging, which is done via the SIP MESSAGE\nrequest, MSRP uses a different communication channel which is negotiated\nvia INVITE-200 OK-ACK.\n\nHowever, MSRP is still a text-based protocol. It uses several routing\nmechanisms similar to what exists in SIP. Furthermore, MSRP requires\nTCP, and recommends TLS for confidentiality and security. In light of\nthe scalability and performance of Kamailio in handling TCP/TLS, this\nmodule reuses Kamailio's core framework to offer MSRP routing\ncapabilities. Along with embedded Presence and XCAP servers, Kamailio\nnow offers a complete solution for SIP beyond VoIP.\n\nOne of the main benefits of this module is the ability to reuse all the\nother extensions that exist in the SIP server, including accounting,\nauthentication, authorization to database connectors, security and DoS\nattack protections.\n\nKamailio can handle SIP and MSRP traffic received on the same port; the\nappropriate configuration file block being executed based on the type of\nmessage. Therefore, you can use Kamailio as a stand-alone MSRP relay or\nyou can have an instance handling both SIP and MSRP. Another option is\nto configure Kamailio to listen on multiple ports, some of them for SIP\nand others for MSRP.\n",
  "parameters": {
   "sipmsg": "### `sipmsg` (int)\n\nIf set to 1, the module will build a SIP message from MSRP frame\nheaders, providing it to \u201cevent_route[msrp:frame-in]\u201d. All the config\nfile functions (apart from SIP request relay) that can be used in a\nrequest route block can be used in the MSRP event_route.\n\n*Default value is '1'.*\n\n```\n...\nmodparam(\"msrp\", \"sipmsg\", 1)\n...\n```\n",
   "cmap_size": "### `cmap_size` (int)\n\nThe size of connection map table, to be computed as power of 2 (e.g., if\nthe value is 4, then the number of slots in map table is 2^4 = 16).\n\n*Default value is '0' (no internal map table to be used).*\n\n```\n...\nmodparam(\"msrp\", \"cmap_size\", 8)\n...\n```\n",
   "timer_interval": "### `timer_interval` (int)\n\nThe timer interval in seconds to run the procedure for cleaning expired\nconnections.\n\n*Default value is '60'.*\n\n```\n...\nmodparam(\"msrp\", \"timer_interval\", 90)\n...\n```\n",
   "auth_min_expires": "### `auth_min_expires` (int)\n\nThe minimum value accepted for the \u201cExpires\u201d header in AUTH requests.\n\n*Default value is '60'.*\n\n```\n...\nmodparam(\"msrp\", \"auth_min_expiresl\", 90)\n...\n```\n",
   "auth_max_expires": "### `auth_max_expires` (int)\n\nThe maximum value accepted for \u201cExpires\u201d header in AUTH requests.\n\n*Default value is '3600'.*\n\n```\n...\nmodparam(\"msrp\", \"auth_max_expiresl\", 1800)\n...\n```\n",
   "use_path_addr": "### `use_path_addr` (str)\n\nThe hostname:port to be used when building the Path header.\n\n*Default value is NULL (server IP and port are used).*\n\n```\n...\nmodparam(\"msrp\", \"use_path_addr\", \"msrp.kamailio.org:5061\")\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues can be: 'msrp:frame-in'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"msrp\", \"event_callback\", \"ksr_msrp_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_msrp_event(evname)\n    KSR.info(\"===== msrp module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n"
  },
  "functions": {
   "msrp_relay": "### `msrp_relay()`\n\nRelay MSRP frame according to the To-Path. This function has to be\nexecuted for each MSRP request or reply that has to be forwarded. Note\nthat due to nature of the MSRP transport layer, which is reliable\n(TCP/TLS), there is no retransmission of MSRP frames.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    msrp_relay();\n}\n...\n```\n",
   "msrp_reply": "### `msrp_reply(code, text [, hdrs])`\n\nSend a reply for the current MSRP request, adding optional headers.\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    msrp_reply(\"403\", \"Not allowed\");\n}\n...\n```\n",
   "msrp_is_request": "### `msrp_is_request()`\n\nReturn true if the MSRP frame is a request.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    if(msrp_is_request())\n    {\n        msrp_relay();\n        exit;\n    }\n}\n...\n```\n",
   "msrp_is_reply": "### `msrp_is_reply()`\n\nReturn true if the MSRP frame is a reply.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    if(msrp_is_reply())\n    {\n        msrp_relay();\n        exit;\n    }\n}\n...\n```\n",
   "msrp_set_dst": "### `msrp_set_dst(addr, sock)`\n\nSet destination attributes: addr - target address as MSRP URI; sock -\nlocal socket to be used (format 'proto:ip:port').\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    ...\n    msrp_set_dst(\"msrp://127.0.0.1:8000\", \"tcp:127.0.0.1:5060\");\n    ...\n}\n...\n```\n",
   "msrp_relay_flags": "### `msrp_relay_flags(flags)`\n\nSet transport layer sending flags for forwarding current MSRP frame;\nflags - a bitmask of flags - 1 (don't create a new connection), 2 (close\nconnection after send).\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    ...\n    msrp_relay_flags(\"1\");\n    ...\n}\n...\n```\n",
   "msrp_reply_flags": "### `msrp_reply_flags(flags)`\n\nSet transport layer sending flags for replies to the current MSRP frame;\nflags - a bitmask of flags - 1 (don't create a new connection), 2 (close\nconnection after send).\n\nThe parameter can be a pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    ...\n    msrp_reply_flags(\"1\");\n    ...\n}\n...\n```\n",
   "msrp_cmap_save": "### `msrp_cmap_save()`\n\nSave details of a MSRP connection upon AUTH request inside the internal\nmap table, indexed by session id.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    ...\n    if(method==\"AUTH\") { msrp_cmap_save(); exit; }\n    ...\n}\n...\n```\n",
   "msrp_cmap_lookup": "### `msrp_cmap_lookup()`\n\nLookup MSRP connection details for current session id.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nevent_route[msrp:frame-in] {\n    ...\n    if(method==\"SEND\" and $msrp(nexthops)==1) {\n        if(msrp_cmap_lookup()) {\n            msrp_relay();\n        } else {\n            msrp_reply(\"481\", \"Session not found\");\n        }\n    }\n    ...\n}\n...\n```\n"
  }
 },
 "mtree": {
  "overview": "This module loads (prefix, value) records from database and indexes them\nin a named memory tree. Name of the tree is specified for each record or\nas module parameter.\n\nIt exports to configuration file functions to match against in-memory\ntrees and return the values (raw or precompiled) associated with matched\nprefixes.\n\nThe maximum size of the prefix is limited internally to 63, database\ntable definition may enforce lower maximum size.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nURL of the database server to be used.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_table": "### `db_table` (string)\n\nName of database table where data for many trees is stored. It is\nignored if a 'mtree' parameter is defined. The SQL scripts creates a\ntable named 'mtrees' that can be used for this parameter.\n\n*Default value is \u201c\u201d (no table name).*\n\n```\n...\nmodparam(\"mtree\", \"db_table\", \"mtrees\")\n...\n```\n",
   "mtree": "### `mtree` (string)\n\nDefinition of memory tree with using a parameters format string. The\nparameter names can be:\n\n- name - the name of the tree to be used for referencing inside\n  configuration file.\n\n- dbtable - the name of the database table from where to load the\n  records stored in the tree.\n\n- cols - the column names of the database table. They must be enclosed\n  in quotes in order to form a valid SIP parameter value and be\n  separated by comma. The first column corresponds to tprefix. When\n  specified, there must be at least two columns. If this attribute is\n  not specified, then the global module parameters for tprefix and\n  tvalue are used. If more than one value columns are specified, the\n  tree will pack the column values in a comma separated string, which\n  will be associated with the prefix (string transformation\n  {s.select,...) can be used in configuration file to extract a specific\n  column value).\n\n- type - the type of tree elements (0 = string, 1 = d:w, 2 = integer).\n  None-zero is valid only when the (tprefix, tvalue) pairs are loaded\n  (not for multi-column values).\n\n  When the type is 1, the value in database has to be two integers\n  separated by colon, the first one (d - dstid) will be stored in\n  pv_dstid AVP and the second (w - weight) will be stored in pv_weight\n  AVP. If in the matching records are many with the same dstid, it will\n  keep only the one with the longest prefix. Then the records are\n  ordered by the weight and stored in the specified AVPs. The number of\n  stored records is saved in pv_count variable.\n\n- multi - tells if dbtable can contain more than one tree (0 = one tree,\n  1 = more than one tree identified by tname column). It is valid only\n  when the (tprefix, tvalue) pairs are loaded (not for multi-column\n  values).\n\nThis parameter can be set many times to add more trees in memory.\n\n*Default value is \u201cnone\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"mtree\", \"name=mytree1;dbtable=routes1;type=0\")\nmodparam(\"mtree\", \"mtree\", \"name=mytree2;dbtable=routes2;type=0;multi=1\")\nmodparam(\"mtree\", \"mtree\",\n    \"name=mytree1;dbtable=routes1;cols='key1,val1,val2,val3'\")\n...\n```\n",
   "tname_column": "### `tname_column` (string)\n\nName of 'tname' column.\n\n*Default value is \u201ctname\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"tname_column\", \"name\")\n...\n```\n",
   "tprefix_column": "### `tprefix_column` (string)\n\nName of 'tprefix' column.\n\n*Default value is \u201ctprefix\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"tprefix_column\", \"prefix\")\n...\n```\n",
   "tvalue_column": "### `tvalue_column` (string)\n\nName of 'tvalue' column.\n\n*Default value is \u201ctvalue\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"tvalue_column\", \"ipaddr\")\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nNumber of rows to be loaded in one step from database.\n\n*Default value is 1000.*\n\n```\n...\nmodparam(\"mtree\", \"fetch_rows\", 4000)\n...\n```\n",
   "char_list": "### `char_list` (string)\n\nThe list with characters allowed in prefix.\n\n*Default value is \u201c0123456789\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"char_list\", \"0123456789*+\")\n...\n```\n",
   "pv_value": "### `pv_value` (string)\n\nThe PV spec where to store the matched value. It can be any writable PV.\n\n*Default value is \u201c$avp(s:tvalue)\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"pv_value\", \"$var(mtval)\")\n...\n```\n",
   "pv_values": "### `pv_values` (string)\n\nThe AVP where to store the matched values when mtree is of type 0 or 2\nand mode of mt_match() call has value 2.\n\n*Default value is \u201c$avp(s:tvalues)\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"pv_values\", \"$avp(mtvals)\")\n...\n```\n",
   "pv_dstid": "### `pv_dstid` (string)\n\nThe AVP name where to store the first integer value when tree type is 1.\n\n*Default value is \u201c$avp(tdstid)\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"pv_dstid\", \"$var(dstid)\")\n...\n```\n",
   "pv_weight": "### `pv_weight` (string)\n\nThe AVP name where to store the second integer value when tree type is\n1.\n\n*Default value is \u201c$avp(tweight)\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"pv_dstid\", \"$var(weight)\")\n...\n```\n",
   "pv_count": "### `pv_count` (string)\n\nThe PV spec where to store the count of matched values when tree type\nis 1. It can be any writable PV.\n\n*Default value is \u201c$avp(tcount)\u201d.*\n\n```\n...\nmodparam(\"mtree\", \"pv_count\", \"$var(count)\")\n...\n```\n",
   "mt_tree_type": "### `mt_tree_type` (integer)\n\nDefault payload type for trees data stored in 'db_table'. Documented\nvalues are 0 for string payloads and 2 for integer payloads.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"mtree\", \"mt_tree_type\", 2)\n...\n```\n",
   "mt_ignore_duplicates": "### `mt_ignore_duplicates` (integer)\n\nIgnore duplicated prefixes when loading data.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"mtree\", \"mt_ignore_duplicates\", 1)\n...\n```\n",
   "mt_allow_duplicates": "### `mt_allow_duplicates` (integer)\n\nAllow duplicate prefixes when loading data.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"mtree\", \"mt_allow_duplicates\", 1)\n...\n```\n"
  },
  "functions": {
   "mt_match": "### `mt_match(mtree, pv, mode)`\n\nMatch 'pv' value against 'mtree'. If 'mtree' type is 0 or 2 and value of\n'mode' is NOT 2, sets associated value of the longest matching prefix to\npseudo variable specified by pv_value parameter. If 'mtree' type is 0 or\n2 and value of 'mode' is 2, sets values of all matching prefixes to avp\nspecified by pv_values parameter so that a value of longest matching\nprefix is in avp index 0. Parameter 'mode' can be an integer constant or\na pseudo variable with integer value.\n\nReturns 1 if match succeeded and -1 otherwise.\n\n```\n...\nmt_match(\"mytree\", \"$rU\", \"0\");\n...\n```\n"
  }
 },
 "nat_traversal": {
  "overview": "The nat_traversal module provides support for handling far-end NAT\ntraversal for SIP signaling. The module includes functionality to detect\nuser agents behind NAT, to modify SIP headers to allow user agents to\nwork transparently behind NAT and to send keepalive messages to user\nagents behind NAT in order to preserve their visibility in the network.\nThe module can handle user agents behind multiple cascaded NAT boxes as\neasily as user agents behind a single level of NAT.\n\nThe module is designed to work in complex environments where multiple\nSIP proxies may be involved in handling registration and routing and\nwhere the incoming and outgoing paths may not necessarily be the same,\nor where the routing path may even change between consecutive dialogs.\nThe nat_traversal functionality is built primarily for IPv4 NAT handling\nand hasn't been adapted to support IPv6 session keepalives.\n",
  "parameters": {},
  "functions": {}
 },
 "nathelper": {
  "overview": "This is a module to help with NAT traversal and reuse of TCP\nconnections. In particular, it helps symmetric UAs that don't advertise\nthey are symmetric and are not able to determine their public address.\n\nThe function `fix_nated_contact()` rewrites the \u201cContact\u201d header field\nwith request's source address:port pair. The function `fix_nated_sdp()`\nadds the active direction indication to SDP (flag 0x01) and updates the\nsource IP address too (flag 0x02). The function `fix_nated_register()`\nexports the request's source address:port into an AVP to be used during\n`save()` and should be used for \u201cREGISTER\u201d requests.\n\nNote: `fix_nated_contact()` changes the \u201cContact\u201d header, thus it breaks\nthe RFC. Although this is not always an issue, it may cause problems\nwith strict SIP clients. An alternative is to use `add_contact_alias()`\n(or `set_contact_alias()`) that together with the `handle_ruri_alias()`\nis standards conforming and also supports reuse of TCP/TLS connections.\n",
  "parameters": {
   "force_socket": "### `force_socket` (string)\n\nSocket to be used when sending NAT pings for UDP communication. If no\none specified, the OS will choose a socket.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"nathelper\", \"force_socket\", \"127.0.0.1:5060\")\n...\n```\n",
   "natping_interval": "### `natping_interval` (integer)\n\nPeriod of time in seconds between sending the NAT pings to all currently\nregistered UAs to keep their NAT bindings alive. Value of 0 disables\nthis functionality.\n\n<div class=\"note\">\n\n\nEnabling the NAT pinging functionality will force the module to bind\nitself to USRLOC module.\n\n</div>\n\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"nathelper\", \"natping_interval\", 10)\n...\n```\n",
   "ping_nated_only": "### `ping_nated_only` (integer)\n\nIf this parameter is set to 1 then only contacts that have the behind\nNAT \u201cnat_bflag\u201d flag set in user location records get the NAT ping (the\n\u201cnat_bflag\u201d is specified via modparam of usrloc module). By default the\nping is done with 4-bytes UDP packet. If sipping_bflag is also set, then\nthe ping is done with a stateless SIP request (by default: OPTIONS\nrequest).\n\nIf it is 0, then all contacts get a NAT ping, by default being the\n4-bytes UDP packet. If it is 0 and sipping_bflag parameter is set, then\nSIP-request-based pinging is sent to all contacts.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"nathelper\", \"ping_nated_only\", 1)\n...\n```\n",
   "natping_processes": "### `natping_processes` (integer)\n\nHow many timer processes should be created by the module for the\nexclusive task of sending the NAT pings.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"nathelper\", \"natping_processes\", 3)\n...\n```\n",
   "natping_socket": "### `natping_socket` (string)\n\nSpoof the natping's source-ip to this address. Works only for IPv4.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"nathelper\", \"natping_socket\", \"192.168.1.1:5006\")\n...\n```\n",
   "received_avp": "### `received_avp` (str)\n\nThe name of the Attribute-Value-Pair (AVP) used to store the URI\ncontaining the received IP, port, and protocol. The URI is created by\nfix_nated_register function of nathelper module and the attribute is\nthen used by the registrar to store the received parameters. Do not\nforget to change the value of corresponding parameter in registrar\nmodule if you change the value of this parameter.\n\n<div class=\"note\">\n\n\nYou must set this parameter if you use `fix_nated_register`. In such\ncase you must set the parameter with same name in the \u201cregistrar\u201d module\nto same value.\n\n</div>\n\n\n*Default value is \"NULL\" (disabled).*\n\n```\n...\nmodparam(\"nathelper\", \"received_avp\", \"$avp(i:42)\")\n...\n```\n",
   "sipping_bflag": "### `sipping_bflag` (integer)\n\nWhich branch flag should be used by the module to identify NATed\ncontacts for which it should perform NAT ping via a SIP request instead\nof dummy UDP packet.\n\n*Default value is -1 (disabled).*\n\n```\n...\nmodparam(\"nathelper\", \"sipping_bflag\", 7)\n...\n```\n",
   "sipping_from": "### `sipping_from` (string)\n\nThe parameter sets the SIP URI to be used in generating the SIP requests\nfor NAT ping purposes. To enable the SIP request pinging feature, you\nhave to set this parameter. The SIP request pinging will be used only\nfor requests marked so.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"nathelper\", \"sipping_from\", \"sip:pinger@siphub.net\")\n...\n```\n",
   "sipping_method": "### `sipping_method` (string)\n\nThe parameter sets the SIP method to be used in generating the SIP\nrequests for NAT ping purposes.\n\n*Default value is \u201cOPTIONS\u201d.*\n\n```\n...\nmodparam(\"nathelper\", \"sipping_method\", \"INFO\")\n...\n```\n",
   "natping_disable_bflag": "### `natping_disable_bflag` (integer)\n\nWhat branch flag should be used by the module to disable NAT pings on a\nper-registration basis. If the given flag is set for a particular\nregistration, then no NAT pings will be sent at all, regardless of any\nother conditions.\n\n*Default value is -1 (disabled).*\n\n```\n...\nmodparam(\"nathelper\", \"natping_disable_bflag\", 8)\n...\n```\n",
   "nortpproxy_str": "### `nortpproxy_str` (string)\n\nThe parameter sets the SDP attribute used by nathelper to mark the\npacket SDP that information have already been mangled.\n\nIf empty string, no marker will be added or checked.\n\n<div class=\"note\">\n\n\nThe string must be a complete SDP line, including the EOH (\\r\\n).\n\n</div>\n\n\n*Default value is \u201ca=nortpproxy:yes\\r\\n\u201d.*\n\n```\n...\nmodparam(\"nathelper\", \"nortpproxy_str\", \"a=sdpmangled:yes\\r\\n\")\n...\n```\n",
   "keepalive_timeout": "### `keepalive_timeout` (int)\n\nThe parameter sets the interval in seconds after which a natted contact\nis removed from location table if it does not reply to SIP keepalives\n(usually OPTIONS ping requests).\n\nThe features is available only for UDP contacts that are stored in\nmemory (not working for db only mode for usrloc module).\n\nKeepalives are sent stateless, not using TM module. The value of this\nparameter has to be few times higher than natping_interval.\n\n*Default value is \u201c0\u201d (feature disabled).*\n\n```\n...\nmodparam(\"nathelper\", \"keepalive_timeout\", 120)\n...\n```\n",
   "udpping_from_path": "### `udpping_from_path` (int)\n\nEnable sending UDP pings (keepalives) using raw socket from Path\naddress.\n\n*Default value is \u201c0\u201d (feature disabled).*\n\n```\n...\nmodparam(\"nathelper\", \"udpping_from_path\", 1)\n...\n```\n",
   "append_sdp_oldmediaip": "### `append_sdp_oldmediaip` (int)\n\nThe parameter controls if oldmediaip field should be appended to the\nSDP.\n\n*Default value is \u201c1\u201d (feature enabled).*\n\n```\n...\nmodparam(\"nathelper\", \"append_sdp_oldmediaip\", 1)\n...\n```\n",
   "filter_server_id": "### `filter_server_id` (int)\n\nFilter contacts by \u201cserver_id\u201d core parameter. Use this parameter to\nlimit pinging. When set to \u201c1\u201d, only proxy instances which send packets\nare those where core server_id matches server_id saved in usrloc.\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"nathelper\", \"filter_server_id\", 1)\n...\n```\n",
   "nat_addr_mode": "### `nat_addr_mode` (int)\n\nIf set to 0, only default private net addresses are checked by\nnat_uac_test(). If set to 1, other reserved net addresses are checked by\nnat_uac_test() as well.\n\nDefault private net addresses are:\n\n- 10.0.0.0/8\n\n- 172.16.0.0/12\n\n- 192.168.0.0/16\n\n- 100.64.0.0/10 - RFC6598 - Carrier Grade NAT\n\n- 192.0.0.0/29 - RFC7335 - IPv4 Service Continuity Prefix\n\nReserved net addresses are:\n\n- 192.0.0.0/24 - RFC7335 - IETF Protocol Assignments\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"nathelper\", \"nat_addr_mode\", 0)\n...\n```\n",
   "alias_name": "### `alias_name` (string)\n\nThe parameter sets the name of the Contact URI parameter set by\nset_contact_alias() or add_contact_alias() and processed by\nhandle_ruri_alias() in R-URI.\n\n*Default value is \u201calias\u201d.*\n\n```\n...\nmodparam(\"nathelper\", \"alias_name\", \"saddr\")\n...\n```\n"
  },
  "functions": {
   "fix_nated_contact": "### `fix_nated_contact()`\n\nRewrites the \u201cContact\u201d header to contain the request's source\naddress:port.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\nif (search(\"User-Agent: Cisco ATA.*\") {fix_nated_contact();};\n...\n```\n",
   "fix_nated_sdp": "### `fix_nated_sdp(flags [, ip_address])`\n\nAlters the SDP information in order to facilitate NAT traversal. What\nchanges to be performed may be controlled via the \u201cflags\u201d parameter.\nReturn value is -1 if error occurred, 1 if ip's were replaced, 2 if no\nip's were replaced.\n\nMeaning of the parameters is as follows:\n\n- *flags* - the value may be a bitwise OR of the following flags:\n\n  - *0x01* - adds \u201ca=direction:active\u201d SDP line;\n\n  - *0x02* - rewrite media IP address (c=) with source address of the\n    message or the provided IP address. (a=rtcp) param will be rewritten\n    if exists. (the provided IP address take precedence over the source\n    address).\n\n  - *0x04* - adds \u201ca=nortpproxy:yes\u201d SDP line;\n\n  - *0x08* - rewrite IP from origin description (o=) with source address\n    of the message or the provided IP address. (a=rtcp) param will be\n    rewritten if exists. (the provided IP address take precedence over\n    the source address).\n\n\n- *ip_address* - IP to be used for rewriting SDP. If not specified, the\n  received signalling IP will be used. The parameter allows\n  pseudo-variables usage. NOTE: For the IP to be used, you need to use\n  0x02 or 0x08 flags, otherwise it will have no effect. Must be IPv4\n  address family.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif (search(\"User-Agent: Cisco ATA.*\") {fix_nated_sdp(\"3\");};\n...\n```\n",
   "add_rcv_param": "### `add_rcv_param([flag])`,\n\nAdd a received parameter to the \u201cContact\u201d header fields (available for\nall transports) or to the Contact URI (available only for UDP traffic).\n\nThe parameter will contain the URI created from the source IP, port, and\nprotocol (if different than UDP) of the packet containing the SIP\nmessage. The parameter can be then processed by another registrar. This\nis useful, for example, when replicating register messages using\n`t_replicate` function to another registrar.\n\nMeaning of the parameters is as follows:\n\n- *flag* - flags to indicate if the parameter should be added to Contact\n  URI or Contact header. If the flag is non-zero, the parameter will be\n  added to the Contact URI. If not used or equal to zero, the parameter\n  will go to the Contact header.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nadd_rcv_param(); # add the parameter to the Contact header\n....\nadd_rcv_param(\"1\"); # add the parameter to the Contact URI\n...\n```\n",
   "fix_nated_register": "### `fix_nated_register()`\n\nThe function creates a URI consisting of the source IP, port, and\nprotocol and stores the URI in an Attribute-Value-Pair. The URI will be\nappended as \"received\" parameter to Contact in 200 OK and registrar will\nstore it in the received column in the location table.\n\nNote: You have to set the \u201creceived_avp\u201d parameter of the nathelper\nmodule and the registrar module (both module parameters must have the\nsame value) to use this function.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nfix_nated_register();\n...\n```\n",
   "nat_uac_test": "### `nat_uac_test(flags)`\n\nTries to guess if client's request originated behind a nat. The\nparameter determines what heuristics is used.\n\nMeaning of the flags is as follows:\n\n- *1* - The \u201cContact\u201d header field is searched for occurrence of RFC1918\n  or RFC6598 addresses.\n\n- *2* - the \"received\" test is used: address in the \u201cVia\u201d header is\n  compared against source IP address of signaling. If the \u201cVia\u201d header\n  contains no port, it uses the default SIP port 5060\n\n- *4* - The Top Most \u201cVia\u201d is searched for occurrence of RFC1918 or\n  RFC6598 addresses\n\n- *8* - The SDP is searched for occurrence of RFC1918 or RFC6598\n  addresses\n\n- *16* - Test if the source port is different from the port in the \u201cVia\u201d\n  header. If the \u201cVia\u201d header contains no port, it uses the default SIP\n  port 5060\n\n- *32* - Test if the source IP address of signaling is a RFC1918 or\n  RFC6598 address\n\n- *64* - Test if the source connection of signaling is a WebSocket\n\n- *128* - Test if the \u201cContact\u201d header URI port differs from the source\n  port of the request (Warning: this is might be legal or even intended\n  combination in non NATted scenarios)\n\n- *256* - Test if the SDP connection address is different from source IP\n  address. It will work also with multiple connection address lines.\n\n- *512* - Test if the target addresses are different or over websocket.\n  For requests, it compares host and port in R-URI ($rU) and D-URI\n  ($du). For replies, it compares host and port in 2nd Via with\n  received and rport parameters.\n\nAll flags can be bitwise combined, the test returns true if any of the\ntests identified a NAT.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif(nat_uac_test(\"19\")) {\n    rtpproxy_manage(\"co\");\n}\n...\n```\n",
   "is_rfc1918": "### `is_rfc1918(ip_address)`\n\nDetermines if the address in the parameter is an rfc1918 or rfc6598\naddress. The parameter allows pseudo-variables usage.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(is_rfc1918(\"$rd\")) {\n    # domain in r-uri is private address\n}\n...\n```\n",
   "add_contact_alias": "### `add_contact_alias([ip_addr, port, proto])`\n\nAdds an \u201c;alias=ip~port~transport\u201d parameter to the contact URI\ncontaining either received ip, port, and transport protocol or those\ngiven as parameters. If called without parameters, \u201c;alias\u201d parameter is\nonly added if received ip, port, or transport protocol differs from that\nin contact URI.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE, and LOCAL_ROUTE.\n\n```\n...\n    if (!is_present_hf(\"Record-Route\")) {\n        if (!add_contact_alias(\"$var(src_ip)\", \"$Rp\", \"tcp\")) {\n            xlog(\"L_ERR\", \"Error in aliasing contact $ct\\n\");\n            send_reply(\"400\", \"Bad request\");\n            exit;\n        };\n    };\n...\n        \n```\n",
   "handle_ruri_alias": "### `handle_ruri_alias([mode])`\n\nChecks if the Request URI has an \u201calias\u201d parameter and if so, removes it\nand sets the \u201c$du\u201d based on its value. Note that this means that\nrouting of request is based on \u201c;alias\u201d parameter value of the Request\nURI rather than the Request URI itself. If you call\n`handle_ruri_alias()` on a request, make sure that you screen the alias\nparameter value of Request URI the same way as you would screen the\nRequest URI itself.\n\nThe optional parameter mode can be 0 to consume first alias parameter,\notherwise it consumes the last alias parameter. If the parameter mode is\nnot provided, it consumes the first parameter.\n\nReturns *1* if \u201c;alias\u201d parameter was found and \u201c$du\u201d was set and the\n\u201c$ru\u201d rewritten, *2* if the alias parameter was not found and nothing\nwas done, or *-1* in case of error.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE, and\nLOCAL_ROUTE.\n\n```\n...\n    if ($du == \"\") {\n        handle_ruri_alias();\n        switch ($rc) {\n        case -1:\n            xlog(\"L_ERR\", \"Failed to handle alias of R-URI $ru\\n\");\n            send_reply(\"400\", \"Bad request\");\n            exit;\n        case 1:\n            xlog(\"L_INFO\", \"Routing in-dialog $rm from $fu to $du\\n\");\n            break;\n        case 2:\n            xlog(\"L_INFO\", \"Routing in-dialog $rm from $fu to $ru\\n\");\n            break;\n         };\n    };\n...\n        \n```\n",
   "set_contact_alias": "### `set_contact_alias([trim])`\n\nAdds an \u201c;alias=ip~port~transport\u201d parameter to the contact URI\ncontaining the received ip, port, and transport protocol. The update of\ncontact URI is signaled to a few other modules in the way the\n`fix_nated_contact()` does it by using the internal flags. The new value\nis not visible to pseudo-variables and it does not change the SIP\nmessage buffer.\n\nMeaning of parameters:\n\n- *trim* - by default, set_contact_alias() will not detect and trim an\n  already existing alias parameter. If this optional parameter is set to\n  \"1\", set_contact_alias() will trim the existing alias before adding a\n  new one.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE, and FAILURE_ROUTE.\n\n```\n...\n    if (!is_present_hf(\"Record-Route\")) {\n        if (!set_contact_alias()) {\n            xlog(\"L_ERR\", \"Error in aliasing contact $ct\\n\");\n            send_reply(\"400\", \"Bad request\");\n            exit;\n        };\n    };\n...\n        \n```\n",
   "set_alias_to_pv": "### `set_alias_to_pv(target_avp)`\n\nReads \u201c;alias=ip~port~transport\u201d from Contact header then writes to\ntarget pseudo-variable as a sip uri.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE, and FAILURE_ROUTE.\n\n```\n...\n        set_alias_to_pv(\"$avp(aliasuri)\");\n...\n        \n```\n"
  }
 },
 "nats": {
  "overview": "The module provides an NATS consumer for Kamailio. NATS is a real time\ndistributed messaging platform, more details about it can be found at\n[nats.io](https://nats.io) .\n\nFrom a high-level perspective, the module may be used for:\n\n- Provide a real-time distributed messaging layer in Kamailio\n\nSupported NATS operations are:\n\n- Subscribe to a Subject and Queue Group\n",
  "parameters": {
   "nats_url": "### `nats_url` (str)\n\nThe nats url.\n\nUsage: nats related.\n\n*Default value is nats://127.0.0.1:4222*\n\n```\n...\nmodparam(\"nats\", \"nats_url\", \"nats://127.0.0.1:4222\")\nmodparam(\"nats\", \"nats_url\", \"nats://user1:pass1127.0.1.2:4222\") // with auth\nmodparam(\"nats\", \"nats_url\", \"nats://127.1.2.3:4222\")\n...\n```\n",
   "num_publish_workers": "### `num_publish_workers` (int)\n\nThe number of worker threads for publishing messages.\n\nUsage: nats related.\n\n*Default value is \u201c2\u201d.*\n\n```\n...\nmodparam(\"nats\", \"num_publish_workers\", 4)\n...\n```\n",
   "subject_queue_group": "### `subject_queue_group` (str)\n\nThe NATS Subject and Queue Group. Separated by \":\"\n\nUsage: nats related.\n\n*Default value is not set.*\n\n```\n...\nmodparam(\"nats\", \"subject_queue_group\", \"Kamailio-World:2020\")\nmodparam(\"nats\", \"subject_queue_group\", \"Kamailio-World:2021\") // this will create two processes for the Kamailio-World subject\nmodparam(\"nats\", \"subject_queue_group\", \"MyQueue1:2021\")\nmodparam(\"nats\", \"subject_queue_group\", \"MyQueue2:2021\")\n...\n                \n```\n",
   "event_callback": "### `event_callback` (str)\n\nName of the KEMI function to be executed instead of the event route.\n\n*Default value is not set.*\n\n```\n...\nmodparam(\"nats\", \"event_callback\", \"ksr_nats_event\")\n\n-- event callback function implemented in Lua\nfunction ksr_nats_event(evname)\n    KSR.info(\"===== nats module received event: \" .. evname ..\n        \", data:\" .. KSR.pv.gete('$natsData') .. \"\\n\");\n    return 1;\nend\n...\n                \n```\n"
  },
  "functions": {
   "nats_publish": "### `nats_publish(subject, payload, reply)`\n\nPublishes the payload to subject, with an optional reply subject.\n\n```\n...\n$var(my_info) = \"$ci=\" + $ci + \" $fU=\" + $fU;\nnats_publish(\"mysubject\", \"$var(my_info)\"); # publish $var(my_info) to \"mysubject\"\n\n# publish $var(my_info) to \"mysubject\" with a reply.topic topic, so a response\n# can be published back from the other side, like the NATS Request-Reply mode.\nnats_publish(\"mysubject\", \"$var(my_info)\", \"reply.topic\");\n...\n                \n```\n"
  }
 },
 "ndb_cassandra": {
  "overview": "Apache Cassandra is an open source distributed database management\nsystem. It is designed to handle very large amounts of data spread out\nacross many servers. It is a NoSQL solution.\n\nThe module allows the insertion and retrieval of information from\nCassandra clusters. This is not a DB driver module.\n",
  "parameters": {
   "host": "### `host` (str)\n\nHost of Cassandra node.\n\nPort of Cassandra node.\n\n```\n...\nmodparam(\"ndb_cassandra\", \"host\", \"10.22.22.190\")\nmodparam(\"ndb_cassandra\", \"port\", 9160)\n...\n```\n"
  },
  "functions": {
   "cass_insert": "### `cass_insert(keyspace, column_family, key, column, value)`\n\nInserts the value for the given key, column, column_family and keyspace.\nThere must be an existing keyspace called 'keyspace' with a\ncolumn_family called 'column_family' in the targeted Cassandra node.\n\nReturn integer needs to be checked:\n\n- ret < 0, error\n\n- ret > 0, success\n",
   "cass_retrieve": "### `cass_retrieve(keyspace, column_family, key, column, value)`\n\nRetrieves the value for the given key, column, column_family and\nkeyspace. There must be an existing keyspace called 'keyspace' with a\ncolumn_family called 'column_family' in the targeted Cassandra node.\n\n`value` will be returned as well as an integer return code.\n\nReturn integer needs to be checked:\n\n- ret < 0, error\n\n- ret > 0, success\n\n<!-- -->\n\n\n```\n          ...\n    loadmodule \"ndb_cassandra.so\"\n    # (...)\n    modparam(\"ndb_cassandra\", \"host\", \"10.22.22.190\")\n    modparam(\"ndb_cassandra\", \"port\", 9160)\n    # (...)\n    xlog(\"L_DBG\", \"Testing ndb_cassandra module.\");\n    # Inserting to cassandra\n    $var(keyspace) = \"indigital\";\n    $var(column_family) = \"employees\";\n    $var(column) = \"name\";\n    $var(val_write) = \"TestMyName\"; # To be written\n    if (cass_insert(\"$var(keyspace)\", \"$var(column_family)\", \"$ru\", \"$var(column)\", \"$var(val_write)\") > 0) {\n       xlog(\"L_DBG\", \"ndb_cassandra. Success while inserting to Cassandra. val_write: \\\"$var(val_write)\\\"\");\n    } else {\n       xlog(\"L_DBG\", \"ndb_cassandra. Error while inserting to Cassandra\");\n    }\n\n    # Retrieving from cassandra\n    $var(keyspace) = \"indigital\";\n    $var(column_family) = \"employees\";\n    $var(key) = \"sip:10.22.22.110\"; # Before we saved our $ru, which was 'sip:10.22.22.110'\n    $var(column) = \"name\";\n    $var(val_read) = \"\"; # To be read\n    if (cass_retrieve(\"$var(keyspace)\", \"$var(column_family)\", \"$var(key)\", \"$var(column)\", \"$var(val_read)\") > 0) {\n       xlog(\"L_DBG\", \"ndb_cassandra. Success while reading from Cassandra. val_read: \\\"$var(val_read)\\\"\");\n    } else {\n       xlog(\"L_DBG\", \"ndb_cassandra. Error while reading from Cassandra\");\n    }\n          ...\n        \n```\n"
  }
 },
 "ndb_mongodb": {
  "overview": "This module provides a non-db connector to interact with MongoDB NoSQL\nserver from configuration file. You can read more about MongoDB at\n<http://www.mongodb.org>.\n\nIt can connect to many MongoDB servers and store the results in\ndifferent containers.\n",
  "parameters": {
   "server": "### `server` (str)\n\nSpecify the details to connect to MongoDB server. It takes a list of\nattribute=value separated by semicolon, the attributes can be name and\nuri. Name is a generic identifier to be used with module functions. The\nuri parameter must be a valid MongoDB database connection string.\n\nYou can set this parameter many times, in case you want to connect to\nmany MongoDB servers, just give different attributes and use the\nspecific server name when querying the MongoDB instance.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"ndb_mongodb\", \"server\", \"name=mgs1;uri='mongodb://localhost/kamailio'\")\nmodparam(\"ndb_mongodb\", \"server\", \"name=mgs2;uri='mongodb://127.0.0.2/kamailio'\")\n...\n```\n"
  },
  "functions": {
   "mongodb_cmd": "### `mongodb_cmd(srvname, dbname, cname, command, replyid)`\n\nSend a valid command to MongoDB server identified by srvname. The reply\nwill be stored in a local container identified by replyid. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThe reply can be accessed via pseudo-variable $mongodb(key). The key\ncan be: type - type of the reply; value - the value in JSON format\nreturned by MongoDB server; info - in case of error from MongoDB, it\nwill contain an info message.\n\nThe result can contain many documents, see mongodb_next() function for\nmore details.\n\nMeaning of the parameters:\n\n- *srvname* - MongoDB server name as given via 'server' parameter.\n\n- *dbname* - MongoDB database name.\n\n- *cname* - MongoDB collection (table) name.\n\n- *command* - valid MongoDB command given as JSON string.\n\n- *replyid* - the name of the container to store the response.\n\nThe function can be used from ANY_ROUTE.\n\n```\n...\nif(mongodb_cmd(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"collStats\\\": \\\"acc\\\" }\", \"mgr1\")) {\n    xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n}\n...\n```\n",
   "mongodb_cmd_simple": "### `mongodb_cmd_simple(srvname, dbname, cname, command, replyid)`\n\nSend a valid command to MongoDB server identified by srvname. The reply\nwill be stored in a local container identified by replyid. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThe reply can be accessed via pseudo-variable $mongodb(key). The key\ncan be: type - type of the reply; value - the value in JSON format\nreturned by MongoDB server; info - in case of error from MongoDB, it\nwill contain an info message.\n\nThis function should be used when the response has only one document.\n\nSee mongodb_cmd() for the meaning of the parameters.\n\nThe function can be used from ANY_ROUTE.\n\n```\n...\nif(mongodb_cmd_simple(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"collStats\\\": \\\"acc\\\" }\", \"mgr1\")) {\n    xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n}\n...\n```\n",
   "mongodb_find": "### `mongodb_find(srvname, dbname, cname, command, replyid)`\n\nSend a find command to MongoDB server identified by srvname. The reply\nwill be stored in a local container identified by replyid. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThe reply can be accessed via pseudo-variable $mongodb(key). The key\ncan be: type - type of the reply; value - the value in JSON format\nreturned by MongoDB server; info - in case of error from MongoDB, it\nwill contain an info message.\n\nThis function is useful for querying collections and accessing the\nresults.\n\nSee mongodb_cmd() for the meaning of the parameters, with the remark\nthat command has to be a valid filter JSON document, like for find()\ncommand in mongoc command line client tool.\n\nThe function can be used from ANY_ROUTE.\n\n```\n...\nif(mongodb_find(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"src_user\\\" : \\\"111\\\" }\", \"mgr1\")) {\n    xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n}\n...\n```\n",
   "mongodb_find_one": "### `mongodb_find_one(srvname, dbname, cname, command, replyid)`\n\nSimilar to mongodb_find(...), but it stops searching after first match,\nreturning the result with one object - faster when expecting to have a\nsingle match. Parameters and behaviour are the same as for\nmongodb_find(...).\n\nThe function can be used from ANY_ROUTE.\n\n```\n...\nif(mongodb_find_one(\"mgs1\", \"kamailio\", \"subscriber\", \"{ \\\"username\\\" : \\\"111\\\" }\", \"mgr1\")) {\n    xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n}\n...\n```\n",
   "mongodb_next": "### `mongodb_next(replyid)`\n\nMoves to next document in a MongoDB reply. This function can be used\nafter a successful mongodb_cmd() or mongodb_find(). It returns true if\nthere is a shift to document. The current document becomes available via\n$mongodb(key) variable.\n\n```\n...\nif(mongodb_find(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"src_user\\\" : \\\"111\\\" }\", \"mgr1\")) {\n    xlog(\"first response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    while(mongodb_next(\"mgr1\") ){\n        xlog(\"next response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n    }\n}\nmongodb_free(\"mgr1\");\n...\n        \n```\n",
   "mongodb_free": "### `mongodb_free(replyid)`\n\nFrees data in a previous reply from memory. After this function call,\naccessing to a freed replyid returns null value.\n\nIt is not really necessary to free a reply to use it again in a new\nmongodb_cmd function, being automatically freed on next command\nexecution, but for freeing used resources (e.g., memory), it is\nrecommended to do it.\n\n```\n...\nif(mongodb_cmd_simple(\"mgs1\", \"kamailio\", \"acc\", \"{ \\\"collStats\\\": \\\"acc\\\" }\", \"mgr1\")) {\n    xlog(\"response from mongodb is [[$mongodb(mgr1=>value)]]\\n\");\n}\nmongodb_free(\"mgr1\");\n...\n        \n```\n"
  }
 },
 "ndb_redis": {
  "overview": "This module provides a connector to interact with REDIS NoSQL Database\nfrom configuration file. You can read more about REDIS at\nhttp://redis.io.\n\nIt can connect to many REDIS servers and store the results in different\ncontainers.\n",
  "parameters": {
   "server": "### `server` (str)\n\nSpecify the details to connect to REDIS server. It takes a list of\nattribute=value separated by semicolon, the attributes can be name,\nunix, addr, port, db, pass and tls. Name is a generic identifier to be\nused with module functions. unix is the path to the unix domain socket\nprovided by redis server. addr and port are the IP address and the port\nto connect to REDIS server. pass is the server password. tls is to\nenable TLS connectivity. unix and (addr, port) are mutually exclusive.\nIf both appear in same server settings unix domain socket is configured.\ndb is the DB number to use (defaults to 0 if not specified).\n\nYou can set this parameter many times, in case you want to connect to\nmany REDIS servers, just give different attributes and use the specific\nserver name when querying the REDIS instance.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"ndb_redis\", \"server\", \"name=srvN;addr=127.0.0.1;port=6379;db=1\")\nmodparam(\"ndb_redis\", \"server\", \"name=srvX;addr=127.0.0.2;port=6379;db=4;pass=mypassword\")\nmodparam(\"ndb_redis\", \"server\", \"name=srvY;addr=127.0.0.3;port=6379;db=5;pass=mypassword;tls=1\")\n\n# Unix domain socket\nmodparam(\"ndb_redis\", \"server\", \"name=srvY;unix=/tmp/redis.sock;db=3\")\n\n# sentinel (for a redis slave)\nmodparam(\"ndb_redis\", \"server\", \"name=srvZ;sentinel_group=group_name;sentinel_master=0;sentinel=1.2.3.4:26379;sentinel=1.2.3.5:26379\")\n\n# sentinel (for a redis master)\nmodparam(\"ndb_redis\", \"server\", \"name=srvZ;sentinel_group=group_name;sentinel_master=1;sentinel=1.2.3.4:26379;sentinel=1.2.3.5:26379\")\n\n...\n```\n",
   "init_without_redis": "### `init_without_redis` (integer)\n\nIf set to 1, the module will correctly initialize even if redis is not\navailable at start up.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"ndb_redis\", \"init_without_redis\", 1)\n...\n            \n```\n",
   "connect_timeout": "### `connect_timeout` (int)\n\nThe timeout when connecting to the redis server\n\n*Default value is 1000 ms.*\n\n```\n...\nmodparam(\"ndb_redis\", \"connect_timeout\", 500)\n...\n            \n```\n",
   "cmd_timeout": "### `cmd_timeout` (int)\n\nThe timeout for each query to the redis server. If the redis server does\nnot reply within the timeout value, the command will fail and kamailio\nwill continue executing the cfg file.\n\n*Default value is 1000 ms.*\n\n```\n...\nmodparam(\"ndb_redis\", \"cmd_timeout\", 500)\n...\n            \n```\n",
   "cluster": "### `cluster` (integer)\n\nIf set to 1, the module will connect to servers indicated in the \"MOVED\"\nreply.\n\nThe module needs to know all existing REDIS-Nodes at startup. The nodes\nare searched by the name \"ip:port\", e.g. if REDIS replies with \"MOVED\n127.0.0.1:4711\", ndb_redis needs to know the databases \"127.0.0.1:4711\".\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"ndb_redis\", \"server\", \"name=127.0.0.1:26001;addr=127.0.0.1;port=26001\")\nmodparam(\"ndb_redis\", \"server\", \"name=127.0.0.1:26004;addr=127.0.0.1;port=26004\")\nmodparam(\"ndb_redis\", \"server\", \"name=127.0.0.1:26008;addr=127.0.0.1;port=26008\")\n...\nmodparam(\"ndb_redis\", \"cluster\", 1)\n...\n            \n```\n",
   "allowed_timeouts": "### `allowed_timeouts` (integer)\n\nIf this is set to a non-negative value, it sets the number of\nconsecutive REDIS commands that can fail before temporarily disabling\nthe REDIS server. This is similar to rtpengine_disable_tout parameter\nfrom the rtpengine module.\n\nWhen communicating with a REDIS server, if redis_cmd or redis_execute\nwill fail for more than \u201callowed_timeouts\u201d consecutive times, the server\nwill be temporary disabled for a number of seconds configured by the\n\u201cdisable_time\u201d parameter.\n\nDisabling a server means that further redis_cmd and redis_execute\ncommands will not do anything and return a negative value \u201c-2\u201d. Messages\nare also logged when disabling and re-enabling a server.\n\nThe number of consecutive fails are counted by each Kamailio process, so\nwhen disabling a server this is done just for that process, not\nglobally.\n\n*Default value is \u201c-1\u201d (disabled).*\n\n```\n...\nmodparam(\"ndb_redis\", \"allowed_timeouts\", 3)\n...\n            \n```\n",
   "disable_time": "### `disable_time` (integer)\n\nIf allowed_timeouts is set to a non negative value this determines the\nnumber of seconds the REDIS server will be disabled\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"ndb_redis\", \"allowed_timeouts\", 0)\nmodparam(\"ndb_redis\", \"disable_time\", 30)\n...\n            \n```\n",
   "flush_on_reconnect": "### `flush_on_reconnect` (integer)\n\nIf this is set to a non zero value, a \"FLUSHALL\" command is issued after\nreconnecting to a REDIS server, to clear the entire database.\n\nWhen a command to a REDIS server fails, a reconnection to that server is\nmade, so with this parameter each failed command will result in a flush\nof the database.\n\nThis is useful in scenarios when a REDIS server does not respond to\ncommands, but the commands might have been issued, and the responses\nlost. If this leaves the data in the db in an uncertain state, a flush\nmight fix any issues that may occur.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"ndb_redis\", \"flush_on_reconnect\", 1)\n...\n            \n```\n",
   "allow_dynamic_nodes": "### `allow_dynamic_nodes` (integer)\n\nIf set to 1, the module will connect to servers indicated in the \"MOVED\"\nreply, even if they are not specified at startup.\n\nWhen \u201ccluster\u201d is enabled the module supports redirections (\"MOVED\")\nreplies. Set \u201callow_dynamic_nodes\u201d to 1 to avoid listing all the nodes\nat startup. You can only list one node, e.g. by using a DNS name for the\ncluster instead of an IP address. The module will add dynamically the\nnew nodes as the MOVED replies are received. Only works if \u201ccluster\u201d is\nset to 1.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n...\nmodparam(\"ndb_redis\", \"server\", \"name=redis_cluster;addr=127.0.0.1;port=26008\")\n...\nmodparam(\"ndb_redis\", \"cluster\", 1)\nmodparam(\"ndb_redis\", \"allow_dynamic_nodes\", 1)\n...\n            \n```\n",
   "debug": "### `debug` (integer)\n\nSet the verbosity level for some of the log messages. It has to be a log\nlevel value.\n\n*Default value is \u201c3\u201d (L_DBG).*\n\n```\n...\nmodparam(\"ndb_redis\", \"debug\", 1)\n...\n            \n```\n",
   "ac_path": "### `ac_path` (string)\n\nSets the path where Certificates Authorities certs are stored.\n\nDefault value: \"\" (empty).\n\n```\n...\nmodparam(\"db_redis\", \"ca_path\", \"/etc/ssl/certs\")\n...\n            \n```\n"
  },
  "functions": {
   "redis_cmd": "### `redis_cmd(srvname, command, ..., replyid)`\n\nSend a command to REDIS server identified by srvname. The reply will be\nstored in a local container identified by replyid. All the parameters\ncan be strings with pseudo-variables that are evaluated at runtime.\n\nMinimum required arguments are srvname, command and replyid. Command\nargument can be separated into several ones using %s token. (See\nexamples) Total number of arguments cannot exceed six.\n\nThe reply can be accessed via pseudo-variable $redis(key). The key can\nbe: type - type of the reply (as in hiredis.h); value - the value\nreturned by REDIS server; info - in case of error from REDIS, it will\ncontain an info message.\n\nIf reply type is an array (as in hiredis.h), there are other keys\navailable:\n\n- size - returns number of elements in the array.\n\n- type[n] - returns the type of the nth element in the array. type -\n  returns array type.\n\n- value[n] - returns value of the nth element. value - returns null\n  for an array. You need to get each element by index.\n\nIn case one of the members of the array is also an array (for example\ncalling SMEMBERS in a MULTI/EXEC transaction), the members of the array\ncan be accessed by adding any of the above keys, after a value[n] key.\nThe first value[n] references the element in the first array, while\nthe next key references an element of the referenced array.\n\nThe result type can be compared with $redisd(key) variable to test its\nvalue. The key can be: rpl_str, rpl_arr, rpl_int, rpl_err, rpl_sts,\nrpl_nil.\n\n```\n...\nif(redis_cmd(\"srvN\", \"INCR cnt\", \"r\")) {\n    # success - the incremented value is in $redis(r=>value)\n    xlog(\"===== $redis(r=>type) * $redis(r=>value)\\n\");\n}\n\n# set a value\nredis_cmd(\"srvN\", \"SET foo bar\", \"r\");\n\nredis_cmd(\"srvN\", \"SET ruri $ru\", \"r\");\n\n# get a value\nredis_cmd(\"srvN\", \"GET foo\", \"r\");\n\n# same command separated into two arguments:\nredis_cmd(\"srvN\", \"GET %s\", \"foo\", \"r\");\n\n# if we have a key with spaces within it:\nredis_cmd(\"srvN\", \"GET %s\", \"foo bar\", \"r\");\n\n# several values substitution:\nredis_cmd(\"srvN\", \"HMGET %s %s %s\", \"key1\", \"field1\", \"field2\", \"r\");\n\n\n# array example\nif(redis_cmd(\"srvN\", \"HMGET foo_key field1 field3\", \"r\")) {\n    xlog(\"array size: $redis(r=>size)\\n\");\n    xlog(\"first values: $redis(r=>value[0]) , $redis(r=>value[1])\\n\");\n}\n\n\n# array as element of an array example\nredis_cmd(\"srvN\", \"MULTI\", \"r1\");\nredis_cmd(\"srvN\", \"SMEMBERS foo\", \"r2\");\nif (redis_cmd(\"srvN\", \"EXEC\", \"r\")) {\n    xlog(\"array size: $redis(r=>value[0]=>size)\\n\");\n    xlog(\"first member of the set:$redis(r=>value[0]=>value[0])\\n\");\n    xlog(\"type of the second member of the set:$redis(r=>value[0]=>type[1])\\n\");\n}\n...\n```\n",
   "redis_pipe_cmd": "### `redis_pipe_cmd(srvname, command, ..., replyid)`\n\nAdd a command to be sent to REDIS server identified by srvname. All the\ncommands will be stored in a buffer until a call to redis_execute is\nmade. When calling redis_execute the stored commands are sent using the\npipelining functionality of redis. The replies will be stored in local\ncontainers identified by the replyid of each added command. All the\nparameters can be strings with pseudo-variables that are evaluated at\nruntime.\n\nThis command is similar in syntax with redis_cmd, the only difference is\nthat it does not send the command but instead appends it to a buffer.\n\nSee examples from redis_execute.\n\nNote: Pipelining feature is incompatible with the clustering feature. If\ncluster parameter is set to 1, this function will log an error and do\nnothing.\n",
   "redis_execute": "### `redis_execute(srvname)`\n\nSends commands to REDIS server identified by srvname. Commands are added\nwith redis_pipe_cmd function, and will be stored for an existing REDIS\nserver. When this function is called all the commands will be sent in a\nsingle message to the REDIS server.\n\nWhen using redis_cmd together with redis_pipe_cmd it is recommended that\na call to redis_execute is made before calling redis_cmd in case there\nare pipelined commands, otherwise when calling redis_cmd, if pipelined\nmessages exist, a call to redis_execute is made automatically and a\nwarning message is logged.\n\nNote: Pipelining feature is incompatible with the clustering feature. If\ncluster parameter is set to 1, this function will log an error and do\nnothing.\n\n```\n...\nAfter several redis command calls:\n    redis_pipe_cmd(\"srvA\", \"SET foo bar\", \"r1\");\n\n    redis_pipe_cmd(\"srvB\", \"SET ruri $ru\", \"r2\");\n\n    redis_pipe_cmd(\"srvB\", \"GET foo\", \"r3\");\n\nSend the data and retrieve the results:\n    redis_execute(\"srvA\"); //send command to srvA and wait for reply. Store the reply in r1\n\n    redis_execute(\"srvB\"); //send command to srvA and wait for reply. Store the replies in r2 (for SET ruri $ru) and r3 (for GET foo)\n\nUsing both redis_cmd and redis_pipe_cmd:\n    redis_pipe_cmd(\"srvA\", \"SET foo bar\", \"r1\");\n\n    redis_pipe_cmd(\"srvA\", \"SET ruri $ru\", \"r2\");\n\n    redis_execute(\"srvA\"); //send commands to srvA and wait for reply. Store replies in r1 and r2\n\n    redis_cmd(\"srvA\", \"GET foo\", \"r3\"); //send command, wait for reply and store it in r3\n\n\n    redis_pipe_cmd(\"srvA\", \"SET foo bar\", \"r1\");\n\n    redis_pipe_cmd(\"srvA\", \"SET ruri $ru\", \"r2\");\n\n    redis_cmd(\"srvA\", \"GET foo\", \"r3\"); //first call redis execute (replies are stored in r1 and r2), log warning and execute redis_cmd\n\n    redis_execute(\"srvA\"); //this does nothing as there are no more pipelined commands. The call is not necessary\n...\n        \n```\n",
   "redis_free": "### `redis_free(replyid)`\n\nFrees data in a previous reply from memory. After this function call,\naccessing to a freed replyid returns null value.\n\nIt is not necessary to free a reply to use it again in a new redis_cmd\nfunction. When ndb_redis module closes, all pending replies are freed\nautomatically.\n\n```\n...\nAfter a redis command call:\n    redis_cmd(\"srvN\", \"INCR cnt\", \"r\");\n\nfree reply data:\n    redis_free(\"r\");\n...\n        \n```\n"
  }
 },
 "nosip": {
  "overview": "This module provides a way to get access to non-SIP packages received by\nKamailio via its SIP worker processes. The content of such packages is\navailable in the $mb variable inside the event_route[nosip:msg].\n\nNote that packets with size less than 32 bytes are discarded, this\nthreshold being set to avoid handling the NAT keepalive packets coming\nfrom devices. The limit is planned to be made configurable. Also, by\ndefault Kamailio writes a log messages in case of SIP parsing error,\nthat can be controlled via 'corelog' global parameter.\n\nBesides the content of the packet, $si and $sp provide the source IP\nand port, allowing to do filtering and authorization.\n",
  "parameters": {
   "msg_match": "### `msg_match` (str)\n\nRegular expression to match against content of the packet in order to\nexecute the event_route[nosip:msg].\n\n*Default value is empty.*\n\n```\n...\nmodparam(\"nosip\", \"msg_match\", \"^KREQUEST-\")\n...\n```\n",
   "msg_skip": "### `msg_skip` (str)\n\nRegular expression to match against content of the packet in order to\nskip execution the event_route[nosip:msg].\n\n*Default value is empty.*\n\n```\n...\nmodparam(\"nosip\", \"msg_skip\", \"^GET \")\n...\n```\n"
  },
  "functions": {}
 },
 "nsq": {
  "overview": "The module provides an NSQ consumer for Kamailio configuration file. NSQ\nis a real time distributed messaging platform, more details about it can\nbe found at [nsq.io](http://nsq.io).\n\nFrom a high-level perspective, the module may be used for:\n\n- Provide a real-time integration with you Kamailio configuration file,\n  which can be used as alternative to interact with a database, allowing\n  to overlay additional logic in your preferred language while utilizing\n  a message bus.\n\n- Rely on a distributed messaging layer, such that machines processing\n  requests/responses/events can go up/down or share the workload,\n  without impacting Kamailio's activity.\n\nSupported NSQ operations are:\n\n- Subscribe to a Topic and Channel\n\n*IMPORTANT* The `nsq.json` transformation is deprecated in favor of\nthe json module's `json.parse` transformation. The\n`nsq_pua_publish()` function is deprecated in favor of pua_json\nmodule's `pua_json_publish()` function.\n",
  "parameters": {
   "lookupd_address": "### `lookupd_address`(str)\n\nThe nsqlookupd address.\n\nUsage: nsq related.\n\n*Default value is 127.0.0.1*\n\n```\n...\nmodparam(\"nsq\", \"lookupd_address\", \"nsqlookupd.mydomain.com\")\n...\n```\n",
   "lookupd_port": "### `lookupd_port`(int)\n\nThe nsqlookupd TCP port.\n\nUsage: nsq related.\n\n*Default value is 4161.*\n\n```\n...\nmodparam(\"nsq\", \"lookupd_port\", 4161)\n...\n                \n```\n",
   "nsqd_address": "### `nsqd_address`(str)\n\nThe nsqd address. You can specify connecting directly to nsqd instead of\nusing nsqlookupd.\n\nUsage: nsq related.\n\n*Default value is 127.0.0.1*\n\n```\n...\nmodparam(\"nsq\", \"nsqd_address\", \"nsqd.mydomain.com\")\n...\n```\n",
   "nsqd_port": "### `nsqd_port`(int)\n\nThe nsqd TCP port.\n\nUsage: nsq related.\n\n*Default value is 4150.*\n\n```\n...\nmodparam(\"nsq\", \"nsqd_port\", 4150)\n...\n```\n",
   "consumer_use_nsqd": "### `consumer_use_nsqd`(int)\n\nSet to 1 if you'd like to connect to nsqd instead of nsqlookupd.\n\nUsage: nsq related.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"nsq\", \"consumer_use_nsqd\", 1)\n...\n```\n",
   "consumer_event_key": "### `consumer_event_key`(str)\n\nThe default name of the field in json payload to compose the event name\n1st part\n\nUsage: nsq related.\n\n*Default value is \u201cEvent-Category\u201d.*\n\n```\n...\nmodparam(\"nsq\", \"consumer_event_key\", \"My-JSON-Field-Name\")\n...\n```\n",
   "consumer_event_subkey": "### `consumer_event_subkey`(str)\n\nThe default name of the field in json payload to compose the event name\n2nd part\n\nUsage: nsq related.\n\n*Default value is \u201cEvent-Name\u201d.*\n\n```\n...\nmodparam(\"nsq\", \"consumer_event_subkey\", \"My-JSON-SubField-Name\")\n...\n```\n",
   "max_in_flight": "### `max_in_flight`(int)\n\nThe number of messages the consumer can receive before nsqd expects a\nresponse.\n\nUsage: nsq related.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"nsq\", \"max_in_flight\", 2)\n...\n```\n",
   "consumer_workers": "### `consumer_workers`(int)\n\nNumber of consumer connections to NSQ per topic_channel.\n\nUsage: nsq related.\n\n*Default value is 4.*\n\n```\n...\nmodparam(\"nsq\", \"consumer_workers\", 2)\n...\n```\n",
   "topic_channel": "### `topic_channel`(str)\n\nThe NSQ Topic and Channel. Delimiter-separated by \u201c:\u201d. It be set\nmultiple times to subscribe to multiple topics and channels. The value\nof consumer_workers is allocated per topic_channel.\n\nUsage: nsq related.\n\n*Default value is \u201cKamailio-Topic:Kamailio-Channel\u201d.*\n\n```\n...\nmodparam(\"nsq\", \"topic_channel\", \"My-NSQ-Topic:My-NSQ-Channel\")\nmodparam(\"nsq\", \"topic_channel\", \"My-NSQ-Topic-2:My-NSQ-Channel-2\")\n...\n                \n```\n"
  },
  "functions": {}
 },
 "osp": {
  "overview": "The OSP module enables Kamailio to support secure, multi-lateral peering\nusing the OSP standard defined by ETSI (TS 101 321 V4.1.1). This module\nwill enable your Kamailio to:\n\n- Send a peering authorization request to a peering server.\n\n- Validate a digitally signed peering authorization token received in a\n  SIP INVITE message.\n\n- Report usage information to a peering server.\n",
  "parameters": {
   "sp1_uri": "### `sp1_uri`, `sp2_uri`, ..., `sp16_uri`\n\nThese sp_uri (string) parameters define peering servers to be used for\nrequesting peering authorization and routing information. At least one\npeering server must be configured. Others are required only if there are\nmore than one peering servers. Each peering server address takes the\nform of a standard URL, and consists of up to four components:\n\n- An optional indication of the protocol to be used for communicating\n  with the peering server. Both HTTP and HTTP secured with SSL/TLS are\n  supported and are indicated by \"http://\" and \"https://\" respectively.\n  If the protocol is not explicitly indicated, the Kamailio defaults to\n  HTTP secured with SSL.\n\n- The Internet domain name for the peering server. An IP address may\n  also be used, provided it is enclosed in square brackets such as\n  [172.16.1.1].\n\n- An optional TCP port number for communicating with the peering server.\n  If the port number is omitted, the Kamailio defaults to port 1080 (for\n  HTTP) or port 1443 (for HTTP secured with SSL).\n\n  The uniform resource identifier for requests to the peering server.\n  This component is not optional and must be included.\n\n<!-- -->\n\n\n```\nmodparam(\"osp\",\"sp1_uri\",\"http://osptestserver.transnexus.com:1080/osp\")\nmodparam(\"osp\",\"sp2_uri\",\"https://[1.2.3.4]:1443/osp\")\n        \n```\n",
   "sp1_weight": "### `sp1_weight`, `sp2_weight`, ..., `sp16_weight`\n\nThese sp_weight (integer) parameters are used for load balancing peering\nrequests to peering servers. These parameters are most effective when\nconfigured as factors of 1000. For example, if sp1_uri should manage\ntwice the traffic load of sp2_uri, then set sp1_weight to 2000 and\nsp2_weight to 1000. Shared load balancing between peering servers is\nrecommended. However, peering servers can be configured as primary and\nbackup by assigning a sp_weight of 0 to the primary server and a\nnon-zero sp_weight to the back-up server. The default values for\nsp1_weight and sp2_weight are 1000.\n\n```\nmodparam(\"osp\",\"sp1_weight\",1000)\n        \n```\n",
   "device_ip": "### `device_ip`\n\nThe device_ip (string) is a recommended parameter that explicitly\ndefines the IP address of Kamailio in a peering request message (as\nSourceAlternate type=transport). The IP address must be in brackets as\nshown in the example below.\n\n```\nmodparam(\"osp\",\"device_ip\",\"[1.1.1.1]\")\n        \n```\n",
   "device_port": "### `device_port`\n\nThe device_port (string) parameter is an optional field which includes\nthe SIP port being used by Kamailio in the peering request (as\nSourceAlternate type=network) to the peering server. If it is not\nconfigured, this information is not included in the peering request.\nThis field is useful if multiple Kamailio are running on the same Linux\ncomputer since it enables the peering server to administer different\npeering policies based on different SIP proxies. This parameter has not\nbeen implemented yet.\n\n```\nmodparam(\"osp\",\"device_port\",\"5060\")\n        \n```\n",
   "token_format": "### `token_format`\n\nWhen Kamailio receives a SIP INVITE with a peering token, the OSP Module\nwill validate the token to determine whether or not the call has been\nauthorized by a peering server. Peering tokens may, or may not, be\ndigitally signed. The token_format (integer) parameter defines if\nKamailio will validate signed or unsigned tokens or both. The values for\ntoken format are defined below. The default value is 2.\n\n0 - Validate only signed tokens. Calls with valid signed tokens are\nallowed.\n\n1 - Validate only unsigned tokens. Calls with valid unsigned tokens are\nallowed.\n\n2 - Validate both signed and unsigned tokens are allowed. Calls with\nvalid tokens are allowed.\n\n```\nmodparam(\"osp\",\"token_format\",2)\n        \n```\n",
   "private_key": "### `private_key`, `local_certificate`, `ca_certificates`\n\nThese parameters identify files are used for validating peering\nauthorization tokens and establishing a secure channel between Kamailio\nand a peering server using SSL. The files are generated using the\n'Enroll' utility from the OSP Toolkit. By default, the proxy will look\nfor pkey.pem, localcert.pem, and cacart_0.pem in the default\nconfiguration directory. The default config directory is set at compile\ntime using CFG_DIR and defaults to /usr/local/etc/kamailio/. The files\nmay be copied to the expected file location or the parameters below may\nbe changed.\n\nIf the default CFG_DIR value was used at compile time, the files will be\nloaded from:\n\n```\nmodparam(\"osp\",\"private_key\",\"/usr/local/etc/kamailio/pkey.pem\")\nmodparam(\"osp\",\"local_certificate\",\"/usr/local/etc/kamailio/localcert.pem\")\nmodparam(\"osp\",\"ca_certificates\",\"/usr/local/etc/kamailio/cacert.pem\")\n        \n```\n",
   "enable_crypto_hardware_support": "### `enable_crypto_hardware_support`\n\nThe enable_crypto_hardware_support (integer) parameter is used to set\nthe cryptographic hardware acceleration engine in the openssl library.\nThe default value is 0 (no crypto hardware is present). If crypto\nhardware is used, the value should be set to 1.\n\n```\nmodparam(\"osp\",\"enable_crypto_hardware_support\",0)\n        \n```\n",
   "ssl_lifetime": "### `ssl_lifetime`\n\nThe ssl_lifetime (integer) parameter defines the lifetime, in seconds,\nof a single SSL session key. Once this time limit is exceeded, the OSP\nModule will negotiate a new session key. Communication exchanges in\nprogress will not be interrupted when this time limit expires. This is\nan optional field with default value is 200 seconds.\n\n```\nmodparam(\"osp\",\"ssl_lifetime\",200)\n        \n```\n",
   "persistence": "### `persistence`\n\nThe persistence (integer) parameter defines the time, in seconds, that\nan HTTP connection should be maintained after the completion of a\ncommunication exchange. The OSP Module will maintain the connection for\nthis time period in anticipation of future communication exchanges to\nthe same peering server.\n\n```\nmodparam(\"osp\",\"persistence\",1000)\n        \n```\n",
   "retry_delay": "### `retry_delay`\n\nThe retry_delay (integer) parameter defines the time, in seconds,\nbetween retrying connection attempts to an OSP peering server. After\nexhausting all peering servers the OSP Module will delay for this amount\nof time before resuming connection attempts. This is an optional field\nwith default value is 1 second.\n\n```\nmodparam(\"osp\",\"retry_delay\",1)\n        \n```\n",
   "retry_limit": "### `retry_limit`\n\nThe retry_limit (integer) parameter defines the maximum number of\nretries for connection attempts to a peering server. If no connection is\nestablished after this many retry attempts to all peering servers, the\nOSP Module will cease connection attempts and return appropriate error\ncodes. This number does not count the initial connection attempt, so\nthat a retry_limit of 1 will result in a total of two connection\nattempts to every peering server. The default value is 2.\n\n```\nmodparam(\"osp\",\"retry_limit\",2)\n        \n```\n",
   "timeout": "### `timeout`\n\nThe timeout (integer) parameter defines the maximum time in\nmilliseconds, to wait for a response from a peering server. If no\nresponse is received within this time, the current connection is aborted\nand the OSP Module attempts to contact the next peering server. The\ndefault value is 10 seconds.\n\n```\nmodparam(\"osp\",\"timeout\",10)\n        \n```\n",
   "max_destinations": "### `max_destinations`\n\nThe max_destinations (integer) parameter defines the maximum number of\ndestinations that Kamailio requests the peering server to return in a\npeering response. The default value is 5.\n\n```\nmodparam(\"osp\",\"max_destinations\",5)\n        \n```\n",
   "validate_call_id": "### `validate_call_id`\n\nThe validate_call_id (integer) parameter instructs the OSP module to\nvalidate call id in the peering token. If this value is set to 1, the\nOSP Module validates that the call id in the SIP INVITE message matches\nthe call id in the peering token. If they do not match the INVITE is\nrejected. If this value is set to 0, the OSP Module will not validate\nthe call id in the peering token. The default value is 1.\n\n```\nmodparam(\"osp\",\"validate_call_id\",1)\n        \n```\n",
   "use_rpid_for_calling_number": "### `use_rpid_for_calling_number`\n\nThe use_rpid_for_calling_number (integer) parameter instructs the OSP\nmodule to use the calling number in the Remote-Party-ID of the SIP\nINVITE message. If this value is set to 1, the OSP Module uses the\ncalling number in the Remote-Party-ID header of the INVITE message when\na Remote-Party-ID exists. If this value is set to 0, the OSP Module will\nuse the calling number in the From header of the INVITE message. The\ndefault value is 1.\n\n```\nmodparam(\"osp\",\"use_rpid_calling_number\",1)\n        \n```\n",
   "redirection_uri_format": "### `redirection_uri_format`\n\nThe redirection_uri_format (integer) parameter instructs the OSP module\nto use the different URI format in the SIP redirection message. If this\nvalue is set to 0, the OSP Module uses \"xxxxxxxxxx@xxx.xxx.xxx.xxx\" URI\nin the SIP redirection messages. If this value is set to 1, the OSP\nModule will use \u201c<xxxxxxxxxx@xxx.xxx.xxx.xxx>\u201d URI in the SIP\nredirection messages. The default value is 0\n\n```\nmodparam(\"osp\",\"redirection_uri_format\",1)\n        \n```\n",
   "source_networkid_avp": "### `source_networkid_avp`\n\nThe source_networkid_avp (string) parameter instructs the OSP module to\nuse the defined AVP to pass the source network ID value. The default\nvalue is \"$avp(s:_osp_source_networkid_)\". Then the source network ID\ncan be set by \"$avp(s:_osp_source_networkid_) = pseudo-variables\".\nAll pseudo variables are described in\nhttps://www.kamailio.org/wikidocs/cookbooks/devel/pseudovariables/.\n\n```\nmodparam(\"osp\",\"source_networkid_avp\",\"$avp(s:snid)\")\n        \n```\n"
  },
  "functions": {
   "checkospheader": "### `checkospheader()`\n\nThis function checks for the existence of the OSP-Auth-Token header\nfield.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (checkospheader()) {\n  log(1,\"OSP header field found.\\n\");\n} else {\n  log(1,\"no OSP header field present\\n\");\n};\n...\n        \n```\n",
   "validateospheader": "### `validateospheader()`\n\nThis function validates an OSP-Token specified in the\nOSP-Auth-Tokenheader field of the SIP message. If a peering token is\npresent, it will be validated locally. If no OSP header is found or the\nheader token is invalid or expired, -1 is returned; on successful\nvalidation 1 is returned.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (validateospheader()) {\n  log(1,\"valid OSP header found\\n\");\n} else {\n  log(1,\"OSP header not found, invalid or expired\\n\");\n};\n...\n        \n```\n",
   "requestosprouting": "### `requestosprouting()`\n\nThis function launches a query to the peering server requesting the IP\naddress of one or more destination peers serving the called party. If\ndestination peers are available, the peering server will return the IP\naddress and a peering authorization token for each destination peer. The\nOSP-Auth-Token Header field is inserted into the SIP message and the SIP\nuri is rewritten to the IP address of destination peer provided by the\npeering server.\n\nThe address of the called party must be a valid E164 number, otherwise\nthis function returns -1. If the transaction was accepted by the peering\nserver, the uri is being rewritten and 1 returned, on errors (peering\nservers are not available, authentication failed or there is no route to\ndestination or the route is blocked) -1 is returned.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (requestosprouting()) {\n  log(1,\"successfully queried OSP server, now relaying call\\n\");\n} else {\n  log(1,\"Authorization request was rejected from OSP server\\n\");\n};\n...\n        \n```\n",
   "checkosproute": "### `checkosproute()`\n\nThis function is used to check if there is any route for the call.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (checkosproute()) {\n  log(1,\"There is at least one route for the call\\n\");\n} else {\n  log(1,\"There is not any route for the call\\n\");\n};\n...\n        \n```\n",
   "prepareosproute": "### `prepareosproute()`\n\nThis function tries to prepare the INVITE to be forwarded using the\ndestination in the list returned by the peering server. If the calling\nnumber is translated, a RPID value for the RPID AVP will be set. If the\nroute could not be prepared, the function returns 'FALSE' back to the\nscript, which can then decide how to handle the failure. Note, if\ncheckosproute has been called and returns 'TRUE' before calling\nprepareosproute, prepareosproute should not return 'FALSE' because\ncheckosproute has confirmed that there is at least one route.\n\nThis function can be used from BRANCH_ROUTE.\n\n```\n...\nif (prepareosproute()) {\n  log(1,\"successfully prepared the route, now relaying call\\n\");\n} else {\n  log(1,\"could not prepare the route, there is not route\\n\");\n};\n...\n        \n```\n",
   "checkcallingtranslation": "### `checkcallingtranslation()`\n\nThis function is used to check if the calling number is translated.\nBefore calling checkcallingtranslation, prepareosproute should be\ncalled. If the calling number does been translated, the original\nRemote-Party-ID, if it exists, should be removed from the INVITE\nmessage. And a new Remote-Party-ID header should be added (a RPID value\nfor the RPID AVP has been set by prepareosproute). If the calling number\nis not translated, nothing should be done.\n\nThis function can be used from BRANCH_ROUTE.\n\n```\n...\nif (checkcallingtranslation()) {\n  # Remove the Remote_Party-ID from the received message\n  # Otherwise it will be forwarded on to the next hop\n  remove_hf(\"Remote-Party-ID\");\n\n  # Append a new Remote_Party\n  append_rpid_hf();\n}\n...\n        \n```\n",
   "prepareallosproute": "### `prepareallosproute()`\n\nThis function tries to prepare all the routes in the list returned by\nthe peering server. The message is then either forked off or redirected\nto the destination. If unsuccessful in preparing the routes a SIP 500 is\nsent back and a trace message is logged.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (prepareallosproute()) {\n  log(1,\"Routes are prepared, now either forking or redirecting the call\\n\");\n} else {\n  log(1,\"Could not prepare the routes. No destination available\\n\");\n};\n...\n        \n```\n",
   "reportospusage": "### `reportospusage()`\n\nThis function should be called after receiving a BYE message. If the\nmessage contains an OSP cookie, the function will forward originating\nand/or terminating duration usage information to a peering server. The\nfunction returns TRUE if the BYE includes an OSP cookie. The actual\nusage message will be sent on a different thread and will not delay BYE\nprocessing. The function should be called before relaying the message.\n\nMeaning of the parameter is as follows:\n\n- \"0\" - Source device releases the call.\n\n- \"1\" - Destination device releases the call.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_direction(\"downstream\")) {\n  log(1,\"This BYE message is from SOURCE\\n\");\n  if (!reportospusage(\"0\")) {\n    log(1,\"This BYE message does not include OSP usage information\\n\");\n  }\n} else {\n  log(1,\"This BYE message is from DESTINATION\\n\");\n  if (!reportospusage(\"1\")) {\n    log(1,\"This BYE message does not include OSP usage information\\n\");\n  }\n}\n...\n        \n```\n"
  }
 },
 "outbound": {
  "overview": "This module provides C-API functions to enable Kamailio to be used as an\noutbound Edge Proxy (see [RFC5626](https://www.ietf.org/rfc/rfc5626.txt)\nsection 5).\n\nThe *path* and *rr* modules will bind to this module if it is loaded\nbefore they are.\n",
  "parameters": {
   "force_outbound_flag": "### `force_outbound_flag` (integer)\n\nA flag which, if set for a request, will force *path* and *rr* to add\nflow tokens to Path: and Record-Route: headers regardless of the request\ncontents.\n\n*Default value is -1.*\n\n```\n...\nmodparam(\"outbound\", \"force_outbound_flag\", 1)\n...\n```\n",
   "force_no_outbound_flag": "### `force_no_outbound_flag` (integer)\n\nA flag which, if set for a request, will force *path* and *rr* not to\nadd flow tokens to Path: and Record-Route: headers regardless of the\nrequest contents.\n\n*Default value is -1.*\n\n```\n...\nmodparam(\"outbound\", \"force_no_outbound_flag\", 2)\n...\n```\n",
   "flow_token_secret": "### `flow_token_secret` (string)\n\nSecret phrase used to calculate the outbound key value used for flow\ntokens validation. Allows to set persistent outbound key.\n\nIf not specified, *outbound* will use randomly generated outbound key\n\n```\n...\nmodparam(\"outbound\", \"flow_token_secret\", \"johndoessecretphrase\")\n...\n            \n```\n"
  },
  "functions": {}
 },
 "p_usrloc": {
  "overview": "\n",
  "parameters": {},
  "functions": {}
 },
 "path": {
  "overview": "This module is designed to be used at intermediate sip proxies like\nloadbalancers in front of registrars and proxies. It provides functions\nfor inserting a Path header including a parameter for passing forward\nthe received-URI of a registration to the next hop. It also provides a\nmechanism for evaluating this parameter in subsequent requests and to\nset the destination URI according to it.\n",
  "parameters": {
   "use_received": "### `use_received` (int)\n\nIf set to 1, the \u201creceived\u201d parameter of the first Route URI is\nevaluated and used as destination-URI if present.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"path\", \"use_received\", 1)\n...\n```\n",
   "received_format": "### `received_format` (int)\n\nIf set to 0, the \u201creceived\u201d parameter value will be in the escaped SIP\nURI format.\n\nIf set to 1, the \u201creceived\u201d parameter value will be in the same format\nas the \u201calias\u201d parameter added by set_contact_alias() from \u201cnathelper\u201d\nmodule (i.e., \u201cip~port~protid\u201d). This is a solution with some SIP\napplications that incorrectly match the transport from received\nparameter instead of the one from the SIP URI.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"path\", \"received_format\", 1)\n...\n```\n",
   "received_name": "### `received_name` (str)\n\nSet the name of the header parameter to add the \u201creceived\u201d value.\n\n*Default value is \"received\".*\n\n```\n...\nmodparam(\"path\", \"received_name\", \"rcv\")\n...\n```\n",
   "enable_r2": "### `enable_r2` (int)\n\nIf set to 1, the module will add two Path headers, similar to the double\nRecord-Route done by rr module. One Path headers corresponds to incoming\nnetwork socket and the other to outgoing network socket. The URIs in the\nPath headers will have the 'r2=on' parameter as well.\n\nNote: if enabled, the module adds the two Path headers even when the\nincoming socket is the same as outgoing socket. Improvements to skip the\nsecond Path header in this case may be introduced in the future,\nmeanwhile, if you need to enable this parameter but also deal with same\nsocket routing, use 'insert_hf(\"Path: <$Ru>\\r\\n\")'.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"path\", \"enable_r2\", 1)\n...\n```\n",
   "sockname_mode": "### `sockname_mode` (int)\n\nIf set to 1, the Path URI is built to contain socket name in 'sn'\nparameter.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"path\", \"sockname_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "add_path": "### `add_path(user, parameters)`\n\nThis function adds a Path header in the form \u201cPath:\n<sip:user@1.2.3.4;lr>\u201d and appends the given *parameters* as\nadditional URI parameters.\n\nMeaning of the parameters is as follows:\n\n- *user* - The username to be inserted as user part. SPVE is supported.\n\n- *parameters* - Additional URI parameters to be appended to the URI.\n  The semicolon separator is added automatically. The script writer is\n  responsible for proper URI escaping. SPVE is supported.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!add_path(\"loadbalancer\", \"ob\")) {\n    sl_send_reply(\"503\", \"Internal Path Error\");\n    ...\n};\n...\n```\n",
   "add_path_received": "### `add_path_received(user, parameters)`\n\nThis function adds a Path header in the form \u201cPath:\n<sip:user@1.2.3.4;received=sip:2.3.4.5:1234;lr>\u201d, setting 'user' as\nusername part of address, its own outgoing address as domain-part, and\nthe address the request has been received from as received-parameter.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (!add_path_received(\"inbound\", \"ob\")) {\n    sl_send_reply(\"503\", \"Internal Path Error\");\n    ...\n};\n...\n```\n"
  }
 },
 "pdb": {
  "overview": "This is a module for fast number portability handling. The client is\nthis module and the server exists in the /utils/pdbt directory. The PDB\nmodule and server supports load-balancing and aggressive timeouts.\nNormally it does not need more than a few ms to query the remote server\nand return the reply to the configuration script.\n\nThe pdb module allows Kamailio to send queries to a list of servers and\nstore the answer in an AVP. The idea is to ask all servers in parallel\nand use the first answer, that comes back. A timeout for the query can\nbe defined in milliseconds. The querying can be activated and\ndeactivated using FIFO commands.\n\nMore about the new communication protocol between this module and\npdb_server can be found in utils/pdbt/docs/network_protocol.txt. The\ncurrent version is 1.\n",
  "parameters": {
   "timeout": "### `timeout` (integer)\n\nThis is the timeout in milliseconds for the pdb_query function.\n\n*Default value is \u201c50\u201d.*\n\n```\n...\nmodparam(\"pdb\", \"timeout\", 10)\n...\n            \n```\n",
   "server": "### `server` (string)\n\nThis is the list of servers to be used by the pdb_query function.\nQueries will be sent in parallel to all servers configured in this list.\nThis parameter is mandatory.\n\n```\n...\nmodparam(\"pdb\", \"server\", \"localhost:10001,host.name:10001,192.168.1.7:10002\")\n...\n            \n```\n",
   "ll_info": "### `ll_info` (int)\n\nLocal log level (per module) for specific INFO messages. It has to be a\nvalid log level value (see xlog() function from xlog module for more\ndetails).\n\n*Default value is \u201c2\u201d.*\n\n```\n...\nmodparam(\"pdb\", \"ll_info\", 3)\n...\n            \n```\n"
  },
  "functions": {
   "pdb_query": "### `pdb_query (string query, string dstavp)`\n\nSends the query string to all configured servers and stores the answer\nin dstavp. If it takes more than the configured timeout, false is\nreturned. Pseudo-variables or AVPs can be used for the query string. The\nanswer must consist of the null terminated query string followed by a\ntwo byte integer value in network byte order. The integer value will be\nstored in the given AVP.\n\n```\n...\n# query external service for routing information\nif (!pdb_query(\"$rU\", \"$avp(i:82)\"))\n  $avp(i:82) = 0; # default routing\n}\ncr_route(\"$avp(i:82)\", \"$rd\", \"$rU\", \"$rU\", \"call_id\");\n...\n                \n```\n"
  }
 },
 "pdt": {
  "overview": "This module translates a numerical prefix into a domain and updates\naccordingly the request URI.\n\nThe module looks up at the R-URI part of a message and if the user part\nbegins with an established prefix it will update the URI. Updating the\nuri consists of: remove the prefix from the user part of the uri and\nkeep the rest as the user part of the new uri. The host and port are\nchanged with the domain matched for the leading prefix and the domain in\nFrom URI.\n\n<prefix><userid><:password>@<mydomain.com> ...\n\nand the result will be:\n\n<userid><:password>@<domain[:port]>...\n\n```\nprefix=123, domain(FROM)=siphub.org\n\nentry in database:\n sdomain=siphub.org\n    domain[123]=alpha.org\n    domain[124]=beta.org\n    domain[125]=gamma.org\n\nThe RURI will be updated in the following way\"\nsip:12391001@mydomain.com  => sip:91001@alpha.org\n```\n\nThe prefix could be prefixed by other digits. These digits will not be\nused to look up the domain (the classic example, 00 used for\ninternational calls, then follows the country prefix). For more\ninformation on this, see 'prefix' parameter.\n\n- A sample config file is located in './doc/'.\n\n- MySQL script to create the database needed by PDT is located in\n  '../../scripts/mysql/pdt-create.sql'\n\n  The database is loaded by Kamailio only at start up time and only\n  cache is used to lookup domains. Check the MI Functions for\n  adding/deleting prefix-domain pairs or reloading from database at\n  runtime.\n\n- Sample shell scripts to manage prefix-domain pairs are also located in\n  './doc/' (pdt_fifo_list.sh).\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nURL of the database table to be used.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"pdt\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_table": "### `db_table` (string)\n\nTable name.\n\n*Default value is \u201cpdt\u201d.*\n\n```\n...\nmodparam(\"pdt\", \"db_table\", \"pdt\")\n...\n```\n",
   "sdomain_column": "### `sdomain_column` (string)\n\nName of 'sdomain' column.\n\n*Default value is \u201csdomain\u201d.*\n\n```\n...\nmodparam(\"pdt\", \"domain_column\", \"source_domain\")\n...\n```\n",
   "prefix_column": "### `prefix_column` (string)\n\nName of 'prefix' column.\n\n*Default value is \u201cprefix\u201d.*\n\n```\n...\nmodparam(\"pdt\", \"prefix_column\", \"prefix\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nName of 'domain' column.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"pdt\", \"domain_column\", \"hostname\")\n...\n```\n",
   "prefix": "### `prefix` (string)\n\nDefault leading prefix who denotes what URI needs to be translated - if\nit is NULL the module will not check the R-URI against it and the PDT\nprefix is considered starting from the first digit. Otherwise, the\nmodule will check first if the R-URI starts with it and will skip it to\nlook up the domain.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"pdt\", \"prefix\", \"00\")\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nNumber of rows to be loaded in one step from database.\n\n*Default value is 1000.*\n\n```\n...\nmodparam(\"pdt\", \"fetch_rows\", 4000)\n...\n```\n",
   "char_list": "### `char_list` (string)\n\nThe list with characters allowed in prefix.\n\n*Default value is \u201c0123456789\u201d.*\n\n```\n...\nmodparam(\"pdt\", \"char_list\", \"0123456789*+\")\n...\n```\n",
   "check_domain": "### `check_domain` (integer)\n\nModule will check if destination domain is duplicated for same source\ndomain (1 - check; 0 - don't check).\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"pdt\", \"check_domain\", 0)\n...\n```\n",
   "mode": "### `mode` (integer)\n\nIf set to 1, duplicated prefixes are ingnored and starting continues, if\n0, then starting or loading fails.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"pdt\", \"mode\", 1)\n...\n```\n"
  },
  "functions": {
   "prefix2domain": "### `prefix2domain()`\n\nThe same as prefix2domain(\"0\", \"0\").\n\n```\n...\nprefix2domain();\n...\n```\n",
   "pd_translate": "### `pd_translate(sdomain, rewrite_mode)`\n\nTranslate R-URI based on source domain and longest prefix matching.\nReturns 1 when the translation was made or there was nothing to\ntranslate. Returns -1 in error cases.\n\nThe translation is done based on lookup up for an entry in the database\nwhere the sdomain parameter equals the sdomain in database table.\n\nThe \u201csdomain\u201d parameter specifies the source domain to be used to match\nthe longest prefix. Can be a static string or dynamic parameter with\nvariables inside.\n\nThe \u201crewrite_mode\u201d parameter specifies whether to strip or not the\nprefix from user part. The possible values are:\n\n- 0: the prefix is removed along with the leading prefix.\n\n- 1: only the leading prefix is removed.\n\n- 2: the user part of the URI is not changed.\n\n- $PV : any PV holding one of the above values.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE or\nBRANCH_ROUTE.\n\n```\n...\npd_translate(\"$fd\", \"2\");\n...\npd_translate(\"*\", \"$var(a)\");\n...\n```\n"
  }
 },
 "peering": {
  "overview": "The peering module allows SIP providers (operators or organizations) to\nverify from a broker if source or destination of a SIP request is a\ntrusted peer.\n\nThis module is obsolete and will be removed in the next release.\n\nIn order to participate in the trust community provided by a broker,\neach SIP provider registers the domains (host parts of SIP URIs) that\nthey serve with the broker. When a SIP proxy of a provider needs to send\na SIP request to a non-local domain, it can find out from the broker\nusing verify_destination() function if the non-local domain is served by\na trusted peer. If so, the provider receives from the broker a hash of\nthe SIP request and a timestamp that it includes in the request to the\nnon-local domain. When a SIP proxy of the non-local domain receives the\nSIP request, it, in turn, can verify from the broker using\nverify_source() function if the request came from a trusted peer.\n\nVerification functions communicate with the broker using Radius\nprotocol. Sample FreeRADIUS configuration files for broker's Radius\nserver are available from http://www.wirlab.net/tsi/.\n\nComments and suggestions for improvements are welcome.\n",
  "parameters": {
   "radius_config": "### `radius_config` (string)\n\nThis is the location of the configuration file of Radius client\nlibraries.\n\nDefault value is \u201c/usr/local/etc/radiusclient-ng/radiusclient.conf\u201d.\n\n```\nmodparam(\"peering\", \"radius_config\", \"/etc/broker/radiusclient.conf\")\n```\n",
   "verify_destination_service_type": "### `verify_destination_service_type` (integer)\n\nThis is the value of the Service-Type Radius attribute to be used, when\nsender of SIP Request verifies the request's destination using\nverify_destination() function.\n\nDefault value is the dictionary value of \u201cSip-Verify-Destination\u201d\nService-Type.\n\n```\nmodparam(\"peering\", \"verify_destination_service_type\", 21)\n```\n",
   "verify_source_service_type": "### `verify_source_service_type` (integer)\n\nThis is the value of the Service-Type Radius attribute to be used, when\nreceiver of SIP Request verifies the request's source using\nverify_source() function.\n\nDefault value is the dictionary value of \u201cSip-Verify-Source\u201d\nService-Type.\n\n```\nmodparam(\"peering\", \"verify_source_service_type\", 22)\n```\n"
  },
  "functions": {
   "verify_destination": "### `verify_destination()`\n\nFunction verify_destination() queries from broker's Radius server if\ndomain (host part) of Request URI is served by a trusted peer. Radius\nrequest contains the following attributes/values:\n\n- User-Name - Request-URI host\n\n- SIP-URI-User - Request-URI user\n\n- SIP-From-Tag - From tag\n\n- SIP-Call-Id - Call id\n\n- Service-Type - verify_destination_service_type\n\nFunction returns value 1 if domain of Request URI is served by a trusted\npeer and -1 otherwise. In case of positive result, the Radius server\nreturns a set of SIP-AVP reply attributes. The value of each SIP-AVP is\nof form:\n\n[#]name(:|#)value\n\nValue of each SIP-AVP reply attribute is mapped to a Kamailio AVP.\nPrefix # in front of name or value indicates a string name or string\nvalue, respectively.\n\nOne of the SIP-AVP reply attributes contains a string that the source\npeer must include \"as is\" in a *P-Request-Hash:* header when it sends\nthe SIP request to the destination peer. The string value may, for\nexample, be of form hash@timestamp, where hash contains a hash\ncalculated by the broker based on the attributes of the query and some\nlocal information and timestamp is the time when the calculation was\ndone.\n\nAVP names used in reply attributes are assigned by the broker.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (verify_destination()) {\n   append_hf(\"P-Request-Hash: $avp(i:200)\\r\\n\");\n}\n...\n```\n",
   "verify_source": "### `verify_source()`\n\nFunction verify_source() queries the broker's Radius server whether the\nSIP request was received from a trusted peer. The Radius request\ncontains the following attributes/values:\n\n- User-Name - Request-URI host\n\n- SIP-URI-User - Request-URI user\n\n- SIP-From-Tag - From tag\n\n- SIP-Call-Id - Call id\n\n- SIP-Request-Hash - body of P-Request-Hash header\n\n- Service-Type - verify_source_service_type\n\nFunction returns value 1 if SIP request was received from a trusted peer\nand -1 otherwise. In case of positive result, Radius server may return a\nset of SIP-AVP reply attributes. Value of each SIP-AVP is of form:\n\n[#]name(:|#)value\n\nValue of each SIP-AVP reply attribute is mapped to a Kamailio AVP.\nPrefix # in front of name or value indicates a string name or string\nvalue, respectively.\n\nAVP names used in reply attributes are assigned by the broker.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (is_present_hf(\"P-Request-Hash\")) {\n   if (verify_source()) {\n      xlog(\"L_INFO\", \"Request came from trusted peer\\n\")\n   }\n}\n...\n```\n"
  }
 },
 "permissions": {
  "overview": "The Permissions module provides functions for handling IP based access\ncontrol lists (ACL) in a number of ways.\n\n- Call Routing\n\n- Registration permissions\n\n- URI permissions\n\n- Address permissions\n\n- Trusted Requests\n\nThe Address permissions and Trusted request handling supports using a\ndatabase to load ACLs into RAM for fast processing.\n",
  "parameters": {
   "default_allow_file": "### `default_allow_file` (string)\n\nDefault allow file used by the functions with no parameters. If you\ndon't specify a full pathname then the directory in which the main\nconfig file is located will be used.\n\n*Default value is \u201cpermissions.allow\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"default_allow_file\", \"/etc/permissions.allow\")\n...\n```\n",
   "default_deny_file": "### `default_deny_file` (string)\n\nDefault file containing deny rules. The file is used by functions with\nno parameters. If you don't specify a full pathname then the directory\nin which the main config file is located will be used.\n\n*Default value is \u201cpermissions.deny\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"default_deny_file\", \"/etc/permissions.deny\")\n...\n```\n",
   "check_all_branches": "### `check_all_branches` (integer)\n\nIf set then allow_routing functions will check Request-URI of all\nbranches (default). If disabled then only Request-URI of the first\nbranch will be checked.\n\n<div class=\"warning\">\n\n\nDo not disable this parameter unless you really know what you are doing.\n\n</div>\n\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"permissions\", \"check_all_branches\", 0)\n...\n```\n",
   "allow_suffix": "### `allow_suffix` (string)\n\nSuffix to be appended to basename to create filename of the allow file\nwhen version with one parameter of either `allow_routing` or\n`allow_register` is used.\n\n<div class=\"note\">\n\n\nIncluding leading dot.\n\n</div>\n\n\n*Default value is \u201c.allow\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"allow_suffix\", \".allow\")\n...\n```\n",
   "deny_suffix": "### `deny_suffix` (string)\n\nSuffix to be appended to basename to create filename of the deny file\nwhen version with one parameter of either `allow_routing` or\n`allow_register` is used.\n\n<div class=\"note\">\n\n\nIncluding leading dot.\n\n</div>\n\n\n*Default value is \u201c.deny\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"deny_suffix\", \".deny\")\n...\n```\n",
   "address_file": "### `address_file` (string)\n\nThis is the name of full path to the file that store rules used by\n`allow_address` function (and its variants). If it is only the file\nname, it is expected to be in the same folder as Kamailio.cfg file.\n\nIf set, this parameter has priority over the database backend, so the\naddress matching records are loaded from the file, not from database.\n\nTo see the format of the file see the section \"Address File Format\".\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"address_file\", \"address.list\")\n...\n```\n",
   "db_url": "### `db_url` (string)\n\nThis is URL of the database to be used to store rules used by\n`allow_trusted` or `allow_address` functions.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "address_table": "### `address_table` (string)\n\nThe name of the database table containing IP subnets and DNS domain\nnames used by `allow_address` and `allow_source_address` functions.\n\n*Default value is \u201caddress\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"address_table\", \"addr\")\n...\n```\n",
   "grp_col": "### `grp_col` (string)\n\nName of address table column containing the group identifier of the\naddress.\n\n*Default value is \u201cgrp\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"grp_col\", \"group_id\")\n...\n```\n",
   "ip_addr_col": "### `ip_addr_col` (string)\n\nName of address table column containing the IP address part of the\naddress.\n\n*Default value is \u201cip_addr\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"ip_addr_col\", \"ip_address\")\n...\n```\n",
   "mask_col": "### `mask_col` (string)\n\nName of address table column containing the network mask of the address.\nPossible values are 0-32 for IPv4 and 0-128 for IPv6 addresses. If the\nvalue is 0, the network mask is set to 32 for IPv4 addresses and to 128\nfor IPv6 addresses.\n\n*Default value is \u201cmask\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"mask_col\", \"subnet_length\")\n...\n```\n",
   "port_col": "### `port_col` (string)\n\nName of address table column containing the port part of the address.\n\n*Default value is \u201cport\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"port_col\", \"port\")\n...\n```\n",
   "db_mode": "### `db_mode` (integer)\n\nDatabase mode. 0 means non-caching, 1 means caching. Valid only for the\n`allow_trusted` function.\n\n*Default value is 0 (non-caching).*\n\n```\n...\nmodparam(\"permissions\", \"db_mode\", 1)\n...\n```\n",
   "trusted_table": "### `trusted_table` (string)\n\nName of database table containing the matching rules used by the\n`allow_trusted` function.\n\n*Default value is \u201ctrusted\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"trusted_table\", \"pbx\")\n...\n```\n",
   "source_col": "### `source_col` (string)\n\nName of column in the \u201ctrusted\u201d table containing the source IP address\nthat is matched against source IP address of received request.\n\n*Default value is \u201csrc_ip\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"source_col\", \"source_ip_address\")\n...\n```\n",
   "proto_col": "### `proto_col` (string)\n\nName of column in the \u201ctrusted\u201d table containing the transport protocol\nthat is matched against transport protocol of the received request.\nPossible values that can be stored in proto_col are \u201cany\u201d, \u201cudp\u201d, \u201ctcp\u201d,\n\u201ctls\u201d, \u201csctp\u201d, \u201cws\u201d, \u201cwss\u201d, and \u201cnone\u201d. Value \u201cany\u201d matches always and\nvalue \u201cnone\u201d never.\n\n*Default value is \u201cproto\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"proto_col\", \"transport\")\n...\n```\n",
   "from_col": "### `from_col` (string)\n\nName of the column trusted table containing a regular expression that is\nmatched against the From URI.\n\n*Default value is \u201cfrom_pattern\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"from_col\", \"regexp\")\n...\n```\n",
   "ruri_col": "### `ruri_col` (string)\n\nName of the column trusted table containing a regular expression that is\nmatched against the Request URI.\n\n*Default value is \u201cruri_pattern\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"ruri_col\", \"regexp\")\n...\n```\n",
   "tag_col": "### `tag_col` (string)\n\nName of the column in the \u201caddress\u201d or \u201ctrusted\u201d table containing a\nstring that is added as value to peer_tag AVP if peer_tag AVP has been\ndefined and if the address or peer matches.\n\n*Default value is \u201ctag\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"tag_col\", \"peer_tag\")\n...\n```\n",
   "priority_col": "### `priority_col` (string)\n\nThe column name used to store the priority of the corresponding rule\nfrom the database row. Priority values should be integer. When db_mode\nis set to 1 (caching), priorities are ordered from highest to lowest. In\nnon-caching mode, priority order (ASC vs DESC) is determined by\ndatabase.\n\n*Default value is \u201cpriority\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"priority_col\", \"column_name\")\n...\n```\n",
   "peer_tag_avp": "### `peer_tag_avp` (AVP string)\n\nIf defined, the AVP will be set as a side effect of `allow_trusted` call\nto not NULL tag column value of the matching peer.\n\n*Default value is \u201cundefined\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"peer_tag_avp\", \"$avp(i:707)\")\n...\n```\n",
   "peer_tag_mode": "### `peer_tag_mode` (integer)\n\nTag mode for `allow_trusted`. \u201c0\u201d sets only the tag of the first match.\n\u201c1\u201d adds the tags of all matches to the avp. In addition the return\nvalue of `allow_trusted` is the number of matches. This parameter is not\nused for address table matching functions.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"peer_tag_mode\", 1)\n...\n```\n",
   "max_subnets": "### `max_subnets` (int)\n\nThe maximum number of subnet addresses to be loaded from address table.\n\n*Default value is \u201c512\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"max_subnets\", 1024)\n...\n```\n",
   "load_backends": "### `load_backends` (int)\n\nControl what backends should be loaded: 1 - address table; 2 - trusted\ntable; 4 - allow file; 8 - deny file.\n\nIt can be a combination (sum) of the options to load many backends\n(e.g., 3 - loads address and trusted tables).\n\n*Default value is \u201c0xffff\u201d (load all backends).*\n\n```\n...\nmodparam(\"permissions\", \"load_backends\", 1)\n...\n```\n",
   "reload_delta": "### `reload_delta` (int)\n\nThe number of seconds that have to be waited before executing a new RPC\nreload. By default there is a rate limiting of maximum one reload in\nfive seconds.\n\nIf set to 0, no rate limit is configured. Note carefully: use this\nconfiguration only in tests environments because executing two RPC\nreloads of the same table at the same time can cause Kamailio to crash.\n\n*Default value is \u201c5\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"reload_delta\", 1)\n...\n        \n```\n",
   "trusted_cleanup_interval": "### `trusted_cleanup_interval` (int)\n\nIf module parameter `db_mode` is set to 1 a cleanup timer is set to the\ntrusted_cleanup_interval value in seconds. This process will cleanup the\nprevious values from memory after a RPC reload.\n\n*Default value is \u201c60\u201d.*\n\n```\n...\nmodparam(\"permissions\", \"trusted_cleanup_interval\", 120)\n...\n        \n```\n"
  },
  "functions": {
   "allow_routing": "### `allow_routing(allow_file, deny_file)`\n\nReturns true if all pairs constructed as described in [Call\nRouting](#sec-call-routing) have appropriate permissions according to\nthe configuration files given as parameters.\n\nMeaning of the parameters is as follows:\n\n- *allow_file* - File containing allow rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\n- *deny_file* - File containing deny rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (allow_routing(\"rules.allow\", \"rules.deny\")) {\n    t_relay();\n};\n...\n```\n",
   "allow_register": "### `allow_register(allow_file, deny_file)`\n\nThe function returns true if all pairs constructed as described in\n[Registration Permissions](#sec-registration-permissions) have\nappropriate permissions according to the configuration files given as\nparameters.\n\nMeaning of the parameters is as follows:\n\n- *allow_file* - File containing allow rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\n- *deny_file* - File containing deny rules.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (method==\"REGISTER\") {\n    if (allow_register(\"register.allow\", \"register.deny\")) {\n        save(\"location\");\n        exit;\n    } else {\n        sl_send_reply(\"403\", \"Forbidden\");\n    };\n};\n...\n```\n",
   "allow_uri": "### `allow_uri(basename, pvar)`\n\nReturns true if the pair constructed as described in [URI\nPermissions](#sec-uri-permissions) have appropriate permissions\naccording to the configuration files specified by the parameter.\n\nMeaning of the parameter is as follows:\n\n- *basename* - Basename from which allow and deny filenames will be\n  created by appending contents of `allow_suffix` and `deny_suffix`\n  parameters.\n\n  If the parameter doesn't contain full pathname then the function\n  expects the file to be located in the same directory as the main\n  configuration file of the server.\n\n- *pvar* - Any pseudo-variable defined in Kamailio.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (allow_uri(\"basename\", \"$rt\")) {  // Check Refer-To URI\n    t_relay();\n};\nif (allow_uri(\"basename\", \"$avp(i:705)\") {  // Check URI stored in $avp(i:705)\n    t_relay();\n};\n...\n```\n",
   "allow_address": "### `allow_address(group_id, ip_addr_pvar, port_pvar)`\n\nReturns true if the address and port given as values of pvar arguments\nbelonging to a group given as group_id argument matches an IP subnet or\na DNS domain name found in cached address table.\n\nWhen matching is done if the argument is an IP address, it is matched\nwith the records from that group that are of type exact IP or subnet. If\nthe argument is not an IP it is tried to be matched with the records\nthat are DNS domain names. No DNS lookup is performed, only strict\nmatching. Cached address table entry containing port value \u201c0\u201d matches\nany port. The \u201cgroup_id\u201d argument can be an integer string or a pseudo\nvariable.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\n\n// Check if source address/port is in group 1\nif (!allow_address(\"1\", \"$si\", \"$sp\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n};\n// Check address/port stored in AVPs src_adr/src_port is in group 2\n$avp(dst_adr) = \"sipdomain.com\";\n$avp(dst_port) = \"0\";\nif (!allow_address(\"2\", \"$avp(dst_adr)\", \"$avp(dst_port)\") {\n    sl_send_reply(\"403\", \"Forbidden\");\n};\n...\n```\n",
   "allow_source_address": "### `allow_source_address([group_id])`\n\nEqual to \u201callow_address(group_id, \"$si\", \"$sp\")\u201d. If 'group_id' is\nmissing, the function is equal to allow_address(\"1\", \"$si\", \"$sp\").\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\n\n// Check source address/port of request\nif (!allow_source_address(\"1\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n};\n...\n```\n",
   "allow_source_address_group": "### `allow_source_address_group()`\n\nChecks if source address/port is found in cached address or subnet table\nin any group. If yes, returns that group. If not returns -1. Port value\n0 in cached address and group table matches any port.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\n\n$var(group) = allow_source_address_group();\nif ($var(group) != -1) {\n   # do something with $var(group)\n};\n...\n```\n",
   "allow_address_group": "### `allow_address_group(addr, port)`\n\nChecks if address/port is found in cached address or subnet table in any\ngroup. If yes, returns that group. If not returns -1. Port value 0 in\ncached address and group table matches any port. The parameters can be\npseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n\n$var(group) = allow_address_group(\"1.2.3.4\", \"5060\");\nif ($var(group) != -1) {\n   # do something with $var(group)\n};\n...\n```\n",
   "allow_trusted": "### `allow_trusted([src_ip_pvar, proto_pvar, furi_pvar])`\n\nChecks based either on request's source address and transport protocol\nor source address and transport protocol given in pvar arguments, and\nFrom URI of request (or furi_pvar if provided) if request can be trusted\nwithout authentication. Returns \u201c1\u201d if a match is found as described in\n[Trusted Requests](#sec-trusted-requests) and \u201c-1\u201d otherwise. If a match\nis found and `peer_tag_avp` has been defined, adds a non-NULL tag column\nvalue of the matching peer to AVP peer_tag_avp.\n\nNOTE: source IP is matched using string comparison. Be careful if the IP\ncan have different forms, for a safer alternative for matching IP\naddresses, look at allow_source_address or allow_address().\n\nSource address, transport protocol and uri given in the arguments must\nbe in string format and they can contain script variables. Valid\ntransport protocol values are (ignoring case) \"any\", \"udp, \"tcp\", \"tls\",\n\"ws\", \"wss\" and \"sctp\".\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (allow_trusted()) {\n    t_relay();\n}\n...\nif (allow_trusted(\"$si\", \"$proto\")) {\n    t_relay();\n}\n...\nif (allow_trusted(\"$si\", \"any\", \"$ai\")) {\n    t_relay();\n}\n...\n```\n"
  }
 },
 "phonenum": {
  "overview": "This module allows real-time queries against the libphonenumber to be\nperformed from the config script. With that it is possible to get\nnormalize and get details about a phone number.\n\nMore details about libphonenumber can be found at\n<https://github.com/googlei18n/libphonenumber>.\n\nThis module exports a new class of pseudo-variables - $phn(pvc=>key) -\nto enable access to the results of a query to the database.\n\nMany queries can be done and store results in different containers to be\nable to use in parallel.\n",
  "parameters": {
   "smode": "### `smode` (int)\n\nPhone number search mode (not in use yet).\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"phonenum\", \"smode\", 0)\n...\n```\n",
   "resid": "### `resid` (str)\n\nPreregister result container id during initialization, enabling the use\nof the module in KEMI scripts. In native Kamailio.cfg file, registration\nis done when parsing config and finding variables.\n\n*Default value is \u201c\u201d (empty).*\n\n```\n...\nmodparam(\"phonenum\", \"resid\", \"src\")\n...\nif(phonenum_match(\"1-484-555-8888\", \"src\")) {\n   ...\n}\n...\n```\n"
  },
  "functions": {
   "phonenum_match": "### `phonenum_match(num, pvc)`\n\nMatch num against the libphonenumber and set the attributes inside the\npvc result container. The function has to be called before accessing a\nkey via: $phn(pvc=>key).\n\nThe parameters can be static strings or strings with variables.\n\nIt can be used from ANY_ROUTE.\n\n```\n...\nif(phonenum_match(\"1-484-555-8888\", \"src\")) {\n    if($phn(src=>valid)==1) {\n        xlog(\"number normalized to: $phn(src=>normalized)\\n\");\n    } else {\n        xlog(\"number normalization error: $phn(src=>error)\\n\");\n    }\n}\n...\n```\n",
   "phonenum_match_cn": "### `phonenum_match_cn(num, cnc, pvc)`\n\nMatch num against the libphonenumber and set the attributes inside the\npvc container, restricting the rules with a country name code (two\nletter, e.g: \"DE\", \"US\", \"ES\"). The function has to be called before\naccessing a key via: $phn(pvc=>key).\n\nNote from libphonenumber library docs: country name code is the region\nthat is expected the number to be from. It is only used if the number\nbeing parsed is not written in international format. The country code\nfor the number in this case would be stored as that of the region\nsupplied. If the number is guaranteed to start with a '+' followed by\nthe country calling code, then region 'ZZ'.\n\nThe parameters can be static strings or strings with variables.\n\nIt can be used from ANY_ROUTE.\n\n```\n...\nif(phonenum_match_cn(\"1-484-555-8888\", \"US\", \"src\")) {\n    if($phn(src=>valid)==1) {\n        xlog(\"number normalized to: $phn(src=>normalized)\\n\");\n    } else {\n        xlog(\"number normalization error: $phn(src=>error)\\n\");\n    }\n}\n...\n```\n"
  }
 },
 "pike": {
  "overview": "The pike module keeps trace of all (or selected ones) incoming request's\nIP source and blocks the ones that exceed the limit. It works\nsimultaneously for IPv4 and IPv6 addresses.\n\nThe module does not implement any actions on blocking - it just simply\nreports that there is high traffic from an IP; what to do, is the\nadministrator decision (via scripting).\n",
  "parameters": {
   "sampling_time_unit": "### `sampling_time_unit` (integer)\n\nTime period in seconds used for sampling (or the sampling accuracy). The\nsmaller the better, but slower. If you want to detect peeks, use a small\none. To limit the access (like total number of requests on a long period\nof time) to a proxy resource (a gateway for example), use a bigger value\nof this parameter.\n\nIMPORTANT: a too small value may lead to performance penalties due to\ntimer process overloading.\n\n*Default value is \u201c2\u201d.*\n\n```\n...\nmodparam(\"pike\", \"sampling_time_unit\", 10)\n...\n```\n",
   "reqs_density_per_unit": "### `reqs_density_per_unit` (integer)\n\nHow many requests should be allowed per `sampling_time_unit` before\nblocking all the incoming request from that IP. Practically, the\nblocking limit is between ( let's have x=reqs_density_per_unit) x and\n3*x for IPv4 addresses and between x and 8*x for IPv6 addresses.\n\n*Default value is 30.*\n\n```\n...\nmodparam(\"pike\", \"reqs_density_per_unit\", 30)\n...\n```\n",
   "remove_latency": "### `remove_latency` (integer)\n\nSpecifies for how long the IP address will be kept in memory after the\nlast request from that IP address. It's a sort of timeout value, in\nseconds. Note that it is not the duration to keep the IP in state\n'blocked'. An IP is unblocked next occurrence of 'sampling_time_unit'\nthat does not exceed 'reqs_density_per_unit'. Keeping an IP in memory\nresults in faster reaching of blocked state -- see the notes about the\nlimits of getting to state 'blocked'.\n\n*Default value is 120.*\n\n```\n...\nmodparam(\"pike\", \"remove_latency\", 130)\n...\n```\n",
   "pike_log_level": "### `pike_log_level` (integer)\n\nSyslog log level to be used by module to auto report the blocking (only\nfirst time) and unblocking of IPs detected as source of floods.\n\n*Default value is 1 (L_WARN).*\n\n```\n...\nmodparam(\"pike\", \"pike_log_level\", -1)\n...\n```\n"
  },
  "functions": {
   "pike_check_req": "### `pike_check_req()`\n\nProcess the source IP of the current request and return false if the IP\nwas exceeding the blocking limit.\n\nReturn codes:\n\n- *1 (true)* - IP is not to be blocked or internal error occurred.\n\n  <div class=\"warning\">\n\n\n  IMPORTANT: in case of internal error, the function returns true to\n  avoid reporting the current processed IP as blocked.\n\n  </div>\n\n\n- *-1 (false)* - IP is source of flooding, previously detected\n\n- *-2 (false)* - IP is detected as a new source of flooding - first time\n  detection\n\nThis function can be used from REQUEST_ROUTE|ONREPLY_ROUTE.\n\n```\n...\nif (!pike_check_req()) { exit; };\n...\n```\n",
   "pike_check_ip": "### `pike_check_ip(ipaddr)`\n\nProcess the IP address parameter and return false if it was exceeding\nthe blocking limit. The return codes are the same from pike_check_req().\n\nThe parameter can contain variables.\n\nThis function can be used from REQUEST_ROUTE|ONREPLY_ROUTE.\n\n```\n...\nif (!pike_check_ip(\"1.2.3.4\")) { exit; };\n...\nif (!pike_check_ip(\"$si\")) { exit; };\n...\n```\n"
  }
 },
 "pipelimit": {
  "overview": "This module implements traffic limiting for SIP requests.\n\nThe module defines in an abstract mode the notion of 'pipe', which can\nbe a reference to an IP address, to a network or a trunk. The\nassociation of traffic to a pipe is done in the config file, therefore,\na pipe could represent SIP traffic coming from a user or the flow of\nspecific SIP requests such as INVITE or REGISTER.\n\nPipelimit started from ratelimit module, adding support for definition\nof pipes limits in database and dynamic names. Complexity of keeping\neverything in a module and make it dual mode functional resulted in a\nnew module which is focused on just traffic shaping policies, the\nimplementation of queues was discarded.\n",
  "parameters": {
   "hash_size": "### `hash_size` (int)\n\nUsed to compute the number of slots for the internal hash table, as\npower of 2 (number of slots = 2^hash_size, aka 1<<hash_size). If you\nhave many pipes, increase this value for proper performances, but don't\ngo too high (hash_size=10 means 1024 slots).\n\n*Default value is \u201c6\u201d (64 slots).*\n\n```\n...\nmodparam(\"pipelimit\", \"hash_size\", 10)\n...\n```\n",
   "db_url": "### `db_url` (string)\n\nURL of the database server to be used.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"pipelimit\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "plp_table_name": "### `plp_table_name` (string)\n\nName of DB table where data definition for pipes is stored.\n\n*Default value is \u201cpl_pipes\u201d.*\n\n```\n...\nmodparam(\"pipelimit\", \"plp_table_name\", \"mypipes\")\n...\n```\n",
   "plp_pipeid_column": "### `plp_pipeid_column` (string)\n\nName of 'pipeid' column.\n\n*Default value is \u201cpipeid\u201d.*\n\n```\n...\nmodparam(\"pipelimit\", \"plp_pipeid_column\", \"name\")\n...\n```\n",
   "plp_limit_column": "### `plp_limit_column` (string)\n\nName of 'limit' column.\n\n*Default value is \u201cplimit\u201d.*\n\n```\n...\nmodparam(\"pipelimit\", \"plp_limit_column\", \"name\")\n...\n```\n",
   "plp_algorithm_column": "### `plp_algorithm_column` (string)\n\nName of 'algorithm' column.\n\n*Default value is \u201calgorithm\u201d.*\n\n```\n...\nmodparam(\"pipelimit\", \"plp_algorithm_column\", \"name\")\n...\n```\n",
   "timer_interval": "### `timer_interval` (integer)\n\nThe length of the timer interval in seconds. Counted messages are reset\neach timer_interval, therefore the amounts of messages have to be\ndivided by this timer_interval value to get the messages per second\nvalue. For example, if you want to allow an average of 10 messages per\nsecond with a timer interval of 10 seconds, then the limit value has to\nbe 100.\n\nNote: A too small value may lead to performance penalties due to timer\nprocess overloading.\n\n*Default value is 10.*\n\n```\n...\nmodparam(\"pipelimit\", \"timer_interval\", 5)\n...\n```\n",
   "timer_mode": "### `timer_mode` (integer)\n\nControl what timer process to be used: 0 - use main fast timer; 1 - use\nsecondary wheel timer.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"pipelimit\", \"timer_mode\", 1)\n...\n```\n",
   "load_fetch": "### `load_fetch` (integer)\n\nControl if the module should fetch the load for CPU and network traffic.\nIf set to 0, no load is fetched; if set to 1, the load is fetched every\ntimer interval.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"pipelimit\", \"load_fetch\", 0)\n...\n```\n",
   "reply_code": "### `reply_code` (integer)\n\nThe code of the reply sent by Kamailio while limiting.\n\n*Default value is 503.*\n\n```\n...\nmodparam(\"pipelimit\", \"reply_code\", 505)\n...\n```\n\nThis value can be modified at runtime using kamcmd\n\n```\nkamcmd cfg.set_now_int pipelimit reply_code 505\n\n        \n```\n",
   "reply_reason": "### `reply_reason` (string)\n\nThe reason of the reply sent by Kamailio while limiting.\n\n*Default value is \"Server Unavailable\".*\n\n```\n...\nmodparam(\"pipelimit\", \"reply_reason\", \"Limiting\")\n...\n```\n\nThis value can be modified at runtime using kamcmd\n\n```\nkamcmd cfg.set_now_string pipelimit reply_reason \"Limiting\"\n\n        \n```\n",
   "clean_unused": "### `clean_unused` (int)\n\nClean unused pipes after this number of timer intervals.\n\n*Default value is 0 (cleanup disabled).*\n\n```\n...\nmodparam(\"pipelimit\", \"clean_unused\", 10)\n...\n```\n\nThis value can be modified at runtime using kamcmd\n\n```\nkamcmd cfg.set_now_int pipelimit clean_unused 10\n\n        \n```\n"
  },
  "functions": {
   "pl_check": "### `pl_check(name [, algorithm, limit])`\n\nCheck the current request against the 'name' pipe.\n\nIf algorithm and limit are provided, the function attempts to create a\nnew pipe if one with that name doesn't exit. If it exists, no changes to\nalgorithm is done and the pipe limit is set to the 'limit' parameter\nvalue, if this is greater than 0. Algorithm is case sensitive.\n\nThe pipe name can be provided via a pseudo variable.\n\nThe method will return:\n\n- *-2* if no pipe was found\n\n- *-1* if pipe limit was reached\n\n- *1* if pipe limit was NOT reached\n\n- *2* if pipe has NOP algorithm\n\nMeaning of the parameters is as follows:\n\n- *name* - the string or pseudovariable with the pipe name.\n\n- *algorithm* - the string or pseudovariable with the algorithm. The\n  values can be: TAILDROP, RED, NETWORK, or FEEDBACK - see readme of\n  ratelimit module for details on each algorithm.\n\n- *limit* - the integer or pseudovariable with the limit value per\n  timer_interval.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    # perform pipe match for current method\n    if (!pl_check(\"one\")) {\n        pl_drop();\n        exit;\n    }\n...\n    # use pipe 'one' for the current method via PV\n    $var(p) = \"one\";\n    $var(check_result) = pl_check(\"$var(p)\");\n    switch($var(check_result)) {\n    case -2:\n        xlog(\"L_ALERT\",\"pl_check(\\\"$var(p)\\\") drop -pipe NOT found\\n\");\n        pl_drop();\n        exit;\n        break;\n    case -1:\n        xlog(\"L_ALERT\",\"pl_check(\\\"$var(p)\\\") drop\\n\");\n        pl_drop();\n        exit;\n        break;\n    case 1:\n        xlog(\"L_INFO\", \"pl_check(\\\"$var(p)\\\") pass\\n\");\n        break;\n    case 2:\n        xlog(\"L_ALERT\",\"pl_check(\\\"$var(p)\\\") pass -NOP algorithm\\n\");\n        break;\n    default:\n        xlog(\"L_ERR\",\"pl_check(\\\"$var(p)\\\") dropping \\\nwith unexpected retcode=$var(check_result)\\n\");\n        pl_drop();\n        exit;\n    }\n...\n    # perform pipe match for authenticated user\n    $var(limit) = 20;\n    if (!pl_check(\"$au\", \"TAILDROP\", \"$var(limit)\")) {\n        pl_drop();\n        exit;\n    }\n...\n    # perform pipe match for INVITE\n    if (is_method(\"INVITE\")) {\n        $var(invlimit) = 10;\n        if (!pl_check(\"$si\", \"TAILDROP\", \"$var(invlimit)\")) {\n            pl_drop();\n            exit;\n        }\n    }\n...\n```\n",
   "pl_active": "### `pl_active(name)`\n\nCheck the pipe 'name' was already created. Return 1 (true) if the pipe\nis found, -1 (false) if the pipe is not found.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    if (!pl_active(\"one\")) {\n        # pipe does not exist\n        exit;\n    }\n...\n```\n",
   "pl_drop": "### `pl_drop([ [min ], max ])`\n\nFor the current request, a \"503 - Server Unavailable\" reply is sent\nback. The reply may or may not have a \"Retry-After\" header. If no\nparameter is given, there will be no \"Retry-After\" header. If only the\n*max* parameter is given, the reply will contain a \"Retry-After: *max*\"\nheader. If both *min* and *max* params are given, the reply will contain\na \"Retry-After: *random*\" header with *random* being a random value\nbetween the given min and max.\n\nMeaning of the parameters is as follows:\n\n- *min* - the minimum value of \"Retry-After\" header.\n\n- *max* - the maximum value of \"Retry-After\" header.\n\nThis function can be used from\nREQUEST_ROUTE|BRANCH_ROUTE|FAILURE_ROUTE|ONSEND_ROUTE.\n\n```\n...\n    if (!pl_check(\"one\")) {\n        # send back a \"503 - Server Unavailable\"\n        # with a \"Retry-After: 5\"\n        pl_drop(\"5\");\n        exit;\n    }\n...\n```\n"
  }
 },
 "posops": {
  "overview": "The module exports utility functions to work with position inside the\nSIP message buffer.\n\nAmong them are function to add or remove content at a specific position.\n",
  "parameters": {
   "idx0": "### `idx0` (int)\n\nThe value to return by functions seeking a position when the index is 0\n(note: returning 0 is stopping the execution of configuration file like\n'exit', but for KEMI usage it is ok).\n\n*Default value is -255.*\n\n```\n...\nmodparam(\"posops\", \"idx0\", -200)\n...\n```\n"
  },
  "functions": {
   "pos_append": "### `pos_append(idx, val)`\n\nAppend the value val after the position idx in the SIP message buffer.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npos_append(\"100\", \"kamailio-$si\");\n...\n                \n```\n",
   "pos_insert": "### `pos_insert(idx, val)`\n\nInsert the value val at the position idx in the SIP message buffer.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npos_insert(\"100\", \"kamailio-$si\");\n...\n                \n```\n",
   "pos_rm": "### `pos_rm(idx, len)`\n\nRemove len characters starting at the position idx in the SIP message\nbuffer.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe idx can be a positive integer value or a variable holding a positive\ninteger.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npos_insert(\"100\", \"10\");\n...\n                \n```\n",
   "pos_set_char": "### `pos_set_char(idx, val)`\n\nSet the char at position index to first character in val.\n\nImportant: it changes the character directly in the SIP message buffer,\nthe update being immediately visible.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npos_set_char(\"100\", \"x\");\n...\n                \n```\n",
   "pos_headers_start": "### `pos_headers_start()`\n\nReturn the position in the message buffer where headers start.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(pos) = pos_headers_start();\n...\n                \n```\n",
   "pos_headers_end": "### `pos_headers_end()`\n\nReturn the position in the message buffer where headers end.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(pos) = pos_headers_end();\n...\n                \n```\n",
   "pos_body_start": "### `pos_body_start()`\n\nReturn the position in the message buffer where body starts.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(pos) = pos_body_start();\n...\n                \n```\n",
   "pos_body_end": "### `pos_body_end()`\n\nReturn the position in the message buffer where body ends.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(pos) = pos_body_end();\n...\n                \n```\n",
   "pos_find_str": "### `pos_find_str(idx, val)`\n\nReturn the position of the val in message buffer starting at idx. In\ncase of not finding it or error, the return code is negative. If val is\nat index 0, it returns the value specified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(idx) = pos_find_str(\"100\", \"kamailio\");\n...\n                \n```\n",
   "pos_findi_str": "### `pos_findi_str(idx, val)`\n\nReturn the position of the val (matching case insensitive) in message\nbuffer starting at idx. In case of not finding it or error, the return\ncode is negative. If val is at index 0, it returns the value specified\nby modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(idx) = pos_findi_str(\"100\", \"kamailio\");\n...\n                \n```\n",
   "pos_rfind_str": "### `pos_rfind_str(idx, val)`\n\nReturn the last position of the val in message buffer starting at idx\n(reverse search). In case of not finding it or error, the return code is\nnegative. If val is at index 0, it returns the value specified by\nmodparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(idx) = pos_rfind_str(\"100\", \"kamailio\");\n...\n                \n```\n",
   "pos_rfindi_str": "### `pos_rfindi_str(idx, val)`\n\nReturn the last position of the val (matching case insensitive) in\nmessage buffer starting at idx (reverse search). In case of not finding\nit or error, the return code is negative. If val is at index 0, it\nreturns the value specified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe val can be a static string or variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(idx) = pos_rfindi_str(\"100\", \"kamailio\");\n...\n                \n```\n",
   "pos_search": "### `pos_search(idx, re)`\n\nReturn the position that starts matching the regular expression re in\nmessage buffer starting at idx. In case of not finding it or error, the\nreturn code is negative. If val is at index 0, it returns the value\nspecified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe re can be a static regular expression string.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(idx) = pos_search(\"100\", \"[0-9]+\");\n...\n                \n```\n",
   "pos_rsearch": "### `pos_rsearch(idx, re)`\n\nReturn the position of last match that starts matching the regular\nexpression re in message buffer starting at idx. In case of not finding\nit or error, the return code is negative. If val is at index 0, it\nreturns the value specified by modparam idx0.\n\nThe idx can be an integer value or a variable holding an integer. If the\nvalue is negative, the position is counted from the end of the buffer.\n\nThe re can be a static regular expression string.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(idx) = pos_rsearch(\"100\", \"[0-9]+\");\n...\n                \n```\n"
  }
 },
 "prefix_route": {
  "overview": "The prefix_route module does routing based on a set of prefixes from the\ndatabase. The prefix rule-set is loaded from the database into a binary\ntree in memory, either on startup or when issuing the\n\"prefix_route.reload\" RPC command. When calling the \"prefix_route()\"\nfunction from the ser.cfg configuration script, it will try to match the\nuser part of the request URI with the best matching route. If a route is\nfound, it will be used for further processing. If not found normal\nprocessing will continue.\n\nDevelopment was sponsored by Telio Telecom.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThis is URL of the database to be used.\n\nDefault value is \"mysql://ser@localhost/ser\"\n\n```\n...\nmodparam(\"prefix_route\", \"db_url\", \"mysql://ser:pass@db_host/ser\")\n...\n            \n```\n",
   "db_table": "### `db_table` (string)\n\nThe name of table where to read prefix route set.\n\nDefault value is \"prefix_route\".\n\n```\n...\nmodparam(\"prefix_route\", \"db_table\", \"new_prefix_route\")\n...\n            \n```\n",
   "exit": "### `exit` (int)\n\nIf set, exit the execution of the configuration file when a route block\nis executed upon matching a prefix. Otherwise return 1 (true).\n\nDefault value is 1 (on).\n\n```\n...\nmodparam(\"prefix_route\", \"exit\", 0)\n...\n            \n```\n"
  },
  "functions": {
   "prefix_route": "### `prefix_route([user])`\n\nThis function tries to find a route from the user part of the request\nURI (if no parameter is provided), or from the value of the parameter.\nThe parameter can contain config variables.\n\nIf a route is found, it will be used for further processing. Otherwise\nthe function will return false.\n\n```\n...\n  if (!prefix_route()) {\n      xlog(\"L_ERR\", \"prefix_route(): no matching routes\\n\");\n  }\n...\n  if (!prefix_route(\"$fU\")) {\n      xlog(\"L_ERR\", \"prefix_route(): no matching routes\\n\");\n  }\n\n...\n            \n```\n"
  }
 },
 "presence": {
  "overview": "The Presence module implements the core functionality of SIP event\nnotification. It handles PUBLISH and SUBSCRIBE messages and generates\nNOTIFY messages in a general, event independent way. It is extensible\nand allows registering events to it from other Kamailio modules.\nSupported SIP event packages are presence, presence.winfo, dialog;sla\nfrom the presence_xml module and message-summary from the presence_mwi\nmodule.\n\nThe module can use database and memory storage (to improve performance).\nFor subscriptions it supports the 4 storage modes: Memory Only, Write\nBack, Write Through and DB Only. For publishes, it stores the state\ndocuments in database only (because of the large size) and it can store\na publish cache in memory to avoid unnecessary database queries. Read\nthe *subs_db_mode* and *publ_cache* parameter sections to decide which\nis the best storage configuration for you.\n\nThe module implements several API functions, that can be used by other\nmodules. In fact, it can be used only as a resource module, or\n\"library\". This mode of operation is enabled if the db_url parameter is\nnot set to any value.\n\nThe Kamailio Presence module implements the specifications in: RFC3265,\nRFC3856, RFC3857, RFC3858.\n",
  "parameters": {
   "db_url": "### `db_url`(str)\n\nThe database url.\n\nIf set, the module is a fully operational presence server. Otherwise, it\nis used as a 'library', for its exported functions.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"presence\", \"db_url\",\n    \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n...\n```\n",
   "presentity_table": "### `presentity_table`(str)\n\nThe name of the db table where PUBLISH presence information is stored.\n\n*Default value is \u201cpresentity\u201d.*\n\n```\n...\nmodparam(\"presence\", \"presentity_table\", \"presentity\")\n...\n```\n",
   "active_watchers_table": "### `active_watchers_table`(str)\n\nThe name of the db table where active subscription information is\nstored.\n\n*Default value is \u201cactive_watchers\u201d.*\n\n```\n...\nmodparam(\"presence\", \"active_watchers_table\", \"active_watchers\")\n...\n```\n",
   "watchers_table": "### `watchers_table`(str)\n\nThe name of the db table where subscription states are stored.\n\n*Default value is \u201cwatchers\u201d.*\n\n```\n...\nmodparam(\"presence\", \"watchers_table\", \"watchers\")\n...\n```\n",
   "clean_period": "### `clean_period` (int)\n\nThe period in seconds between checks if there are expired messages\nstored in the database.\n\n*Default value is \u201c100\u201d. A zero or negative value disables this\nactivity.*\n\n```\n...\nmodparam(\"presence\", \"clean_period\", 100)\n...\n```\n",
   "cseq_offset": "### `cseq_offset` (int)\n\nThe allowed offset between server and client cseq.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence\", \"cseq_offset\", 1)\n...\n```\n",
   "db_update_period": "### `db_update_period` (int)\n\nThe period at which to synchronize cached subscriber info with the\ndatabase.\n\n*Default value is \u201c100\u201d. A zero or negative value disables\nsynchronization.*\n\n```\n...\nmodparam(\"presence\", \"db_update_period\", 100)\n...\n```\n",
   "waitn_time": "### `waitn_time` (int)\n\nThe maximum time period that NOTIFY requests will be buffered for. The\nserver will attempt to send NOTIFY requests within many seconds of a\nchange occurring.\n\nNote: this parameter is only used when notifier_processes is greater\nthan 0. When notifier_processes is less than or equal to 0 NOTIFY\nrequests are sent immediately.\n\n*Default value is \u201c5\u201d.*\n\n```\n...\nmodparam(\"presence\", \"waitn_time\", 10)\n...\n```\n",
   "notifier_poll_rate": "### `notifier_poll_rate` (int)\n\nThe number of times per second that the notifier processes should check\nfor work. Approximately 1/(waitn_time * notifier_poll_rate *\nnotifier_processes) of the pending updates will be sent each time a\nnotifier process runs.\n\nSeparate notifier processes are only run when subs_db_mode is 3 (DB only\nmode).\n\n*Default value is \u201c10\u201d.*\n\n```\n...\nmodparam(\"presence\", \"notifier_poll_rate\", 20)\n...\n```\n",
   "notifier_processes": "### `notifier_processes` (int)\n\nThe number of notifier processes that should be started.\n\nSeparate notifier processes are only run when subs_db_mode is 3 (DB only\nmode).\n\nNote: setting this parameter to 0 when subs_db_mode is 3 keeps the old\nbehaviour (sending NOTIFY requests immediately). This (old) behaviour is\ndisabled by default in DB only mode because under load, when lots of\nNOTIFY requests can be sent on a dialog at the same time, there are race\nconditions which result in CSeq re-use.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"presence\", \"notifier_processes\", 2)\n...\n```\n",
   "force_delete": "### `force_delete` (int)\n\nEnabling this parameter will delete expired presentity records without\nupdating watchers.\n\nSet this parameter to \u201c1\u201d to enable.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence\", \"force_delete\", 1)\n...\n```\n",
   "startup_mode": "### `startup_mode` (int)\n\nSetting this parameter to 0 will provide startup related backward\ncompatibility for some modules. Setting to 0 fixes presentity requests\nwith low expires (e.g. time() + 1)\n\nSet this parameter to \u201c0\u201d to enable backward compatibility.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"presence\", \"startup_mode\", 0)\n...\n```\n",
   "expires_offset": "### `expires_offset` (int)\n\nThe value in seconds that should be subtracted from the expires value\nwhen sending a 200OK for a publish. It is used for forcing the client to\nsend an update before the old publish expires.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence\", \"expires_offset\", 10)\n...\n```\n",
   "max_expires": "### `max_expires` (int)\n\nThe maximum admissible expires value for PUBLISH/SUBSCRIBE message (in\nseconds).\n\n*Default value is \u201c3600\u201d.*\n\n```\n...\nmodparam(\"presence\", \"max_expires\", 3600)\n...\n```\n",
   "min_expires": "### `min_expires` (int)\n\nThe minimum admissible expires value for PUBLISH/SUBSCRIBE message (in\nseconds).\n\nIf > 0 then min_expires_action parameter determines the response.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence\", \"min_expires\", 1800)\n...\n```\n",
   "min_expires_action": "### `min_expires_action` (int)\n\nThe action to take when UA sends an expires value less than min_expires.\n\n- 1 : RFC Compliant, returns \u201c423 Interval Too Brief\u201d\n\n- 2 : forces the min_expires value in the subscription\n\nIf > 0 then min_expires_action parameter determines the response.\n\n*Default value is \u201c1\u201d.*\n\n```\n            ...\n            modparam(\"presence\", \"min_expires\", 1800)\n            ...\n        \n```\n",
   "server_address": "### `server_address` (str)\n\nThe presence server address which will become the value of Contact\nheader filed for 200 OK replies to SUBSCRIBE and PUBLISH and in NOTIFY\nmessages.\n\n```\n...\nmodparam(\"presence\", \"server_address\", \"sip:10.10.10.10:5060\")\n...\n```\n",
   "subs_db_mode": "### `subs_db_mode` (int)\n\nThe presence module can utilize database for persistent subscription\nstorage. If you use database, your subscriptions will survive machine\nrestarts or SW crashes. The disadvantage is that accessing the database\ncan be time consuming. Therefore, presence module implements four\ndatabase accessing modes:\n\n- 0 - This disables database completely. Only memory will be used.\n  Subscriptions will not survive restart. Use this value if you need a\n  really fast presence module and subscription persistence is not\n  necessary or is provided by other means.\n\n- 1 - Write-Through scheme. Subscriptions are updated synchronously in\n  database and in memory(used for read operations). Use this scheme if\n  speed is not top priority, but it's important that no subscriptions\n  will be lost during crash or reboot or if you have an external\n  application that reads the state of the subscriptions from database\n  and they need to be updated synchronously.\n\n- 2 - Write-Back scheme. This is a combination of previous two schemes.\n  All changes are made to memory and database synchronization is done in\n  the timer. The timer deletes all expired contacts and flushes all\n  modified or new subscriptions to database. Use this scheme if you\n  encounter high-load peaks and want them to process as fast as\n  possible. Latency of this mode is much lower than latency of mode 1,\n  but slightly higher than latency of mode 0. To control the interval at\n  which data is flushed to database, set the *db_update_period*\n  parameter.\n\n- 3 - DB-Only scheme. No memory cache is kept, all operations being\n  directly performed with the database. The timer deletes all expired\n  subscriptions from database. The mode is useful if you configure more\n  servers sharing the same DB without any replication at SIP level. The\n  mode may be slower due the high number of DB operation.\n\n*Default value is 2 (Write-Back scheme).*\n\n```\n...\nmodparam(\"presence\", \"subs_db_mode\", 1)\n...\n```\n",
   "publ_cache": "### `publ_cache` (int)\n\nTo improve performance, the presence module can operate in a couple of\nmodes related to how PUBLISH data is stored. If publ_cache is 0, then no\ninformation is stored in memory.\n\nIf publ_cache is 1, then the module keeps in memory an index of the\nrecords stored in database, In this mode it keeps only the list of URIs\nand events, so it does not use much memory. The cache is used when a\nSubscription is received to check if there is any published state in\ndatabase. This way unnecessary queries in presentity table are avoided.\n\nIf publ_cache is 2, then the module keeps everything related to PUBLISH\nrequests in memory, not storing anything in the database.\n\nSetting this parameter to 0 will disable the usage of the publish cache.\nThis is desirable when you have more servers sharing the same database\nor there are other external entities inserting data into the presentity\ntable.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"presence\", \"publ_cache\", 0)\n...\n    \n```\n",
   "subs_htable_size": "### `subs_htable_size` (int)\n\nThe size of the in-memory hash table to store subscription dialogs. This\nparameter will be used as the power of 2 when computing table size.\n\n*Default value is \u201c9 (512)\u201d.*\n\n```\n...\nmodparam(\"presence\", \"subs_htable_size\", 11)\n...\n    \n```\n",
   "pres_htable_size": "### `pres_htable_size` (int)\n\nThe size of the in-memory hash table to store publish records. This\nparameter will be used as the power of 2 when computing table size.\n\n*Default value is \u201c9 (512)\u201d.*\n\n```\n...\nmodparam(\"presence\", \"pres_htable_size\", 11)\n...\n    \n```\n",
   "send_fast_notify": "### `send_fast_notify` (int)\n\nThis parameter enables or disables the sending of an initial empty\nNOTIFY after a SUBSCRIBE/reSUBSCRIBE. This caused problems for MWI\napplication, because some CPEs (like Samsung) fail to understand an\nempty NOTIFY to a message-summary event. This parameter is enabled by\ndefault, thus adhering to the standard.\n\n*Default value is \u201c1 \u201d.*\n\n```\n...\nmodparam(\"presence\", \"send_fast_notify\", 0)\n...\n    \n```\n",
   "enable_sphere_check": "### `enable_sphere_check` (int)\n\nThis parameter is a flag that should be set if permission rules include\nsphere checking. The sphere information is expected to be present in the\nRPID body published by the presentity. The flag is introduced as this\ncheck requires extra processing that should be avoided if this feature\nis not supported by the clients.\n\n*Default value is \u201c0 \u201d.*\n\n```\n...\nmodparam(\"presence\", \"enable_sphere_check\", 1)\n...\n    \n```\n",
   "timeout_rm_subs": "### `timeout_rm_subs` (int)\n\nThis parameter is a flag that should be set if subscriptions should be\nremoved from the active_watchers when a NOTIFY times out. RFC3265\nsection 3.2.2 defines this behaviour as a SHOULD, so by default it is\non. Disabling this will keep subscriptions active on unreliable\nnetworks.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"presence\", \"timeout_rm_subs\", 0)\n...\n    \n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nNumber of rows to be loaded in one step from database.\n\n*Default value is 500.*\n\n```\n...\nmodparam(\"presence\", \"fetch_rows\", 1000)\n...\n```\n",
   "db_table_lock_type": "### `db_table_lock_type` (integer)\n\nEnable (=1) or disable (=0) the Locks for table during a transaction.\nLocking only the \"current\" table causes problems with a MySQL-Databases\nin \"DB-Only\" mode.\n\nIn order to use the Presence-Module in \"DB_ONLY\"-mode with a\nMySQL-Backend, set this parameter to \"0\", otherwise the MySQL-Operations\nwill fail. The Presence-Module will generate a \"500 Server error\" due to\nthe failed MySQL-queries.\n\n*Default value is 1 (Write Lock for the Tables).*\n\n```\n...\nmodparam(\"presence\", \"db_table_lock_type\", 0)\n...\n```\n",
   "local_log_level": "### `local_log_level` (int)\n\nControl log level for some debug messages inside the module.\n\n*Default value is 2 (L_INFO).*\n\n```\n...\nmodparam(\"presence\", \"local_log_level\", 3)\n...\n```\n",
   "local_log_facility": "### `local_log_facility` (int)\n\nControl syslog facility for some debug messages inside the module.\n\n*Default value is taken from the core log_facility configuration\nparameter.*\n\n```\n...\nmodparam(\"presence\", \"local_log_facility\", \"LOG_LOCAL3\")\n...\n```\n",
   "subs_remove_match": "### `subs_remove_match` (int)\n\nControl how to match the subscriptions to remove from memory. If set to\n0, then the match is done on To-Tag (local generated), if set to 1, then\nthe match is done on all dialog attributes (Call-Id, From-Tag, To-Tag).\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"presence\", \"subs_remove_match\", 1)\n...\n```\n",
   "xavp_cfg": "### `xavp_cfg` (str)\n\nThe name of the xavp to be used to specify attributes for internal\nprocessing of presence module.\n\nInner attributes inside xavp can be:\n\n- *priority* - integer value to set the priority of the presence\n  document (higher value, higher priority). It can set the order of the\n  aggregated presence documents sent by NOTIFY (first the document with\n  higher priority). If xavp_cfg parameter is set but this attribute is\n  not in the avp, the priority of the presence document is based on\n  timestamp, so newer documents have higher priority.\n\n- *delete_subscription* - integer value to give extra control of\n  deleting the subscription after processing of\n  event_route[presence:notify-reply]. If value = 1, it deletes the\n  subscription. If xavp_cfg parameter is set but this attribute is not\n  in the avp, the subscription is not deleted. This does not apply for\n  codes 404, 481 and 408 (when timeout_rm_subs = 1) where subscription\n  is deleted.\n\nDefault value is *empty* (not set).\n\n```\n...\nmodparam(\"presence\", \"xavp_cfg\", \"pres\")\n...\nif(is_method(\"PUBLISH\")) {\n    $xavp(pres=>priority) = 100;\n}\n...\n```\n",
   "retrieve_order": "### `retrieve_order` (int)\n\nIf set to 0, presentity records are retrieved by received_time order. If\nset to 1, presentity records are retrieved by the value of\nretrieve_order_by parameter.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"presence\", \"retrieve_order\", 1)\n...\n```\n",
   "retrieve_order_by": "### `retrieve_order_by` (str)\n\nUsed to set the order-by of the db query for fetching the presence\nrecords when retrieve_order is set to 1.\n\n*Default value is \u201cpriority\u201d.*\n\n```\n...\nmodparam(\"presence\", \"retrieve_order_by\", \"priority, received_time\")\n...\n```\n",
   "sip_uri_match": "### `sip_uri_match` (int)\n\nThe mode used when comparing uris.\n\n- 0 : case sensitive\n\n- 1 : case insensitive\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence\", \"sip_uri_match\", 1)\n...\n```\n",
   "enable_dmq": "### `enable_dmq` (integer)\n\nIf set to 1, will enable DMQ replication of presentities between nodes.\nUse this instead of a shared DB to share state across a cluster and\nupdate local watchers in realtime (subs_db_mode < 3) or on next\nnotifier run (subs_db_mode = 3).\n\n*If this parameter is enabled, the DMQ module must be loaded first -\notherwise, startup will fail.*\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"presence\", \"enable_dmq\", 1)\n...\n```\n",
   "pres_subs_mode": "### `pres_subs_mode` (integer)\n\nAllow disabling cloning subscription structure for pv $subs(...),\nsaving the pkg memory and copy operations for all its fields. If 1 the\ncloning is done; if 0, no cloning and $subs(...) returns $null.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"presence\", \"pres_subs_mode\", 0)\n...\n```\n",
   "delete_same_subs": "### `delete_same_subs` (integer)\n\nEnable deleting of subscriptions with the same presence uri and callid.\n\n*Default value is 0 (disabled behavior).*\n\n```\n...\nmodparam(\"presence\", \"delete_same_subs\", 1)\n...\n```\n",
   "timer_mode": "### `timer_mode` (integer)\n\nSpecify what timer process to be used. If set to 0, the core main timer\nis used. If set to 1, the core secondary timer is used.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"presence\", \"timer_mode\", 0)\n...\n```\n",
   "subs_respond_200": "### `subs_respond_200` (integer)\n\nSpecify the response code for accepted SUBSCRIBE requests. If set to 0,\n\"202 Accepted\" will be returned (default behaviour till version 5.5). If\nset to 1, \"200 OK\" will be returned instead, in conformance to RFC6665,\nwhich prohibits 202 responses.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"presence\", \"subs_respond_200\", 0)\n...\n```\n"
  },
  "functions": {
   "handle_publish": "### `handle_publish([sender_uri])`\n\nHandles PUBLISH requests by storing and updating published information\nin memory cache and database, then calls functions to send NOTIFY\nmessages when changes in the published information occur. It takes one\nargument -> sender_uri. The parameter was added for enabling BLA\nimplementation. If present, notification of a change in published state\nis not sent to the respective uri even though a subscription exists. It\nshould be taken from the Sender header. It was left at the decision of\nthe administrator whether or not to transmit the content of this header\nas parameter for handle_publish, to prevent security problems.\n\nThis function can be used from REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - if success*.\n\n- *-1 - if error*.\n\nThe module sends an appropriate stateless reply in all cases.\n\n```\n...\n    if(is_method(\"PUBLISH\"))\n    {\n        if($hdr(Sender)!= NULL)\n            handle_publish(\"$hdr(Sender)\");\n        else\n            handle_publish();\n        t_release();\n    }\n...\n```\n",
   "handle_subscribe": "### `handle_subscribe([watcher_uri])`\n\nThe function which handles SUBSCRIBE requests. It stores or updates\ninformation in memory and database and calls functions to send NOTIFY\nmessages when a SUBSCRIBE which initiate a dialog is received.\n\nBy default this function uses the From: URI from the SUBSCRIBE request\nas the Watcher URI. The optional watcher_uri parameter can be used to\nspecify a different Watcher URI, possibly taken from a SIP header like\nP-Asserted-Identity:.\n\nThis function can be used from REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - if success*.\n\n- *-1 - if error*.\n\nThe module sends an appropriate stateless reply in all cases.\n\n```\n...\nif(method==\"SUBSCRIBE\")\n    handle_subscribe();\n...\n```\n",
   "pres_auth_status": "### `pres_auth_status(watcher_uri, presentity_uri)`\n\nThe function checks if watcher URI is authorized to subscribe event\n'presence' of presentity URI. Both watcher_uri and presentity_uri can be\nstatic strings or contain pseudo variables.\n\nThe function returns ACTIVE_STATUS, if subscription is allowed, and\nPENDING_STATUS, TERMINATED_STATUS, or WAITING_STATUS otherwise. See\npresence/subscribe.h for the corresponding integer codes. In case of\nerror, function returns -1.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (method==\"MESSAGE\") {\n    pres_auth_status(\"$fu\", $ru\");\n    if ($retcode == 1) {\n        t_relay();\n    } else {\n        send_reply(\"403\", \"Forbidden\");\n    }\n}\n...\n```\n",
   "pres_has_subscribers": "### `pres_has_subscribers(presentity_uri, event)`\n\nAllows to check if presentity has any subscribers of event.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(pres_has_subscribers($var(uri), \"message-summary\"))\n    # do something...;\n...\n```\n",
   "pres_refresh_watchers": "### `pres_refresh_watchers(uri, event, type[, file_uri, filename])`\n\nThe function can be used in configuration to trigger notifies to\nwatchers if a change in watchers authorization or in published state\noccurred (i.e., updates of xcap documents).\n\nParameters:\n\n- uri - the uri of the user who made the change and whose watchers\n  should be informed.\n\n- event - the event package.\n\n- type - it distinguishes between the three different types of events\n  that can trigger the refresh, depending on its value:\n\n  - 0 - a change in watchers authentication.\n\n  - 1 - a statical update in published state through direct update in db\n    table.\n\n  - 2 - a statical update in published state by modifying the pidf\n    manipulation document.\n\n\n- file_uri - the uri of the pidf-manipulation file on the XCAP server\n  (only used for type 2).\n\n- filename - the name of the pidf-manipulation file on the XCAP server\n  (only used for type 2).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npres_refresh_watchers(\"sip:test@kamailio.org\", \"presence\", 1);\n...\n```\n",
   "pres_update_watchers": "### `pres_update_watchers(uri, event)`\n\nThe function can be used in configuration to trigger updates to watchers\nstatus if a change in watchers authorization state occurred (i.e.,\nupdates of xcap documents change state from pending to active).\n\nParameters:\n\n- uri - the uri of the user who made the change and whose watchers\n  should be informed. Can be PV.\n\n- event - the event package (e.g., presence).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npres_update_watchers(\"sip:test@kamailio.org\", \"presence\");\n...\n```\n"
  }
 },
 "presence_conference": {
  "overview": "This module is a mixer for presence notifications published by an audio\nconference mixer as per RFC 4353: A Framework for Conferencing with SIP\nand RFC 4575: A SIP Event Package for Conference State. In other words\nit is presence handling of conference events - conference-info+xml\ndocuments.\n",
  "parameters": {
   "use_partial_states": "### `use_partial_states` (int)\n\nControl usage of partial state notifications.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_conference\", \"use_partial_states\", 0)\n...\n```\n",
   "default_expires": "### `default_expires` (int)\n\nThe default expires value used when missing from SUBSCRIBE message (in\nseconds).\n\n*Default value is \u201c3600\u201d.*\n\n```\n...\nmodparam(\"presence_conference\", \"default_expires\", 3600)\n...\n```\n"
  },
  "functions": {}
 },
 "presence_dialoginfo": {
  "overview": "The module enables the handling of \"Event: dialog\" (as defined in RFC\n4235) inside of the presence module. This can be used distribute the\ndialog-info status to the subscribed watchers.\n\nThe module does not currently implement any authorization rules. It\nassumes that publish requests are only issued by an authorized\napplication and subscribe requests only by authorized users.\nAuthorization can thus be easily done in Kamailio configuration file\nbefore calling handle_publish() and handle_subscribe() functions.\n\nNote: This module only activates the processing of the \"dialog\" in the\npresence module. To send dialog-info to watchers you also need a source\nwhich PUBLISH the dialog info to the presence module. For example you\ncan use the pua_dialoginfo module or any external component. This\napproach allows to have the presence server and the dialog-info aware\npublisher (e.g. the main proxy) on different Kamailio instances.\n\nThis module by default does body aggregation. That means, if the\npresence module received PUBLISH from multiple presentities (e.g. if the\nentity has multiple dialogs the pua_dialoginfo will send multiple\nPUBLISH), the module will parse all the received (and still valid,\ndepending on the Expires header in the PUBLISH request) XML documents\nand generate a single XML document with multiple \"dialog\" elements. This\nis perfectly valid, but unfortunately not supported by all SIP phones,\ne.g. Linksys SPA962 crashes when it receives dialog-info with multiple\ndialog elements. In this case use the ..... module parameter.\n\nTo get better understanding how all the module works together please\ntake a look at the following figure:\n\n```\n    Main Proxy and Presence Server on the same Instance\n\n   caller        proxy &      callee         watcher\nalice@example   presence   bob@example   watcher@example\n                 server\n     |             |            |               |\n     |             |<-------SUBSCRIBE bob-------|\n     |             |--------200 OK------------->|\n     |             |--------NOTIFY------------->|\n     |             |<-------200 OK--------------|\n     |             |            |               |\n     |--INV bob--->|            |               |\n     |             |--INV bob-->|               |\n     |             |<-100-------|               |\n     |             |            |               |\n     |             |<-180 ring--|               |\n     |<--180 ring--|            |               |\n     |             |--          |               |\n     |             |   \\        |               |\n     |             | PUBLISH bob|               |\n     |             |   /        |               |\n     |             |<-          |               |\n     |             |            |               |\n     |             |--          |               |\n     |             |   \\        |               |\n     |             | 200 ok     |               |\n     |             |   /        |               |\n     |             |<-          |               |\n     |             |--------NOTIFY------------->|\n     |             |<-------200 OK--------------|\n     |             |            |               |\n```\n\n- The watcher subscribes the \"Event: dialog\" of Bob.\n\n- Alice calls Bob.\n\n- Bob replies with ringing, the dialog in the dialog module transits to\n  \"early\". The callback in pua_dialoginfo is executed. The\n  pua_dialoginfo module creates the XML document and uses the pua module\n  to send the PUBLISH. (pua module itself uses tm module to send the\n  PUBLISH stateful)\n\n- PUBLISH is received and handled by presence module. Presence module\n  updates the \"presentity\". Presence module checks for active watchers\n  of the presentity. It gives all the XML documents to\n  presence_dialoginfo module to aggregate them into a single XML\n  document. Then it sends the NOTIFY with the aggregated XML document to\n  all active watchers.\n\nThe presence server can also be separated from the main proxy by using a\nseparate Kamailio instance as shown in the following figure. (Either set\nthe outbound_proxy parameter of pua module or make sure to route the\n\"looped\" PUBLISH requests from the main proxy to the presence server).\n\n```\n    Main Proxy and Presence Server use a separate Instance\n\n   caller        proxy &   presence      callee         watcher\nalice@example    server     server     bob@example   watcher@example\n     |             |            |               |            |\n     |             |<--------------------SUBSCRIBE bob-------|\n     |             |-SUBSC bob->|               |            |\n     |             |<-200 ok----|               |            |\n     |             |---------------------200 OK------------->|\n     |             |          .... NOTIFY ... 200 OK ...     |\n     |             |            |               |            |\n     |             |            |               |            |\n     |--INV bob--->|            |               |            |\n     |             |--INV bob------------------>|            |\n     |             |<-100-----------------------|            |\n     |             |            |               |            |\n     |             |<-180 ring------------------|            |\n     |<--180 ring--|            |               |            |\n     |             |--PUBL bob->|               |            |\n     |             |<-200 ok----|               |            |\n     |             |            |--------NOTIFY------------->|\n     |             |            |<-------200 OK--------------|\n     |             |            |               |            |\n```\n\nKnown issues:\n\n- The \"version\" attribute is increased for every NOTIFY, even if the XML\n  document has not changed. This is of course valid, but not very smart.\n",
  "parameters": {
   "force_single_dialog": "### `force_single_dialog` (int)\n\nBy default the module aggregates all available dialog info into a single\ndialog-info document containing multiple \"dialog\" elements. If the phone\ndoes not support this, you can activate this parameter.\n\nIf this parameter is set, only the dialog element with the currently\nmost interesting dialog state will be put into the dialog-info document.\nThus, the dialog-info element will contain only a single \"dialog\"\nelement. The algorithm chooses the state based on the following order of\npriority (least important first): terminated, trying, proceeding,\nconfirmed, early. Note: I consider the \"early\" state more interesting\nthan confirmed as often you might want to pickup a call if the original\ncallee is already busy in a call.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_dialoginfo\", \"force_single_dialog\", 1)\n...\n```\n",
   "force_dummy_dialog": "### `force_dummy_dialog` (int)\n\nBy default the module returns null body if there are no bodies to\naggregate. some sip clients like Bria expect at least one dialog. you\ncan activate this parameter to send a dummy dialog.\n\nIf this parameter is set and there are no dialog bodies to aggregate, it\nwill return a dummy dialog.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_dialoginfo\", \"force_dummy_dialog\", 1)\n...\n```\n",
   "default_expires": "### `default_expires` (int)\n\nThe default expires value used when missing from SUBSCRIBE message (in\nseconds).\n\n*Default value is \u201c3600\u201d.*\n\n```\n...\nmodparam(\"presence_dialoginfo\", \"default_expires\", 3600)\n...\n```\n"
  },
  "functions": {}
 },
 "presence_mwi": {
  "overview": "The module does specific handling for notify-subscribe message-summary\n(message waiting indication) events as specified in RFC 3842. It is used\nwith the general event handling module, presence. It constructs and adds\nmessage-summary event to it.\n\nThe module does not currently implement any authorization rules. It\nassumes that publish requests are only issued by a voicemail application\nand subscribe requests only by the owner of voicemail box. Authorization\ncan thus be easily done by Kamailio configuration file before calling\nhandle_publish() and handle_subscribe() functions.\n\nThe module implements a simple check of content type\n\u201capplication/simple-message-summary:\u201d Content must start with\n\u201cMessages-Waiting\u201d status line followed by zero or more lines that\nconsist of tabs and printable ASCII characters.\n",
  "parameters": {
   "default_expires": "### `default_expires` (int)\n\nThe default expires value used when missing from SUBSCRIBE message (in\nseconds).\n\n*Default value is \u201c3600\u201d.*\n\n```\n            ...\n            modparam(\"presence_mwi\", \"default_expires\", 3600)\n            ...\n            \n```\n"
  },
  "functions": {}
 },
 "presence_profile": {
  "overview": "The module extends the presence server implementation, providing the\nability to handle the 'ua-profile' event. When a user agent subscribes\nto ua-profile event for its own AoR, it retrieves the profile data\ndocument from the body of a NOTIFY request.\n\nThe profile data document format is usually specific to the user agent.\nSuch documents have to be built and added to presentity table by either\nthe admin or a third party application.\n\nWarning: When you add a profile data document (i.e. the user agent's\nprovisioning config) to the presentity table, you must make sure that\nyou set the presentity table expires field to a time value far in the\nfuture.\n\nRead more about SIP user agent configuration framework in RFC6080:\n<http://tools.ietf.org/html/rfc6080>.\n",
  "parameters": {},
  "functions": {}
 },
 "presence_reginfo": {
  "overview": "The module enables the handling of \"Event: reg\" (as defined in RFC 3680)\ninside of the presence module. This can be used distribute the\nregistration-info status to the subscribed watchers.\n\nThe module does not currently implement any authorization rules. It\nassumes that publish requests are only issued by an authorized\napplication and subscribe requests only by authorized users.\nAuthorization can thus be easily done in Kamailio configuration file\nbefore calling handle_publish() and handle_subscribe() functions.\n\nNote: This module only activates the processing of the \"reg\" in the\npresence module. To send dialog-info to watchers you also need a source\nwhich PUBLISH the reg info to the presence module. For example you can\nuse the pua_reginfo module or any external component. This approach\nallows to have the presence server and the reg-info aware publisher\n(e.g. the main proxy) on different Kamailio instances.\n",
  "parameters": {
   "default_expires": "### `default_expires` (int)\n\nThe default expires value used when missing from SUBSCRIBE message (in\nseconds).\n\n*Default value is \u201c3600\u201d.*\n\n```\n        ...\n        modparam(\"presence_reginfo\", \"default_expires\", 3600)\n        ...\n        \n```\n",
   "aggregate_presentities": "### `aggregate_presentities` (int)\n\nWhether to aggregate in a single notify body all registration\npresentities. Useful to have all registrations on first NOTIFY following\ninitial SUBSCRIBE.\n\n*Default value is \u201c0\u201d (disabled).*\n\n```\n                    ...\n                    modparam(\"presence_reginfo\", \"aggregate_presentities\", 1)\n                    ...\n                    \n```\n"
  },
  "functions": {}
 },
 "presence_xml": {
  "overview": "The module does specific handling for notify-subscribe events using xml\nbodies. It is used with the general event handling module, presence. It\nconstructs and adds 3 events to it:\n\n- presence - SIMPLE status presence: RFC 3856\n\n- presence.winfo - SIMPLE watcher info: RFC 3857\n\n- dialog;sla (or dialog;ma) - Bridged Line Appearances (BLA) (or\n  Multiple Line Appearances (MLA)): draft-anil-sipping-bla\n\nYou can control which events are enabled via module parameters.\n\nThis module takes the XCAP permission rule documents from xcap_table.\nThe presence permission rules are interpreted according to the\nspecifications in RFC 4745 and RFC 5025.\n",
  "parameters": {
   "db_url": "### `db_url`(str)\n\nThe database URL.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "xcap_table": "### `xcap_table`(str)\n\nThe name of the database table where XCAP documents are stored.\n\n*Default value is \u201cxcap\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"xcap_table\", \"xcaps\")\n...\n```\n",
   "disable_presence": "### `disable_presence`(int)\n\nSet this parameter to disable the handling of the \"presence\" event.\n\n*Default value: \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"disable_presence\", 1)\n...\n```\n",
   "disable_winfo": "### `disable_winfo`(int)\n\nSet this parameter to disable the handling of the \"presence.winfo\"\nevent.\n\n*Default value: \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"disable_winfo\", 1)\n...\n```\n",
   "disable_bla": "### `disable_bla`(int)\n\nSet this parameter to disable the handling of the \"dialog;sla\" event.\n\n*Default value: \u201c1\u201d (0 - enabled, 1 - disabled).*\n\n```\n...\nmodparam(\"presence_xml\", \"disable_bla\", 1)\n...\n```\n",
   "disable_xcapdiff": "### `disable_xcapdiff`(int)\n\nSet this parameter to disable the handling of the \"xcap-diff\" event.\n\n*Default value: \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"disable_xcapdiff\", 1)\n...\n```\n",
   "force_active": "### `force_active` (int)\n\nThis parameter is used for permissions when handling Subscribe messages.\nIf set to 1, subscription state is considered active and the presentity\nis not queried for permissions (should be set to 1 if not using an XCAP\nserver). Otherwise, the XCAP server is queried and the subscription\nstates is according to user defined permission rules. If no rules are\ndefined for a certain watcher, the subscriptions remains in pending\nstate and the Notify sent will have no body.\n\nNote: When switching from one value to another, the watchers table must\nbe emptied.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"force_active\", 1)\n...\n```\n",
   "integrated_xcap_server": "### `integrated_xcap_server` (int)\n\nThis parameter is a flag for the type of XCAP servers used. If the XCAP\nserver is integrated with Kamailio presence_xml module and access the\nsame database tables directly, like the embedded XCAP server implemented\nin xcap_server module, the parameter has to be set to 1. Apart from\nupdating in xcap table, if the integrated server is not running on the\nsame Kamailio instance, it must send an RPC command\npresence.refreshWatchers [pres_uri] [event] when a user modifies a\nrules document, to instruct the presence_xml module to update states\nfrom the database and, if needed, send NOTIFY updates.\n\nOtherwise (if set to 0) it uses xcap_client module to fetch documents\nfrom the XCAP servers with HTTP requests.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"integrated_xcap_server\", 1)\n...\n```\n",
   "xcap_server": "### `xcap_server` (str)\n\nThe address of the xcap servers used for storage. This parameter is\ncompulsory if the integrated_xcap_server parameter is not set. It can be\nset more than once, to construct an address list of trusted XCAP\nservers.\n\n```\n...\nmodparam(\"presence_xml\", \"xcap_server\", \"xcap_server.example.org\")\nmodparam(\"presence_xml\", \"xcap_server\", \"xcap_server.ag.org\")\n...\n```\n",
   "passive_mode": "### `passive_mode`(int)\n\nIf set to 1, module acts in passive mode - no bind to presence module,\nno connection to database. Useful when needing only to use $xml(...)\npseudo-variable.\n\n*Default value: \u201c0\u201d (0 - active mode, 1 - passive mode).*\n\n```\n...\nmodparam(\"presence_xml\", \"passive_mode\", 1)\n...\n```\n",
   "xcapauth_userdel_reason": "### `xcapauth_userdel_reason`(str)\n\nThis parameter represents the reason that will be included in the\nSubscription-State header of the Notify when a rule is no longer found\nin the XCAP pres-auth document for a user that was previously allowed.\nThe Subscription state in this case switches to \"terminated\". Because it\nis not clear which reason is most appropriate in this case from the ones\ndefined by the RFC 3265, this parameter offers the possibility for the\nadmin to decide which one he wishes to use.\n\n*Default value: \u201cprobation\u201d* . Since probation also accepts a\nretry-after parameter to specify after at least how may seconds the\nclient should reattempt to resubscribe, you can include this in the\nparameter also.\n\n```\n...\nmodparam(\"presence_xml\", \"xcapauth_userdel_reason\", \"probation;retry-after=30\")\nmodparam(\"presence_xml\", \"xcapauth_userdel_reason\", \"rejected\")\n...\n```\n",
   "force_dummy_presence": "### `force_dummy_presence`(int)\n\nSet this parameter to enable simple body notify with status 'open' when\npresentity info is not available.\n\n*Default value: \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"force_dummy_presence\", 1)\n...\n```\n",
   "force_presence_single_body": "### `force_presence_single_body`(int)\n\nSet this parameter to enable single body notify. One presentity can have\nmultiple dialogs and will by default notify all the dialogs and this can\nbe a problem when dealing with large ring-groups or attendants, use this\nparameter to only send one body. Look at\n`presence_single_body_priorities` and\n`presence_single_body_lookup_element` to customize the behaviour.\n\n*Default value: \u201c0\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"force_presence_single_body\", 1)\n...\n```\n",
   "presence_single_body_priorities": "### `presence_single_body_priorities`(str)\n\nChange this parameter to set the priorities when choosing the dialog\nthat will be the final.\n\nImportance is left to right.\n\n*Default value: \u201cAvailable|Ringing|On the Phone\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"presence_single_body_priorities\", \"Offline|Online|Busy|Really Busy\")\n...\n```\n",
   "presence_single_body_lookup_element": "### `presence_single_body_lookup_element`(str)\n\nSet the name of the element that should be used to get the priority. If\nthe value obtained is not in the list of\n`presence_single_body_priorities` the priority is 0.\n\n*Default value: \u201cnote\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"presence_single_body_lookup_element\", \"status\")\n...\n```\n",
   "default_expires": "### `default_expires` (int)\n\nThe default expires value used when missing from SUBSCRIBE message (in\nseconds).\n\n*Default value is \u201c3600\u201d.*\n\n```\n...\nmodparam(\"presence_xml\", \"default_expires\", 3600)\n...\n```\n"
  },
  "functions": {
   "pres_check_basic": "### `pres_check_basic(presentity_uri, status)`\n\nChecks the /presence/tuple/status/basic nodes in the presentity for\n*presentity_uri* against the value in status.\n\nThis function can be used from ANY_ROUTE.\n\n*Return code:*\n\n- *1 - if a match is found*.\n\n- *-1 - if a match is not found*.\n\n<!-- -->\n\n\n```\n...\n    if (pres_check_basic(\"$ru\", \"open\")) {\n        ...\n    } else {\n        if (is_method(\"MESSAGE\"))\n            m_store();\n    else\n        send_reply(\"404\", \"Not Found\");\n    }\n...\n```\n",
   "pres_check_activities": "### `pres_check_activities(presentity_uri, activity)`\n\nChecks whether a /presence/person/activities/*activity* node exists in\nthe presentity for *presentity_uri*.\n\nThis function can be used from ANY_ROUTE.\n\n*Return code:*\n\n- *1 - if a match is found*.\n\n- *-1 - if a match is not found*.\n\n- *-2 - if /presence/person or /presence/person/activity do not exist*.\n\n<!-- -->\n\n\n```\n...\n    if (pres_check_basic(\"$ru\", \"open\")) {\n    pres_check_activities(\"$ru\", \"unknown\");\n    if ($retcode || $retcode == -2 || !is_method(\"INVITE\"))\n            t_relay();\n    else\n            send_reply(\"486\", \"Busy Here\");\n    } else {\n        ...\n    }\n...\n```\n"
  }
 },
 "print": {
  "overview": "This is an example module. It implements only one function that prints\nits string parameter to stdout (it won't work if ser is started in\ndaemon mode). It also shows how module parameters can be declared.\n",
  "parameters": {
   "str_param": "### `str_param` (string)\n\nNot used, just an example\n\nDefault value is NULL.\n\n```\n...\nmodparam(\"print\", \"str_param\", \"foobar\")\n...\n        \n```\n",
   "int_param": "### `int_param` (integer)\n\nNot used, just an example.\n\nDefault value is 0.\n\n```\n...\nmodparam(\"print\", \"int_param\", 42)\n...\n        \n```\n"
  },
  "functions": {
   "print": "### `print(txt)`\n\nPrints string to stdout.\n\nMeaning of the parameters is as follows:\n\n- *txt* - string to be printed.\n\n<!-- -->\n\n\n```\n...\nprint(\"The answer is 42\\n\");\n...\n        \n```\n"
  }
 },
 "print_lib": {
  "overview": "This is an example module. It implements only one function that prints\nits string parameter to stderr (it won't work if server is started in\ndaemon mode). Its purpose is to show how to link to an internal library\n(lib/print).\n",
  "parameters": {},
  "functions": {
   "print_stderr": "### `print_stderr(txt)`\n\nPrints string to stderr.\n\nMeaning of the parameters is as follows:\n\n- *txt* - string to be printed.\n\n<!-- -->\n\n\n```\n...\nprint_stderr(\"The answer is 42\\n\");\n...\n        \n```\n"
  }
 },
 "pua": {
  "overview": "This module offers the functionality of a presence user agent client,\nsending SUBSCRIBE and PUBLISH SIP messages. It's a core part of\nKamailio's SIP presence package, implementing SIMPLE and various shared\nline appearance implementations.\n\nIt can be used with the following modules: pua_rpc, pua_usrloc, pua_bla,\npua_dialoginfo, pua_reginfo and pua_xmpp. The *pua_rpc* module offers\nthe possibility to publish any kind of information via the RPC\ntransport. The *pua_usrloc* module calls a function exported by pua\nmodules to publish elementary presence information, such as basic status\n\"open\" or \"closed\", for clients that do not implement client-to-server\npresence. Through *pua_bla* , BRIDGED LINE APPEARANCE features are added\nto Kamailio The *pua_xmpp* module represents a gateway between SIP and\nXMPP, so that jabber and SIP clients can exchange presence information.\nThe *pua_reginfo* modules presents registration information from the\nusrloc module using the reginfo event package.\n\nThe module supports 2 modes of operation. In the first a cache is used\nto store the presentity list and writes to database on timer to be able\nto recover upon restart. The presence is kept in-memory during run-time.\nThe second is a database only mode where the presentity list is stored\npurely in a database, allowing both scalability and resilience.\n",
  "parameters": {
   "hash_size": "### `hash_size` (int)\n\nThe size of the hash table used for storing SUBSCRIBE and PUBLISH\ninformation. This parameter will be used as the power of 2 when\ncomputing table size.\n\n*Default value is \u201c9\u201d.*\n\n```\n...\nmodparam(\"pua\", \"hash_size\", 11)\n...\n```\n",
   "db_url": "### `db_url` (str)\n\nDatabase url.\n\n*Default value is \u201c>mysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"pua\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_table": "### `db_table` (str)\n\nThe name of the database table.\n\n*Default value is \u201cpua\u201d.*\n\n```\n...\nmodparam(\"pua\", \"db_table\", \"pua\")\n...\n```\n",
   "min_expires": "### `min_expires` (int)\n\nThe inferior expires limit for both Publish and Subscribe.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua\", \"min_expires\", 0)\n...\n```\n",
   "default_expires": "### `default_expires` (int)\n\nThe default expires value used in case this information is not\nprovisioned.\n\n*Default value is \u201c3600\u201d.*\n\n```\n...\nmodparam(\"pua\", \"default_expires\", 3600)\n...\n```\n",
   "update_period": "### `update_period` (int)\n\nThe interval at which the information in database and hash table should\nbe updated. In the case of the hash table updating means deleting\nexpired messages. Setting a value less than or equal to zero, disables\nupdates.\n\n*Default value is \u201c100\u201d.*\n\n```\n...\nmodparam(\"pua\", \"update_period\", 100)\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy` (str)\n\nSIP URI of outbound proxy to be used when sending PUBLISH requests if no\noutbound proxy is given in outbound_proxy field of struct publ_info.\n\n*By default, no outbound proxy has been defined.*\n\n```\n...\nmodparam(\"pua\", \"outbound_proxy\", \"sip:outbound.example.com\")\n...\n```\n",
   "dlginfo_increase_version": "### `dlginfo_increase_version` (int)\n\nWhen sending PUBLISH messages for Event: dialog, the body contains an\nXML document according to RFC 4235. This XML document contains a version\nattribute to easily detect changes in the dialog state. By setting this\nparameter, the pua module parses the XML document and sets the version\nattribute to the proper value. If the receiver of the PUBLISH does not\ncare about the version parameter (e.g. like Kamailio presence_dialoginfo\nmodule) it makes no sense to waste CPU resources for parsing the XML\nbody and the parameter should be set to 0.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua\", \"dlginfo_increase_version\", 1)\n...\n```\n",
   "reginfo_increase_version": "### `reginfo_increase_version` (int)\n\nWhen sending PUBLISH messages for Event: reg, the body contains an XML\ndocument according to RFC 4235(?). This XML document contains a version\nattribute to easily detect changes in the registration state. By setting\nthis parameter, the pua module parses the XML document and sets the\nversion attribute to the proper value. If the receiver of the PUBLISH\ndoes not care about the version parameter (e.g. like Kamailio\npresence_reginfo module) it makes no sense to waste CPU resources for\nparsing the XML body and the parameter should be set to 0.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua\", \"reginfo_increase_version\", 1)\n...\n```\n",
   "db_mode": "### `db_mode` (int)\n\nThe module supports 2 modes of operation, high speed memory based\nstorage (mode 0), and database only (mode 2) where all data is stored in\na database, allowing scalability at the expense of speed. Mode 1 is\nreserved.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua\", \"db_mode\", 0)\n...\n```\n",
   "db_table_lock_write": "### `db_table_lock_write` (integer)\n\nEnable (=1) or disable (=0) the Locks for table during a transaction.\nLocking only the \"current\" table causes problems with a MySQL-Databases\nin \"DB-Only\" mode.\n\n*Default value is 1 (Write Lock for the Tables).*\n\n```\n...\nmodparam(\"pua\", \"db_table_lock_write\", 0)\n...\n```\n",
   "check_remote_contact": "### `check_remote_contact` (int)\n\nWhen sending a SUBSCRIBE check that the remote contact matches the one\nin the stored dialog or not. If the remote contact is checked and does\nnot match the one in the stored dialog then the dialog is not matched.\nChecking the remote contact can cause problems when using modules like\nRLS and should not be required in order to properly match the dialog\nanyway. Set this parameter to 0 to disable checking of remote contact\nfor SUBSCRIBE dialog matching.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"pua\", \"check_remote_contact\", 0)\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nNumber of rows to be loaded in one step from database.\n\n*Default value is 500.*\n\n```\n...\nmodparam(\"pua\", \"fetch_rows\", 1000)\n...\n```\n"
  },
  "functions": {
   "pua_update_contact": "### `pua_update_contact()`\n\nThe remote target can be updated by the Contact of a subsequent in\ndialog request. In the PUA watcher case (sending a SUBSCRIBE messages),\nthis means that the remote target for the following Subscribe messages\ncan be updated at any time by the contact of a Notify message. If this\nfunction is called on request route on receiving a Notify message, it\nwill try to update the stored remote target.\n\nThis function can be used from REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - if success*.\n\n- *-1 - if error*.\n\n<!-- -->\n\n\n```\n...\nif(method==\"NOTIFY\")\n    pua_update_contact();\n...\n```\n"
  }
 },
 "pua_bla": {
  "overview": "The pua_bla module enables Bridged Line Appearances support according to\nthe specifications in draft-anil-sipping-bla-03.txt.\n",
  "parameters": {
   "default_domain": "### `default_domain`(str)\n\nThe default domain for the registered users to be used when constructing\nthe uri for the registrar callback.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_bla\", \"default_domain\", \"kamailio.org\")\n...\n```\n",
   "header_name": "### `header_name`(str)\n\nThe name of the header to be added to Publish requests. It will contain\nthe uri of the user agent that sent the Notify that is transformed into\nPublish. It stops sending a Notification with the same information to\nthe sender.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_bla\", \"header_name\", \"Sender\")\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy`(str)\n\nThe outbound_proxy uri to be used when sending Subscribe requests.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_bla\", \"outbound_proxy\", \"sip:proxy@kamailio.org\")\n...\n```\n",
   "server_address": "### `server_address`(str)\n\nThe IP address of the server.\n\n```\n...\nmodparam(\"pua_bla\", \"server_address\", \"sip:bla@160.34.23.12\")\n...\n```\n"
  },
  "functions": {
   "bla_set_flag": "### `bla_set_flag`\n\nThe function is used to mark REGISTER requests made to a BLA AOR. The\nmodule subscribes to the registered contacts for dialog;sla event.\n\n```\n...\nif(is_method(\"REGISTER\") && to_uri=~\"bla_aor@kamailio.org\")\n    bla_set_flag();\n...\n```\n",
   "bla_handle_notify": "### `bla_handle_notify`\n\nThe function handles Notify requests sent from phones on the same BLA to\nthe server. The message is transformed in Publish request and passed to\npresence module for further handling. in case of a successful processing\na 2xx reply should be sent.\n\n```\n...\nif(is_method(\"NOTIFY\") && to_uri=~\"bla_aor@kamailio.org\")\n{\n        if( bla_handle_notify() )\n            t_reply(\"200\", \"OK\");\n}\n...\n```\n"
  }
 },
 "pua_dialoginfo": {
  "overview": "The pua_dialoginfo retrieves dialog state information from the dialog\nmodule and PUBLISHes the dialog-information using the pua module. Thus,\nin combination with the presence_xml module this can be used to derive\ndialog-info from the dialog module and NOTIFY the subscribed watchers\nabout dialog-info changes. This can be used for example with SNOM and\nLinksys phones.\n\nNote: This implements dialog-info according to RFC 4235 and is not\ncompatible with the BLA feature defined in\ndraft-anil-sipping-bla-03.txt. (Actually the BLA draft is really crap as\nit changes SIP semantics)\n\nThe module is based on code (copy/paste) from pua_usrloc and\nnat_traversal module.\n\nFollowing you will show some examples of a dialog-info XML document\ntaken from RFC 4235. This will help you to understand the meaning of the\nmodule parameters:\n\n```\n<?xml version=\"1.0\"?>\n<dialog-info xmlns=\"urn:ietf:params:xml:ns:dialog-info\"\n             version=\"1\"\n             state=\"full\"\n             entity=\"sip:alice@example.com\">\n    <dialog id=\"as7d900as8\"\n            call-id=\"a84b4c76e66710\"\n            local-tag=\"1928301774\"\n            remote-tag=\"456887766\"\n            direction=\"initiator\">\n        <state>early</state>\n    </dialog>\n</dialog-info>\n```\n\nThe root element is the \"dialog-info\". It contains the namespace, the\nversion (which must be incremented for each new PUBLISH for this certain\ndialog), the state (this module only supports state=full) and the entity\nfor which we publish the dialog-info.\n\nThe \"dialog\" element must contain an id parameter. The id parameter is\nusually different to the optional call-id parameter (which is the\ncall-id of the INVITE request) as an INVITE can create multiple dialogs\n(forked request). But as the dialog module does not support multiple\ndialogs created by a single transaction, the pua_dialoginfo module sets\nthe id parameter to the same value as the call-id parameter. The\n\"local-tag\" indicates the local tag of the entity. The remote-tag\nindicates the tag of the remote party. The \"direction\" indicates if the\nentity was the initiator of the dialog or the recipient (aka if the\nentity sent or received the first INVITE).\n\nThe \"state\" element describes the state of the dialog state machine and\nmust be either: trying, proceeding, early, confirmed or terminated.\n\nThe dialog element can contain optional \"local\" and \"remote\" elements\nwhich describes the local and the remote party in more detail, for\nexample:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<dialog-info xmlns=\"urn:ietf:params:xml:ns:dialog-info\"\n             version=\"1\" state=\"full\">\n    <dialog id=\"as7d900as8\"\n            call-id=\"a84b4c76e66710\"\n            local-tag=\"1928301774\"\n            remote-tag=\"456887766\"\n            direction=\"initiator\">\n        <state>early</state>\n        <local>\n            <identity display=\"Alice\">sip:alice@example.com</identity>\n            <target uri=\"sip:alice@phone11.example.com\"/>\n        </local>\n        <remote>\n            <identity display=\"Bob\">sip:bob@example.org</identity>\n            <target uri=\"sip:bobster@phone21.example.org\"/>\n        </remote>\n    </dialog>\n</dialog-info>\n```\n\nThe local and remote elements are needed to implement call pickup. For\nexample if the above XML document is received by somebody who SUBSCRIBEd\nthe dialog-info of Alice, then it can pick-up the call by sending an\nINVITE to Bob (actually I am not sure if it should use the URI in the\nidentity element or the URI in the target parameter) which contains a\nReplaces header which contains the call-id and the tags. This was tested\nsuccessfully with Linksys SPA962 phones and with SNOM 320 Firmware 7.3.7\n(you have to set the function key to \"Extension\").\n\nA dialog-info XML document may contain multiple \"dialog\" elements, for\nexample if the entity has multiple ongoing dialogs. For example the\nfollowing XML document shows a confirmed dialog and an early (probably a\nsecond incoming call) dialog.\n\n```\n<?xml version=\"1.0\"?>\n<dialog-info xmlns=\"urn:ietf:params:xml:ns:dialog-info\"\n             version=\"3\"\n             state=\"full\"\n             entity=\"sip:alice@example.com\">\n    <dialog id=\"as7d900as8\" call-id=\"a84b4c76e66710\"\n            local-tag=\"1928301774\" remote-tag=\"hh76a\"\n            direction=\"initiator\">\n        <state>confirmed</state>\n    </dialog>\n    <dialog id=\"j7zgt54\" call-id=\"ASDRRVASDRF\"\n            local-tag=\"123456789\" remote-tag=\"EE345\"\n            direction=\"recipient\">\n        <state>early</state>\n    </dialog>\n</dialog-info>\n```\n\nAs the dialog module callbacks only address a certain dialog, the\npua_dialoginfo always PUBLISHes XML documents with a single \"dialog\"\nelement. If an entity has multiple concurrent dialogs, the\npua_dialoginfo module will send PUBLISH for each dialog. These multiple\n\"presenties\" can be aggregated by the presence_dialoginfo module into a\nsingle XML document with multiple \"dialog\" elements. Please see the\ndescription of the presence_dialoginfo module for details about the\naggregation.\n\nIf there are problems with the callbacks from dialog module and you want\nto debug them you define PUA_DIALOGINFO_DEBUG in pua_dialoginfo.c and\nrecompile.\n",
  "parameters": {
   "include_callid": "### `include_callid` (int)\n\nIf this parameter is set, the optional call-id will be put into the\ndialog element. This is needed for call-pickup features.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"include_callid\", 0)\n...\n```\n",
   "include_tags": "### `include_tags` (int)\n\nIf this parameter is set, the local and remote tag will be put into the\ndialog element. This is needed for call-pickup features.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"include_tags\", 0)\n...\n```\n",
   "include_localremote": "### `include_localremote` (int)\n\nIf this parameter is set, the optional local and remote elements will be\nput into the dialog element. This is needed for call-pickup features.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"include_localremote\", 0)\n...\n```\n",
   "override_lifetime": "### `override_lifetime` (int)\n\nThe PUBLISH requests used to send the dialog-info contain an Expires\nheader. The value of the expires is usually taken from the lifetime of\nthe dialog (see README of dialog module). If the override_lifetime is\nset, the value specified here is used instead of the lifetime of the\ndialog module. If used, the value should at least be a few seconds more\nthan the fr_inv_timer of the tm module.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"override_lifetime\", 300)\n...\n```\n",
   "include_req_uri": "### `include_req_uri` (int)\n\ncontrols if R-URI is going to be used instead of To header value in the\nPUBLISH as \"identity\" on \"remote\" node.\n\n*Default value is \u201c0\u201d. Disabled*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"include_req_uri\", 1)\n...\n```\n",
   "caller_confirmed": "### `caller_confirmed` (int)\n\nUsually the dialog-info of the caller will be \"trying -> early ->\nconfirmed\" and the dialog-info of the callee will be \"early ->\nconfirmed\". On some phones the function LED will start blinking if the\nstate is early, regardless if is is the caller or the callee (indicated\nwith the \"direction\" parameter). To avoid blinking LEDs for the caller,\nyou can enable this parameter. Then the state of the caller will be\nsignaled as \"confirmed\" even in \"early\" state. This is a workaround for\nthe buggy Linksys SPA962 phones. SNOM phones work well with the default\nsetting.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"caller_confirmed\", 1)\n...\n```\n",
   "send_publish_flag": "### `send_publish_flag` (int)\n\nThis message flag indicates whether to send PUBLISH requests or not. If\nnot set, PUBLISH requests are sent out only if their R-URI is local\n(according to myself).\n\n*Default value is \u201c-1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"send_publish_flag\", 8)\n...\n```\n",
   "disable_caller_publish_flag": "### `disable_caller_publish_flag` (int)\n\nThis message flag indicates whether to send caller (initiator) PUBLISH\nrequests or not. If set, PUBLISH requests are not sent for the caller\n(initiator).\n\n*Default value is \u201c-1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"disable_caller_publish_flag\", 9)\n...\n```\n",
   "disable_callee_publish_flag": "### `disable_callee_publish_flag` (int)\n\nThis message flag indicates whether to send callee (recipient) PUBLISH\nrequests or not. If set, PUBLISH requests are not sent for the callee\n(recipient).\n\n*Default value is \u201c-1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"disable_callee_publish_flag\", 10)\n...\n```\n",
   "use_pubruri_avps": "### `use_pubruri_avps` (int)\n\nGet Publish R-Uri from avps (see corresponding avp params), not from\nrequest to/from uri.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"use_pubruri_avps\", 1)\n...\n```\n",
   "refresh_pubruri_avps_flag": "### `refresh_pubruri_avps_flag` (int)\n\nIf use_pubruri_avps is enabled, this message flag indicates whether to\nrefresh R-Uri from avps before sending the PUBLISH requests.\n\n*Default value is \u201c-1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"refresh_pubruri_avps_flag\", 11)\n...\n```\n",
   "pubruri_caller_avp": "### `pubruri_caller_avp` (str)\n\nIf use_pubruri_avps is enabled, PUBLISH-requests reporting\ndialog-information about the caller (entity=caller) are sent using the\nvalue of the specified avp as R-Uri. If multiple AVPs with the same name\n(but different indexes) are present, for each value a corresponding\nPUBLISH-request is generated. If no AVP with the specified name exists,\nno caller-related PUBLISH requests are sent.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"pubruri_caller_avp\", \"$avp(s:puburis_caller)\")\n...\n```\n",
   "pubruri_callee_avp": "### `pubruri_callee_avp` (str)\n\nIf use_pubruri_avps is enabled, PUBLISH-requests reporting\ndialog-information about the callee (entity=callee) are sent using the\nvalue of the specified avp as R-Uri. If multiple AVPs with the same name\n(but different indexes) are present, for each value a corresponding\nPUBLISH-request is generated. If no AVP with the specified name exists,\nno callee-related PUBLISH requests are sent.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"pubruri_callee_avp\", \"$avp(s:puburis_callee)\")\n...\n```\n",
   "pubruri_caller_dlg_var": "### `pubruri_caller_dlg_var` (str)\n\nMust be set to the name of dialog variable where to store the URI for\ncaller, used to send the notifications. This is needed to restored the\nvalue after Kamailio restart. If not set, loaded dialogs at restart are\nno longer sending notifications. New dialogs are working fine.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"pubruri_caller_dlg_var\", \"pubruri_caller\")\n...\n```\n",
   "pubruri_callee_dlg_var": "### `pubruri_callee_dlg_var` (str)\n\nMust be set to the name of dialog variable where to store the URI for\ncallee, used to send the notifications. This is needed to restored the\nvalue after Kamailio restart. If not set, loaded dialogs at restart are\nno longer sending notifications. New dialogs are working fine.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"pubruri_callee_dlg_var\", \"pubruri_callee\")\n...\n```\n",
   "callee_trying": "### `callee_trying` (int)\n\nIf this parameter is set, a \"Trying\" state will be sent for both the\ncaller and callee, rather than just the caller.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"callee_trying\", 1)\n...\n```\n",
   "caller_entity_when_publish_disabled": "### `caller_entity_when_publish_disabled` (int)\n\nMust be a valid sip uri. If this parameter is set, this uri is used as\ncaller entity in publish xml body if associated dialog has the flag\ndisable_caller_publish_flag set. Note only the flag received on dialog\ncreation is used to activate this feature.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"caller_entity_when_publish_disabled\", \"sip:caller@publish.disabled.com\")\n...\n            \n```\n",
   "callee_entity_when_publish_disabled": "### `callee_entity_when_publish_disabled` (int)\n\nMust be a valid sip uri. If this parameter is set, this uri is used as\ncallee entity in publish xml body if associated dialog has the flag\ndisable_callee_publish_flag set. Note only the flag received on dialog\ncreation is used to activate this feature.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"callee_entity_when_publish_disabled\", \"sip:callee@publish.disabled.com\")\n...\n            \n```\n",
   "publish_dialog_req_within": "### `publish_dialog_req_within` (int)\n\nIf this parameter is set to 1, subsequents requests received in dialog\ngenerate corresponding publish request.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"publish_dialog_req_within\", 0)\n...\n            \n```\n",
   "local_identity_dlg_var": "### `local_identity_dlg_var` (str)\n\nPUBLISH-requests reporting dialog-information will use the value of the\ndialog variable if exists\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"local_identity_dlg_var\", \"local_identity\")\n...\n```\n",
   "attribute_display": "### `attribute_display` (int)\n\nIf set to 1, the display name attribute is added with user part of the\nURI for local and remote targets.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"pua_dialoginfo\", \"attribute_display\", 1)\n...\n```\n"
  },
  "functions": {}
 },
 "pua_json": {
  "overview": "The PUA_JSON module adds support to publish updates to the presence\nmodule through the pua_json_publish() function.\n\nFrom a high-level perspective, the module may be used for:\n\n- Providing a real-time presence updates.\n",
  "parameters": {},
  "functions": {
   "pua_json_publish": "### `pua_json_publish(json_payload)`\n\nThe function build presentity state from json_payload and updates\npresentity table.\n\nUsage: presence related.\n\nThis function can be used from ANY ROUTE.\n\n```\n...\nevent_route[xhttp:request] {\n    $var(call-id) = $(rb{json.parse,Call-ID});\n    if ($(rb{json.parse,Event-Package}) == \"dialog\") {\n        xlog(\"L_INFO\", \"$var(call-id)|log|received $(rb{json.parse,Event-Package}) update for $(rb{json.parse,From})\");\n        pua_json_publish($rb);\n    }\n}\n...\n```\n"
  }
 },
 "pua_reginfo": {
  "overview": "This module publishes information about \"reg\"-events according to to RFC\n3680. This can be used distribute the registration-info status to the\nsubscribed watchers.\n\nThis module \"PUBLISH\"es information when a new user registers at this\nserver (e.g. when \"save()\" is called) to users, which have subscribed\nfor the reg-info for this user.\n\nThis module can \"SUBSCRIBE\" for information at another server, so it\nwill receive \"NOTIFY\"-requests, when the information about a user\nchanges.\n\nAnd finally, it can process received \"NOTIFY\" requests and it will\nupdate the local registry accordingly.\n\nUse cases for this might be:\n\n- Keeping different Servers in Sync regarding the location database\n- Get notified, when a user registers: A presence-server, which handles\n  offline message storage for an account, would get notified, when the\n  user comes online.\n- A client could subscribe to its own registration-status, so he would\n  get notified as soon as his account gets administratively\n  unregistered.\n- ...\n",
  "parameters": {
   "default_domain": "### `default_domain`(str)\n\nThe default domain for the registered users to be used when constructing\nthe uri for the registrar callback.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_reginfo\", \"default_domain\", \"kamailio.org\")\n...\n```\n",
   "publish_reginfo": "### `publish_reginfo`(int)\n\nWhether or not to generate PUBLISH requests.\n\n*Default value is \u201c1\u201d (enabled).*\n\n```\n...\nmodparam(\"pua_reginfo\", \"publish_reginfo\", 0)\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy`(str)\n\nThe outbound_proxy uri to be used when sending Subscribe and Publish\nrequests.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_reginfo\", \"outbound_proxy\", \"sip:proxy@kamailio.org\")\n...\n```\n",
   "server_address": "### `server_address`(str)\n\nThe IP address of the server.\n\n```\n...\nmodparam(\"pua_reginfo\", \"server_address\", \"sip:reginfo@160.34.23.12\")\n...\n```\n"
  },
  "functions": {
   "reginfo_handle_notify": "### `reginfo_handle_notify(uldomain)`\n\nThis function processes received \"NOTIFY\"-requests and updates the local\nregistry accordingly.\n\nThis method does not create any SIP-Response, this has to be done by the\nscript-writer.\n\nThe parameter has to correspond to user location table (domain) where to\nstore the record.\n\nReturn codes:\n\n- *2* - contacts successfully updated, but no more contacts online now.\n\n  *1* - contacts successfully updated and at at least one contact still\n  registered.\n\n  *-1* - Invalid NOTIFY or other error (see log-file)\n\n<!-- -->\n\n\n```\n...\nif(is_method(\"NOTIFY\"))\n    if (reginfo_handle_notify(\"location\"))\n        send_reply(\"202\", \"Accepted\");\n...\n                \n```\n",
   "reginfo_subscribe": "### `reginfo_subscribe(uri[, expires])`\n\nThis function will subscribe for reginfo-information at the given server\nURI.\n\nMeaning of the parameters is as follows:\n\n- *uri* - SIP-URI of the server, where to subscribe, may contain\n  pseudo-variables.\n\n  *expires* - Expiration date for this subscription, in seconds (default\n  3600)\n\n<!-- -->\n\n\n```\n...\nroute {\n    t_on_reply(\"1\");\n    t_relay();\n}\n\nreply_route[1] {\n    if (t_check_status(\"200\"))\n        reginfo_subscribe(\"$ru\");\n}\n...\n                \n```\n"
  }
 },
 "pua_rpc": {
  "overview": "The pua_rpc module offers the possibility to publish presence\ninformation via the RPC transport. Subscribing to presence information\nhas not been implemented yet.\n\nUsing this module you can create independent applications/scripts to\npublish SIP and not SIP related information (e.g., MWI message summary\ninformation, system resources like CPU-usage, memory, number of active\nsubscribers, ...). Future version of this module may allow non-SIP\nspeaking applications to subscribe to presence information kept in a SIP\npresence server.\n",
  "parameters": {},
  "functions": {}
 },
 "pua_usrloc": {
  "overview": "The pua_usrloc module is the connector between the usrloc and pua\nmodules. With this module, you can monitor the status of SIP\nregistrations. The module sends PUBLISH requests for user location\nrecord changes, based on specific events (e.g., when a new record is\nadded in usrloc, a PUBLISH with status open (online) is issued; when\nexpires, it sends closed (offline)).\n\nUsing this module phones which have no support for presence can be seen\nas online/offline.\n",
  "parameters": {
   "default_domain": "### `default_domain` (str)\n\nThe default domain to use when constructing the presentity URI if it is\nmissing from stored AOR in the usrloc table (in memory or database).\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_usrloc\", \"default_domain\", \"kamailio.org\")\n...\n```\n",
   "entity_prefix": "### `entity_prefix` (str)\n\nThe prefix used when constructing the entity attribute to be added to a\npresence node in the XML PIDF document. (ex: pres:user@domain ).\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"pua_usrloc\", \"entity_prefix\", \"pres\")\n...\n```\n",
   "branch_flag": "### `branch_flag` (int)\n\nWhich branch flag to be used to select the contact addresses for which\nto generate PUBLISH. Valid values are 0 to 31.\n\n*Default value is \u201c-1\u201d (disabled).*\n\n```\n...\nmodparam(\"pua_usrloc\", \"branch_flag\", 9)\n...\n```\n"
  },
  "functions": {
   "pua_set_publish": "### `pua_set_publish()`\n\nThe function is used to mark REGISTER requests that have to issue a\nPUBLISH. The PUBLISH is issued when REGISTER is saved in location table.\n\n```\n...\nif(is_method(\"REGISTER\") && from_uri=~\"john@kamailio.org\")\n    pua_set_publish();\n...\n```\n"
  }
 },
 "pua_xmpp": {
  "overview": "This module is a gateway for presence between SIP and XMPP.\n\nIt translates one format into another and uses xmpp, pua and presence\nmodules to manage the transmission of presence state information.\n",
  "parameters": {
   "server_address": "### `server_address`(str)\n\nThe SIP URI specifying the address of the SIP server.\n\n```\n...\nmodparam(\"pua_xmpp\", \"server_address\", \"sip:160.23.23.10\")\n...\n```\n"
  },
  "functions": {
   "pua_xmpp_notify": "### `pua_xmpp_notify()`\n\nFunction that handles Notify messages addressed to a user from an xmpp\ndomain. It requires filtering after method and domain in configuration\nfile. If the function is successful, a 2xx reply must be sent.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    if( is_method(\"NOTIFY\") && uri=~\"sip:.+@sip-xmpp.kamailio.org\")\n    {\n        if(pua_xmpp_notify())\n            t_reply(\"200\", \"OK\");\n        exit;\n    }\n...\n```\n",
   "pua_xmpp_req_winfo": "### `pua_xmpp_req_winfo(request_uri, expires)`\n\nFunction called when a Subscribe addressed to a user from an xmpp domain\nis received. It calls sending a Subscribe for winfo for the user, and\nthe following Notify with dialog-info is translated into a subscription\nin xmpp. It also requires filtering in configuration file, after method,\ndomain and event(only for presence).\n\nIt takes 2 parameters: request_uri and the value of Expires header field\nin received Subscribe.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    if( is_method(\"SUBSCRIBE\"))\n    {\n        handle_subscribe();\n        if(uri=~\"sip:.+@sip-xmpp.siphub.ro\" && $hdr(Event)== \"presence\")\n        {\n            pua_xmpp_req_winfo(\"$ruri\", \"$hdr(Expires)\");\n        }\n        t_release();\n    }\n\n...\n        \n```\n"
  }
 },
 "pv": {
  "overview": "This module collects the core pseudo-variables that can be used in\nconfiguration file. They are listed in wiki:\n<https://www.kamailio.org/wikidocs/> in Pseudo-Variables section\n",
  "parameters": {
   "shvset": "### `shvset` (string)\n\nSet the initial value of a shared variable ($shv(name)). The parameter\ncan be set many times.\n\nThe value of the parameter has the format: _name_ '=' _type_ ':'\n_value_\n\n- _name_: shared variable name\n\n- _type_: type of the value\n\n  - \u201ci\u201d: integer value\n\n  - \u201cs\u201d: string value\n\n\n- _value_: value to be set\n\nNote: this is special useful for usage with KEMI scripts, the $shv(...)\nvariables must be defined during Kamailio initialization in order to\nbecome available in all worker processes.\n\nDefault value is \u201cNULL\u201d.\n\n```\n...\nmodparam(\"pv\", \"shvset\", \"debug=i:1\")\nmodparam(\"pv\", \"shvset\", \"pstngw=s:sip:10.10.10.10\")\n...\n```\n",
   "varset": "### `varset` (string)\n\nSet the value of a script variable ($var(name)). The parameter can be\nset many times.\n\nThe value of the parameter has the format: _name_ '=' _type_ ':'\n_value_\n\n- _name_: shared variable name\n\n- _type_: type of the value\n\n  - \u201ci\u201d: integer value\n\n  - \u201cs\u201d: string value\n\n\n- _value_: value to be set\n\nDefault value is \u201cNULL\u201d.\n\n```\n...\nmodparam(\"pv\", \"varset\", \"init=i:1\")\nmodparam(\"pv\", \"varset\", \"gw=s:sip:11.11.11.11;transport=tcp\")\n...\n```\n",
   "avp_aliases": "### `avp_aliases` (string)\n\nDefine aliases for PV AVP names.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"pv\",\"avp_aliases\",\"email=s:email_addr;tmp=i:100\")\n...\n                \n```\n"
  },
  "functions": {
   "pv_isset": "### `pv_isset(pvar)`\n\nReturn true if a PV value is different than 'null'.\n\nMeaning of the parameters is as follows:\n\n- *pvar* - pvar identifier.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(pv_isset(\"$avp(s:x)\"))\n{\n    ...\n}\n...\n```\n",
   "pv_unset": "### `pv_unset(pvar)`\n\nUnset the value of the PV (e.g., delete AVP, set to null).\n\nMeaning of the parameters is as follows:\n\n- *pvar* - pvar identifier.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\npv_unset(\"$avp(s:x)\");\n...\n```\n",
   "is_int": "### `is_int(pvar)`\n\nFunction checks if pvar argument contains integer value and returns 1 if\nit does and -1 otherwise.\n\nFunction can be used from all kinds of routes.\n\n```\n...\nif (is_int(\"$var(foo)\")) {\n    xlog(\"L_INFO\", \"variable foo contains integer value\\n\");\n}\n...\n                \n```\n",
   "typeof": "### `typeof(pvar, vtype)`\n\nReturns true if the type of pseudo-variable matches the second\nparameter. The second parameter can be: 'int' - type is integer; 'str' -\ntype is string; 'null' - type is null.\n\nFunction can be used from ANYROUTE.\n\n```\n...\nif (typeof(\"$var(foo)\", \"str\")) {\n    xdbg(\"variable foo is a string\\n\");\n}\n...\n                \n```\n",
   "not_empty": "### `not_empty(pvar)`\n\nReturns true if the pseudo-variables has the type string and is not\nempty value.\n\nFunction can be used from all kinds of routes.\n\n```\n...\nif (not_empty(\"$var(foo)\")) {\n    append_hf(\"X-Foo: $var(foo)\\r\\n\");\n}\n...\n                \n```\n",
   "xavp_copy": "### `xavp_copy(source_name, source_index, destination_name, destination_index)`\n\nCopy and replace one XAVP.\n\nThe parameters can be variables or strings. First parameter is the\nsource XAVP name. Second parameter is the source XAVP stack index, use 0\nto copy the last assigned XAVP. Third parameter is the destination XAVP\nname, if not found xavp_copy will return -1. Fourth parameter is the\ndestination XAVP index, if not found xavp_copy will return -1.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n# Using xavp_copy to reorder an existing xavp stack inplace\n$xavp(d=>x) = \"d-0-x\";\n$xavp(d[0]=>y) = \"d-0-y\";\n$xavp(d=>x) = \"d-1-x\";\n$xavp(d[0]=>y) = \"d-1-y\";\n$xavp(d=>x) = \"d-2-x\";\n$xavp(d[0]=>y) = \"d-2-y\";\n\nxinfo(\"NEW $xavp(d[0]=>x) == [d-2-x] and $xavp(d[0]=>y) == [d-2-y]\\n\");\nxinfo(\"NEW $xavp(d[1]=>x) == [d-1-x] and $xavp(d[1]=>y) == [d-1-y]\\n\");\nxinfo(\"NEW $xavp(d[2]=>x) == [d-0-x] and $xavp(d[2]=>y) == [d-0-y]\\n\");\n\nxavp_copy(\"d\", \"0\", \"e\");\nxavp_copy(\"d\", \"2\", \"d\", \"0\");\nxavp_copy(\"e\", \"0\", \"d\", \"2\");\n\nxinfo(\"AFTER $xavp(d[0]=>x) == [d-0-x] $xavp(d[0]=>y) == [d-0-y]\\n\");\nxinfo(\"AFTER $xavp(d[1]=>x) == [d-1-x] $xavp(d[1]=>y) == [d-1-y]\\n\");\nxinfo(\"AFTER $xavp(d[2]=>x) == [d-2-x] $xavp(d[2]=>y) == [d-2-y]\\n\");\n...\n                \n```\n",
   "xavp_params_explode": "### `xavp_params_explode(sparams, xname)`\n\nConvert a parameters string in xavp attributes.\n\nThe first parameter has to be a string in the format of SIP header\nparameters (name1=value1;...;nameN=valueN). The second parameter is the\nname of the root xavp to hold the pairs (nameX,valueX).\n\nThe values are stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavp_params_explode(\"a=b;c=d;e=d\", \"x\");\n# results in:\n#    $xavp(x=>a) = \"b\";\n#    $xavp(x=>c) = \"d\";\n#    $xavp(x=>e) = \"f\";\n...\n                \n```\n",
   "xavp_params_implode": "### `xavp_params_implode(xname, pvname)`\n\nSerialize the subfields in an XAVP to a parameters string format.\n\nNumber values are serialized as unsigned integer string format.\n\nThe first parameter has to be the name of XAVP (only the string name,\nnot the in $xavp(name)). The second parameter is the name of output\nvariable (in full name, like $var(output)).\n\nThe value is stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$xavp(x=>e) = \"f\";\n$xavp(x[0]=>c) = \"d\";\n$xavp(x[0]=>a) = \"b\";\nxavp_params_implode(\"x\", \"$var(out)\");\n# results in: $var(out) is \"a=b;c=d;e=f;\"\n...\n                \n```\n",
   "xavp_params_implode_qval": "### `xavp_params_implode_qval(xname, pvname)`\n\nSerialize the subfields in an XAVP to a parameters string format,\nenclosing string values in double quotes.\n\nNumber values are serialized as unsigned integer string format.\n\nThe first parameter has to be the name of XAVP (only the string name,\nnot the in $xavp(name)). The second parameter is the name of output\nvariable (in full name, like $var(output)).\n\nThe value is stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$xavp(x=>e) = \"f\";\n$xavp(x[0]=>c) = 5;\n$xavp(x[0]=>a) = \"b\";\nxavp_params_implode(\"x\", \"$var(out)\");\n# results in: $var(out) is: a=\"b\";c=5;e=\"f\";\n...\n                \n```\n",
   "xavu_params_explode": "### `xavu_params_explode(sparams, xname)`\n\nConvert a parameters string in xavu attributes.\n\nThe first parameter has to be a string in the format of SIP header\nparameters (name1=value1;...;nameN=valueN). The second parameter is the\nname of the root xavu to hold the pairs (nameX,valueX).\n\nThe values are stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavu_params_explode(\"a=b;c=d;e=d\", \"x\");\n# results in:\n#    $xavu(x=>a) = \"b\";\n#    $xavu(x=>c) = \"d\";\n#    $xavu(x=>e) = \"f\";\n...\n                \n```\n",
   "xavu_params_implode": "### `xavu_params_implode(xname, pvname)`\n\nSerialize the subfields in an XAUP to a parameters string format.\n\nNumber values are serialized as unsigned integer string format.\n\nThe first parameter has to be the name of XAVU (only the string name,\nnot the in $xavu(name)). The second parameter is the name of output\nvariable (in full name, like $var(output)).\n\nThe value is stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$xavu(x=>e) = \"f\";\n$xavu(x=>c) = \"d\";\n$xavu(x=>a) = \"b\";\nxavu_params_implode(\"x\", \"$var(out)\");\n# results in: $var(out) is \"a=b;c=d;e=f;\"\n...\n                \n```\n",
   "xavp_slist_explode": "### `xavp_slist_explode(slist, sep, mode, xname)`\n\nBreaks a string list in tokens by separators and stores them in XAVPs.\nNote that is not storing empty values.\n\nThe first parameter has to be a string (static or with variables).\n\nThe second parameter has to contain separator characters (they can be\nmany).\n\nThe third parameter is mode, controlling the behaviour of extracting the\ntokens, the supported mode right now is 't', which trims the white\nspaces around the value.\n\nThe fourth parameter is the name of the root xavp to hold the tokens in\nfields named 'v' and indexed from 0.\n\nThe values are stored as string type.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavp_slist_explode(\"a=b; c=d;\", \"=;\", \"t\", \"x\");\n# results in:\n#    $xavp(x[0]=>v[0]) = \"a\";\n#    $xavp(x[0]=>v[1]) = \"b\";\n#    $xavp(x[0]=>v[2]) = \"c\";\n#    $xavp(x[0]=>v[3]) = \"d\";\n...\n                \n```\n",
   "xavp_child_seti": "### `xavp_child_seti(rname, cname, ival)`\n\nSet the value of $xavp(rname=>cname) to integer value ival.\n\nThe first parameter has to be the name of XAVP in the root list. The\nsecond parameter name of child XAVP. The third parameter can be an\ninteger number or a variable holding an integer.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$var(n) = 10;\nxavp_child_seti(\"x\", \"y\", \"$var(n)\");\n# results in: $xavp(x=>y) is 10\n...\n                \n```\n",
   "xavi_child_seti": "### `xavi_child_seti(rname, cname, ival)`\n\nSet the value of $xavi(rname=>cname) to integer value ival.\n\nThe first parameter has to be the name of XAVI in the root list. The\nsecond parameter name of child XAVI. The third parameter can be an\ninteger number or a variable holding an integer.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$var(n) = 10;\nxavi_child_seti(\"WhatEver\", \"FoO\", \"$var(n)\");\n# results in: $xavi(whatever=>foo) is 10\n...\n                \n```\n",
   "xavp_child_sets": "### `xavp_child_sets(rname, cname, sval)`\n\nSet the value of $xavp(rname=>cname) to string value sval.\n\nThe first parameter has to be the name of XAVP in the root list. The\nsecond parameter name of child XAVP. The third parameter can be a static\nor dynamic (with variables) string.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$var(n) = 10;\nxavp_child_sets(\"x\", \"y\", \"Count: $var(n)\");\n# results in: $xavp(x=>y) is \"Count: 10\"\n...\n                \n```\n",
   "xavi_child_sets": "### `xavi_child_sets(rname, cname, sval)`\n\nSet the value of $xavi(rname=>cname) to string value sval.\n\nThe first parameter has to be the name of XAVI in the root list. The\nsecond parameter name of child XAVI. The third parameter can be a static\nor dynamic (with variables) string.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$var(n) = 10;\nxavi_child_sets(\"WhatEver\", \"FoO\", \"Count: $var(n)\");\n# results in: $xavi(whatever=>foo) is \"Count: 10\"\n...\n                \n```\n",
   "xavp_rm": "### `xavp_rm(rname)`\n\nRemove the value of $xavp(rname).\n\nThe parameter has to be the name of XAVP in the root list. It can be\nstatic or dynamic string (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavp_rm(\"x\");\n# same result as: $xavp(x) = $null;\n...\n                \n```\n",
   "xavi_rm": "### `xavi_rm(rname)`\n\nRemove the value of $xavi(rname).\n\nThe parameter has to be the name of XAVI in the root list. It can be\nstatic or dynamic string (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavi_rm(\"WhatEver\");\n# same result as: $xavi(whatever) = $null;\n...\n                \n```\n",
   "xavp_child_rm": "### `xavp_child_rm(rname, cname)`\n\nRemove the value of $xavp(rname=>cname).\n\nThe first parameter has to be the name of XAVP in the root list. The\nsecond parameter name of child XAVP. Both parameters can be static or\ndynamic strings (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavp_child_rm(\"x\", \"y\");\n# same result as: $xavp(x=>y) = $null;\n...\n                \n```\n",
   "xavi_child_rm": "### `xavi_child_rm(rname, cname)`\n\nRemove the value of $xavi(rname=>cname).\n\nThe first parameter has to be the name of XAVI in the root list. The\nsecond parameter name of child XAVI. Both parameters can be static or\ndynamic strings (to include variables).\n\nFunction can be used from ANY ROUTE.\n\n```\n...\nxavi_child_rm(\"WhatEver\", \"FoO\");\n# same result as: $xavi(whatever=>foo) = $null;\n...\n                \n```\n",
   "xavp_lshift": "### `xavp_lshift(xname, idx)`\n\nLeft shift with rotation of the xavps with name xname so that the one at\nthe index idx becomes the first and the ones before it are at the end of\nthe list.\n\nThe first parameter has to be the name of XAVP in the root list.\n\nThe second parameter is the index of the XAVP that becomes the first one\n(if it is greater than the number of XAVPs, modulo operation is done\nfirst; if it is negative, it counts from the end of the list).\n\nThe parameters can be with variables.\n\nFunction can be used from ANY ROUTE.\n\n```\n...\n$xavp(n) = 10;\n$xavp(n) = 20;\n$xavp(n) = 30;\nxavp_lshift(\"n\", \"1\");\n# results in: $xavp(n) having the list of values 20 30 10\n...\n                \n```\n",
   "xavp_push_dst": "### `xavp_push_dst(xname)`\n\nSet destination fields from XAVP attributes.\n\nThe first parameter has to be the name of XAVP in the root list.\n\nThe parameters can be with variables.\n\nThe attributes that can be stored in the XAVP fields:\n\n- uri: SIP URI address to set R-URI\n\n- dsturi: SIP URI address to set DST-URI\n\n- socket: listen address to set outgoing socket\n\nFunction can be used from REQUEST_ROUTE|BRANCH_ROUTE|FAILURE_ROUTE.\n\n```\n...\n$xavp(dst=>uri) = \"sip:alice@server.com\";\n$xavp(dst[0]=>dsturi) = \"sip:proxy.com\";\n$xavp(dst[0]=>socket) = \"udp:1.2.3.4:5060\";\nxavp_push_dst(\"dst\");\n...\n                \n```\n",
   "sbranch_set_ruri": "### `sbranch_set_ruri()`\n\nUse the attributes from static branch ($sbranch(key) variable) to set\nrequest URI and the other fields of the branch associated with request\nURI (destination URI, path, ...).\n\nContent of the static branch is not reset after this function is\nexecuted. It has to be done explicitly with sbranch_reset().\n\nFunction can be used from REQUEST_ROUTE, BRANCH_ROUTE or FAILURE_ROUTE.\n\n```\n...\nsbranch_reset();\n$sbranch(uri) = \"sip:127.0.0.1:5080\";\n$sbranch(dst_uri) =  \"sip:127.0.0.1:5090\";\n$sbranch(path) =  \"sip:127.0.0.1:5090, sip:127.0.0.1:5094\";\n$sbranch(send_socket) =  \"udp:127.0.0.1:5060\";\nsbranch_set_ruri();\n...\n                \n```\n",
   "sbranch_append": "### `sbranch_append()`\n\nUse the attributes from static branch ($sbranch(key) variable) to\nappend a new branch to destination set. It is an alternative to\nappend_branch() that allows setting each attribute specific to the\nbranch.\n\nContent of the static branch is not reset after this function is\nexecuted. It has to be done explicitly with sbranch_reset().\n\nFunction can be used from REQUEST_ROUTE, BRANCH_ROUTE or FAILURE_ROUTE.\n\n```\n...\nsbranch_reset();\n$sbranch(uri) = \"sip:127.0.0.1:5080\";\n$sbranch(dst_uri) =  \"sip:127.0.0.1:5090\";\n$sbranch(send_socket) =  \"udp:127.0.0.1:5060\";\nsbranch_append();\n...\n                \n```\n",
   "sbranch_reset": "### `sbranch_reset()`\n\nReset the content of static branch ($sbranch(key) variable.\n\nFunction can be used from REQUEST_ROUTE, BRANCH_ROUTE or FAILURE_ROUTE.\n\n```\n...\nsbranch_reset();\n...\n                \n```\n",
   "pv_xavp_print": "### `pv_xavp_print()`\n\nPrint all XAVPs to the syslog using INFO log level.\n\nFunction can be used from ANY_ROUTE.\n\n```\n...\npv_xavp_print();\n...\n                \n```\n",
   "pv_xavu_print": "### `pv_xavu_print()`\n\nPrint all XAVUs to the syslog using INFO log level.\n\nFunction can be used from ANY_ROUTE.\n\n```\n...\npv_xavu_print();\n...\n                \n```\n",
   "pv_xavi_print": "### `pv_xavi_print()`\n\nPrint all XAVIs to the syslog using INFO log level.\n\nFunction can be used from ANY_ROUTE.\n\n```\n...\npv_xavi_print();\n...\n                \n```\n",
   "pv_var_to_xavp": "### `pv_var_to_xavp(varname, xname)`\n\nCopy the script variable value into an xavp.\n\nFirst parameter can be '*' in order to copy all script variables.\nSecond parameter is the name of the destination xavp. If xavp already\nexists it will be reset first.\n\nBoth parameters can contain variables that are evaluated at runtime.\n\nFunction can be used from ANY_ROUTE.\n\n```\n...\n$var(\"temp\") = 3;\n$var(\"foo\") = \"foo indeed\";\npv_var_to_xavp(\"temp\", \"ok\");\n...\n$xavp(\"ok[0]=>temp\") now is 3\n...\npv_var_to_xavp(\"*\", \"ok\");\n...\n$xavp(\"ok[0]=>temp\") now is 3\n$xavp(\"ok[0]=>foo\") now is \"foo indeed\"\n...\n                \n```\n",
   "pv_xavp_to_var": "### `pv_xavp_to_var(xname)`\n\nCopy xavp values into vars. Reverse of pv_var_to_xavp().\n\nBoth parameters can contain variables that are evaluated at runtime.\n\nFunction can be used from ANY_ROUTE.\n\n```\n...\n$xavp(\"bar=>temp\") = 3;\n$xavp(\"bar[0]=>foo\") = \"foo indeed\";\npv_xavp_to_var(\"bar\");\n...\n$var(\"temp\") now is 3\n$var(\"foo\") now is \"foo indeed\"\n...\n                \n```\n",
   "pv_evalx": "### `pv_evalx(dst, fmt)`\n\nThe fmt string is evaluated twice for exiting variables, the result is\nstored in dst variable. The dst must be the name of a writable variable.\nThe fmt can contain variables that have a value containing other\nvariables.\n\nFunction can be used from ANY_ROUTE.\n\n```\n...\n$var(x) = \"test\";\n$var(y) = \"$var(x)\"\npv_evalx(\"$var(z)\", \"$var(y) one\");\n\n# - the value of $var(z) is \"test one\"\n...\n                \n```\n"
  }
 },
 "pv_headers": {
  "overview": "The main goal of the module is to offload the intermediate header\nprocessing into the XAVI dynamic container as well as provide with high\nlevel methods and pseudovariables to simplify SIP message header\nmodifications.\n",
  "parameters": {
   "xavi_name": "### `xavi_name` (string)\n\nName of the XAVI where the collected headers are stored.\n\n*Default value is \u201cheaders\u201d.*\n\n```\n...\nmodparam(\"pv_headers\", \"xavi_name\", \"headers\")\n...\n```\n\nResult: $xavi(headers[0]=>From) $xavi(headers[0]=>To)\n$xavi(headers[0]=>Call-ID)\n",
   "header_value_size": "### `header_value_size` (int)\n\nDefines an internal maximum SIP header value size. Header values longer\nthan this setting will be stripped down when collected or applied.\n\n*Default value is 1024.*\n\n```\n...\nmodparam(\"pv_headers\", \"header_value_size\", 512)\n...\n```\n",
   "header_collect_flag": "### `header_collect_flag` (int)\n\nUsed to mark that headers are collected for the SIP message, leading to\nsubsequent headers collection on this message to be declined with an\nerror. Should be used only in branches and replies.\n\n*Default value is 27.*\n\n```\n...\nmodparam(\"pv_headers\", \"header_collect_flag\", 17)\n...\n```\n",
   "header_apply_flag": "### `header_apply_flag` (int)\n\nUsed to mark that headers are applied for the SIP message, leading to\nsubsequent headers applies on this message to be declined with an error.\nShould be used only in branches and replies.\n\n*Default value is 28.*\n\n```\n...\nmodparam(\"pv_headers\", \"header_apply_flag\", 18)\n...\n```\n",
   "skip_headers": "### `skip_headers` (string)\n\nA comma separated headers list that must be excluded from processing\n(they are skipped when [pvh_apply_headers()](#) changes the SIP message\nheaders).\n\nIf the parameter is set to an empty string then all the SIP message\nheaders are processed.\n\n*Default value is\n\u201cRecord-Route,Via,Route,Content-Length,Max-Forwards,CSeq\u201d.*\n\n```\n...\nmodparam(\"pv_headers\", \"skip_headers\", \"Record-Route,Via,Route\")\n...\n```\n",
   "split_headers": "### `split_headers` (string)\n\nA comma separated headers list that must be split into multi headers if\ntheir value is a comma separated list.\n\nIf the parameter is set to an empty string then no headers are split.\n\n*Default value is \u201c\u201d.*\n\n```\n...\nmodparam(\"pv_headers\", \"split_headers\", \"Diversion\")\n...\n```\n\nResult: Received Diversion header: Diversion:\n<user1@test.local>,<user2@test.local>,<user3@test.local> After\nsplit: Diversion: <user1@test.local> Diversion: <user2@test.local>\nDiversion: <user3@test.local>\n\nBecomes handy if used together with [pvh_modify_header()](#) or\n[pvh_remove_header()](#) to change or remove value 2 for instance.\n",
   "auto_msg": "### `auto_msg` (int)\n\nDefines whether the headers are automatically collected for incoming\nmessages, as well as automatically applied for forwarded messages.\n\nIt is enabled by default and requires the 'tm' module to be loaded,\notherwise the mode is disabled and manual invocation of\n[pvh_collect_headers()](#)/[pvh_apply_headers()](#) is required.\n\n*Default value is 1 (enabled).*\n\n```\n...\nmodparam(\"pv_headers\", \"auto_msg\", 1)\n...\n```\n"
  },
  "functions": {
   "pvh_collect_headers": "### `pvh_collect_headers()`\n\nCollects all headers from the message into the XAVP. It should be used\npreferably just when the SIP message is received by Kamailio.\n\nThis function can be used from ANY_ROUTE.\n",
   "pvh_apply_headers": "### `pvh_apply_headers()`\n\nApplies the current XAVP headers state to the real headers. Should be\ncalled only once per branch when the message is about to leave Kamailio.\n\nThe following rules apply:\n\n- all headers in the XAVP except for ones provided in the\n  skip_headers\n  parameter and From/To are recreated in the\n  SIP\n  message.\n- From/To headers are processed by the uac module if it is loaded.\n- From/To headers are not changed in the reply messages.\n- headers with NULL value are removed if exist in the\n  SIP\n  message.\n- the initial order of the\n  SIP\n  headers is preserved.\n\nThis function can be used from ANY_ROUTE.\n",
   "pvh_reset_headers": "### `pvh_reset_headers()`\n\nCollects all headers from the message into the XAVP. It should be used\npreferably just when the SIP message is received by >Kamailio.\n\nThis function can be used from ANY_ROUTE.\n",
   "pvh_check_header": "### `pvh_check_header(hname)`\n\nChecks if the header \u201chname\u201d already exists in the XAVP.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n",
   "pvh_append_header": "### `pvh_append_header(hname, hvalue)`\n\nAppends a new header \u201chname\u201d with the value \u201chvalue\u201d into the XAVP.\nPlease note that subsequent \"pv_append_header\" calls will result in\nmultiple headers.\n\nIf the provided \u201chvalue\u201d is $null then the header is added into the\nXAVP but it is not going to be added into the message.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n",
   "pvh_modify_header": "### `pvh_modify_header(hname, hvalue, [idx])`\n\nModifies an existing header in the XAVP \u201chname\u201d with the value \u201chvalue\u201d\ninto the XAVP. Index order is top to bottom. Please note that subsequent\n[pvh_append_header](#) calls will result in multiple headers.\n\nPlease note that if the header \u201chname\u201ddoes not exist it will be\nexplicitly appended. If there are multiple headers with the same name\nand \u201cidx\u201d is omitted, only the first one will be affected.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n",
   "pvh_remove_header": "### `pvh_remove_header(hname, [idx])`\n\nRemoves an existing header \u201chname\u201d from the XAVP. Index order is top to\nbottom.\n\nIf there are multiple headers with the same name and \u201cidx\u201d is omitted,\nall of them will be removed.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) or with \u201cauto_msg\u201d parameter enabled.\n",
   "pvh_value_exists": "### `pvh_value_exists(hname, hparameter)`\n\nChecks if the parameter \u201chparameter\u201d is present in the header \u201chname\u201d\nfrom XAVP.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) have been called or with \u201cauto_msg\u201d parameter\nenabled.\n",
   "pvh_remove_header_param": "### `pvh_remove_header_param(hname, hparameter)`\n\nRemoves an existing parameter \u201chparameter\u201d in the header \u201chname\u201d from\nthe XAVP.\n\nIf there are multiple headers, only the one containing the parameter\nwill be modified.\n\nThe parameter can be located in any position (beginning, middle or end)\nof the list of parameters.\n\nIf the parameter is the only one present, the header will be removed.\n\nThis function can be used from ANY_ROUTE but only after [\npvh_collect_headers()](#) have been called or with \u201cauto_msg\u201d parameter\nenabled.\n"
  }
 },
 "qos": {
  "overview": "The qos module provides a way to keep track of per dialog SDP\nsession(s).\n",
  "parameters": {
   "qos_flag": "### `qos_flag` (integer)\n\nThe module will not do anything to any message unless instructed to do\nso via the config script. You must set the `qos_flag` value in the\n`setflag()` call of the INVITE you want the qos module to process. But\nbefore you can do that, you need to tell the qos module which flag value\nyou are assigning to qos.\n\nIn most cases when ever you set the dialog flag you will want to set the\nqos flag. If the dialog flag is not set and the qos flag is set, it will\nnot have any effect.\n\n*This parameter must be set or the module will not load.*\n\n*Default value is \u201cNot set!\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_flag\", 5)\nmodparam(\"qos\", \"qos_flag\", 7)\n...\nroute {\n  ...\n  if (method==\"INVITE\") {\n    setflag(5); # set the dialog flag\n    setflag(7); # Set the qos flag\n  }\n  ...\n}\n```\n"
  },
  "functions": {}
 },
 "rabbitmq": {
  "overview": "This module offers amqp communication using librabbitmq. This module was\ncreated using *rabbitmq-c* C client\n(<https://github.com/alanxz/rabbitmq-c>). A new amqp connection is setup\non a per-children basis, when Kamailio starts. If connection is lost,\nthe process tries to re-establish it when a new amqp action is required.\n\nCurrently librabbitmq offers no async API, but sync API, with a timeout.\nSee below link for updates on this issue:\n\n- *https://github.com/alanxz/rabbitmq-c/issues/370*.\n",
  "parameters": {
   "url": "### `url` (string)\n\nThe amqp connection url.\n\n*Default value is \u201camqp://guest:guest@localhost:5672/%2F\u201d.*\n\n```\n...\nmodparam(\"rabbitmq\", \"url\", \"amqp://kamailio:kamailio@localhost:5672/%2Fkamailio\")\n...\n                \n```\n",
   "timeout_sec": "### `timeout_sec` (int)\n\nThe timeout in seconds. The timeout_sec + timeout_usec combination gives\nthe time to wait for an amqp reply, when rabbitmq_publish_consume() is\nused.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"rabbitmq\", \"timeout_sec\", 1)\n...\n                \n```\n",
   "timeout_usec": "### `timeout_usec` (int)\n\nThe timeout in micro seconds. The timeout_sec + timeout_usec combination\ngives the time to wait for an amqp reply, when\nrabbitmq_publish_consume() is used.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"rabbitmq\", \"timeout_usec\", 0)\n...\n                \n```\n",
   "direct_reply_to": "### `direct_reply_to` (int)\n\nSetting this parameter to 1, enables rabbitmq direct reply-to feature.\nMore info about this, can be found at\nhttps://www.rabbitmq.com/direct-reply-to.html.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"rabbitmq\", \"direct_reply_to\", 1)\n...\n                \n```\n"
  },
  "functions": {
   "rabbitmq_publish": "### `rabbitmq_publish(exchange, routing_key, content_type, messagebody)`\n\nThe function publishes messagebody without waiting for a reply.\n\nMeaning of the parameters is as follows:\n\n- *exchange* - the amqp exchange.\n\n- *routing_key* - the amqp routing_key.\n\n- *content_type* - the content_type of the messagebody.\n\n- *messagebody* - the messagebody to be published.\n\nThis function can be used from any route.\n\n```\nrabbitmq_publish(\"exchange\", \"routing_key\", \"application/json\", \"$avp(json_request)\");\n                \n```\n",
   "rabbitmq_publish_consume": "### `rabbitmq_publish_consume(exchange, routing_key, content_type, messagebody, reply)`\n\nThe function publishes messagebody and waits timeoute_sec + timeout_usec\nfor a reply. If the reply comes, one can read it in the *reply* avp.\n\nMeaning of the parameters is as follows:\n\n- *exchange* - the amqp exchange.\n\n- *routing_key* - the amqp routing_key.\n\n- *content_type* - the content_type of the messagebody.\n\n- *messagebody* - the messagebody to be published.\n\n- *reply* - the consumed reply.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\nrabbitmq_publish_consume(\"exchange\", \"routing_key\", \"application/json\", \"$avp(json_request)\", \"$avp(json_reply)\");\n                \n```\n"
  }
 },
 "ratelimit": {
  "overview": "This module implements rate limiting for SIP requests. In contrast to\nthe PIKE module this limits the flow based on a per SIP request type\nbasis and not per source IP. The RPC interface can be used to change\ntunables while running Kamailio.\n\nThe module implements the pipe/queue policy from BSD's ipfw manual, with\nsome simplifications. In principle, each specified method is associated\nwith its own queue and a number of queues are connected to a certain\npipe (see the queue and pipe params).\n\nPlease also take a look at the \u201cpipelimit\u201d module, that implements the\npipe policy with database support. Note that it doesn't implement the\nqueues that exist in this module.\n",
  "parameters": {
   "timer_interval": "### `timer_interval` (integer)\n\nThe initial length of a timer interval in seconds. All amounts of\nmessages have to be divided by this timer to get a messages per second\nvalue.\n\nIMPORTANT: A too small value may lead to performance penalties due to\ntimer process overloading.\n\n*Default value is 10.*\n\n```\n...\nmodparam(\"ratelimit\", \"timer_interval\", 5)\n...\n```\n",
   "queue": "### `queue` (integer:string)\n\nThe format of the queue parameter is \"pipe_no:method\". For each defined\nmethod, the algorithm defined by pipe number \"pipe_no\" will be used.\n\nTo specify a queue that accepts all methods, use \u201c*\u201d instead of METHOD.\nAs queues are matched against request methods, you will usually want to\nhave this as the last queue added or other queues with specific methods\nwill never match. At this time, glob or regexp patterns are not\nsupported.\n\n```\n...\n# assign pipe no 0 to method REGISTER\n# assign pipe no 3 to method INVITE\n# assign pipe no 2 to all other methods\nmodparam(\"ratelimit\", \"queue\", \"0:REGISTER\")\nmodparam(\"ratelimit\", \"queue\", \"3:INVITE\")\nmodparam(\"ratelimit\", \"queue\", \"2:*\")\n...\n```\n",
   "pipe": "### `pipe` (integer:string:integer)\n\nThe format of the pipe param is \"pipe_no:algorithm:limit\". For each\ndefined pipe, the given algorithm with the given limit will be used.\n\nA pipe is characterised by its algorithm and limit (bandwidth, in ipfw\nterms). When specifying a limit, the unit depends on the algorithm used\nand doesn't need to be specified also (eg, for TAILDROP or RED, limit\nmeans packets/sec, whereas with the FEEDBACK algorithm, it means [CPU]\nload factor).\n\n```\n...\n# define pipe 0 with a limit of 200 pkts/sec using TAILDROP algorithm\n# define pipe 1 with a limit of 100 pkts/sec using RED algorithm\n# define pipe 2 with a limit of 50 pkts/sec using TAILDROP algorithm\n# define pipe 3 with a limit of load factor 80 using FEEDBACK algorithm\n# define pipe 4 with a limit of 10000 pending bytes in the rx_queue\n#                                     using NETWORK algorithm\nmodparam(\"ratelimit\", \"pipe\", \"0:TAILDROP:200\")\nmodparam(\"ratelimit\", \"pipe\", \"1:RED:100\")\nmodparam(\"ratelimit\", \"pipe\", \"2:TAILDROP:50\")\nmodparam(\"ratelimit\", \"pipe\", \"3:FEEDBACK:80\")\nmodparam(\"ratelimit\", \"pipe\", \"4:NETWORK:10000\")\n...\n```\n"
  },
  "functions": {
   "rl_check": "### `rl_check([pvar])`\n\nCheck the current request against the matched ratelimit algorithm. If no\nparameter is provided, the queue will be matched based on method type,\nand then the pipe will be identified based on the matched queue. If a\npipe number is provided as a parameter, then the given pipe number will\nbe used for identifying the ratelimit algorithm. The pipe number must be\nprovided as number or via a pseudovariable.\n\nThe method will return an error code if the limit for the matched\nalgorithm is reached.\n\nMeaning of the parameters is as follows:\n\n- *pvar* - the pseudovariable holding the pipe id to be used by\n  ratelimit.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    # perform queue/pipe match for current method\n    if (!rl_check()) {\n        append_to_reply(\"Retry-After: 5\\r\\n\");\n        sl_send_reply(\"503\",\"Limiting\");\n        exit;\n    }\n...\n    # use pipe no 1 for the current method\n    # set int pvar to 1\n    $var(p) = 1;\n    if (!rl_check(\"$var(p)\")) {\n        append_to_reply(\"Retry-After: 5\\r\\n\");\n        sl_send_reply(\"503\",\"Limiting\");\n        exit;\n    }\n...\n```\n",
   "rl_check_pipe": "### `rl_check_pipe(pipe_no)`\n\nCheck the current request against the matched ratelimit algorithm of the\npipe provided as parameter. The parameter can be provided as number or\nvariable.\n\nThe method will return an error code if the limit for the matched\nalgorithm is reached.\n\nMeaning of the parameters is as follows:\n\n- *pipe_no* - the pipe id to be used by ratelimit.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n    # use pipe no 1 for the current method\n    if (!rl_check_pipe(\"1\") {\n        append_to_reply(\"Retry-After: 5\\r\\n\");\n        sl_send_reply(\"503\",\"Limiting\");\n        exit;\n    }\n...\n```\n"
  }
 },
 "regex": {
  "overview": "This module offers matching operations using regular expressions based\non the powerful [PCRE](http://www.pcre.org/) library.\n\nA text file containing regular expressions categorized in groups is\ncompiled when the module is loaded, the resulting PCRE objects are\nstored in an array. A function to match a string or pseudo-variable\nagainst any of these groups is provided. The text file can be modified\nand reloaded at any time via a RPC command. The module also offers a\nfunction to perform a PCRE matching operation against a regular\nexpression provided as function parameter.\n\nFor a detailed list of PCRE features read the [man\npage](http://www.pcre.org/pcre.txt) of the library.\n",
  "parameters": {
   "file": "### `file` (string)\n\nText file containing the regular expression groups. It must be set in\norder to enable the group matching function.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"regex\", \"file\", \"/etc/kamailio/regex_groups\")\n...\n```\n",
   "max_groups": "### `max_groups` (int)\n\nMax number of regular expression groups in the text file.\n\n*Default value is \u201c20\u201d.*\n\n```\n...\nmodparam(\"regex\", \"max_groups\", 40)\n...\n```\n",
   "group_max_size": "### `group_max_size` (int)\n\nMax content size of a group in the text file.\n\n*Default value is \u201c8192\u201d.*\n\n```\n...\nmodparam(\"regex\", \"group_max_size\", 16384)\n...\n```\n",
   "pcre_caseless": "### `pcre_caseless` (int)\n\nIf this options is set, matching is done caseless. It is equivalent to\nPerl's /i option, and it can be changed within a pattern by a (?i) or\n(?-i) option setting.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"regex\", \"pcre_caseless\", 1)\n...\n```\n",
   "pcre_multiline": "### `pcre_multiline` (int)\n\nBy default, PCRE treats the subject string as consisting of a single\nline of characters (even if it actually contains newlines). The \"start\nof line\" metacharacter (^) matches only at the start of the string,\nwhile the \"end of line\" metacharacter ($) matches only at the end of\nthe string, or before a terminating newline.\n\nWhen this option is set, the \"start of line\" and \"end of line\"\nconstructs match immediately following or immediately before internal\nnewlines in the subject string, respectively, as well as at the very\nstart and end. This is equivalent to Perl's /m option, and it can be\nchanged within a pattern by a (?m) or (?-m) option setting. If there are\nno newlines in a subject string, or no occurrences of ^ or $ in a\npattern, setting this option has no effect.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"regex\", \"pcre_multiline\", 1)\n...\n```\n",
   "pcre_dotall": "### `pcre_dotall` (int)\n\nIf this option is set, a dot metacharacter in the pattern matches all\ncharacters, including those that indicate newline. Without it, a dot\ndoes not match when the current position is at a newline. This option is\nequivalent to Perl's /s option, and it can be changed within a pattern\nby a (?s) or (?-s) option setting.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"regex\", \"pcre_dotall\", 1)\n...\n```\n",
   "pcre_extended": "### `pcre_extended` (int)\n\nIf this option is set, whitespace data characters in the pattern are\ntotally ignored except when escaped or inside a character class.\nWhitespace does not include the VT character (code 11). In addition,\ncharacters between an unescaped # outside a character class and the\nnext newline, inclusive, are also ignored. This is equivalent to Perl's\n/x option, and it can be changed within a pattern by a (?x) or (?-x)\noption setting.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"regex\", \"pcre_extended\", 1)\n...\n```\n"
  },
  "functions": {
   "pcre_match": "### `pcre_match (string, pcre_regex)`\n\nMatches the given string parameter against the regular expression\npcre_regex, which is compiled in runtime into a PCRE object. Returns\nTRUE if it matches, FALSE otherwise.\n\nMeaning of the parameters is as follows:\n\n- *string* - String or pseudo-variable to compare.\n\n- *pcre_regex* - Regular expression to be compiled in a PCRE object. It\n  can be a string or pseudo-variable.\n\nNOTE: To use the \"end of line\" symbol '$' in the pcre_regex parameter\nuse '$$'.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (pcre_match(\"$ua\", \"(?i)^twinkle\")) {\n    xlog(\"L_INFO\", \"User-Agent matches\\n\");\n}\n...\n\n...\nif (pcre_match(\"$rU\", \"^user[1234]$$\")) {  # Will be converted to \"^user[1234]$\"\n    xlog(\"L_INFO\", \"RURI username matches\\n\");\n}\n...\n```\n",
   "pcre_match_group": "### `pcre_match_group (string [, group])`\n\nTries to match the given string against a specific group in the text\nfile (see [File format](#file-format-id)). Returns TRUE if it matches,\nFALSE otherwise.\n\nMeaning of the parameters is as follows:\n\n- *string* - String or pseudo-variable to compare.\n\n- *group* - Number of group to use in the operation. If not specified\n  then 0 (the first group) is used. A pseudo-variable containing an\n  integer can also be used.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.\n\n```\n...\nif (pcre_match_group(\"$rU\", \"2\")) {\n    xlog(\"L_INFO\", \"RURI username matches group 2\\n\");\n}\n...\n\n...\n$avp(i:10) = 5;  # Maybe got from a DB query.\nif (pcre_match_group(\"$ua\", \"$avp(i:10)\")) {\n    xlog(\"L_INFO\", \"User-Agent matches group 5\\n\");\n}\n...\n                \n```\n"
  }
 },
 "registrar": {
  "overview": "The module contains REGISTER processing logic. The actual location\ndatabase is managed by the USRLOC module.\n",
  "parameters": {
   "default_expires": "### `default_expires` (integer)\n\nIf the processed message contains neither Expires header fields nor\nexpires contact parameters, this value will be used for newly created\nusrloc records. The parameter contains number of second to expire (for\nexample use 3600 for one hour). If it is set to a lower value than the\n\u201cmin_expires\u201d parameter then it will be ignored. This parameter can be\nmodified via ser config framework. A random value in a specific interval\ncan be selected by using the default_expires_range parameter\n\n*Default value is 3600.*\n\n```\n...\nmodparam(\"registrar\", \"default_expires\", 1800)\n...\n```\n",
   "default_expires_range": "### `default_expires_range` (integer)\n\nThis parameter specifies that the expiry used for newly created usrloc\nrecords are not fixed, but a random value in the interval\n\u201c[default_expires-default_expires_range%, default_expires]\u201d. The value\nis between 0 and 100 and represent the maximum percentage from expires\nthat will be subtracted when computing the value. Default is 0, meaning\ndefault_expires is left unmodified. This parameter can be modified via\nthe Kamailio config framework.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"default_expires_range\", 30) # +- 30% from default_expires\n...\n```\n",
   "expires_range": "### `expires_range` (integer)\n\nSimilar to default_expires_range, but it applies to the incoming expires\nvalue. Default in 0, meaning the expires is left unmodified. This\nparameter can be modified via the Kamailio config framework.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"expires_range\", 30) # expires within [0.7*expires .. expires]\n...\n```\n",
   "min_expires": "### `min_expires` (integer)\n\nThe minimum expires value of a \u201cContact\u201d. Values lower than this minimum\nwill be either set to the minimum or 423 response is sent back. Value 0\ndisables the checking. This parameter can be modified via the Kamailio\nconfig framework.\n\n*Default value is 60.*\n\n```\n...\nmodparam(\"registrar\", \"min_expires\", 60)\n...\n```\n",
   "min_expires_mode": "### `min_expires_mode` (integer)\n\nControl what to do when expires value in REGISTER request is lower than\nmin_expires parameter. If set to 0, expires is set to min_expires. If\nset to 1, then 423 Interval Too Brief is sent back.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"min_expires_mode\", 1)\n...\n```\n",
   "max_expires": "### `max_expires` (integer)\n\nThe maximum accepted expires value of a \u201cContact\u201d, values higher than\nthis maximum will be automatically set to the maximum. Value 0 disables\nthe checking. This parameter can be modified via the Kamailio config\nframework.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"max_expires\", 120)\n...\n```\n",
   "default_q": "### `default_q` (integer)\n\nThe parameter represents default \u201cq\u201d value for new contacts. Because\nKamailio doesn't support float parameter types, the value in the\nparameter is divided by 1000 and stored as float. For example, if you\nwant default_q to be 0.38, use value 380 here. This parameter can be\nmodified via the Kamailio config framework.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"default_q\", 1000)\n...\n```\n",
   "realm_prefix": "### `realm_prefix` (string)\n\nPrefix to be automatically stripped from realm. As an alternative to SRV\nrecords (not all SIP clients support SRV lookup), a subdomain of the\nmaster domain can be defined for SIP purposes (like sip.mydomain.net\npointing to same IP address as the SRV record for mydomain.net). By\nignoring the realm_prefix \"sip.\", at registration, sip.mydomain.net will\nbe equivalent to mydomain.net. This parameter can be modified via the\nKamailio config framework.\n\n*Default value is NULL (none).*\n\n```\n...\nmodparam(\"registrar\", \"realm_prefix\", \"sip.\")\n...\n```\n",
   "append_branches": "### `append_branches` (integer)\n\nThe parameter controls how lookup function processes multiple contacts.\nIf there are multiple contacts for the given username in usrloc and this\nparameter is set to 1, Request-URI will be overwritten with the\nhighest-q rated contact. The rest will be appended to sip_msg structure\nand can be later used by tm for forking. If the parameter is set to 0,\nonly Request-URI will be overwritten with the highest-q rated contact\nand the rest will be left unprocessed. This parameter can be modified\nvia Kamailio config framework.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"registrar\", \"append_branches\", 0)\n...\n```\n",
   "aor_avp": "### `aor_avp` (str)\n\nThis module parameter has been removed. Use the 'uri' parameter from\nfunctions (e.g., save, lookup, registered).\n",
   "case_sensitive": "### `case_sensitive` (integer)\n\nIf set to 1 then AOR comparison and also storing will be case sensitive,\nif set to 0 then AOR comparison and storing will be case insensitive.\nThis is recommended. This parameter can be modified via Kamailio config\nframework.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"case_sensitive\", 1)\n...\n```\n",
   "received_avp": "### `received_avp` (str)\n\nRegistrar will store the value of the AVP configured by this parameter\nin the received column in the user location database. It will leave the\ncolumn empty if the AVP is empty. The AVP should contain a SIP URI\nconsisting of the source IP, port, and transport protocol of the\nREGISTER message being processed.\n\n<div class=\"note\">\n\n\nThe value of this parameter should be the same as the value of\ncorresponding parameter of nathelper module.\n\n</div>\n\n\n*Default value is \"NULL\" (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"received_avp\", \"$avp(s:rcv)\")\n...\n```\n",
   "received_param": "### `received_param` (string)\n\nThe name of the parameter that will be appended to Contact URI's of 200\nOK when the received URI was set by the \u201cnathelper\u201d module. If the value\nis an empty string, then the parameter is not appended anymore.\n\n*Default value is \"received\".*\n\n```\n...\nmodparam(\"registrar\", \"received_param\", \"rcv\")\n...\n```\n",
   "max_contacts": "### `max_contacts` (integer)\n\nThe parameter can be used to limit the number of contacts per AOR\n(Address of Record) in the user location database. If the maximum number\nof contacts is exceeded, Kamailio will not accept the registration and\nsend an error response. Value 0 disables the check. This parameter can\nbe modified via the Kamailio config framework. (Please also check the\nflag for `save()` if you only want only one active registration).\n\n*Default value is 0.*\n\n```\n...\n# Allow no more than 10 contacts per AOR\nmodparam(\"registrar\", \"max_contacts\", 10)\n...\n        \n```\n",
   "retry_after": "### `retry_after` (integer)\n\nThe registrar can generate a 5xx reply to REGISTER requests in various\nsituations. It can, for example, happen when the `max_contacts`\nparameter is set and the processing of REGISTER request would exceed the\nlimit. In this case the registrar would generate \"503 Service\nUnavailable\" response. This parameter can be modified via the Kamailio\nconfig framework.\n\nIf you want to add the Retry-After header field in 5xx replies, set this\nparameter to a value grater than zero (0 means do not add the header\nfield). See section 20.33 of RFC3261 for more details.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"retry_after\", 30)\n...\n        \n```\n",
   "sock_flag": "### `sock_flag` (integer)\n\nMessage flag to signal to the registrar module to look into REGISTER\nrequest for a header which contains a socket description (IP:port). This\nsocket info will be stored by registrar instead of the received socket\ninfo.\n\nThis makes sense only in multiple replicated servers scenarios.\n\n*Default value is -1 (no flag).*\n\n```\n...\nmodparam(\"registrar\", \"sock_flag\", 18)\n...\n        \n```\n",
   "sock_hdr_name": "### `sock_hdr_name` (string)\n\nHeader which contains a socket description (proto:IP:port) to override\nthe received socket info. The header will be read only if the flag\nsock_flag is set.\n\nThis makes sense only in multiple replicated servers scenarios.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"registrar\", \"sock_hdr_name\", \"Sock-Info\")\n...\n        \n```\n",
   "sock_mode": "### `sock_mode` (integer)\n\nIf set to 1, the server stores the advertised address in socket field,\ninstead of bind address.\n\nThis could be useful when kamailio is installed behind NAT and it is\nnecessary to store its public IP instead socket on which the register\nrequest was received.\n\n*Default value is 0 (store bind address).*\n\n```\n...\nmodparam(\"registrar\", \"sock_mode\", 1)\n...\n        \n```\n",
   "method_filtering": "### `method_filtering` (integer)\n\nTells if the contact filtering based on supported methods should be\nperformed during lookup on initial requests without to-tag. It's enabled\nonly if it has a non zero value. Supported methods are listed in the\n\u201cAllow:\u201d header in the REGISTER message and stored in the location\ndatabase.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"method_filtering\", 1)\n...\n        \n```\n",
   "use_path": "### `use_path` (integer)\n\nIf set to 1, the \u201cPath:\u201d header is handled according to the parameter.\nThis parameter can be modified via Kamailio config framework.\n\u201cpath_mode\u201d.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"use_path\", 1)\n...\n        \n```\n",
   "path_mode": "### `path_mode` (integer)\n\nThe registrar module implements three different modes regarding the\nresponse to a registration which includes one or more Path headers:\n\n- 0 - The Path header is saved into usrloc, but is not included in the\n  reply.\n\n- 1 - The Path header is saved into usrloc, but is only included in the\n  reply if path support is indicated in the registration request by the\n  \u201cpath\u201d option in the \u201cSupported:\u201d header.\n\n- 2 - The path header is only saved into usrloc, if path support is\n  indicated in the registration request by the \u201cpath\u201d option of the\n  \u201cSupported\u201d header. If no path support is indicated, the request is\n  rejected with \u201c420 - Bad Extension\u201d and the header \u201cUnsupported: path\u201d\n  is included in the reply along with the received \u201cPath\u201d header. This\n  mode is the one recommended by RFC-3327.\n\n*Default value is 2.*\n\n```\n...\nmodparam(\"registrar\", \"path_mode\", 0)\n...\n        \n```\n",
   "path_use_received": "### `path_use_received` (integer)\n\nIf set to 1, the \u201creceived\u201d parameter of the first Path URI of a\nregistration is set as received-uri and the NAT branch flag is set for\nthis contact. This is useful if the registrar is placed behind a SIP\nloadbalancer, which passes the nat'ed UAC address as \u201creceived\u201d\nparameter in its Path uri.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"path_use_received\", 1)\n...\n        \n```\n",
   "path_check_local": "### `path_check_local` (integer)\n\nIf set to 1, when performing a lookup the Path (if present) is evaluated\nand if the first hop is local (according to \u201cmyself\u201d test), we skip it\nto avoid unnecessary looping.\n\nThis is useful if multiple servers are sharing a common location\ndatabase, each saving contacts with their local address as the Path.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"path_check_local\", 1)\n...\n        \n```\n",
   "reg_callid_avp": "### `reg_callid_avp` (string)\n\n*obsolete. use match_option in registered function*\n\nIf reg_callid_avp is defined and populated when the `registered()` is\ninvoked, the result is TRUE only if an active registration with the\nspecified callID is found.\n\n*Default value is NULL (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"reg_callid_avp\", \"$avp(s:avp)\")\n...\n        \n```\n",
   "xavp_cfg": "### `xavp_cfg` (string)\n\nDefines the name of XAVP class to store runtime module config values.\nThe values are stored as inner XAVPs, like $xavp(class=>attribute).\nValid inner XAVP names:\n\n- *match_callid* - filter contacts by callid. Used in registered().\n\n- *match_contact* - filter contacts by contact. Used in registered().\n\n- *match_received* - filter contacts by received. Used in registered().\n\n- *rlf_bflags* - filter contacts by branch flags. Used in lookup().\n\n- *q* - q value of contact (integer 0-1000). It overrides q value given\n  in contact header and default_q parameter. Used in save().\n\n- *expires* - the expires value, to overwrite the value from SIP\n  headers. Used in save().\n\n- *max_contacts* - the number of maximum contacts to be stored for the\n  current registration AoR. It overwrites the 'max_contacts' module\n  parameter value. Used in save().\n\n- *socket* - the string representing the socket on which the register\n  request was received, as alternative to using the sock_hdr. Used in\n  save().\n\n- *tcpconn_id* This can be set with $conid, the TCP connection ID of\n  the connection the current message. This is useful when calling save()\n  on a reply route to set the connecion of the original request. Used in\n  save().\n\nFor example if this parameter is set to 'reg', then the number of\nmaximum contacts can be set in $xavp(reg=>max_contacts).\n\n*Default value is NULL (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"xavp_cfg\", \"reg\")\n...\nrequest_route {\n    ...\n    $xavp(reg=>max_contacts) = 4;\n    $xavp(reg[0]=>expires) = 600;\n    save(\"location\");\n    ...\n}\n...\n        \n```\n",
   "xavp_rcd": "### `xavp_rcd` (string)\n\nDefines the name of XAVP class to store details from the location\nrecords. The values are stored as inner XAVPs, like\n$xavp(class[0]=>attribute). Valid inner XAVP names:\n\n- *ruid* - the record's internal unique id.\n\n- *contact* - the record's contact value.\n\n- *expires* - the record's expires value.\n\n- *received* - the record's received value.\n\n- *path* - the record's path value.\n\nFor example. if this parameter is set to 'ulrcd', then values are set\nin:\n\n- *$xavp(ulrcd[0]=>ruid)*\n\n- *$xavp(ulrcd[0]=>contact)*\n\n- *$xavp(ulrcd[0]=>received)*\n\n- *$xavp(ulrcd[0]=>path)*\n\n*Default value is NULL (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"xavp_rcd\", \"ulrcd\")\n...\n        \n```\n",
   "xavp_rcd_mask": "### `xavp_rcd_mask` (int)\n\nDefines what values to skip when xavp_rcd is stored.\n\n- 1 - *ruid*\n\n- 2 - *contact*\n\n- 4 - *expires*\n\n- 8 - *received*\n\n- 16 - *path*\n\n*Default value is 0 (none).*\n\n```\n...\n# skip path value\nmodparam(\"registrar\", \"xavp_rcd_mask\", 16)\n...\n# skip path and expires values\nmodparam(\"registrar\", \"xavp_rcd_mask\", 20)\n...\n        \n```\n",
   "gruu_enabled": "### `gruu_enabled` (integer)\n\nIf set to 1 and the \u201c+sip.instance\u201d parameter to Contact header of\nREGISTER is present, then the value of the parameter is saved to\nlocation and pub-gruu and temp-gruu addresses are generated.\n\nSet it to 0 if you want to ignore GRUU extensions in REGISTER.\n\n*Default value is 1 (enabled).*\n\n```\n...\nmodparam(\"registrar\", \"gruu_enabled\", 0)\n...\n        \n```\n",
   "outbound_mode": "### `outbound_mode` (integer)\n\nIf set to 0 this module will accept REGISTER requests that do not\ncontain a \u201cSupported:\u201d header with the outbound options-tag. The 200 OK\nresponse to REGISTER requests that this module generates will not\ncontain \u201cRequire:\u201d or \u201cSupported:\u201d headers with the outbound\noptions-tag. If the client has a \u201cRequire:\u201d header with the outbound\noptions tag the REGISTER will be rejected with a \u201c420 Bad Extension\u201d\nresponse.\n\nIf set to 1 this module will accept REGISTER requests that do not\ncontain a \u201cSupported:\u201d header with the outbound options-tag and REGISTER\nrequests that do contain a Supported: or Requires: header with the\noutbound options-tag. When the client supports *outbound* the\nappropriate RFC5626 procedures will be followed.\n\nIf set to 2 this module will reject REGISTER requests that do not\ncontain a \u201cSupported:\u201d header with the outbound options-tag. When the\nclient supports outbound the appropriate RFC5626 procedures will be\nfollowed.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"outbound_mode\", 2)\n...\n        \n```\n",
   "regid_mode": "### `regid_mode` (integer)\n\nIf set to 0 this module will ignore the \u201cregid\u201d contact param when\nsaving REGISTER request if the request does not indicate support for\noutbound.\n\nIf set to 1 this module will use \u201cregid\u201d contact param (if present) when\nsaving REGISTER request even if REGISTER request does not indicate\nsupport for outbound.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"regid_mode\", 1)\n...\n        \n```\n",
   "flow_timer": "### `flow_timer` (integer)\n\nIf set to 0 then this module will not add a \u201cFlow-Timer:\u201d header to 200\nOK responses to REGISTER requests.\n\nIf set to > 0 then this module will add a \u201cFlow-Timer:\u201d header\ncontaining this value to 200 OK responses to REGISTER requests. This\nparameter may only be set to a value > 0 when *outbound_mode* is set to\n1 or 2.\n\nWhen set to a value greater than 0 this parameter should be set to\nslightly less than the connection timeout value between the UAC and the\nnetwork (this corresponds to the core *tcp_connection_lifetime* option\nand *websocket* *keepalive_timeout* modparam). This parameter is most\nuseful when you have a single edge proxy/registrar or if you have an\nedge proxy that cannot modify responses. If you are using a separate\nedge proxy you should consider leaving this parameter set to 0 and\nadding the \u201cFlow-Timer:\u201d header on the edge proxy as this allows you to\nkeep all of the timer values for a specific flow in one configuration.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"registrar\", \"flow_timer\", 25)\n...\n        \n```\n",
   "contact_max_size": "### `contact_max_size` (integer)\n\nMax size of URIs in \u201cContact:\u201d header.\n\nThe size of URIs in \u201cContact:\u201d headers are checked to be lower or equal\nto this value. A warning is logged and a 400 Bad Request is sent in\nresponse to REGISTER requests with contact URIs that are longer than\nthis value.\n\nIf a database is used then you must make sure that your database model\nsupports strings of the configured size in the column \u201ccontact\u201d of the\ntable specified in \u201csave()\u201d function.\n\n*Default value is 512.*\n\n```\n...\nmodparam(\"registrar\", \"contact_max_size\", 1024)\n...\n        \n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the KEMI configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event. The\nonly possible value currently is 'usrloc:contact-expired'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"registrar\", \"event_callback\", \"ksr_registrar_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_registrar_event(evname)\n    KSR.info( \"Expired contact for \" .. KSR.pv.getw(\"$ulc(exp=>aor)\") .. \"\\n\");\n    return 1;\nend\n...\n        \n```\n",
   "lookup_filter_mode": "### `lookup_filter_mode` (int)\n\nControl what filters should be applied to lookup(...) operations. It can\nbe a combination (sum) of the next values:\n\n- *1* - apply the branch flags filter - return only contact records with\n  branch flags matching at least one set inside xavp specified by\n  xavp_cfg parameter with inner name rlf_bflags - e.g.,\n  $xavp(reg=>rlf_bflags).\n\n- *2* - apply the active tcp connection filter - return only contact\n  records that have the associated TCP/TLS/WSS connection active. UDP\n  and SCTP contacts are not filtered, all are returned.\n\n*Default value is NULL (disabled).*\n\n```\n...\nmodparam(\"registrar\", \"xavp_cfg\", \"reg\")\nmodparam(\"registrar\", \"lookup_filter_mode\", 1)\n...\nrequest_route {\n    ...\n    $xavp(reg=>rlf_bflags) = 8;\n    if(lookup(\"location\")) { ... }\n    ...\n}\n...\n        \n```\n",
   "use_expired_contacts": "### `use_expired_contacts` (int)\n\nAllow/Disallow the usage of the expired contacts.\n\n- *0* Disallow the usage of the expired contacts.\n\n- *1* Allow the usage of the expired contacts.\n\n*Default value is 0 (Disallow).*\n\n```\n...\nmodparam(\"registrar\", \"use_expired_contacts\", 1)\n...\n\nkamcmd cfg.set_now_int registrar use_expired_contacts 1\nkamcmd cfg.set_now_int registrar use_expired_contacts 0\n        \n```\n"
  },
  "functions": {
   "save": "### `save(domain, [, flags [, uri]])`\n\nThe function processes a *REGISTER* message. It can add, remove or\nmodify location records (in usrloc) depending on Contact and Expires\nheader fields in the REGISTER message. On success and when called from\nthe REQUEST_ROUTE, \u201c200 OK\u201d will be returned listing all contacts that\nare currently in the location database. As a side effect, also branch\nflags are stored in usrloc. On an error, an error message will be sent\nwith a short description in reason phrase.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Logical domain within the registrar. If a database is used\n  then this must be name of the table which stores the contacts.\n\n- *flags* (optional) - the value may be a bitwise OR of the following\n  flags:\n\n  - *0x01* - save the contacts only in memory cache with no DB\n    operation;\n\n  - *0x02* - do not generate a SIP reply to the current REGISTER\n    request. When used in ONREPLY_ROUTE, this parameter is obsolete.\n\n  - *0x04* - store and maintain one contact per AoR. If there are other\n    contact addresses for AoR not matching current registration, remove\n    them. This mode ensures one contact per AoR (user).\n\n  - *0x08* - Do not apply *expires_range* or *default_expires_range* to\n    this registration.\n\n  - *0x10* - prepare the headers for reply, used only if flag 0x02 is\n    set.\n\n\n  The flags may be given in decimal or hexadecimal format.\n\n- *uri* (optional - flags param has to be set and can be 0 for default\n  behavior) - SIP URI to be used instead of To header URI. It can be a\n  dynamic string with pseudo-variables.\n\nReturn codes:\n\n- *-2* - error, too many contacts for AOR.\n\n- *-1* - error.\n\n- *1* - contacts inserted.\n\n- *2* - contacts updated.\n\n- *3* - contacts deleted.\n\n- *4* - contacts returned.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE and\nREPLY_ROUTE.\n\n```\n...\nsave(\"location\");\nsave(\"location\", \"0x01\");\nsave(\"location\", \"0x00\", \"sip:test@kamailio.org\");\n...\n```\n",
   "lookup": "### `lookup(domain [, uri])`\n\nThe lookup function extracts username and/or domain from Request-URI and\ntries to find all contacts for the username in usrloc. If there are no\nsuch contacts, -1 will be returned. If there are such contacts,\nRequest-URI will be overwritten with the contact that has the highest q\nvalue and optionally the rest will be appended to the message (depending\non append_branches parameter value). As a side effect, also branch flags\nare restored from usrloc.\n\nIf the `method_filtering` option is enabled and request is initial\nrequest without to-tag, the `lookup` function will return only the\ncontacts that support the method of the processed request.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup.\n\n- *uri* (optional) - SIP URI to be used instead of R-URI. It can be a\n  dynamic string with pseudo-variables.\n\nReturn codes:\n\n- *1* - contacts found and returned.\n\n- *-1* - no contact found.\n\n- *-2* - contacts found, but method not supported.\n\n- *-3* - internal error during processing.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nlookup(\"location\");\n            switch ($retcode) {:1\n\n    case -1:\n    case -3:\n        sl_send_reply(\"404\", \"Not Found\");\n        exit;\n    case -2:\n        sl_send_reply(\"405\", \"Not Found\");\n        exit;\n};\n...\n```\n",
   "lookup_to_dset": "### `lookup_to_dset(domain [, uri])`\n\nSimilar to lookup(...), but push the location contacts to destination\nset, without changing the R-URI (first branch not changed, it creates\nadditional branches). For the meaning of the parameters and the return\ncodes, see the documentation for lookup(...) function.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nlookup_to_dset(\"location\");\n...\n```\n",
   "lookup_branches": "### `lookup_branches(domain)`\n\nThe function performs lookup(domain) on r-uri and additional branches\n(only branches that have no other attributes set than uri).\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup.\n\nReturn codes are propagated from the `lookup(domain)` function.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nlookup_branches(\"location\");\n...\n```\n",
   "lookup_xavp": "### `lookup_xavp(ultable, uri, rxname, cxname)`\n\nSimilar to lookup(...), but store the location record attributes in\nXAVPs. Note that not all contact record fields are stored\n\nMeaning of the parameters:\n\n- *ultable* - name of the usrloc table that is used for the lookup.\n\n- *uri* - the URI to be searched in location table.\n\n- *rxname* - name of the XAVP to store record attributes. These are:\n\n  - *aor* - the address of record.\n\n- *cxname* - name of the XAVP to store content attributes, name mapping\n  is done from the perspective of using them to send out SIP requests.\n  These are:\n\n  - *uri* - the contact address.\n\n  - *socket* - the socket of the contact record.\n\n  - *dsturi* - the destination uri of the contact record (the received\n    field in location contact).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nlookup_xavp(\"location\", \"$fu\", \"rul\", \"cul\");\nxinfo(\"aor: $xavp(rul=>aor)\\n\");\nxinfo(\"number of contacts: $xavp(rul>count)\\n\");\nxinfo(\"first contact record - uri: $xavp(cul>uri)\\n\");\nxinfo(\"first contact record - socket: $xavp(cul>socket)\\n\");\n...\n```\n",
   "registered": "### `registered(domain [, uri [, match_option [, match_action]]])`\n\nThe function returns true if the AOR in the URI is registered, false\notherwise. The function does not modify the message being processed, it\nneither rewrites the Request-URI if a contact is found nor append\nbranches. If uri parameter is not provided, then it considered to be the\nRequest-URI for SIP requests and To-URI for SIP replies.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup.\n\n- *uri* (optional) - SIP URI to be used instead of Request/To-URI. It\n  can be a dynamic string with pseudo-variables.\n\n- *match_option* (optional) - flag parameter to restrict contact search.\n  use xavp_cfg to set the values to compare to.\n\n  flag values is as follows:\n\n  - 1 - match_callid\n\n  - 2 - match_received\n\n  - 4 - match_contact\n\n\n- *match_action* (optional) - actions to perform when match is positive.\n\n  flag values is as follows:\n\n  - 1 - restore the xavps associated with the matched contact\n\n  - 2 - skip adding the matched location record attributes to xavp_rcd\n    (e.g., the ruid, contact, received, ...)\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (registered(\"location\")) {\n    sl_send_reply(\"100\", \"Trying\");\n    ...\n};\n...\n$xavp(regcfg=>match_received) = $su;\nif (registered(\"location\",\"$rz:$Au\", 2)) {\n    sl_send_reply(\"100\", \"Trying\");\n    ...\n};\n...\n```\n",
   "add_sock_hdr": "### `add_sock_hdr(hdr_name)`\n\nAdds a new header to the current REGISTER request with \u201chdr_name\u201d which\ncontains the description of the received socket (proto:ip:port)\n\nThis makes sense only in multiple replicated servers scenarios.\n\nMeaning of the parameters is as follows:\n\n- *hdr_name* - header name to be used, it can be a static string or\n  contain variables.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nadd_sock_hdr(\"Sock-Info\");\n...\n```\n",
   "unregister": "### `unregister(domain, uri[, ruid])`\n\nThe function removes contacts associated with 'uri' from the location\ndatabase. If 'ruid' is provided a specific contact is removed, if 'ruid'\nis not provided all the current contacts are removed. If 'ruid' is\nprovided and the \u201cusrloc\u201d module is using \u201cdb_mode=3\u201d, 'uri' does not\nneed to be given and can be empty string.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup or contact\n  addresses.\n\n- *uri* - The SIP URI address of the user which to remove the contact\n  addresses for. It can contain pseudo-variables that are evaluated at\n  runtime.\n\n- *ruid* - The record unique ID for a specific contact to be removed. It\n  can contain pseudo-variables that are evaluated at runtime.\n\nThis function can be used from ANY_ROUTE.\n\nReturn values:\n\n- *0* - Successfully deleted contact(s)\n\n- *-1* - Failed to extract or parse address of record from argument\n\n- *-2* - Error in unregistering user\n\n- *-3* - Contacts for AOR not found\n\n<!-- -->\n\n\n```\n...\nunregister(\"location\", \"$ru\");\nunregister(\"location\", \"sip:user@kamailio.org\");\nunregister(\"location\", \"$ru\", \"$ulc(caller=>ruid)\");\nunregister(\"location\", \"\", \"$ruid\");\n...\n```\n",
   "reg_fetch_contacts": "### `reg_fetch_contacts(domain, uri, profile)`\n\nThe function fetches the contacts for 'uri' from table 'domain' to\npseudo-variable $ulc(profile).\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for the lookup of contact\n  addresses.\n\n- *uri* - The SIP URI address of the user which to fetch the contact\n  addresses for. It can contain pseudo-variables that are evaluated at\n  runtime.\n\n- *profile* - Name of $ulc pseudo-variable profile that will store the\n  fetched contacts. It is a static string.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nreg_fetch_contacts(\"location\", \"$ru\", \"callee\");\nreg_fetch_contacts(\"location\", \"sip:user@kamailio.org\", \"caller\");\n...\n```\n",
   "reg_free_contacts": "### `reg_free_contacts(profile)`\n\nThe function frees the contacts from pseudo-variable $ulc(profile).\nShould be called to release the content of a profile. Anyhow, fetching a\nnew contact addresses set over a profile will release any existing data\nin that profile.\n\nMeaning of the parameters is as follows:\n\n- *profile* - Name of $ulc pseudo-variable profile that stores fetched\n  contacts. It is a static string.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nreg_free_contacts(\"callee\");\n...\n```\n",
   "reg_send_reply": "### `reg_send_reply()`\n\nThe function sends the SIP reply that is normally sent by save(...), but\nthat was skipped due to flag 0x2. It must be used after save(...,\n\"0x2\"). Practically it allows saving registration to location table, do\nother operations and then send the reply.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nsave(\"location\", \"0x2\");\n...\nreg_send_reply();\n...\n```\n",
   "reg_from_user": "### `reg_from_user(ultable, uri, mode)`\n\nThe function returns true if the SIP message comes from the user\nidentified by 'uri' parameter by matching the associated location\nrecords. The matching is done with the field 'received' if it is set,\notherwise with the contact address.\n\nMeaning of the parameters is as follows:\n\n- *ultable* - user location table (e.g., 'location')\n\n- *uri* - SIP URI to identify the location records to match against.\n\n- *mode* - matching mode (int) - host part (IP address) is matched\n  always. If mode has bit 1 set (value 1), then the port is matched as\n  well. If mode has bit 2 set (value 2), then the protocol is matched as\n  well.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(reg_from_user(\"location\", \"sip:alice@server.com\", \"0\")) {\n    # message coming from where 'alice' sent before a REGISTER request\n}\n...\n```\n"
  }
 },
 "rls": {
  "overview": "The module is a Resource List Server implementation following the\nspecification in RFC 4662 and RFC 4826.\n\nThe server is independent from local presence servers, retrieving\npresence information with Subscribe-Notify messages.\n\nThe module uses the presence module as a library, as it requires a\nresembling mechanism for handling Subscribe. Therefore, in case the\nlocal presence server is not collocated on the same machine with the RL\nserver, the presence module should be loaded in a library mode only (see\ndoc for presence module).\n\nIt handles subscription to lists in an event independent way. The\ndefault event is presence, but if some other events are to be handled by\nthe server, they should be added using the module parameter\n\"rls_events\".\n\nIt works with XCAP server for storage. There is also the possibility to\nconfigure it to work in an integrated_xcap server mode, when it only\nqueries database for the resource lists documents. This is useful in a\nsmall architecture when all the clients use an integrated server and\nthere are no references to exterior documents in their lists.\n\nThe same as presence module, it has a caching mode with periodical\nupdate in database for subscribe information. The information retrieved\nwith Notify messages is stored in database only.\n",
  "parameters": {
   "db_url": "### `db_url`(str)\n\nThe database url.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"rls\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "rlpres_db_url": "### `rlpres_db_url`(str)\n\nThe rlpres (rls_presentity table) database url. This parameter only\nneeds to be specified if the rls_watchers table and rls_presentity\ntables are in different databases. rls_presentity is used to cache the\nbodies of back-end NOTIFY requests until an RLS NOTIFY can be sent. On a\nmulti-server system having a single cache for all active servers can\ncause issues if both servers try to send RLS NOTIFY requests at the same\ntime. This parameter enables each server to have its own (possibly\nlocal) rls_presentity table.\n\n*Default value is a mirror of the \u201cdb_url\u201d setting.*\n\n```\n...\nmodparam(\"rls\", \"rlpres_db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "xcap_db_url": "### `xcap_db_url`(str)\n\nThe xcap database url. This parameter only needs to be specified if the\nrls db and integrated xcap server db have different urls.\n\n*Default value is a mirror of the \u201cdb_url\u201d setting.*\n\n```\n...\nmodparam(\"rls\", \"xcap_db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_mode": "### `db_mode`(int)\n\nThe module supports 2 modes of operation, high speed memory based\nstorage (mode 0), and database only (mode 2) where all data is stored in\na database, allowing scalability at the expense of speed. Mode 1 is\nreserved.\n\n*Default value is \u201c0\u201d*\n\n```\n...\nmodparam(\"rls\", \"db_mode\", 2)\n...\n```\n",
   "xcap_table": "### `xcap_table`(str)\n\nThe name of the xcap table in which the integrated server or the\nxcap_client module writes. If integrated_xcap_server parameter not set,\nthe name of the table must be the same as the one set for the\nxcap_client module.\n\n*Default value is \u201cxcap\u201d.*\n\n```\n...\nmodparam(\"rls\", \"xcap_table\", \"xcaps\");\n...\n```\n",
   "rlsubs_table": "### `rlsubs_table`(str)\n\nThe name of the db table where resource lists subscription information\nis stored.\n\n*Default value is \u201crls_watchers\u201d.*\n\n```\n...\nmodparam(\"rls\", \"rlsubs_table\", \"rls_subscriptions\")\n...\n```\n",
   "rlpres_table": "### `rlpres_table`(str)\n\nThe name of the db table where notified event specific information is\nstored.\n\n*Default value is \u201crls_presentity\u201d.*\n\n```\n...\nmodparam(\"rls\", \"rlpres_table\", \"rls_notify\")\n...\n```\n",
   "clean_period": "### `clean_period` (int)\n\nThe period at which to check for expired information. 0 means do not\ncheck.\n\n*Default value is \u201c100\u201d.*\n\n```\n...\nmodparam(\"rls\", \"clean_period\", 100)\n...\n```\n",
   "rlpres_clean_period": "### `rlpres_clean_period` (int)\n\nThe period at which to check for expired rls_presentity information. -1\nmeans do not use (clean_period) is used instead. 0 means do not check.\nThis option can be used when you want to check rls_presentity and\nrls_watchers on different timeouts. This is useful when they are in\ndifferent databases.\n\n*Default value is \u201c-1\u201d.*\n\n```\n...\nmodparam(\"rls\", \"rlpres_clean_period\", 100)\n...\n```\n",
   "waitn_time": "### `waitn_time` (int)\n\nThe maximum time period that RLS NOTIFY requests will be buffered for.\nThe server will attempt to send NOTIFY requests with the updated\npresence state of the subscribed list or watcher information within this\nmany seconds of a change occurring.\n\n*Default value is \u201c5\u201d.*\n\n```\n...\nmodparam(\"rls\", \"waitn_time\", 10)\n...\n```\n",
   "notifier_poll_rate": "### `notifier_poll_rate` (int)\n\nThe number of times per second that the notifier processes should check\nfor work. Approximately 1/(waitn_time * notifier_poll_rate *\nnotifier_processes) of the pending updates will be sent each time a\nnotifier process runs.\n\nSeparate notifier processes are only run when db_mode is 2 (DB only\nmode).\n\n*Default value is \u201c10\u201d.*\n\n```\n...\nmodparam(\"rls\", \"notifier_poll_rate\", 20)\n...\n```\n",
   "notifier_processes": "### `notifier_processes` (int)\n\nThe number of notifier processes that should be started.\n\nSeparate notifier processes are only run when db_mode is 2 (DB only\nmode).\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"rls\", \"notifier_processes\", 2)\n...\n```\n",
   "max_expires": "### `max_expires` (int)\n\nThe maximum accepted expires for a subscription to a list.\n\n*Default value is \u201c7200\u201d.*\n\n```\n...\nmodparam(\"rls\", \"max_expires\", 10800)\n...\n        \n```\n",
   "expires_offset": "### `expires_offset` (int)\n\nThis parameter only has an effect when the db_mode is DB_ONLY (mode 2).\nWhen expired subscribers are checked for deletion from the database,\nthose that have a value in the expires column which is less than\ncurrent_time - expires_offset are matched. Hence when an offset of zero\nis used, all those that expire prior the current time will be deleted.\nIf an offset of 't' is used, only those that expired more than t seconds\nago are deleted from the database. Negative offsets are treated as\nthough an offset of zero was specified.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"rls\", \"expires_offset\", 0)\n...\n        \n```\n",
   "hash_size": "### `hash_size` (int)\n\nThe dimension of the hash table used to store subscription to a list.\nThis parameter will be used as the power of 2 when computing table size.\n\n*Default value is \u201c9 (512)\u201d.*\n\n```\n...\nmodparam(\"rls\", \"hash_size\", 11)\n...\n        \n```\n",
   "xcap_root": "### `xcap_root` (str)\n\nThe address of the xcap server.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"rls\", \"xcap_root\", \"http://192.168.2.132/xcap-root:800\")\n...\n        \n```\n",
   "integrated_xcap_server": "### `integrated_xcap_server` (int)\n\nThis parameter should be set if only integrated xcap servers are used to\nstore resource lists.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"rls\", \"integrated_xcap_server\", 1)\n...\n        \n```\n",
   "to_presence_code": "### `to_presence_code` (int)\n\nThe code to be returned by rls_handle_subscribe function if the\nprocessed Subscribe is not a resource list Subscribe. This code can be\nused in an architecture with presence and rls servers collocated on the\nsame machine, to call handle_subscribe on the message causing this code.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"rls\", \"to_presence_code\", 10)\n...\n        \n```\n",
   "rls_event": "### `rls_event` (str)\n\nThe default event that RLS handles is presence. If some other events\nshould also be handled by RLS they should be added using this parameter.\nIt can be set more than once.\n\n*Default value is \u201c\"presence\"\u201d.*\n\n```\n...\nmodparam(\"rls\", \"rls_event\", \"dialog;sla\")\n...\n        \n```\n",
   "outbound_proxy": "### `outbound_proxy` (str)\n\nThe SIP address where to send RLS subscriptions (outbound proxy address\nas SIP URI).\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"rls\", \"outbound_proxy\", \"sip:presence.kamailio.org\")\n...\n        \n```\n",
   "server_address": "### `server_address` (str)\n\nThe address of the server that will be used as a contact in sent\nSubscribe requests and 200 OK replies for Subscribe requests for RLS. It\nis a mandatory parameter.\n\n```\n...\nmodparam(\"rls\", \"server_address\", \"sip:rls@ip.address.ofyour.proxy:5060\")\n...\n        \n```\n",
   "max_notify_body_length": "### `max_notify_body_length` (int)\n\nThe maximum size that the body of a NOTIFY message may be. If set to 0\n(the default), no size limit is applied. Note that this refers only to\nthe body, not the complete NOTIFY message.\n\n```\n...\nmodparam(\"rls\", \"max_notify_body_length\", 32000)\n...\n        \n```\n",
   "reload_db_subs": "### `reload_db_subs` (integer)\n\nReload subscriptions on module initialization (requires db_mode 0\n(memory only mode)).\n\n*Default value is 0 (do not load rows from db).*\n\n```\n...\nmodparam(\"rls\", \"reload_db_subs\", 1)\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (integer)\n\nNumber of rows to be loaded in one step from database.\n\n*Default value is 500.*\n\n```\n...\nmodparam(\"rls\", \"fetch_rows\", 1000)\n...\n```\n",
   "disable_remote_presence": "### `disable_remote_presence` (integer)\n\nWhen set to a non-zero value RLS will not perform back-end SUBSCRIBEs to\nnon-local presentities. When people have large contact lists RLS will\nmake lots of back-end subscriptions for each local subscriber. This can\nbe a lot of traffic, and if the contact lists contain non-local (as in\nnot on this Kamailio server or cluster) contacts this can result in a\nlot of Internet traffic. Setting this option to a non-zero value\nprevents RLS from performing back-end SUBSCRIBEs for remote\npresentities.\n\n*Default value is 0*\n\n```\n...\nmodparam(\"rls\", \"disable_remote_presence\", 1)\n...\n```\n",
   "max_backend_subs": "### `max_backend_subs` (integer)\n\nWhen set to a non-zero value RLS will limit the number of back-end\nSUBSCRIBEs for each RLS SUBSCRIBE to this value. Leaving this at the\ndefault of zero means no limit. When people have large contact lists RLS\nwill make lots of back-end subscriptions. This can easily overload a\nsystem. This option allows you to limit the number of back-end\nSUBSCRIBEs to help prevent overload.\n\n*Default value is 0*\n\n```\n...\nmodparam(\"rls\", \"max_backend_subs\", 30)\n...\n```\n"
  },
  "functions": {
   "rls_handle_subscribe": "### `rls_handle_subscribe([watcher_uri])`\n\nThis function detects if a Subscribe message should be handled by RLS.\nIf not it replies with the configured to_presence_code. If it is, it\nextracts the dialog info and sends aggregate Notify requests with\ninformation for the list.\n\nBy default this function uses the From: URI from the SUBSCRIBE request\nas the Watcher URI. The optional watcher_uri parameter can be used to\nspecify a different Watcher URI, possibly taken from a SIP header like\nP-Asserted-Identity:.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nFor presence and rls on the same machine:\n    modparam(\"rls\", \"to_presence_code\", 10)\n\n    if(is_method(\"SUBSCRIBE\"))\n    {\n        $var(ret_code)= rls_handle_subscribe();\n\n        if($var(ret_code)== 10)\n                handle_subscribe();\n\n        t_release();\n    }\n\nFor rls only:\n    if(is_method(\"SUBSCRIBE\"))\n    {\n        rls_handle_subscribe();\n        t_release();\n    }\n\n...\n```\n",
   "rls_handle_notify": "### `rls_handle_notify()`\n\nHandle NOTIFY requests.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif(method==\"NOTIFY\")\n    rls_handle_notify();\n...\n```\n",
   "rls_update_subs": "### `rls_update_subs(uri, event)`\n\nThis function can be used in configuration to trigger updates to\nresource list subscriptions (for example, after the contents of a\nresource list has changes).\n\nParameters:\n\n- uri - the uri of the user who made the change and whose resource list\n  subscriptions should be updated\n\n- event - the event package (e.g. presence).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nWithin event_route[xhttp:request]:\n    case \"PUT\":\n        xcaps_put(\"$var(uri)\", \"$var(doc_uri)\", \"$rb\");\n        if($xcapuri(u=>auid)=~\"pres-rules\") {\n            pres_update_watchers(\"$var(uri)\", \"presence\");\n            pres_refresh_watchers(\"$var(uri)\", \"presence\", 1);\n        } else if ($xcapuri(u=>auid)=~\"resource-lists\"\n               || $xcapuri(u=>auid)=~\"rls-services\") {\n            rls_update_subs(\"$var(uri)\", \"presence\");\n        }\n        exit;\n        break;\n...\n```\n"
  }
 },
 "rr": {
  "overview": "The module contains record routing logic.\n",
  "parameters": {
   "enable_full_lr": "### `enable_full_lr` (integer)\n\nIf set to 1 then \u201c;lr=on\u201d instead of just \u201c;lr\u201d will be used. This is to\novercome problems with broken UAs which strip \u201c;lr\u201d parameter when\ngenerating Route header fields from Record-Route (\u201c;lr=on\u201d seems to\nhelp).\n\n*Default value is 0 (no).*\n\n```\n...\nmodparam(\"rr\", \"enable_full_lr\", 1)\n...\n```\n",
   "append_fromtag": "### `append_fromtag` (integer)\n\nIf turned on, request's from-tag is appended to record-route; that's\nuseful for understanding whether subsequent requests (such as BYE) come\nfrom caller (route's from-tag==BYE's from-tag) or callee (route's\nfrom-tag==BYE's to-tag)\n\n*Default value is 1 (yes).*\n\n```\n...\nmodparam(\"rr\", \"append_fromtag\", 0)\n...\n```\n",
   "enable_double_rr": "### `enable_double_rr` (integer)\n\nThere are some situations when the server needs to insert two\nRecord-Route header fields instead of one. For example when using two\ndisconnected networks or doing cross-protocol forwarding from UDP->TCP.\nThis parameter enables inserting of 2 Record-Routes. The server will\nlater remove both of them.\n\nDouble record-routing does not occur when outbound is used for a\nrequest.\n\n*Default value is 1 (yes).*\n\n```\n...\nmodparam(\"rr\", \"enable_double_rr\", 0)\n...\n```\n\nSome useragents (e. g. Linphone) incorrectly use UDP transport for\nsubsequent requests in dialog, despite being configured to use another\nSIP transport protocol. This can be worked around by setting\nRecord-Route header with explicit transport attribute. But\nenable_double_rr enabled in default mode omits transport attribute from\nbeing added to header if it detects that both sender and receiver use\nsame protocol (e. g. TCP or TLS), and this results in UDP being used by\nsuch broken clients. Set enable_double_rr to value 2 to always have two\nRR headers with transport attributes explicitly set.\n\n```\n...\nmodparam(\"rr\", \"enable_double_rr\", 2)\n...\n```\n",
   "add_username": "### `add_username` (integer)\n\nIf set to a non 0 value (which means yes), the username part will be\nalso added in the Record-Route URI.\n\nThis option cannot be set when the \u201coutbound\u201d module is loaded before\nthis module as outbound uses the username part of Record-Route URIs to\nstore flow-tokens.\n\n*Default value is 0 (no).*\n\n```\n...\nmodparam(\"rr\", \"add_username\", 1)\n...\n```\n",
   "enable_socket_mismatch_warning": "### `enable_socket_mismatch_warning` (integer)\n\nWhen a preset record-route header is forced in Kamailio config and the\nhost from the record-route header is not the same as the host server, a\nwarning will be printed out in the logs. The\n'enable_socket_mismatch_warning' parameter enables or disables the\nwarning. When Kamailio is behind a NATed firewall, we don't want this\nwarning to be printed for every bridged call.\n\n*Default value is 1 (yes).*\n\n```\n...\nmodparam(\"rr\", \"enable_socket_mismatch_warning\", 0)\n...\n```\n",
   "custom_user_avp": "### `custom_user_avp` (avp string)\n\nWhen add_username is enabled, a call to record_route will add the\nusername of the RequestURI to the Record-Route URI. This parameter\nallows you to setup an AVP with which you can customise the username to\nbe added in the Record-Route URI.\n\n*Default value: if not set, the std add_username behaviour is used -\ni.e. Request URI username.*\n\n```\n...\nmodparam(\"rr\", \"custom_user_avp\", \"$avp(RR_CUSTOMER_USER_AVP)\")\n\n#usage in cfg file\n$avp(RR_CUSTOM_USER_AVP)=\"mo\";\nrecord_route();\n...\n```\n",
   "force_send_socket": "### `force_send_socket` (int)\n\nIf set to 1, local socket is forced even for single Record-Route,\notherwise is done on double Record-Route (should that be enabled).\n\nWhen use of \u201coutbound\u201d is enabled, the socket is not forced.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"rr\", \"force_send_socket\", 1)\n...\n```\n",
   "ignore_sips": "### `ignore_sips` (int)\n\nIf set to 1, the Record-Route header are build with 'sip' schema always,\nignoring the presence of 'sips' schema in request URI.\n\n*Default value is 0 (use 'sips' if present in R-URI).*\n\n```\n...\nmodparam(\"rr\", \"ignore_sips\", 1)\n...\n```\n",
   "sockname_mode": "### `sockname_mode` (int)\n\nIf set to 1, the Record-Route URI is built to contain socket name in\n'sn' parameter and then it is used to lookup the local socket for Route\nheader processing.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"rr\", \"sockname_mode\", 1)\n...\n```\n"
  },
  "functions": {
   "loose_route": "### `loose_route()`\n\nThe function performs routing of SIP requests which contain a route set.\nThe name is a little bit confusing, as this function also routes\nrequests which are in the \u201cstrict router\u201d format.\n\nThis function is usually used to route in-dialog requests (like ACK,\nBYE, reINVITE). Nevertheless also out-of-dialog requests can have a\n\u201cpre-loaded route set\u201d and my be routed with loose_route. It also takes\ncare of translating between strict-routers and loose-router.\n\nThe loose_route function analyzes the Route: headers in the requests. If\nthere is no Route: header, the function returns FALSE and routing should\nbe done with normal lookup functions. If a Route: header is found, the\nfunction returns 1 and behaves as described in section 16.12 of RFC\n3261. There is only one exception: If the request is out-of-dialog (no\nto-tag) and there is only one Route: header indicating the local proxy,\nthen the Route: header is removed and the function returns FALSE.\n\nWhen the \u201coutbound\u201d module was loaded before this module and the Route:\nheader contains a username part this function will attempt to use the\nusername part as a flow-token for routing. If route calculation based on\nflow-token succeeds, function returns TRUE even if there is only one\nRoute: header indicating the local proxy.\n\nMake sure your loose_routing function can't be used by attackers to\nbypass proxy authorization.\n\nThe loose_routing topic is very complex. See the RFC3261 for more\ndetails (grep for \u201croute set\u201d is a good starting point in this\ncomprehensive RFC).\n\nReturn codes:\n\n- *1* - route calculation has been successful\n\n- *2* - route calculation based on flow-token has been successful\n\n- *-1* - route calculation has been unsuccessful\n\n- *-2* - outbound flow-token shows evidence of tampering\n\n- *-3* - next hop is taken from a preloaded route set\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nloose_route();\n...\n```\n",
   "loose_route_preloaded": "### `loose_route_preloaded()`\n\nThe function is similar to `loose_route()`, but it returns 1 (true)\nwhen the Route header is preloaded (is in an initial request) and -1\n(false) if processing of the Route header failed or it is for requests\nwithin dialog.\n\nIt is a convenient function to use for routing initial requests on an\nedge proxy that adds Path header to REGISTER requests.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif(!loose_route_preloaded()) {\n   sl_send_reply(\"404\" \"Preloaded route expected\");\n   exit;\n}\n...\n```\n",
   "loose_route_mode": "### `loose_route_mode(vmode)`\n\nThe function is similar to `loose_route()`, but it does only loose\nrouting processing if vmode==1, skipping the testing of r-uri==myself\nfor performing strict routing. If vmode==0, it behaves like\nloose_route().\n\nIt is a convenient function to use with application servers that set the\nContact URI to SIP server address.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif(has_totag() and uri==myself) {\n    if(loose_route_mode(\"1\")) {\n        rewritehostport(\"my.app.server:5090\");\n        t_relay();\n        exit;\n    }\n}\n...\n```\n",
   "record_route": "### `record_route([sparams])`\n\nThe function adds a new Record-Route header field. The header field will\nbe inserted in the message before any other Record-Route header fields.\n\nIf any string is passed as parameter, it will be appended as URI\nparameter to the Record-Route header. The string must follow the\n\u201c;name=value\u201d scheme and it may contain pseudo-variables.\n\nWhen the \u201coutbound\u201d module was loaded before this module this function\nwill determine whether outbound is required for the request and generate\nand add a flow-token as the username part of the Record-Route-URI.\n\nNote: if append From-tag is enabled and the function is used for\nrequests within dialog, it must be executed after loose_route() in order\nto detect properly the direction.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\nrecord_route();\n...\n```\n",
   "remove_record_route": "### `remove_record_route()`\n\nThe function removes the internal lumps added by record_route()\nfunctions.\n\nCan be used to revert adding Record-Route header(s).\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nremove_record_route();\n...\n```\n",
   "record_route_preset": "### `record_route_preset(string [,string2])`\n\nThis function will put the string params into Record-Route, avoid to use\nit unless you know what you are doing.\n\nMeaning of the parameters is as follows:\n\n- *string* - String to be inserted into the first header field; it may\n  contain pseudo-variables.\n\n- *string2* - String to be inserted into the second header field; it may\n  contain pseudo-variables.\n\nNote: If 'string2' is present, then the 'string' param is pointing to\nthe outbound interface and the 'string2' param is pointing to the\ninbound interface.\n\nNote: The value of parameters must not contain the SIP protocol scheme\n(sip: or sips:), one is added based on routing requirements. Thus the\nvalue has to be like \"address:port;parameters\", the port and parameters\nare optional. If the second parameter is provided, do not forget to add\nthe parameter \"r2=on\" so the proxy processes both corresponding Route\nheaders at once.\n\nWhen the \u201coutbound\u201d module was loaded before this module this function\nwill determine whether outbound is required for the request and generate\nand add a flow-token as the username part of the Record-Route-URI.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\nrecord_route_preset(\"1.2.3.4:5090\");\n...\n```\n",
   "record_route_advertised_address": "### `record_route_advertised_address(address)`\n\nThe function adds a new Record-Route header field using the address\ngiven. The header field will be inserted in the message before any other\nRecord-Route header fields.\n\nWhen the \u201coutbound\u201d module was loaded before this module this function\nwill determine whether outbound is required for the request and generate\nand add a flow-token as the username part of the Record-Route-URI.\n\nMeaning of the parameter is as follows:\n\n- *address* - Advertised address to use in the header; it may contain\n  pseudo-variables.\n\nIf double record-routing is enabled two Record-Route headers will be\ninserted with the same given address with different transports if the\ntransport changes.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\nrecord_route_advertised_address(\"1.2.3.4:5080\");\n...\n```\n",
   "add_rr_param": "### `add_rr_param(param)`\n\nAdds a parameter to the Record-Route URI (param must be in \u201c;name=value\u201d\nformat. The function may be called also before or after the\nrecord_route(), record_route_advertised_address(), and\nrecord_route_preset() calls (see [](#rr.f.record_route) or\n[](#rr.f.record_route_adv_addr))).\n\nMeaning of the parameters is as follows:\n\n- *param* - String containing the URI parameter to be added. It must\n  follow the \u201c;name=value\u201d scheme; it may contain pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\nadd_rr_param(\";nat=yes\");\n...\n```\n",
   "check_route_param": "### `check_route_param(re)`\n\nThe function checks if the URI parameters of the local Route header\n(corresponding to the local server) matches the given regular\nexpression. It must be called after loose_route() (see\n[](#rr.f.loose_route)).\n\nMeaning of the parameters is as follows:\n\n- *re* - regular expression to check against the Route URI parameters.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (check_route_param(\"nat=yes\")) {\n    setflag(6);\n}\n...\n```\n",
   "is_direction": "### `is_direction(dir)`\n\nThe function checks the flow direction of in-dialog requests. This\nfunction uses the \u201cftag\u201d parameter from the Route header, therefore the\nappend_fromtag (see [???](#rr.p.append_fromtag) module parameter must be\nenabled. Also this must be called only after loose_route() (see\n[](#rr.f.loose_route)).\n\nThe function returns true if the \u201cdir\u201d is the same with the request's\nflow direction.\n\nThe \u201cdownstream\u201d direction means that the request is in the same\ndirection as the initial request that created the dialog.\n\nMeaning of the parameters is as follows:\n\n- *dir* - string containing the direction to be checked. It may be\n  \u201cupstream\u201d (from callee to caller) or \u201cdownstream\u201d (caller to callee).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_direction(\"downstream\")) {\n    xdbg(\"in-dialog request from caller to callee (downstream) ($rm)\\n\");\n} else {\n    xdbg(\"in-dialog request from callee to caller (upstream) ($rm)\\n\");\n}\n...\n```\n",
   "rr_next_hop_route": "### `rr_next_hop_route()`\n\nThe function returns 1 (true) if there is a Route header for the next\nhop address. It has to be used after loose_route(), when the local Route\nheaders are processed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(loose_route) {\n    if(rr_next_hop_route()) {\n        # next hop address is from Route header\n    }\n\n}\n...\n```\n"
  }
 },
 "rtimer": {
  "overview": "The module executes route blocks on a timer base. It can create new\ntimer processes and execute many route blocks on same timer.\n\nA static faked SIP message is given as parameter to called functions, so\nall functions available for REQUEST_ROUTE can be used.\n",
  "parameters": {
   "default_interval": "### `default_interval` (int)\n\nThe definition of the default interval of timers (if not present on the\n\"timer\" parameter)\n\nThe parameter can be set multiple times to get different intervals in\nsame configuration file.\n\n```\n...\n# default time interval set to 300 seconds\nmodparam(\"rtimer\", \"default_interval\", 300)\n...\n        \n```\n",
   "timer": "### `timer` (str)\n\nThe definition of a timer. The value of the parameter must have the\nfollowing format:\n\n- \"name=_string_;mode=_number_;interval=_number_\"\n\nThe parameter can be set multiple times to get more timers in same\nconfiguration file.\n\n- *name* - name of the timer.\n\n- *mode* - if set to 0, the timer will use the main (shared) timer. Any\n  number > 0 will create the specified amount of new timer processes\n  (which will only be handling this timer).\n\n- *interval* - timer interval in seconds or micro-seconds (the value\n  must be ended in 'u'). For micro-seconds intervals, mode is set always\n  to 1.\n\n*Default value is NULL.*\n\n```\n...\n# time interval set to 10 seconds\nmodparam(\"rtimer\", \"timer\", \"name=ta;interval=10;mode=1;\")\n# time interval set to 100 milliseconds\nmodparam(\"rtimer\", \"timer\", \"name=ta;interval=100000u;mode=1;\")\n...\n```\n",
   "exec": "### `exec` (str)\n\nSpecify route to be executed on timer. The value of the parameter must\nhave the following format:\n\n- \"timer=_string_;route=_number_\"\n\nThe parameter can be set multiple times to get more routes executed on\nsame timer.\n\n- *timer* - name of the timer.\n\n- *route* - the name of the route block to be executed, or the name of\n  the function from kemi script. The kemi function receives a string\n  parameter with the value being the name of the module.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"rtimer\", \"timer\", \"name=ta;interval=10;mode=1;\")\nmodparam(\"rtimer\", \"exec\", \"timer=ta;route=ONTIMER\")\n\nroute[ONTIMER] {\n    xlog(\"timer routine: time is $TF\\n\");\n    # delete from my sql cache table entries older than 2H\n    sql_query(\"delete from kamailio_cache where last_updated<$TS-3600\");\n}\n...\n\n...\nmodparam(\"rtimer\", \"timer\", \"name=ta;interval=10;mode=1;\")\nmodparam(\"rtimer\", \"exec\", \"timer=ta;route=ksr_rtimer\")\n...\n-- rtimer event callback function implemented in Lua\nfunction ksr_rtimer(evname)\n    KSR.info(\"===== rtimer module triggered event\\n\");\n    return 1;\nend\n...\n```\n"
  },
  "functions": {}
 },
 "rtjson": {
  "overview": "This module facilitates SIP routing based on JSON specifications.\n\nThe values for R-URI ($ru), outbound proxy ($du) and other attributes\nused for SIP routing can be retrieved in a JSON document. It is able to\nprocess attributes for more than one destination and prepare for routing\nin serial or parallel fashion.\n",
  "parameters": {
   "xavp_cfg": "### `xavp_cfg` (str)\n\nThe name of the xavp to be used internally by the module.\n\n*Default value is \"rtjson\".*\n\n```\n...\nmodparam(\"rtjson\", \"xavp_cfg\", \"myxavp\")\n...\n```\n"
  },
  "functions": {
   "rtjson_init_routes": "### `rtjson_init_routes(rtdoc)`\n\nInitialize routing based on JSON document stored in rtdoc parameter.\n\nThe rtdoc parameter can be a static string or a dynamic string value\nwith config variables. It has to result in a valid JSON document with\nthe structure specified in chapter 'JSON Routing Structure'.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nrtjson_init_routes(\"$var(json)\");\n...\n```\n",
   "rtjson_push_routes": "### `rtjson_push_routes()`\n\nPush the routes given in JSON document to rtjson_init_routes(rtdoc) to\nthe internal fields used by Kamailio for routing.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nrtjson_init_routes(\"$var(json)\");\nrtjson_push_routes();\n...\n```\n",
   "rtjson_next_route": "### `rtjson_next_route()`\n\nTo be used in failure_route for serial forking, to push the next route\nto the internal fields used by Kamailio for routing.\n\nThis function can be used from FAILURE_ROUTE.\n\n```\n...\nrtjson_init_routes(\"$var(json)\");\nrtjson_push_routes();\nt_on_failure(\"REROUTE\");\nt_relay();\n...\nfailure_route[REROUTE] {\n    rtjson_next_route();\n}\n...\n```\n",
   "rtjson_update_branch": "### `rtjson_update_branch()`\n\nTo be used in branch_route if the JSON document had attributes that\nneeds to be set for each branch.\n\nThis function can be used from BRANCH_ROUTE.\n\n```\n...\nrtjson_init_routes(\"$var(json)\");\nrtjson_push_routes();\nt_on_branch(\"OUTGOING\");\nt_relay();\n...\nbranch_route[OUTGOING] {\n    rtjson_update_branch();\n}\n...\n```\n"
  }
 },
 "rtp_media_server": {
  "overview": "rtp_media_server module adds RTP and media processing functionalities to\nKamailio. Kamailio is providing SIP signaling including an endpoint with\nDialog state, SDP parsing and scripting language.\n\noRTP: is providing Real-time Transport Protocol (RFC 3550)\n\nmediastreamer2: is providing mediaprocessing functionnalities using\ngraphs and filters, many modules are available to support various\nfeatures, it should be relatively simple to integrated them.\n\nmediastreamer2 is also providing a framework to create custom\nmediaprocessing modules.\n",
  "parameters": {
   "log_file_name": "### `log_file_name` (string)\n\noRTP and MediaStreamer2 log file settings the log mask is not\nconfigurable : MESSAGE | WARNING | ERROR | FATAL levels are\nactivated.\n\nDefault value is not-set (no logging to file).\n\n```\n...\nmodparam(\"rtp_media_server\", \"log_file_name\", \"/var/log/rms/rms_ortp.log\")\n...\n        \n```\n"
  },
  "functions": {
   "rms_answer": "### `rms_answer` (event_route)\n\nCreate a call leg with a SIP dialog and an RTP session call the\nevent_route\n\nThis function can be used from REQUEST_ROUTE, REPLY_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\nevent_route[rms:start] {\n    xnotice(\"[rms:start] play ...\\n\");\n    rms_play(\"/tmp/reference_8000.wav\", \"rms:after_play\");\n};\n\nevent_route[rms:after_play] {\n    xnotice(\"[rms:after_play] play done...\\n\");\n    rms_hangup();\n};\n\nroute {\n    if (t_precheck_trans()) {\n        t_check_trans();\n        exit;\n    }\n    t_check_trans();\n    if (is_method(\"INVITE\") && !has_totag()) {\n        if (!rms_answer(\"rms:start\")) {\n            t_reply(\"503\", \"server error\");\n        }\n    }\n    rms_sip_request();\n...\n        \n```\n",
   "rms_hangup": "### `rms_hangup` ()\n\nSend a BYE, delete the RTP session and the media resources.\n\nThis function can be used from EVENT_ROUTE.\n\n```\n...\n    rms_hangup();\n...\n        \n```\n",
   "rms_bridge": "### `rms_bridge` (target URI, event_route)\n\nBridge the incoming call, create a second call leg using a UAC in a\nB2BUA manner, this is needed in case we want to un-bridge later, a\nfeature not currently implemented Call the specified event_route,\ndefaulting to [rms:bridge].\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nevent_route[rms:bridged] {\n    xnotice(\"[rms:bridged] !\\n\");\n};\n\nroute {\n    if (t_precheck_trans()) {\n        t_check_trans();\n        exit;\n    }\n    t_check_trans();\n    if (is_method(\"INVITE\") && !has_totag()) {\n        $var(target) = \"sip:\" + $rU + \"@mydomain.com:5060;\";\n        if (!rms_bridge(\"$var(target)\", \"rms:bridged\")) {\n            t_reply(\"503\", \"server error\");\n        }\n    }\n    if(rms_dialog_check()) // If the dialog is managed by the RMS module, the in-dialog request needs to be handled by it.\n        rms_sip_request();\n...\n        \n```\n",
   "rms_dialog_check": "### `rms_dialog_check` ()\n\nReturns true if the current SIP message it handled/known by the RMS\nmodule, else it may be handled in any other way by Kamailio.\n\nThis function can be used from REQUEST_ROUTE, REPLY_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\n    if (rms_dialog_check()) {\n        xnotice(\"This dialog is handled by the RMS module\\n\");\n        rms_sip_request();\n    }\n...\n        \n```\n",
   "rms_sip_request": "### `rms_sip_request` ()\n\nThis should be called for every in-dialog SIP request, it will be\nforwarded behaving as a B2BUA, the transaction will be suspended until\nthe second leg replies.\n\nIf the SIP dialog is not found \"481 Call/Transaction Does Not Exist\" is\nreturned.\n\nThis function can be used from REQUEST_ROUTE, REPLY_ROUTE and\nFAILURE_ROUTE.\n\n```\n...\n    if (rms_dialog_check()) {\n        rms_sip_request();\n    }\n...\n        \n```\n",
   "rms_play": "### `rms_play` (file, event_route)\n\nPlay a wav file, a resampler is automatically configured to resample and\nconvert stereo to mono if needed.\n\nThe second parameter is the event route that will be called when the\nfile was played.\n\nThis function can be used from EVENT_ROUTE.\n\n```\n...\n    rms_play(\"file.wav\", \"event_route_name\");\n...\n        \n```\n"
  }
 },
 "rtpengine": {
  "overview": "This is a module that enables media streams to be proxied via an RTP\nproxy. The only RTP proxy currently known to work with this module is\nthe Sipwise rtpengine [](https://github.com/sipwise/rtpengine). The\nrtpengine module is a modified version of the original rtpproxy module\nusing a new control protocol. The module is designed to be a drop-in\nreplacement for the old module from a configuration file point of view,\nhowever due to the incompatible control protocol, it only works with RTP\nproxies which specifically support it.\n",
  "parameters": {
   "rtpengine_sock": "### `rtpengine_sock` (string)\n\nDefinition of socket(s) used to connect to (a set) RTP proxy. It may\nspecify an IPv4/IPv6 UDP socket or a websocket URI.\n\n*Default value is \u201cNONE\u201d (disabled).*\n\n```\n...\n# single rtproxy\nmodparam(\"rtpengine\", \"rtpengine_sock\", \"udp:localhost:12221\")\n# IPv6 UDP\nmodparam(\"rtpengine\", \"rtpengine_sock\", \"udp6:localhost:12221\")\n# websocket\nmodparam(\"rtpengine\", \"rtpengine_sock\", \"ws://localhost:12221/\")\n# websocket with TLS\nmodparam(\"rtpengine\", \"rtpengine_sock\", \"wss://localhost:12221/\")\n# multiple rtproxies for LB with weights (missing weight defaults to 1)\nmodparam(\"rtpengine\", \"rtpengine_sock\",\n    \"udp:localhost:12221=2 udp:localhost:12222=1\")\n# multiple sets of multiple rtproxies\nmodparam(\"rtpengine\", \"rtpengine_sock\",\n    \"1 == udp:localhost:12221 udp:localhost:12222\")\nmodparam(\"rtpengine\", \"rtpengine_sock\",\n    \"2 == udp:localhost:12225\")\n...\n```\n",
   "rtpengine_disable_tout": "### `rtpengine_disable_tout` (integer)\n\nOnce an RTP proxy was found unreachable and marked as disabled, the\nrtpengine module will not attempt to establish communication to that RTP\nproxy for rtpengine_disable_tout seconds.\n\n*Default value is \u201c60\u201d.*\n\nCan be set at runtime, e.g.:\n\n```\n            $ kamcmd cfg.set_now_int rtpengine rtpengine_disable_tout 20\n            \n\n...\nmodparam(\"rtpengine\", \"rtpengine_disable_tout\", 20)\n...\n```\n",
   "aggressive_redetection": "### `aggressive_redetection` (integer)\n\nThis parameter determines what happens when all potential rtpengines are\nfound to be unreachable. If enabled, the sip server will send pings to\nall rtpengines, else no rtpengine will be queried until its\nrtpengine_disable_tout timeout passes.\n\n*Default value is \u201c1\u201d (enabled).*\n\nCan be set at runtime, e.g.:\n\n```\n            $ kamcmd cfg.set_now_int rtpengine aggressive_redetection 0\n            \n\n...\nmodparam(\"rtpengine\", \"aggressive_redetection\", 0)\n...\n```\n",
   "rtpengine_tout_ms": "### `rtpengine_tout_ms` (integer)\n\nTimeout value expressed in milliseconds in waiting for reply from RTP\nproxy.\n\n*Default value is \u201c1000\u201d.*\n\nCan be set at runtime, e.g.:\n\n```\n            $ kamcmd cfg.set_now_int rtpengine rtpengine_tout_ms 1000\n            \n\n...\nmodparam(\"rtpengine\", \"rtpengine_tout_ms\", 2000)\n...\n```\n",
   "rtpengine_allow_op": "### `rtpengine_allow_op` (integer)\n\nEnable this setting to allow finishing the current sessions while\ndenying new sessions for deactivated nodes.\n\nNodes can be *manually deactivated* via kamctl command i.e.\n\"disabled(permanent)\" nodes. Probably the manually deactivated machine\nis still running (did not crash).\n\nThis is *useful* when deactivating a node for maintenance and reject new\nsessions but allow current ones to finish.\n\nThe behaviour is the same for a rtpengine deleted table node. When the\nnode is deleted from the table and the table reloaded (see\nnh_reload_rtpp) the node actually is disabled(permanent) and hidden for\ndisplay. Next time the same node will be added in the table, and the\ndatabase content reloaded, the re-activated node will be updated and\nre-displayed.\n\n*Default value is \u201c0\u201d to keep the current behaviour.*\n\n*If value set to \u201c1\u201d it will send commands to all disabled nodes for the\nexisting call.*\n\n*If value set to \u201c2\u201d it will send commands only to manually disabled\nnodes. (Not when timeout is disabled or node broken)*\n\n```\n...\nmodparam(\"rtpengine\", \"rtpengine_allow_op\", 1)\n...\n```\n",
   "queried_nodes_limit": "### `queried_nodes_limit` (integer)\n\nThe total number of nodes inside a set (sets are configurable via\nrtpengine_sock function) to be queried before giving up establishing a\nsession. This brings more flexibility in case checking all rtpengines\nwould take too long. Max limit is 30.\n\n*By default all nodes in a set are tried before giving up communicating\nwith the rtpengines.*\n\nCan be set at runtime, e.g.:\n\n```\n            $ kamcmd cfg.set_now_int rtpengine queried_nodes_limit 5\n            \n\n...\nmodparam(\"rtpengine\", \"queried_nodes_limit\", 5)\n...\n```\n",
   "rtpengine_retr": "### `rtpengine_retr` (integer)\n\nHow many times the module should retry to send and receive after timeout\nwas generated.\n\n*Default value is \u201c5\u201d.*\n\nCan be set at runtime, e.g.:\n\n```\n            $ kamcmd cfg.set_now_int rtpengine rtpengine_retr 5\n            \n\n...\nmodparam(\"rtpengine\", \"rtpengine_retr\", 2)\n...\n```\n",
   "extra_id_pv": "### `extra_id_pv` (string)\n\nThe parameter sets the PV definition to use when the \u201cvia-branch\u201d\nparameter is used on rtpengine_delete(), rtpengine_offer(),\nrtpengine_answer() or rtpengine_manage() command.\n\nDefault is empty, the \u201cvia-branch\u201d parameter may not be used then.\n\n```\n...\nmodparam(\"rtpengine\", \"extra_id_pv\", \"$avp(extra_id)\")\n...\n```\n",
   "setid_avp": "### `setid_avp` (string)\n\nThe parameter defines an AVP that, if set, determines which RTP proxy\nset rtpengine_offer(), rtpengine_answer(), rtpengine_delete(), and\nrtpengine_manage() functions use.\n\nThere is no default value.\n\n```\n...\nmodparam(\"rtpengine\", \"setid_avp\", \"$avp(setid)\")\n...\n```\n",
   "force_send_interface": "### `force_send_interface` (string)\n\nForces all control messages between the SIP proxy and the RTP proxy to\nbe sent from the specified local interface. Both IPv4 and IPv6 addresses\nare supported. If not specified, the default interface selected by the\noperating system will be used. Note: when rtpengine_sock is an IPv6\nlink-local address, one _must_ set this parameter in order to\nsuccessfully connect to RTP engine. This is necessarily because OS needs\nadditional scope_id hint to communicate over IPv6 link locals. The\nscope_id is resolved based on the given IPv6.\n\nThere is no default value.\n\n```\n...\nmodparam(\"rtpengine\", \"force_send_interface\", \"10.3.7.123\")\nmodparam(\"rtpengine\", \"force_send_interface\", \"2001:8d8:1ff:10c0:9a90:96ff:fea8:fd99\")\n...\n```\n",
   "read_sdp_pv": "### `read_sdp_pv` (string)\n\nIf this parameter is set to a valid AVP or script var specifier,\nrtpengine will take the input SDP from this pv instead of the message\nbody.\n\nThere is no default value.\n\n```\n...\nmodparam(\"rtpengine\", \"read_sdp_pv\", \"$var(sdp)\")\n...\nroute {\n    ...\n    $var(sdp) = $rb + \"a=foo:bar\\r\\n\";\n    rtpengine_manage();\n}\n```\n",
   "write_sdp_pv": "### `write_sdp_pv` (string)\n\nIf this parameter is set to a valid AVP or script var specifier, the SDP\nreturned by rtpengine in the offer/answer operations is returned in the\nspecified variable instead of the message body.\n\nThere is no default value.\n\n```\n...\nmodparam(\"rtpengine\", \"write_sdp_pv\", \"$avp(sdp)\")\n...\nroute {\n    ...\n    rtpengine_manage();\n    set_body(\"$avp(sdp)a=baz123\\r\\n\", \"application/sdp\");\n}\n```\n",
   "rtp_inst_pvar": "### `rtp_inst_pvar` (string)\n\nA pseudo variable to store the chosen RTP Engine IP address. If this\nparameter is set, the IP address and port of the instance chosen will be\nstored in the given variable.\n\nBy default, this parameter is not set.\n\n```\n...\nmodparam(\"rtpengine\", \"rtp_inst_pvar\", \"$avp(RTP_INSTANCE)\")\n...\n```\n",
   "hash_table_size": "### `hash_table_size` (integer)\n\nTo maintain information about a selected rtp machine node for a given\ncall, entries are added in a hashtable of (callid, node) pairs. This\nparameter sets the size of the hash table. Default value is 256.\n\nNOTE: If configured size is *less than* 1, the size will be defaulted to\n1.\n\n```\n...\nmodparam(\"rtpengine\", \"hash_table_size\", 123)\n...\n```\n",
   "hash_table_tout": "### `hash_table_tout` (integer)\n\nNumber of seconds after an rtpengine hash table entry is marked for\ndeletion. By default, this parameter is set to 3600 (seconds).\n\nTo maintain information about a selected rtp machine node for a given\ncall, entries are added in a hashtable of (callid, node) pairs. When\ncommand comes the callid is looked up in this table. If found, the\nchosen node is used. If not found, choose a new node, insert the callid\nin the hashtable and return the chosen node.\n\nNOTE: In the current implementation, the actual deletion happens *on the\nfly*, while insert/remove/lookup the hastable, *only* for the entries in\nthe insert/remove/lookup path.\n\nNOTE: When configuring this parameter, one should consider maximum call\ntime VS shared memory for unfinished calls.\n\n```\n...\nmodparam(\"rtpengine\", \"hash_table_tout\", 300)\n...\n```\n",
   "db_url": "### `db_url` (string)\n\nThe rtpengine database url. If present and valid, it activates database\nmode. In this mode the node information is read from database, not from\nconfiguration modparam parameters.\n\nBy default, the database url is NULL (not set).\n\n```\n...\nmodparam(\"rtpengine\", \"db_url\", \"mysql://pass@localhost/db\")\n...\n```\n",
   "table_name": "### `table_name` (string)\n\nThe rtpengine table name. If database mode is activated (i.e. valid\ndb_url), sets the name of the rtpengine table, on startup.\n\nBy default, the rtpengine table name is \"rtpengine\".\n\nNOTE: One needs to add the version of the rtpengine table in the version\ntable. The current version is version 1.\n\n```\n...\nmodparam(\"rtpengine\", \"table_name\", \"rtpengine_table_name\")\n...\n\nmysql> describe rtpengine;\n+----------+------------------+------+-----+---------------------+-------+\n| Field    | Type             | Null | Key | Default             | Extra |\n+----------+------------------+------+-----+---------------------+-------+\n| setid    | int(10) unsigned | NO   | PRI | 0                   |       |\n| url      | varchar(64)      | NO   | PRI | NULL                |       |\n| weight   | int(10) unsigned | NO   |     | 1                   |       |\n| disabled | int(1)           | NO   |     | 0                   |       |\n| stamp    | datetime         | NO   |     | 1900-01-01 00:00:01 |       |\n+----------+------------------+------+-----+---------------------+-------+\n\nmysql> select * from rtpengine;\n+-------+----------------------------+--------+----------+---------------------+\n| setid | url                        | weight | disabled | stamp               |\n+-------+----------------------------+--------+----------+---------------------+\n|     0 | udp:rtpengine1.domain:8800 |      1 |        0 | 2016-03-10 10:30:54 |\n|     0 | udp:rtpengine2.domain:8800 |      1 |        1 | 2016-03-10 10:30:54 |\n+-------+----------------------------+--------+----------+---------------------+\n\nmysql> select * from version;\n+---------------------------+---------------+\n| table_name                | table_version |\n+---------------------------+---------------+\n| rtpengine                 |             1 |\n+---------------------------+---------------+\n```\n",
   "setid_col": "### `setid_col` (string)\n\nColumn name for the \"setid\" in the rtpengine table. If database mode is\nactivated (i.e. valid db_url), set the setid of rtp nodes according to\nthis column, on startup. The MySQL value for this column should be INT\nUNSIGNED.\n\nBy default, the column name is \"setid\".\n\n```\n...\nmodparam(\"rtpengine\", \"setid_col\", \"setid_column_name\")\n...\n```\n",
   "url_col": "### `url_col` (string)\n\nColumn name for the url in the rtpengine table. If database mode is\nactivated (i.e. valid db_url), set the url of rtp nodes according to\nthis column, on startup. The MySQL value for this column should be\nVARCHAR.\n\nBy default, the column name is \"url\".\n\n```\n...\nmodparam(\"rtpengine\", \"url_col\", \"url_column_name\")\n...\n```\n",
   "weight_col": "### `weight_col` (string)\n\nColumn name for weight in the rtpengine table. If database mode is\nactivated (i.e. valid db_url), set the weight of rtp nodes according to\nthis column, on startup. The column value has priority over the URL\nweight. The MySQL value for this column should be INT UNSIGNED.\n\nBy default, the column name is \"weight\".\n\n```\n...\nmodparam(\"rtpengine\", \"weight_col\", \"weight_column_name\")\n...\n```\n",
   "disabled_col": "### `disabled_col` (string)\n\nColumn name in the rtpengine table. If database mode is activated (i.e.\nvalid db_url), set the state of rtp nodes according to this column, on\nstartup. The MySQL value for this column should be INT.\n\nBy default, the column name is \"disabled\".\n\n```\n...\nmodparam(\"rtpengine\", \"disabled_col\", \"disabled_column_name\")\n...\n```\n",
   "setid_default": "### `setid_default` (integer)\n\nThe default set of nodes to be used.\n\nBy default, the setid is 0.\n\nNOTE that if setid_avp is configured, this value will be ignored and the\nactive set will be chosen according to the setid_avp.\n\n```\n...\nmodparam(\"rtpengine\", \"setid_default\", 11)\n...\n```\n",
   "media_duration": "### `media_duration` (string)\n\nThe name of a pseudovariable to be filled in with the length of the\nmedia being played back after a call to \u201cplay_media\u201d, expressed in\nmilliseconds. It's set to -1 if the length of the media could not be\ndetermined.\n\nBy default, this parameter is not set.\n\n```\n...\nmodparam(\"rtpengine\", \"media_duration\", \"$avp(MEDIA_DURATION)\")\n...\n```\n",
   "mos_min_pv": "### `mos_min_pv` (string)\n\nThe name of a pseudovariable to hold the minimum encountered MOS (Mean\nOpinion Score) value for the call. The value typically has a range of\n1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_pv\", \"$avp(mos_min)\")\n...\n```\n",
   "mos_min_at_pv": "### `mos_min_at_pv` (string)\n\nThe name of a pseudovariable to hold the timestamp of when the minimum\nMOS value was encountered during the call, such as \u201c0:30\u201d for 30 seconds\nafter the start of the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_at_pv\", \"$avp(mos_min_at)\")\n...\n```\n",
   "mos_min_packetloss_pv": "### `mos_min_packetloss_pv` (string)\n\nThe name of a pseudovariable to hold the amount of packetloss in percent\nat the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_packetloss_pv\", \"$avp(mos_min_packetloss)\")\n...\n```\n",
   "mos_min_jitter_pv": "### `mos_min_jitter_pv` (string)\n\nThe name of a pseudovariable to hold the amount of jitter in\nmilliseconds at the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_jitter_pv\", \"$avp(mos_min_jitter)\")\n...\n```\n",
   "mos_min_roundtrip_pv": "### `mos_min_roundtrip_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time in\nmicroseconds at the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_roundtrip_pv\", \"$avp(mos_min_roundtrip)\")\n...\n```\n",
   "mos_max_pv": "### `mos_max_pv` (string)\n\nThe name of a pseudovariable to hold the maximum encountered MOS value\nfor the call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_pv\", \"$avp(mos_max)\")\n...\n```\n",
   "mos_max_at_pv": "### `mos_max_at_pv` (string)\n\nThe name of a pseudovariable to hold the timestamp of when the maximum\nMOS value was encountered during the call, such as \u201c0:30\u201d for 30 seconds\nafter the start of the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_at_pv\", \"$avp(mos_max_at)\")\n...\n```\n",
   "mos_max_packetloss_pv": "### `mos_max_packetloss_pv` (string)\n\nThe name of a pseudovariable to hold the amount of packetloss in percent\nat the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_packetloss_pv\", \"$avp(mos_max_packetloss)\")\n...\n```\n",
   "mos_max_jitter_pv": "### `mos_max_jitter_pv` (string)\n\nThe name of a pseudovariable to hold the amount of jitter in\nmilliseconds at the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_jitter_pv\", \"$avp(mos_max_jitter)\")\n...\n```\n",
   "mos_max_roundtrip_pv": "### `mos_max_roundtrip_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time in\nmicroseconds at the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_roundtrip_pv\", \"$avp(mos_max_roundtrip)\")\n...\n```\n",
   "mos_average_pv": "### `mos_average_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) MOS value for\nthe call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_pv\", \"$avp(mos_average)\")\n...\n```\n",
   "mos_average_packetloss_pv": "### `mos_average_packetloss_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) amount of\npacketloss in percent present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_packetloss_pv\", \"$avp(mos_average_packetloss)\")\n...\n```\n",
   "mos_average_jitter_pv": "### `mos_average_jitter_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) amount of\njitter in milliseconds present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_jitter_pv\", \"$avp(mos_average_jitter)\")\n...\n```\n",
   "mos_average_roundtrip_pv": "### `mos_average_roundtrip_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) packet\nround-trip time in milliseconds present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_roundtrip_pv\", \"$avp(mos_average_roundtrip)\")\n...\n```\n",
   "mos_average_samples_pv": "### `mos_average_samples_pv` (string)\n\nThe name of a pseudovariable to hold the number of samples used to\ndetermine the other \u201caverage\u201d MOS data points.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_samples_pv\", \"$avp(mos_average_samples)\")\n...\n```\n",
   "mos_A_label_pv": "### `mos_A_label_pv` (string)\n\nThe name of a pseudovariable to hold a custom label used in rtpengine\nsignalling. If set, all the statistics pseudovariables with the \u201c_A\u201d\nsuffix will be filled in with statistics only from the call legs that\nmatch the label given in this variable.\n\nThere is no default value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_A_label_pv\", \"$avp(mos_A_label)\")\n...\n```\n",
   "mos_min_A_pv": "### `mos_min_A_pv` (string)\n\nThe name of a pseudovariable to hold the minimum encountered MOS value\nfor the call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_A_pv\", \"$avp(mos_min_A)\")\n...\n```\n",
   "mos_min_at_A_pv": "### `mos_min_at_A_pv` (string)\n\nThe name of a pseudovariable to hold the timestamp of when the minimum\nMOS value was encountered during the call, such as \u201c0:30\u201d for 30 seconds\nafter the start of the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_at_A_pv\", \"$avp(mos_min_at_A)\")\n...\n```\n",
   "mos_min_packetloss_A_pv": "### `mos_min_packetloss_A_pv` (string)\n\nThe name of a pseudovariable to hold the amount of packetloss in percent\nat the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_packetloss_A_pv\", \"$avp(mos_min_packetloss_A)\")\n...\n```\n",
   "mos_min_jitter_A_pv": "### `mos_min_jitter_A_pv` (string)\n\nThe name of a pseudovariable to hold the amount of jitter in\nmilliseconds at the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_jitter_A_pv\", \"$avp(mos_min_jitter_A)\")\n...\n```\n",
   "mos_min_roundtrip_A_pv": "### `mos_min_roundtrip_A_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time in\nmicroseconds at the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_roundtrip_A_pv\", \"$avp(mos_min_roundtrip_A)\")\n...\n```\n",
   "mos_min_roundtrip_leg_A_pv": "### `mos_min_roundtrip_leg_A_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time of the\nspecific call leg in microseconds at the time the minimum MOS value was\nencountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_roundtrip_leg_A_pv\", \"$avp(mos_min_roundtrip_leg_A)\")\n...\n```\n",
   "mos_max_A_pv": "### `mos_max_A_pv` (string)\n\nThe name of a pseudovariable to hold the maximum encountered MOS value\nfor the call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_A_pv\", \"$avp(mos_max_A)\")\n...\n```\n",
   "mos_max_at_A_pv": "### `mos_max_at_A_pv` (string)\n\nThe name of a pseudovariable to hold the timestamp of when the maximum\nMOS value was encountered during the call, such as \u201c0:30\u201d for 30 seconds\nafter the start of the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_at_A_pv\", \"$avp(mos_max_at_A)\")\n...\n```\n",
   "mos_max_packetloss_A_pv": "### `mos_max_packetloss_A_pv` (string)\n\nThe name of a pseudovariable to hold the amount of packetloss in percent\nat the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_packetloss_A_pv\", \"$avp(mos_max_packetloss_A)\")\n...\n```\n",
   "mos_max_jitter_A_pv": "### `mos_max_jitter_A_pv` (string)\n\nThe name of a pseudovariable to hold the amount of jitter in\nmilliseconds at the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_jitter_A_pv\", \"$avp(mos_max_jitter_A)\")\n...\n```\n",
   "mos_max_roundtrip_A_pv": "### `mos_max_roundtrip_A_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time in\nmicroseconds at the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_roundtrip_A_pv\", \"$avp(mos_max_roundtrip_A)\")\n...\n```\n",
   "mos_max_roundtrip_leg_A_pv": "### `mos_max_roundtrip_leg_A_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time of the\nspecific call leg in microseconds at the time the maximum MOS value was\nencountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_roundtrip_leg_A_pv\", \"$avp(mos_max_roundtrip_leg_A)\")\n...\n```\n",
   "mos_average_A_pv": "### `mos_average_A_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) MOS value for\nthe call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_A_pv\", \"$avp(mos_average_A)\")\n...\n```\n",
   "mos_average_packetloss_A_pv": "### `mos_average_packetloss_A_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) amount of\npacketloss in percent present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_packetloss_A_pv\", \"$avp(mos_average_packetloss_A)\")\n...\n```\n",
   "mos_average_jitter_A_pv": "### `mos_average_jitter_A_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) amount of\njitter in milliseconds present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_jitter_A_pv\", \"$avp(mos_average_jitter_A)\")\n...\n```\n",
   "mos_average_roundtrip_A_pv": "### `mos_average_roundtrip_A_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) packet\nround-trip time in microseconds present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_roundtrip_A_pv\", \"$avp(mos_average_roundtrip_A)\")\n...\n```\n",
   "mos_average_roundtrip_leg_A_pv": "### `mos_average_roundtrip_leg_A_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) packet\nround-trip time of the specific call leg in microseconds present\nthroughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_roundtrip_leg_A_pv\", \"$avp(mos_average_roundtrip_leg_A)\")\n...\n```\n",
   "mos_average_samples_A_pv": "### `mos_average_samples_A_pv` (string)\n\nThe name of a pseudovariable to hold the number of samples used to\ndetermine the other \u201caverage\u201d MOS data points.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_samples_A_pv\", \"$avp(mos_average_samples_A)\")\n...\n```\n",
   "mos_B_label_pv": "### `mos_B_label_pv` (string)\n\nThe name of a pseudovariable to hold a custom label used in rtpengine\nsignalling. If set, all the statistics pseudovariables with the \u201c_B\u201d\nsuffix will be filled in with statistics only from the call legs that\nmatch the label given in this variable.\n\nThere is no default value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_B_label_pv\", \"$avp(mos_B_label)\")\n...\n```\n",
   "mos_min_B_pv": "### `mos_min_B_pv` (string)\n\nThe name of a pseudovariable to hold the minimum encountered MOS value\nfor the call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_B_pv\", \"$avp(mos_min_B)\")\n...\n```\n",
   "mos_min_at_B_pv": "### `mos_min_at_B_pv` (string)\n\nThe name of a pseudovariable to hold the timestamp of when the minimum\nMOS value was encountered during the call, such as \u201c0:30\u201d for 30 seconds\nafter the start of the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_at_B_pv\", \"$avp(mos_min_at_B)\")\n...\n```\n",
   "mos_min_packetloss_B_pv": "### `mos_min_packetloss_B_pv` (string)\n\nThe name of a pseudovariable to hold the amount of packetloss in percent\nat the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_packetloss_B_pv\", \"$avp(mos_min_packetloss_B)\")\n...\n```\n",
   "mos_min_jitter_B_pv": "### `mos_min_jitter_B_pv` (string)\n\nThe name of a pseudovariable to hold the amount of jitter in\nmilliseconds at the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_jitter_B_pv\", \"$avp(mos_min_jitter_B)\")\n...\n```\n",
   "mos_min_roundtrip_B_pv": "### `mos_min_roundtrip_B_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time in\nmicroseconds at the time the minimum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_roundtrip_B_pv\", \"$avp(mos_min_roundtrip_B)\")\n...\n```\n",
   "mos_min_roundtrip_leg_B_pv": "### `mos_min_roundtrip_leg_B_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time of the\nspecific call leg in microseconds at the time the minimum MOS value was\nencountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_min_roundtrip_leg_B_pv\", \"$avp(mos_min_roundtrip_leg_B)\")\n...\n```\n",
   "mos_max_B_pv": "### `mos_max_B_pv` (string)\n\nThe name of a pseudovariable to hold the maximum encountered MOS value\nfor the call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_B_pv\", \"$avp(mos_max_B)\")\n...\n```\n",
   "mos_max_at_B_pv": "### `mos_max_at_B_pv` (string)\n\nThe name of a pseudovariable to hold the timestamp of when the maximum\nMOS value was encountered during the call, such as \u201c0:30\u201d for 30 seconds\nafter the start of the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_at_B_pv\", \"$avp(mos_max_at_B)\")\n...\n```\n",
   "mos_max_packetloss_B_pv": "### `mos_max_packetloss_B_pv` (string)\n\nThe name of a pseudovariable to hold the amount of packetloss in percent\nat the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_packetloss_B_pv\", \"$avp(mos_max_packetloss_B)\")\n...\n```\n",
   "mos_max_jitter_B_pv": "### `mos_max_jitter_B_pv` (string)\n\nThe name of a pseudovariable to hold the amount of jitter in\nmilliseconds at the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_jitter_B_pv\", \"$avp(mos_max_jitter_B)\")\n...\n```\n",
   "mos_max_roundtrip_B_pv": "### `mos_max_roundtrip_B_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time in\nmicroseconds at the time the maximum MOS value was encountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_roundtrip_B_pv\", \"$avp(mos_max_roundtrip_B)\")\n...\n```\n",
   "mos_max_roundtrip_leg_B_pv": "### `mos_max_roundtrip_leg_B_pv` (string)\n\nThe name of a pseudovariable to hold the packet round-trip time of the\nspecific call leg in microseconds at the time the maximum MOS value was\nencountered;\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_A_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_max_roundtrip_leg_B_pv\", \"$avp(mos_max_roundtrip_leg_B)\")\n...\n```\n",
   "mos_average_B_pv": "### `mos_average_B_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) MOS value for\nthe call. The value typically has a range of 1.0 through 5.0.\n\nThere is no default value.\n\nThis value is filled in after invoking\u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_B_pv\", \"$avp(mos_average_B)\")\n...\n```\n",
   "mos_average_packetloss_B_pv": "### `mos_average_packetloss_B_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) amount of\npacketloss in percent present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_packetloss_B_pv\", \"$avp(mos_average_packetloss_B)\")\n...\n```\n",
   "mos_average_jitter_B_pv": "### `mos_average_jitter_B_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) amount of\njitter in milliseconds present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_jitter_B_pv\", \"$avp(mos_average_jitter_B)\")\n...\n```\n",
   "mos_average_roundtrip_B_pv": "### `mos_average_roundtrip_B_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) packet\nround-trip time in microseconds present throughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_roundtrip_B_pv\", \"$avp(mos_average_roundtrip_B)\")\n...\n```\n",
   "mos_average_roundtrip_leg_B_pv": "### `mos_average_roundtrip_leg_B_pv` (string)\n\nThe name of a pseudovariable to hold the average (median) packet\nround-trip time of the specific call leg in microseconds present\nthroughout the call.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_roundtrip_leg_B_pv\", \"$avp(mos_average_roundtrip_leg_B)\")\n...\n```\n",
   "mos_average_samples_B_pv": "### `mos_average_samples_B_pv` (string)\n\nThe name of a pseudovariable to hold the number of samples used to\ndetermine the other \u201caverage\u201d MOS data points.\n\nThere is no default value.\n\nThis value is filled in after invoking \u201crtpengine_delete\u201d,\n\u201crtpengine_query\u201d, or \u201crtpengine_manage\u201d if the command resulted in a\ndeletion of the call (or call branch).\n\nOnly call legs matching the rtpengine label given in the\n\u201cmos_B_label_pv\u201d will be used in calculating this statistics value.\n\n```\n...\nmodparam(\"rtpengine\", \"mos_average_samples_B_pv\", \"$avp(mos_average_samples_B)\")\n...\n```\n",
   "dtmf_event_callid": "### `dtmf_event_callid` (string)\n\nThe name of a pseudovariable to be filled in with the callid of the\ntriggered dtmf event.\n\nBy default, this parameter is not set.\n\n```\n...\nmodparam(\"rtpengine\", \"dtmf_event_callid\", \"$avp(dtmf_event_callid)\")\n...\n```\n",
   "dtmf_event_source_tag": "### `dtmf_event_source_tag` (string)\n\nThe name of a pseudovariable to be filled in with the source tag that\ntriggered the dtmf event.\n\nBy default, this parameter is not set.\n\n```\n...\nmodparam(\"rtpengine\", \"dtmf_event_source_tag\", \"$avp(dtmf_event_source_tag)\")\n...\n```\n",
   "dtmf_event_timestamp": "### `dtmf_event_timestamp` (string)\n\nThe name of a pseudovariable to be filled in with the timestamp when the\ndtmf event was triggered.\n\nBy default, this parameter is not set.\n\n```\n...\nmodparam(\"rtpengine\", \"dtmf_event_timestamp\", \"$avp(dtmf_event_timestamp)\")\n...\n```\n",
   "dtmf_event": "### `dtmf_event` (string)\n\nThe name of a pseudovariable to be filled in with the triggered DTMF\nvalue.\n\nBy default, this parameter is not set.\n\n```\n...\nmodparam(\"rtpengine\", \"dtmf_event\", \"$avp(dtmf_event)\")\n...\n```\n",
   "control_cmd_tos": "### `control_cmd_tos` (integer)\n\nThe parameter is used to set the value of \u201ctype of service (tos)\u201d for\nthe control commands (such as rtpengine_offer(), rtpengine_answer()\netc).\n\nThere is no default value. By default this feature is not used.\n\nThe values not falling into the range \u201c0-255\u201d will be simply ignored.\n\n```\n...\nmodparam(\"rtpengine\", \"control_cmd_tos\", 144)\n...\n```\n",
   "hash_algo": "### `hash_algo` (integer)\n\nHashing algorithm to be used in node selection algorithm. Now there are\n3 possibilities: legacy algorithm - 0 (very basic hash over callid),\nSHA1 - 1 (apply sha1 over the callid and calculate hash) or CRC32 - 2\n(calculate crc32 sum over the callid).\n\nDefault value is 0, legacy algorithm.\n\nThe values not falling into the range \u201c0-2\u201d are ignored.\n\n```\n...\n### use SHA1 instead of legacy algorithm\nmodparam(\"rtpengine\", \"hash_algo\", 1)\n\n### use CRC32 instead of legacy algorithm\nmodparam(\"rtpengine\", \"hash_algo\", 2)\n...\n```\n",
   "wsapi": "### `wsapi` (string)\n\nConfigure a backend API for websocket usage. Currently the only\nsupported setting is \u201clwsc\u201d (libwebsockets). If unset, then the\nwebsocket protocol cannot be used.\n\n```\n...\nmodparam(\"rtpengine\", \"wsapi\", \"lwsc\")\n...\n```\n",
   "dtmf_events_sock": "### `dtmf_events_sock` (string)\n\nDefinition of IPv4/IPv6 UDP socket used to receive dtmf events from\nRTPEngine.\n\nDTMF events coming from RTPEngine will trigger rtpengine:dtmf-event\nroute.\n\n*Default value is \u201cNONE\u201d (disabled).*\n\n```\n...\nmodparam(\"rtpengine\", \"dtmf_events_sock\", \"127.0.0.1:2223\")\n...\n```\n",
   "ping_mode": "### `ping_mode` (integer)\n\nSpecify if the RTPEngine instances have to be pinged at startup to\ndetect if they are active. Set it to 0 to disable pinging and to 1 to\nactivate pinging.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"rtpengine\", \"ping_mode\", 0)\n...\n```\n"
  },
  "functions": {
   "set_rtpengine_set": "### `set_rtpengine_set(setid[, setid])`\n\nSets the ID of the RTP proxy set to be used for the next\nrtpengine_delete(), rtpengine_offer(), rtpengine_answer() or\nrtpengine_manage() command. The parameter can be an integer or a config\nvariable holding an integer.\n\nA second set ID can be specified to daisy-chain two RTP proxies. The two\nset IDs must be distinct from each other and there must not be any\noverlap in the proxies present in both sets. In this use case, the\nrequest (offer, answer, etc) is first sent to an RTP proxy from the\nfirst set, which rewrites the SDP body and sends it back to the module.\nThe rewritten SDP body is then used to make another request to an RTP\nproxy from the second set, which rewrites the SDP body another time and\nsends it back to the module to be placed back into the SIP message. This\nis useful if you have a set of RTP proxies that the caller must use, and\nanother distinct set of RTP proxies that the callee must use.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\nset_rtpengine_set(\"2\");\nrtpengine_offer();\n...\n```\n",
   "rtpengine_offer": "### `rtpengine_offer([flags])`\n\nRewrites SDP body to ensure that media is passed through an RTP proxy.\nTo be invoked on INVITE for the cases the SDP bodies are in INVITE and\n200 OK and on 200 OK when SDP bodies are in 200 OK and ACK.\n\nThe function will return true on success and false (-1) on various\nfailures, like using rtp_engine_offer() on a SIP MESSAGE request or\ncommunication with rtpengine fails.\n\nMeaning of the parameters is as follows:\n\n- *flags* - flags to turn on some features.\n\n  The \u201cflags\u201d string is a list of space-separated items. Each item is\n  either an individual token, or a token in \u201ckey=value\u201d format. The\n  possible tokens are described below.\n\n  - *via-branch=...* - Include the \u201cbranch\u201d value of one of the \u201cVia\u201d\n    headers in the request to the RTP proxy. Possible values are: \u201c1\u201d -\n    use the first \u201cVia\u201d header; \u201c2\u201d - use the second \u201cVia\u201d header;\n    \u201cauto\u201d - use the first \u201cVia\u201d header if this is a request, or the\n    second one if this is a reply; \u201cextra\u201d - don't take the value from a\n    header, but instead use the value of the \u201cextra_id_pv\u201d variable;\n    \u201cnext\u201d - use the branch ID generated by Kamailio for the next\n    outgoing branch; \u201cauto-next\u201d - use \u201cnext\u201d in requests and \u201c1\u201d in\n    replies; \u201cauto-extra\u201d - use \u201cextra\u201d in requests and \u201c1\u201d in replies.\n    This can be used to create one media session per branch on the RTP\n    proxy. When sending a subsequent \u201cdelete\u201d command to the RTP proxy,\n    you can then stop just the session for a specific branch when\n    passing the flag '1' or '2' in the \u201crtpengine_delete\u201d, or stop all\n    sessions for a call when not passing one of those two flags there.\n    This is especially useful if you have serially forked call scenarios\n    where the RTP proxy gets an \u201coffer\u201d command for a new branch, and\n    then a \u201cdelete\u201d command for the previous branch, which would\n    otherwise delete the full call, breaking the subsequent \u201canswer\u201d for\n    the new branch. *This flag is only supported by the Sipwise\n    rtpengine RTP proxy at the moment!*\n\n  - *asymmetric* - flags that UA from which message is received doesn't\n    support symmetric RTP. Disables learning of endpoint addresses in\n    the Sipwise rtpengine proxy.\n\n  - *no-redis-update* - this flag can be used by Kamailio in order to\n    tell rtpengine not to persist the call into Redis upon receiving\n    offer/answer() control commands. If flag is not set, default action\n    is rtpengine persists call to redis.\n\n  - *force-answer* - force \u201canswer\u201d, that is, only rewrite SDP when\n    corresponding session already exists in the RTP proxy. By default is\n    on when the session is to be completed. This is only necessary when\n    the offer was sent by `rtpengine_offer()`, and the answer is handled\n    by `rtpengine_manage()`.\n\n  - *direction=...* - this option specifies a logical network interface\n    and should be given exactly twice. It enables RTP bridging between\n    different addresses or networks of the same family (e.g. IPv4 to\n    IPv4). The first instance of the option specifies the interface that\n    the originator of this message should be using, while the second\n    instance specifies the interface that the target should be using.\n    For example, if the SIP message was sent by an endpoint on a private\n    network and will be sent to an endpoint on the public internet, you\n    would use \u201cdirection=priv direction=pub\u201d if those two logical\n    network interfaces were called \u201cpriv\u201d and \u201cpub\u201d in your RTP proxy's\n    configuration respectively. The direction must only be specified in\n    for initial SDP offer; answers or subsequent offers can omit this\n    option.\n\n  - *internal, external* - shorthand for \u201cdirection=internal\u201d and\n    \u201cdirection=external\u201d respectively. Useful for brevity or as legacy\n    option if the RTP proxy only supports two network interfaces instead\n    of multiple, arbitrarily named ones.\n\n  - *address-family=...* - instructs the RTP proxy that the recipient of\n    this SDP body expects to see addresses of a particular family.\n    Possible values are \u201cIP4\u201d and \u201cIP6\u201d. For example, if the SDP body\n    contains IPv4 addresses but the recipient only speaks IPv6, you\n    would use \u201caddress-family=IP6\u201d to bridge between the two address\n    families.\n\n    Sipwise rtpengine remembers the address family preference of each\n    party after it has seen an SDP body from them. This means that\n    normally it is only necessary to explicitly specify the address\n    family in the \u201coffer\u201d, but not in the \u201canswer\u201d.\n\n    Note: Please note, that this will only work properly with\n    non-dual-stack user-agents or with dual-stack clients according to\n    RFC6157 (which suggest ICE for Dual-Stack implementations). This\n    short-cut will not work properly with RFC4091 (ANAT) compatible\n    clients, which suggests having different m-lines with different\n    IP-protocols grouped together.\n\n  - *force* - instructs the RTP proxy to ignore marks inserted by\n    another RTP proxy in transit to indicate that the session already\n    goes through another proxy. Allows creating a chain of proxies. Not\n    supported and ignored by Sipwise rtpengine.\n\n  - *trust-address* - flags that IP address in SDP should be trusted.\n    Starting with rtpengine 3.8, this is the default behaviour. In older\n    versions, without this flag the RTP proxy ignores the address in the\n    SDP and uses source address of the SIP message as media address\n    which is passed to the RTP proxy.\n\n  - *SIP-source-address* - the opposite of *trust-address*. Restores the\n    old default behaviour of ignoring endpoint addresses in the SDP\n    body.\n\n  - *received-from=IP* - Configure the SIP-source-address IP explicitly,\n    which will be useful when two kamailio is cascaded where first\n    kamailio is handling NAT and second kamailio RTPEngine.\n\n  - *replace-origin* - flags that IP from the origin description (o=)\n    should be also changed.\n\n  - *replace-session-connection* - flags to change the session-level SDP\n    connection (c=) IP if media description also includes connection\n    information.\n\n  - *symmetric* - flags that for the UA from which message is received,\n    support symmetric RTP must be forced. Does nothing with the Sipwise\n    rtpengine proxy as it is the default.\n\n  - *repacketize=NN* - requests the RTP proxy to perform\n    re-packetization of RTP traffic coming from the UA which has sent\n    the current message to increase or decrease payload size per each\n    RTP packet forwarded if possible. The NN is the target payload size\n    in ms, for the most codecs its value should be in 10ms increments,\n    however for some codecs the increment could differ (e.g. 30ms for\n    GSM or 20ms for G.723). The RTP proxy would select the closest value\n    supported by the codec. This feature could be used for significantly\n    reducing bandwith overhead for low bitrate codecs, for example with\n    G.729 going from 10ms to 100ms saves two thirds of the network\n    bandwith. Not supported by Sipwise rtpengine.\n\n  - *ICE=...* - controls the RTP proxy's behaviour regarding ICE\n    attributes within the SDP body. Possible values are: \u201cforce\u201d -\n    discard any ICE attributes already present in the SDP body and then\n    generate and insert new ICE data, leaving itself as the *only* ICE\n    candidates; \u201cforce-relay\u201d - discard any \u201crelay\u201d type ICE attributes\n    already present in the SDP body and then generate and insert itself\n    as the *only* ICE \u201crelay\u201d candidates; \u201cremove\u201d instructs the RTP\n    proxy to discard any ICE attributes and not insert any new ones into\n    the SDP. The default (if no \u201cICE=...\u201d is given at all), new ICE data\n    will only be generated if no ICE was present in the SDP originally;\n    otherwise the RTP proxy will only insert itself as *additional* ICE\n    candidate. Other SDP substitutions (c=, m=, etc) are unaffected by\n    this flag.\n\n  - *RTP, SRTP, DTLS, AVP, AVPF* - These flags control the RTP transport\n    protocol that should be used towards the recipient of the SDP. If\n    none of them are specified, the protocol given in the SDP is left\n    untouched. Otherwise, the \u201cSRTP\u201d flag indicates that SRTP should be\n    used, while \u201cRTP\u201d indicates that both SRTP and AVPF should not be\n    used. \u201cAVPF\u201d indicates that the advanced RTCP profile with feedback\n    messages should be used, and \u201cAVP\u201d indicates that the regular RTCP\n    profile should be used. See also the next set of flags below.\n\n  - *RTP/AVP, RTP/SAVP, UDP/TLS/RTP/SAVP, RTP/AVPF, RTP/SAVPF,\n    UDP/TLS/RTP/SAVPF* - these serve as an alternative, more explicit\n    way to select between the different RTP protocols and profiles\n    supported by the RTP proxy. For example, giving the flag \u201cRTP/SAVPF\u201d\n    has the same effect as giving the two flags \u201cSRTP AVPF\u201d.\n\n  - *to-tag* - force inclusion of the \u201cTo\u201d tag. Normally, the \u201cTo\u201d tag\n    is always included when present, except for \u201cdelete\u201d messages.\n    Including the \u201cTo\u201d tag in a \u201cdelete\u201d messages allows you to be more\n    selective about which dialogues within a call are being torn down.\n\n  - *to-tag=...* - use the specified string as \u201cTo\u201d tag instead of the\n    actual \u201cTo\u201d tag from the SIP message, and force inclusion of the tag\n    in the message as per above.\n\n  - *from-tag=...* - use the specified string as \u201cFrom\u201d tag instead of\n    the actual \u201cFrom\u201d tag from the SIP message.\n\n  - *call-id=...* - use the specified string as \u201cCall-ID\u201d instead of the\n    actual \u201cCall-ID\u201d from the SIP message.\n\n  - *rtcp-mux-demux* - if rtcp-mux (RFC 5761) was offered, make the RTP\n    proxy accept the offer, but not offer it to the recipient of this\n    message.\n\n  - *rtcp-mux-reject* - if rtcp-mux was offered, make the RTP proxy\n    reject the offer, but still offer it to the recipient. Can be\n    combined with \u201crtcp-mux-offer\u201d to always offer it.\n\n  - *rtcp-mux-offer* - make the RTP proxy offer rtcp-mux to the\n    recipient of this message, regardless of whether it was offered\n    originally or not.\n\n  - *rtcp-mux-accept* - if rtcp-mux was offered, make the RTP proxy\n    accept the offer and also offer it to the recipient of this message.\n    Can be combined with \u201crtcp-mux-offer\u201d to always offer it.\n\n  - *media-address=...* - force a particular media address to be used in\n    the SDP body. Address family is detected automatically.\n\n  - *TOS=...* - change the IP TOS value for all outgoing RTP packets\n    within the entire call in both directions. Only honoured in an\n    \u201coffer\u201d, ignored for an \u201canswer\u201d. Valid values are 0 through 255,\n    given in decimal. If this option is not specified, the TOS value\n    will revert to the default TOS (normally 184). A value of -1 may be\n    used to leave the currently used TOS unchanged.\n\n  - *delete-delay=...* - override the default delay (in seconds) before\n    a call is actually deleted from memory. Can be set to zero to\n    effectuate immediate deletion. This option only makes sense for\n    *delete* operations.\n\n  - *strict-source* - instructs the RTP proxy to check the source\n    addresses of all incoming RTP packets and drop the packets if the\n    address doesn't match.\n\n  - *media-handover* - the antithesis of *strict-source*. Instructs the\n    RTP proxy not only to accept mismatching RTP source addresses (as it\n    normally would), but also to accept them as the new endpoint address\n    of the opposite media flow. Not recommended as it allows media\n    streams to be hijacked by an attacker.\n\n  - *DTLS=...* - influence the behaviour of DTLS-SRTP. Possible values\n    are \u201cno\u201d or \u201coff\u201d to suppress offering or accepting DTLS-SRTP, and\n    \u201cpassive\u201d to prefer participating in DTLS-SRTP in a passive role.\n\n  - *SDES-off* - don't offer SDES when it normally would. In an SRTP\n    context, this leaves DTLS-SRTP as the only other option.\n\n  - *SDES-unencrypted_srtp, SDES-unencrypted_srtcp,\n    SDES-unauthenticated_srtp* - these directly reflect the SDES session\n    parameters from RFC 4568 and will make the RTP proxy offer these\n    parameters when offering SDES.\n\n  - *SDES-encrypted_srtp, SDES-encrypted_srtcp,\n    SDES-authenticated_srtp* - the opposites of the flags above. Useful\n    if accepting these parameters is not desired and they should be\n    rejected instead.\n\n  - *SDES-nonew* - don't add any new crypto suites into the offer. This\n    means, offered SDES crypto suites will be accepted, meanwhile no new\n    is going to be generated by RTPEngine. It takes precedence over the\n    `SDES-no` and `SDES-only` flags, if used in combination.\n\n  - *SDES-pad* - RFC 4568 (section 6.1) is somewhat ambiguous regarding\n    the base64 encoding format of `a=crypto` parameters added to an\n    SDP body. The default interpretation is that trailing `=`\n    characters used for padding should be omitted. With this flag set,\n    these padding characters will be left in place.\n\n  - *unidirectional* - allows kernelization of one-way streams in the\n    Sipwise rtpengine proxy. This is especially useful when the first\n    call leg is handled by some rtpengine machine while the second call\n    leg is handled by other rtpengine machine.\n\n  - *record-call=on* - instructs RTPEngine to record the session. Use it\n    in rtpengine_offer() to start recording immediately and save the\n    call metadata, as alternative to start_recording().\n\n  - *metadata* - a generic metadata string. The metadata will be used\n    when recording calls to provide custom additional information. More\n    details about this are found in the rtpengine README.\n\n  - *codec-transcode=...* - allows codecs to be added to the list of\n    offered codecs even if they were not present in the original list of\n    codecs. In this case, the transcoding engine will be engaged. Only\n    codecs that are supported for both decoding and encoding can be\n    added in this manner. More details about this are found in the\n    rtpengine README.\n\n  - *codec-set=...* - set codec options (bitrate etc) for codecs that\n    are implicitly accepted for transcoding from the offering side.\n\n  - *codec-strip=...* - strips given codec from sdp\n\n  - *codec-offer=...* - offer given codec from sdp. More details about\n    this are found in the rtpengine README.\n\n  - *codec-except=...* - same as *codec-offer* but preserves original\n    order\n\n  - *codec-mask=...* - Similar to strip except that codecs listed here\n    will still be accepted and used for transcoding on the offering\n    side. Useful only in combination with codec-transcode. *all* keyword\n    can be used to mask all offered codecs\n\n  - *codec-accept=...* - Similar to `mask` and `consume` but doesn't\n    remove the codec from the list of offered codecs. This means that a\n    codec listed under `accept` will still be offered to the remote\n    peer, but if the remote peer rejects it, it will still be accepted\n    towards the original offerer and then used for transcoding. It is a\n    more selective version of what the `always transcode` flag does.\n\n  - *codec-consume=...* - Identical to mask but enables the transcoding\n    engine even if no other transcoding related options are given.\n\n  - *T.38=decode* - If the offered SDP contains a media section\n    advertising T.38 over UDPTL, translate it to a regular audio media\n    section over RTP. By default, PCMU and PCMA will be used as audio\n    codecs, but that can be overridden using the codec options described\n    above. Other transport protocols (e.g. SRTP) can also be selected in\n    the same way. If the offered SDP does not contain a T.38 section,\n    then this flag has no effect.\n\n  - *T.38=force* - Any audio media section (over RTP) in the offered SDP\n    will be translated into a T.38 section over UDPTL.\n\n  - *T.38=stop* - Stops a previously established T.38 to audio gateway\n    and reverts the session back to media passthrough. This is useful\n    when handling a rejected T.38 offer.\n\n\n  Check also the documentation of RTPEngine, these flags are documented\n  there as well: <https://github.com/sipwise/rtpengine>.\n\nThis function can be used from ANY_ROUTE.\n\n```\nroute {\n...\n    if (is_method(\"INVITE\")) {\n        if (has_body(\"application/sdp\")) {\n            if (rtpengine_offer())\n                t_on_reply(\"1\");\n        } else {\n            t_on_reply(\"2\");\n        }\n    }\n    if (is_method(\"ACK\") && has_body(\"application/sdp\"))\n        rtpengine_answer();\n...\n}\n\nonreply_route[1]\n{\n...\n    if (has_body(\"application/sdp\"))\n        rtpengine_answer();\n...\n}\n\nonreply_route[2]\n{\n...\n    if (has_body(\"application/sdp\"))\n        rtpengine_offer();\n...\n}\n...\nif (has_body(\"application/sdp\")) {\n        if (rtpengine_offer(\"codec-mask=all codec-transcode=PCMU codec-transcode=PCMA\"))\n                t_on_reply(\"1\");\n}\n\n...\n\nroute {\n...\n    if (is_method(\"INVITE\")) {\n        if (has_body(\"application/sdp\")) {\n            if (rtpengine_offer(\"codec-mask=opus codec-accept=opus codec-strip=PCMU codec-transcode=PCMU\"))\n                t_on_reply(\"1\");\n        }\n    }\n...\n}\n\nonreply_route[1]\n{\n...\n    if (has_body(\"application/sdp\"))\n        rtpengine_answer(\"codec-strip=PCMU codec-strip=PCMA\");\n...\n}\n...\n```\n",
   "rtpengine_answer": "### `rtpengine_answer([flags])`\n\nRewrites SDP body to ensure that media is passed through an RTP proxy.\nTo be invoked on 200 OK for the cases the SDP bodies are in INVITE and\n200 OK and on ACK when SDP bodies are in 200 OK and ACK.\n\nSee rtpengine_offer() function description above for the meaning of the\nparameters.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\nSee rtpengine_offer() function example above for example.\n",
   "rtpengine_info": "### `rtpengine_info([flags])`\n\nSend an updated offer to rtpengine. This is meant to be used when\nprocessing Trickle ICE SDP Fragments that are carried in SIP INFO\nmessages and are proxied to endpoints that do not support ICE. With a\nmatching content type, the SDP fragment is used to update rtpengine's\nlist of ICE candidates. No new SDP is returned and so the SIP INFO\nmessage should be consumed after calling this function.\n\nWhile this function supports the same flags as \u201crtpengine_offer\u201d et al,\nit is not normally necessary to provide any.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrtpengine_info();\n...\n```\n",
   "rtpengine_delete": "### `rtpengine_delete([flags])`\n\nTears down the RTP proxy session for the current call. This populates\nthe statistics pseudovariables (such \u201cmos_min_pv\u201d etc).\n\nSee rtpengine_offer() function description above for the meaning of the\nparameters. Note that not all flags make sense for a \u201cdelete\u201d.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrtpengine_delete();\n...\n```\n",
   "rtpengine_query": "### `rtpengine_query([flags])`\n\nQueries the RTP proxy about the current status and statistics of a\nrunning call. This populates the statistics pseudovariables (such\n\u201cmos_min_pv\u201d etc).\n\nSee rtpengine_offer() function description above for the meaning of the\nparameters. Note that not all flags make sense for a \u201cquery\u201d.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrtpengine_query();\n...\n```\n",
   "rtpengine_query_v": "### `rtpengine_query_v(fmt, var)`\n\nQueries the RTP proxy about the current status and statistics of a\nrunning call, converts the response to JSON according to fmt and sets\nthe variable var with the result.\n\nThe fmt parameter can be 'j' for compacted JSON and 'jp' for\npretty-formatted JSON.\n\nThe var parameter has to be the name of a writable variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(rtpengine_query_v(\"j\", \"$var(rdata)\")) {\n    xinfo(\"rtpengine query response: $var(rdata)\\n\");\n}\n...\n```\n",
   "rtpengine_manage": "### `rtpengine_manage([flags])`\n\nManage the RTPEngine session - it combines the functionality of\nrtpengine_offer(), rtpengine_answer() and rtpengine_delete(), detecting\ninternally based on message type and method which one to execute.\n\nIt can take the same parameters as `rtpengine_offer()`. The flags\nparameter to rtpengine_manage() can be a configuration variable\ncontaining the flags as a string.\n\nFunctionality:\n\n- If INVITE with SDP, then do `rtpengine_offer()`\n\n- If INVITE with SDP, when the tm module is loaded, mark transaction\n  with internal flag FL_SDP_BODY to know that the 1xx and 2xx are for\n  `rtpengine_answer()`\n\n- If ACK with SDP, then do `rtpengine_answer()`\n\n- If BYE or CANCEL, or called within a FAILURE_ROUTE[], then call\n  `rtpengine_delete()`. Be careful with calling this function after\n  resuming a suspended transaction (e.g., after t_continue()), because\n  the context of executed route is FAILURE ROUTE (in other words,\n  rtpengine_manage() in the route block of t_continue() does the same as\n  in failure_route; use a branch route to engage rtpengine for a\n  forwarded branch after resuming the transaction).\n\n- It does nothing if used inside event_route[tm:branch-failure:...]\n\n- If reply to INVITE with code >= 300 do `rtpengine_delete()`\n\n- If reply with SDP to INVITE having code 1xx and 2xx, then do\n  `rtpengine_answer()` if the request had SDP or tm is not loaded,\n  otherwise do `rtpengine_offer()`\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrtpengine_manage();\n...\n```\n",
   "start_recording": "### `start_recording([flags])`\n\nThis function will send a signal to the RTP relay to record the RTP\nstream flowing through it. See also the option \u201crecord-call=on\u201d for\nrtpengine_manage()/rtpengine_offer(), which offers an alternative for\ncall recording, saving also call metadata from SDP.\n\nIt can take the same parameters as `rtpengine_manage()`. The flags\nparameter to start_recording can be a configuration variable containing\nthe flags as a string. The call-id flag can be used to start recording\nfor a different call.\n\nThis function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.\n\n```\n...\nstart_recording();\n...\n        \n```\n",
   "stop_recording": "### `stop_recording([flags])`\n\nThis function will send a signal to the RTP relay to stop recording the\nRTP stream flowing through it. See also the option \u201crecord-call=off\u201d for\nrtpengine_manage()/rtpengine_offer(), which offers an alternative for\ncall recording.\n\nIt can take the same parameters as `rtpengine_manage()`. The flags\nparameter to start_recording can be a configuration variable containing\nthe flags as a string. The call-id flag can be used to stop recording\nfor a different call.\n\nThis function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.\n\n```\n...\nstop_recording();\n...\n        \n```\n",
   "block_dtmf": "### `block_dtmf([flags])`\n\nThis function will instruct the RTP proxy to start blocking DTMF event\npackets (RFC 4733). DTMF events will still be processed by the RTP\nproxy, but they won't be forwarded to the receiving peer.\n\nThe call-id flag can be used to block DTMF for a different call.\n\nWithout any flags given, DTMF events will be blocked for the entire\ncall. It's possible to block DTMF directionally only for individual\nparticipants. If the \u201cdirectional\u201d flag is given, DTMF events will be\nblocked for the UA with the currently matching \u201cFrom\u201d tag. Events can be\nblocked for a different UA either by specifying an alternative\n\u201cfrom-tag=...\u201d, or by matching UAs against the media address they\nadvertised in the SDP using the \u201caddress=...\u201d flag (which can contain\neither an IPv4 or IPv6 address).\n\nThis function can be used from REQUEST_ROUTE and ONREPLY_ROUTE.\n\n```\n...\nblock_dtmf();\nblock_dtmf(\"directional\");\nblock_dtmf(\"address=192.168.42.42\");\n...\n        \n```\n",
   "unblock_dtmf": "### `unblock_dtmf([flags])`\n\nReverses the effects of a previously issued `block_dtmf` call. See above\nfor a description of which flags can be used.\n\nIf DTMF events were previously blocked for individual UAs, then\nunblocking DTMF events for the entire call (i.e. no flags given) will\nnot remove these blocks. The flag \u201call\u201d can be used to achieve this.\n\n```\n...\nunblock_dtmf();\nunblock_dtmf(\"all\");\n...\n        \n```\n",
   "block_media": "### `block_media([flags])`\n\nAnalogous to \u201cblock_dtmf\u201d, but blocks media RTP packets instead of DTMF\nevents. When media is blocked, DTMF events still pass through the RTP\nproxy.\n\nSee \u201cblock_dtmf\u201d for a description of the flags that can be used.\n\n```\n...\nblock_media();\nblock_media(\"directional\");\nblock_media(\"address=192.168.42.42\");\n...\n        \n```\n",
   "unblock_media": "### `unblock_media([flags])`\n\nAnalogous to \u201cunblock_dtmf\u201d, but applies to media RTP packets instead of\nDTMF events.\n\nSee \u201cunblock_dtmf\u201d for a description of the flags that can be used.\n\n```\n...\nunblock_media();\nunblock_media(\"all\");\n...\n        \n```\n",
   "silence_media": "### `silence_media([flags])`\n\nIdentical to \u201cblock_media\u201d except that media RTP packets are not simply\nblocked, but instead have their audio payload replaced by silence audio.\nThis is only supported for certain trivial audio codecs (e.g. G.711,\nG.722).\n\nSee \u201cblock_dtmf\u201d for a description of the flags that can be used.\n\n```\n...\nsilence_media();\nsilence_media(\"directional\");\nsilence_media(\"address=192.168.42.42\");\n...\n        \n```\n",
   "unsilence_media": "### `unsilence_media([flags])`\n\nIdentical to \u201cunblock_media\u201d except that it's the counterpart to\n\u201csilence_media\u201d.\n\nSee \u201cunblock_dtmf\u201d for a description of the flags that can be used.\n\n```\n...\nunsilence_media();\nunsilence_media(\"all\");\n...\n        \n```\n",
   "start_forwarding": "### `start_forwarding([flags])`\n\nControls the PCM forwarding feature of the recording daemon. Unlike the\nrecording feature, PCM forwarding can be done directionally for\nindividual call participants only, therefore this command takes the same\nflags as the media/DTMF blocking commands above.\n\nSee \u201cblock_dtmf\u201d for a description of the flags that can be used.\n\n```\n...\nstart_forwarding();\nstart_forwarding(\"directional\");\nstart_forwarding(\"address=192.168.42.42\");\n...\n        \n```\n",
   "stop_forwarding": "### `stop_forwarding([flags])`\n\nAnalogous to \u201cunblock_dtmf\u201d, but controls the PCM forwarding feature\ninstead of DTMF blocking.\n\nSee \u201cunblock_dtmf\u201d for a description of the flags that can be used.\n\n```\n...\nstop_forwarding();\nstop_forwarding(\"all\");\n...\n        \n```\n",
   "play_media": "### `play_media([flags])`\n\nInstructs rtpengine to play a prerecorded announcement to the selected\ncall participant, either from a local file or from a file stored in a\ndatabase. The participant must be selected using the same flags as are\ndescribed under the \u201cblock_dtmf\u201d function. If none of these flags are\ngiven, then the \u201cFrom\u201d tag from the current SIP message context is used.\n\nIf successful, the \u201cmedia_duration\u201d pseudovariable is filled in with the\nduration of the media being played, expressed in milliseconds. If the\nlength of the media could not be determined, it's set to -1.\n\n```\n...\nplay_media(\"file=/use/share/media/hello.wav\");\nplay_media(\"from-tag=tfugklbildfydrtuykgfv db-id=12345\");\n...\n        \n```\n",
   "stop_media": "### `stop_media([flags])`\n\nStops the playback of media previously started by \u201cplay_media\u201d. Media\nplayback is automatically stopped when the end of the media file is\nreached, so this function is only useful to prematurely stop playback.\n\n```\n...\nstop_media();\nstop_media(\"from-tag=5yqaeriguhxcikxj\");\n...\n        \n```\n",
   "play_dtmf": "### `play_dtmf([flags])`\n\nInjects a DTMF event into the media stream. Depending on which codecs\nwere negotiated, this either injects an RFC 2833/4733 DTMF event, or an\nin-band PCM DTMF tone into the audio stream. The flag \u201cinject DTMF\u201d must\nhave been present in both offer and answer messages when the call was\nestablished, which forces all audio to go through rtpengine's\ntranscoding engine.\n\nUsage is similar to \u201cplay_media\u201d with the following exceptions. The\nselected party is not the party that will receive the DTMF event, but\nrather the party which is generating the event. This is to support DTMF\nevents that are carried in SIP INFO messages. Instead of specifying a\nmedia file, a DTMF event code must be specified, as well as optionally a\nduration and the volume. The \u201ccode\u201d can be a number 0 through 15, or a\nDTMF digit (0-9, A-D, *, #). The \u201cduration\u201d is specified in\nmilliseconds and defaults to 250, within a range of 100-5000. The\n\u201cvolume\u201d is specified in absolute decibels, with a default of -8 db.\n\nMultiple consecutive DTMF events can be queued up by calling this\nfunction multiple times consecutively. RTPengine will play out the DTMF\nevents in sequence, separated by a default pause of 100 ms. An\nalternative pause length can be given through the \u201cpause\u201d option,\nbetween 100 and 5000 ms.\n\n```\n...\nplay_dtmf(\"from-tag=5yqaeriguhxcikxj code=#\");\nplay_dtmf(\"code=1 volume=5 duration=300 pause=150\");\n...\n        \n```\n"
  }
 },
 "ruxc": {
  "overview": "The module exports utility functions based on libruxc.\n\nAmong them are function to perform HTTP GET and POST queries.\n\nThe ruxc project is available at: <https://github.com/miconda/ruxc>.\n",
  "parameters": {
   "http_timeout": "### `http_timeout` (int)\n\nThe interval in milliseconds after which the HTTP GET or POST query\ntimes out. It is the overall timeout, including DNS resolution,\nconnecting time, redirects, and reading the response body. Slow DNS\nresolution may cause a request to exceed the timeout, because the DNS\nrequest cannot be interrupted with the available APIs. It takes\nprecedence over http_timeout_read() and http_timeout_write(), but not\nhttp_timeout_connect. See also the comments in\n'https://github.com/algesten/ureq/blob/main/src/agent.rs'.\n\nUse 0 to disable setting it in the library.\n\n*Default value is 5000 (5 secs).*\n\n```\n...\nmodparam(\"ruxc\", \"http_timeout\", 2000)\n...\n```\n",
   "http_timeout_connect": "### `http_timeout_connect` (int)\n\nThe interval in milliseconds after which to give up on connecting to the\nHTTP/S server. If http_timeout is set, this one takes precedence. The\nlibrary beneath has a default 30 seconds connect timeout.\n\nUse 0 to disable setting it in the library.\n\n*Default value is 5000 (5 secs).*\n\n```\n...\nmodparam(\"ruxc\", \"http_timeout_connect\", 2000)\n...\n```\n",
   "http_timeout_read": "### `http_timeout_read` (int)\n\nThe interval in milliseconds after which the read on HTTP/S connection\nsocket timeouts. If http_timeout is set, it takes precedence.\n\nUse 0 to disable setting it in the library.\n\n*Default value is 5000 (5 secs).*\n\n```\n...\nmodparam(\"ruxc\", \"http_timeout_read\", 2000)\n...\n```\n",
   "http_timeout_write": "### `http_timeout_write` (int)\n\nThe interval in milliseconds after which the write on HTTP/S connection\nsocket timeouts. If http_timeout is set, it takes precedence.\n\nUse 0 to disable setting it in the library.\n\n*Default value is 5000 (5 secs).*\n\n```\n...\nmodparam(\"ruxc\", \"http_timeout_write\", 2000)\n...\n```\n",
   "http_tlsmode": "### `http_tlsmode` (int)\n\nThe mode to connect over TLS to HTTPS sites: 0 accept all certificates;\n1 - accept trusted certificates.\n\n*Default value is 0 (accept all certificates).*\n\n```\n...\nmodparam(\"ruxc\", \"http_tlsmode\", 1)\n...\n```\n",
   "http_reuse": "### `http_reuse` (int)\n\nSet to 1 in order to reuse the connection for all requests (each\nKamailio process has its own connection). Useful to avoid TCP connect\n(and TLS handshake) when all requests are performed against the same\nHTTP/S server.\n\nSet to 2 in order to keep connections per base URL (scheme://host:port)\nindexed in a hash map. Useful when doing HTTP/S requests to many\nservers.\n\n*Default value is 0 (new connection for each request).*\n\n```\n...\nmodparam(\"ruxc\", \"http_reuse\", 1)\n...\n```\n",
   "http_retry": "### `http_retry` (int)\n\nHow many times to retry if the HTTP request does not get a 200 OK\nresponse.\n\n*Default value is 0 (no retry).*\n\n```\n...\nmodparam(\"ruxc\", \"http_retry\", 2)\n...\n```\n",
   "http_logtype": "### `http_logtype` (int)\n\nSet the log type for libruxc http functions: 0 - stdout; 1 - syslog.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ruxc\", \"http_logtype\", 1)\n...\n```\n",
   "http_debug": "### `http_debug` (int)\n\nSet the debug mode for libruxc http functions: 0 - no debug; 1 - errors;\n2 - debug.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"ruxc\", \"http_debug\", 1)\n...\n```\n"
  },
  "functions": {
   "ruxc_http_get": "### `ruxc_http_get(url, hdrs, respv)`\n\nPerform a HTTP GET request to \"url\", storing the response body in the\n\"respv\" variable. The \"hdrs\" can be empty string to skip setting them.\nThe first two parameters can contain variables that are evaluated at\nruntime. The \"respv\" has to be the name of a writable variable.\n\nThe function returns response code of HTTP reply or negative value if\nsomething went wrong.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nruxc_http_get(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n       \"\", \"X-Token: abc\", \"$var(result)\");\nswitch ($rc) {\n    ...\n}\n...\n                \n```\n",
   "ruxc_http_post": "### `ruxc_http_post(url, body, hdrs, respv)`\n\nPerform a HTTP POST request to \"url\", storing the response body in the\n\"respv\" variable. The \"body\" and \"hdrs\" can be empty strings to skip\nsetting them. The first three parameters can contain variables that are\nevaluated at runtime. The \"respv\" has to be the name of a writable\nvariable.\n\nThe function returns response code of HTTP reply or negative value if\nsomething went wrong.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nruxc_http_post(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n       \"\", \"X-Token: abc\", \"$var(result)\");\nswitch ($rc) {\n    ...\n}\n...\n                \n```\n",
   "ruxc_http_delete": "### `ruxc_http_delete(url, body, hdrs, respv)`\n\nPerform a HTTP DELETE request to \"url\", storing the response body in the\n\"respv\" variable. The \"body\" and \"hdrs\" can be empty strings to skip\nsetting them. The first three parameters can contain variables that are\nevaluated at runtime. The \"respv\" has to be the name of a writable\nvariable.\n\nThe function returns response code of HTTP reply or negative value if\nsomething went wrong.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nruxc_http_delete(\"http://api.com/index.php?r_uri=$(ru{s.escape.param})&f_uri=$(fu{s.escape.param})\",\n       \"\", \"X-Token: abc\", \"$var(result)\");\nswitch ($rc) {\n    ...\n}\n...\n                \n```\n"
  }
 },
 "sanity": {
  "overview": "This module aims to implement several sanity checks on incoming requests\nwhich are suggested or even required by a RFC, but are not available yet\nin the core of Kamailio.\n\nThese checks are not required by Kamailio itself for its functionality.\nBut on the other side it does not make much sense if a broken request\ntraverses through a SIP network if it is rejected sooner or later by a\nSIP device any way. As every sanity check cost extra performance because\nof additional parsing and evaluation it is with this module now up to\nthe Kamailio administrator what checks should be done on which request.\n\nThe following checks are available:\n\n- ruri sip version - (1) - checks if the SIP version in the request URI\n  is supported, currently only 2.0.\n\n- ruri scheme - (2) - checks if the URI scheme of the request URI is\n  supported (sip[s]|tel[s]) by Kamailio\n\n- required headers - (4) -checks if the minimum set of required headers\n  To, From, CSeq, Call-ID and Via is present in the request.\n\n- via sip version - (8) - disabled.\n\n- via protocol - (16) - disabled.\n\n- Cseq method - (32) - checks if the method from the CSeq header is\n  equal to the request method.\n\n- Cseq value - (64) - checks if the number in the CSeq header is a valid\n  unsigned integer.\n\n- content length - (128) - checks if the size of the body matches with\n  the value from the Content-Length header.\n\n- expires value - (256) - checks if the value of the Expires header is a\n  valid unsigned integer.\n\n- proxy require - (512) - checks if all items of the Proxy-Require\n  header are present in the list of the extensions from the module\n  parameter proxy_require.\n\n- parse uri's - (1024) - checks if the specified URIs are present and\n  parseable by the Kamailio parsers\n\n- digest credentials (2048) - Check all instances of digest credentials\n  in a message. The test checks whether there are all required digest\n  parameters and that they have meaningful values. *NOTE:* the message\n  will be considered invalid if the authorization scheme differs from\n  \"digest\",\n\n- duplicated To/From tags (4096) - checks for the presence of duplicated\n  tags in To/From headers.\n\n- Authorization header (8192) - checks if the Authorization header is\n  valid if the scheme is \"digest\" (see \"digest credentials\" above),\n  always returns success for other schemes.\n\n- first via header (16384) - checks if the first Via header is\n  available, can be parsed and has an address value.\n",
  "parameters": {
   "default_checks": "### `default_checks` (integer)\n\nThis parameter determines which of the checks from the sanity module are\nexecuted if no parameter was given to the `sanity_check` function call.\nBy default all implemented checks are included in the execution of the\n`sanity_check` function. The integer value is the sum of the check\nnumbers which should be executed by default.\n\nDefault value is \u201c3047\u201d. This resolves to the following list of checks:\nruri_sip_version (1), ruri_scheme (2), required_headers (4), cseq_method\n(32), cseq_value (64), content_length (128), expires_value (256),\nproxy_require (512), digest credentials (2048).\n\n```\n...\nmodparam(\"sanity\", \"default_checks\", 1)\n...\n        \n```\n",
   "uri_checks": "### `uri_checks` (integer)\n\nThis parameter determines which URIs are going to be checked if the\n'parse uri' will be executed.\n\nDefault value is 7. This resolves to the following list of parsed URIs:\nRequest URI (1), From URI (2) and To URI (4). Additionally the Contact\nURI can be also checked (8).\n\n```\n...\nmodparam(\"sanity\", \"uri_checks\", 3)\n...\n        \n```\n",
   "proxy_require": "### `proxy_require` (string)\n\nThis parameter sets the list of supported SIP extensions for this\nKamailio. The value is expected as a comma separated list (leading and\ntrailing whitespaces are stripped from each token) of extensions. This\nlist is separated into single tokens. Each token from a proxy require\nheader will be compared with the tokens from this list.\n\n```\n...\nmodparam(\"sanity\", \"proxy_require\", \"foo, bar\")\n...\n        \n```\n",
   "autodrop": "### `autodrop` (integer)\n\nThis parameter controls whether the module drops the SIP message\nautomatically if the sanity checks fail. Default value is 1 (auto drop).\nIf set to 0, sanity_check() function will return -1 (false) to\nconfiguration file, allowing to write log messages for example - be sure\nyou \u201cexit\u201d execution of config without sending a SIP reply because it is\nsent by module itself.\n\n```\n...\nmodparam(\"sanity\", \"autodrop\", 1)\n...\n        \n```\n",
   "noreply": "### `noreply` (int)\n\nIf set to 1, then the module does not send a SIP reply internally in\ncase there is an error detected when performing the sanity checks. There\nis the option to send the reply from config file with functions from sl\nor tm module as well as sanity_reply() from this module.\n\nDefault value: 0.\n\n```\n...\nmodparam(\"sanity\", \"noreply\", 1)\n...\n        \n```\n"
  },
  "functions": {
   "sanity_check": "### `sanity_check([msg_checks [, uri_checks]])`\n\nThis function makes a row of sanity checks over the given SIP request.\nThe behavior of the function is also controlled by `autodrop` parameter.\nIf autodrop=0, the function returns false (-1) if one of the checks\nfailed. When autodrop=1, the function stops the execution of\nconfiguration file. In both cases, if one of the checks fails the module\nsends a precise error reply via SL `send_reply()`. Thus there is no need\nto reply with a generic error message.\n\nThe parameters can be static integers or variables holding integer\nvalues.\n\n```\n...\nif (!sanity_check()) {\n    exit;\n}\n...\n\n        \n```\n\nOptionally the function takes an integer argument which overwrites the\nglobal module parameter `default_checks`. This makes it possible to run\ncertain tests from script regions. The integer value is again the sum of\nthe checks (like for the module parameter) which should be executed at\nthis function call.\n\n```\n...\nif (method==\"REGISTER\" && !sanity_check(\"256\")) {\n    /* the register contains an invalid expires value and is replied with a 400 */\n    exit;\n}\n...\n\n        \n```\n\nOptionally the function takes a second integer argument which overwrites\nthe global module parameter uri_checks and thus determines which URIs\nwill be checked if the parse uri test will be executed.\n\n```\n...\nif (method==\"INVITE\" && !sanity_check(\"1024\", \"6\")) {\n    /* the INVITE contains an invalid From or To header and is replied with a 400 */\n    exit;\n}\n...\n\n        \n```\n",
   "sanity_reply": "### `sanity_reply()`\n\nSend a SIP reply using the code and reason text set internally by the\nmodule when detecting errors while performing the sanity checks. It is\ndone only when parameter noreply is set to 1.\n\n```\n...\nif(!sanity_check(\"1024\", \"6\")) {\n   xdbg(\"sanity checks failed\\n\");\n   sanity_reply();\n   exit;\n}\n...\n        \n```\n"
  }
 },
 "sca": {
  "overview": "The sca module implements Shared Call Appearances. It handles SUBSCRIBE\nmessages for call-info and line-seize events, and sends call-info\nNOTIFYs to line subscribers to implement line bridging. The module\nimplements SCA as defined in Broadworks SIP Access Side Extensions\nInterface Specifications, Release 13.0, version 1, sections 2, 3 and 4.\n\nSCA group members receive call state notifications when other group\nmembers participate in calls. An SCA caller can place a call on hold,\nand the call may be retrieved from hold by another member of the group.\n\nSubscribers to SCA call-info events SUBSCRIBE to their address-of-record\n(AoR), asking the application server to send call-info NOTIFYs with line\nstate information as lines in the subscriber group are used.\n\nFor example, when an SCA subscriber takes the phone off hook, it sends a\nline-seize SUBSCRIBE to the application server. The application server\nacknowledges the request, and sends to the subscriber a line-seize\nNOTIFY with the appearance index of the line claimed for the subscriber.\nThe application also sends call-info NOTIFYs to the other SCA\nsubscribers to the AoR, letting them know that an appearance within the\ngroup has gone off hook. Subscribers update their display appropriately.\n\nSubscribers to an SCA address-of-record will receive call-info NOTIFYs\nwhen a member of the group seizes a line (seized); receives a 180\nringing response from the remote party (ringing); receives a 183\nprogressing response from the remote party (progressing); when the\nremote party answers the call (active); when either party in the call\nplaces the call on hold (held); and when an SCA line goes back on hook\n(idle).\n\nThe call-info subscriber information is stored in memory and is\nperiodically written to the database. Call state information is stored\nin memory. A future release may periodically write call state to the\ndatabase, as well. The database is purely for restoring subscriptions\nafter a restart of the application server. Subscriber information is\nalso flushed to the database when the service is stopped.\n\nAt the time of this writing, Polycom and Cisco handsets are known to\nimplement the call-info and line-seize event packages defined in the\ndocument, which may be found freely on the web.\n\nTo date, this module has only been tested with Polycom Soundpoint 550s\nand 650s running Polycom SIP 3.3.4.\n",
  "parameters": {
   "hash_table_size": "### `hash_table_size` (integer)\n\nSize, as a power of two, of the shared memory hash table containing the\ncall-info subscriptions and the appearance state. A larger power of two\nmeans better performance (fewer collisions, making for fewer subscriber\nURI comparisons) at the expense of increased shared memory use.\n\n*Default value is 9 (2 ^ 9 == 512).*\n\n```\n...\n# create shared memory hash table with 2^8 (256) slots\nmodparam( \"sca\", \"hash_table_size\", 8 )\n...\n        \n```\n",
   "call_info_max_expires": "### `call_info_max_expires` (integer)\n\nThe maximum allowed call-info subscription time in seconds.\n\n*Default value is 3600 (1 hour).*\n\n```\n...\nmodparam( \"sca\", \"call_info_max_expires\", 1800 )\n...\n        \n```\n",
   "line_seize_max_expires": "### `line_seize_max_expires` (integer)\n\nThe maximum allowed line-seize subscription time in seconds.\n\n*Default value is 15 (15 seconds).*\n\nA maximum line-seize subscription time of 15 seconds is recommended in\nthe SIP Access Side Extensions document. This interval is purposely\nshort to prevent a client from seizing an appearance without making a\ncall for extended periods of time.\n\n```\n...\nmodparam( \"sca\", \"line_seize_max_expires\", 30 )\n...\n                \n```\n",
   "purge_expired_interval": "### `purge_expired_interval` (integer)\n\nThe period of time in seconds between purges of expired call-info and\nline-seize subscriptions.\n\n*Default value is 120 (2 minutes).*\n\nOn finding an expired subscription, the module removes the subscription\nfrom the shared memory hash table, and sends a NOTIFY with\nSubscription-State \"terminated;expired\" header value to the subscriber.\nIt also NOTIFYs other members of the group, in the event that the\nexpired subscription was a line-seize.\n\n```\n...\nmodparam( \"sca\", \"purge_expired_interval\", 60 )\n...\n                \n```\n",
   "db_url": "### `db_url` (str)\n\nURL of database to which subscribers will be written.\n\n*Default value is mysql://kamailio:kamailiorw@localhost/kamailio*\n\n```\n...\nmodparam( \"sca\", \"db_url\", \"mysql://kamailio:kamailiorw@localhost/kamailio\" )\n...\n        \n```\n",
   "subs_table": "### `subs_table` (str)\n\nName of the database table where call-info subscriptions are written.\n\n*Default value is \u201csca_subscriptions\u201d.*\n\n```\n...\nmodparam( \"sca\", \"subs_table\", \"call_info_subscriptions\" )\n...\n                \n```\n",
   "db_update_interval": "### `db_update_interval` (integer)\n\nPeriod in seconds between writes of call-info subscriber information to\nthe database.\n\n*Default value is 300 (5 minutes).*\n\n```\n...\nmodparam( \"sca\", \"db_update_interval\", 120 )\n...\n        \n```\n",
   "onhold_bflag": "### `onhold_bflag` (integer)\n\nWhen bflag is set the media will be treated as on-hold and sdp parse\nwill be skipped. If the bflag is not set the sdp will be parsed to\ndetect on-hold.\n\n*Default value is -1 (disabled).*\n\n```\n...\nmodparam(\"sca\", \"onhold_bflag\", 15)\n...\n```\n",
   "server_address": "### `server_address` (string)\n\nThe server address which will become the value of Contact header filed\nfor reply messages.\n\n*Default value is \"\" (disabled).*\n\n```\n...\nmodparam(\"sca\", \"server_address\", \"sip:10.10.10.10:5060\")\n...\n```\n"
  },
  "functions": {
   "sca_handle_subscribe": "### `sca_handle_subscribe()`\n\nThe function handling call-info and line-seize SUBSCRIBE requests. It\nstores or updates the subscriptions in shared memory, and sends NOTIFYs\nto the subscriber and other members of the group as needed.\n\nFor example, a line-seize SUBSCRIBE will cause the module to reserve an\nappearance index for the subscriber; send a line-seize NOTIFY to the\nsubscriber indicating which appearance index it must use; and send\ncall-info NOTIFYs to other subscribers to the address-of-record letting\nthem know the appearance is off hook.\n\nThis function can be used from the REQUEST_ROUTE.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n\n```\n...\nif ( is_method( \"SUBSCRIBE\" )) {\n    if ( $hdr(Event) == \"call-info\" || $hdr(Event) == \"line-seize\" ) {\n    sca_handle_subscribe();\n    exit;\n    }\n}\n...\n        \n```\n",
   "sca_call_info_update": "### `sca_call_info_update([mask, to, from])`\n\n- *mask* - integer (optional)\n\n  controls what to check as shared line (BOTH, CALLER, CALLEE)\n\n  - 0 - SCA_CALL_INFO_SHARED_NONE (default) check both\n\n  - 1 - SCA_CALL_INFO_SHARED_CALLER\n\n  - 2 - SCA_CALL_INFO_SHARED_CALLEE\n\n\n- *to* - string (optional)\n\n  string to use as To and skip parsing To header from the message. The\n  parameter allows pseudo-variables usage\n\n- *from* - string (optional)\n\n  string to use as From and skip parsing From header from the message.\n  The parameter allows pseudo-variables usage\n\nThe sca_call_info_update function updates call state for SCA\nappearances. If a request or response packet contains a Call-Info\nheader, the function extracts call state from the header and sends\nNOTIFYs to subscribers if needed. If no Call-Info header is included in\nthe packet, the module looks up the To and From URIs to see if either\nare SCA addresses-of-record. If either the To or From URI are SCA AoRs,\nthe function looks up the appearance by dialog and updates call state as\nneeded, sending NOTIFYs to members of the group if the call state has\nchanged.\n\nThe sca_call_info_update function updates call state for INVITE, CANCEL,\nBYE, PRACK and REFER requests and responses.\n\nThis function can be used from the REQUEST_ROUTE, REPLY_ROUTE, and\nFAILURE_ROUTE.\n\n*Return code:*\n\n- *1 - successful*\n\n- *-1 - failed, error logged*\n\n<!-- -->\n\n\n```\n...\nroute\n{\n...\n    sca_call_info_update(0, \"$var(to)\", \"$var(from)@$var(domain)\");\n...\n}\n\nonreply_route[REPLY_ROUTE]\n{\n...\n    if ( status =~ \"[456][0-9][0-9]\" ) {\n    # don't update SCA state here, since there may be\n    # failure route processing (e.g., call forwarding).\n    # update state in failure route instead.\n    break;\n    }\n\n    sca_call_info_update();\n...\n}\n\nfailure_route[FAILURE_ROUTE]\n{\n...\n    sca_call_info_update();\n...\n}\n...\n                \n```\n"
  }
 },
 "sctp": {
  "overview": "This module provides SCTP transport layer for Kamailio. SCTP is an\nacronym for Stream Control Transmission Protocol, read more about it at:\n<http://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol>\n\nThe module itself implements the callbacks required by the core to\nreceive and send SIP messages over SCTP sockets.\n\nThe core Makefile variable SCTP must be set to 1 (which is by default\nset to 1 in Makefile.defs) and sources compiled with -DUSE_SCTP\n(automatically set when SCTP=1). In other words, if core Makefiles are\nnot changed and SCTP variable is not overwritten from command line, then\nthe SCTP support in core is enabled.\n\nNote: it is recommended to use recent versions of libsctp (>1.0.10) and\nkernel (>4.0.0) when enabling SCTP transport.\n",
  "parameters": {
   "sctp_socket_rcvbuf": "### `sctp_socket_rcvbuf` (int)\n\nSize for the sctp socket receive buffer.\n\n*Default value is automatically set based on OS limits.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_socket_rcvbuf\", 14096)\n...\n```\n",
   "sctp_socket_sndbuf": "### `sctp_socket_sndbuf` (int)\n\nSize for the sctp socket send buffer.\n\n*Default value is automatically set based on OS limits.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_socket_sndbuf\", 14096)\n...\n```\n",
   "sctp_autoclose": "### `sctp_autoclose` (int)\n\nNumber of seconds before autoclosing an idle association. Can be changed\nat runtime, but it will affect only new associations.\n\n*Default value is 180 (seconds).*\n\n```\n...\n# kamcmd cfg.set_now_int sctp autoclose 120\n...\nmodparam(\"sctp\", \"sctp_autoclose\", 300)\n...\n```\n",
   "sctp_send_ttl": "### `sctp_send_ttl` (int)\n\nNumber of milliseconds before an unsent message/chunk is dropped. Can be\nchanged at runtime.\n\n*Default value is 32000 (milliseconds - 32 seconds).*\n\n```\n...\n# kamcmd cfg.set_now_int sctp send_ttl 180000\n...\nmodparam(\"sctp\", \"sctp_send_ttl\", 10000)\n...\n```\n",
   "sctp_send_retries": "### `sctp_send_retries` (int)\n\nHow many times to attempt re-sending a message on a re-opened\nassociation, if the sctp stack did give up sending it (it's not related\nto sctp protocol level retransmission). Useful to improve reliability\nwith peers that reboot/restart or fail over to another machine.\n\nWARNING: use with care and low values (e.g. 1-3) to avoid \"multiplying\"\ntraffic to unresponding hosts.\n\nCan be changed at runtime.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_send_retries\", 1)\n...\n```\n",
   "sctp_assoc_tracking": "### `sctp_assoc_tracking` (int)\n\nControls whether or not sctp associations are tracked inside Kamailio.\nTurning it off would result in less memory being used and slightly\nbetter performance, but it will also disable some other features that\ndepend on it (e.g. sctp_assoc_reuse).\n\nCan be changed at runtime (kamcmd sctp assoc_tracking 0), but changes\nwill be allowed only if all the other features that depend on it are\nturned off (for example it can be turned off only if first\nsctp_assoc_reuse was turned off).\n\nNote: turning sctp_assoc_tracking on/off will delete all the tracking\ninformation for all the currently tracked associations and might\nintroduce a small temporary delay in the sctp processing if lots of\nassociations were tracked.\n\nConfig options depending on sctp_assoc_tracking being on:\nsctp_assoc_reuse.\n\n*Default value is 1 (enabled, 0 - disabled).*\n\n```\n...\nmodparam(\"sctp\", \"sctp_assoc_tracking\", 0)\n...\n```\n",
   "sctp_assoc_reuse": "### `sctp_assoc_reuse` (int)\n\nControls sctp association reuse. For now only association reuse for\nreplies is affected by it. Default is on. Depends on sctp_assoc_tracking\nbeing on.\n\nNote that even if turned off, if the port in via corresponds to the\nsource port of the association the request was sent on or if rport is\nturned on (force_rport() or via containing a rport option), the\nassociation will be automatically reused by the sctp stack. Can be\nchanged at runtime (sctp assoc_reuse), but it can be turned on only if\nsctp_assoc_tracking is on.\n\n*Default value is 1 (enabled, 0 - disabled).*\n\n```\n...\nmodparam(\"sctp\", \"sctp_assoc_reuse\", 0)\n...\n```\n",
   "sctp_max_assocs": "### `sctp_max_assocs` (int)\n\nMaximum number of allowed open sctp associations. -1 means maximum\nallowed by the OS. Default: -1. Can be changed at runtime (e.g.: kamcmd\ncfg.set_now_int sctp max_assocs 10 ). When the maximum associations\nnumber is exceeded and a new associations is opened by a remote host,\nthe association will be immediately closed. However it is possible that\nsome sip packets get through (especially if they are sent early, as part\nof the 4-way handshake).\n\nWhen Kamailio tries to open a new association and the max_assocs is\nexceeded the exact behaviour depends on whether or not\nsctp_assoc_tracking is on. If on, the send triggering the active open\nwill gracefully fail, before actually opening the new association and no\npacket will be sent. However if sctp_assoc_tracking is off, the\nassociation will first be opened and then immediately closed. In general\nthis means that the initial sip packet will be sent (as part of the\n4-way handshake).\n\n*Default value is -1.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_max_assocs\", 10)\n...\n```\n",
   "sctp_srto_initial": "### `sctp_srto_initial` (int)\n\nInitial value of the retransmission timeout (in milliseconds), used in\nRTO calculations.\n\nCan be changed at runtime (sctp srto_initial) but it will affect only\nnew associations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_srto_initial\", 1000)\n...\n```\n",
   "sctp_srto_max": "### `sctp_srto_max` (int)\n\nMaximum value of the retransmission timeout (RTO) in milliseconds.\n\nWARNING: values lower than the sctp sack_delay will cause lots of\nretransmissions and connection instability (see sctp_srto_min for more\ndetails).\n\nCan be changed at runtime (sctp srto_max) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_srto_max\", 2000)\n...\n```\n",
   "sctp_srto_min": "### `sctp_srto_min` (int)\n\nMinimum value of the retransmission timeout (RTO) in milliseconds.\n\nWARNING: values lower than the sctp sack_delay of any peer might cause\nretransmissions and possible interoperability problems. According to the\nstandard the sack_delay should be between 200 and 500 ms, so avoid\ntrying values lower than 500 ms unless you control all the possible sctp\npeers and you do make sure their sack_delay is higher or their sack_freq\nis 1.\n\nCan be changed at runtime (sctp srto_min) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_srto_min\", 800)\n...\n```\n",
   "sctp_asocmaxrxt": "### `sctp_asocmaxrxt` (int)\n\nMaximum retransmissions attempts per association. It should be set to\nsctp_pathmaxrxt * no. of expected paths.\n\nCan be changed at runtime (sctp asocmaxrxt) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_asocmaxrxt\", 5)\n...\n```\n",
   "sctp_init_max_attempts": "### `sctp_init_max_attempts` (int)\n\nMaximum INIT retransmission attempts.\n\nCan be changed at runtime (sctp init_max_attempts).\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_init_max_attempts\", 3)\n...\n```\n",
   "sctp_init_max_timeo": "### `sctp_init_max_timeo` (int)\n\nMaximum INIT retransmission timeout (RTO max for INIT) in milliseconds.\n\nCan be changed at runtime (sctp init_max_timeo).\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_init_max_timeo\", 1000)\n...\n```\n",
   "sctp_hbinterval": "### `sctp_hbinterval` (int)\n\nSCTP heartbeat interval. Setting it to -1 will disable the heartbeats.\n\nCan be changed at runtime (sctp hbinterval) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_hbinterval\", 2000)\n...\n```\n",
   "sctp_pathmaxrxt": "### `sctp_pathmaxrxt` (int)\n\nMaximum retransmission attempts per path (see also sctp_asocmaxrxt).\n\nCan be changed at runtime (sctp pathmaxrxt) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_pathmaxrxt\", 2)\n...\n```\n",
   "sctp_sack_delay": "### `sctp_sack_delay` (int)\n\nDelay until an ACK is generated after receiving a packet (in\nmilliseconds).\n\nWARNING: a value higher than srto_min can cause a lot of retransmissions\n(and strange problems). A value higher than srto_max will result in very\nhigh connections instability. According to the standard the sack_delay\nvalue should be between 200 and 500 ms.\n\nCan be changed at runtime (sctp sack_delay) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_sack_delay\", 400)\n...\n```\n",
   "sctp_sack_freq": "### `sctp_sack_freq` (int)\n\nNumber of packets received before an ACK is sent (without waiting for\nthe sack_delay to expire). Default: OS specific.\n\nNote: on linux with lksctp up to and including 1.0.9 is not possible to\nset this value (having it in the config will produce a warning on\nstartup).\n\nCan be changed at runtime (sctp sack_freq) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_sack_freq\", 3)\n...\n```\n",
   "sctp_max_burst": "### `sctp_max_burst` (int)\n\nMaximum burst of packets that can be emitted by an association.\n\nCan be changed at runtime (sctp max_burst) but it will affect only new\nassociations.\n\n*Default value is OS specific.*\n\n```\n...\nmodparam(\"sctp\", \"sctp_max_burst\", 3)\n...\n```\n"
  },
  "functions": {}
 },
 "sdpops": {
  "overview": "This module provides functions for checking and managing the SDP\npayloads of SIP messages.\n\nExamples of functions this module offers: remove codecs from SDP, check\nthe media stream types and return attributes of SDP document. For the\nfull list of the features provided by this module and the implementation\nstate, please read the list of exported functions.\n",
  "parameters": {},
  "functions": {
   "sdp_remove_codecs_by_id": "### `sdp_remove_codecs_by_id(list [, mtype])`\n\nRemove the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one item or a\ncomma separated list of numeric codec IDs. The parameter can be a static\nstring or a variable holding the list of numeric codec IDs.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# remove PCMU\nsdp_remove_codecs_by_id(\"0\");\n# remove PCMU, PCMA and GSM\nsdp_remove_codecs_by_id(\"0,8,3\");\nsdp_remove_codecs_by_id(\"17\", \"audio\");\nsdp_remove_codecs_by_id(\"23\", \"video\");\n...\n```\n",
   "sdp_remove_codecs_by_name": "### `sdp_remove_codecs_by_name(list [, mtype])`\n\nRemove the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one item or a\ncomma separated list of codec names. The parameter can be a static\nstring or a variable holding the list of codec names.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# remove PCMU\nsdp_remove_codecs_by_name(\"PCMU\");\n# remove PCMU, PCMA and GSM\nsdp_remove_codecs_by_name(\"PCMU,PCMA,GSM\");\n...\n```\n",
   "sdp_remove_line_by_prefix": "### `sdp_remove_line_by_prefix(string [, mtype])`\n\nRemove all SDP attribute lines beginning with 'string' in all media\nstreams.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif ($si == \"2001:DB8::8:800:200C:417A\"\n        and ( has_body(\"application/sdp\") or has_body(\"multipart/mixed\")))\n{\n    xlog(\"L_INFO\", \"Cleaning ugly SDP from $si\\n\");\n    sdp_remove_codecs_by_name(\"X-NSE\");\n    sdp_remove_line_by_prefix(\"a=X-\");\n}\n\n...\n```\n",
   "sdp_keep_codecs_by_id": "### `sdp_keep_codecs_by_id(list [, mtype])`\n\nKeep only the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one item or a\ncomma separated list of numeric codec IDs. The parameter can be a static\nstring or a variable holding the list of numeric codec IDs.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# keep only PCMU\nsdp_keep_codecs_by_id(\"0\");\n# keep PCMU, PCMA and GSM in audio stream\nsdp_keep_codecs_by_id(\"0,8,3\", \"audio\");\n...\n```\n",
   "sdp_keep_codecs_by_name": "### `sdp_keep_codecs_by_name(list [, mtype])`\n\nKeep only the codecs provided in the parameter 'list' from all media\nstreams found in SDP payload. The parameter 'list' must be one or a\ncomma separated list of codec names. The parameter can be a static\nstring or a variable holding the list of codec names.\n\nNote that you have to explicitly keep 'telephone-event' in the list of\nnames if you want to keep DTMF attributes.\n\nOptional parameter mtype can be provided to apply the operations only to\nthe streams matching m=mtype.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# keep only PCMU\nsdp_keep_codecs_by_name(\"PCMU\");\n# keep PCMU, PCMA and GSM\nsdp_keep_codecs_by_name(\"PCMU,PCMA,GSM\");\n...\n```\n",
   "sdp_with_media": "### `sdp_with_media(type)`\n\nReturn true if the SDP has 'media=type ...' line. Useful to check the\ncontent of the RTP sessions, such as 'audio' or 'video'. The parameter\ncan be static string or variable holding the media type.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# check for video stream\nif(sdp_with_media(\"video\"))\n{\n    # the session has a video stream\n}\n...\n```\n",
   "sdp_with_active_media": "### `sdp_with_active_media(type)`\n\nReturn true if the SDP has 'media=type ...' line and the media is\nactive. Useful to check the content of the RTP sessions, such as 'audio'\nor 'video'. Active media means the port is non-zero and the direction is\nnot \"inactive\" The parameter can be static string or variable holding\nthe media type.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# check for active video stream\nif(sdp_with_active_media(\"video\"))\n{\n    # the session has an active video stream\n}\n...\n```\n",
   "sdp_remove_media": "### `sdp_remove_media(type)`\n\nRemove the streams that match on 'm=type ...' line. The parameter can be\nstatic string or variable holding the media type.\n\nNote: If this is executed on a request, the callee should reply without\nthe Media too. However, RFC 3264 mandates, that the reply should contain\nthe exact same number of \"m=\" lines as the request.\n\n> 6 Generating the Answer\n\n> [...]\n\n> For each \"m=\" line in the offer, there MUST be a corresponding \"m=\"\n> line in the answer. The answer MUST contain exactly the same number of\n> \"m=\" lines as the offer. This allows for streams to be matched up\n> based on their order. This implies that if the offer contained zero\n> \"m=\" lines, the answer MUST contain zero \"m=\" lines.\n\n> \u2014 RFC 3264\n\n\n\nSo this may not work with all Endpoints, especially if they follow RFC\n3264 precisely (e.g. JSSIP).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# remove video stream\nsdp_remove_media(\"video\");\n...\n```\n",
   "sdp_with_transport": "### `sdp_with_transport(type)`\n\nReturn true if the SDP has 'media=media port type ...' line. Useful to\ncheck the transport of the RTP sessions, such as 'RTP/AVP', 'RTP/SAVP',\n'RTP/SAVPF' or 'UDP/TLS/RTP/SAVPF'. The parameter can be static string\nor variable holding the transport type. The function does an exact match\nof the strings.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# check for RTP/SAVP stream\nif(sdp_with_transport(\"UDP/TLS/RTP/SAVPF\"))\n{\n    # the session has a UDP/TLS/RTP/SAVPF stream\n}\n...\n```\n",
   "sdp_with_transport_like": "### `sdp_with_transport_like(type)`\n\nReturns true if the SDP has 'media=media port type ...' line, where type\ncontains the string in the parameter. The parameter can be static string\nor variable holding a string.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# check for SAVPF stream\nif(sdp_with_transport_like(\"SAVPF\"))\n{\n    # the session has a SAVPF stream, e.g., RTP/SAVPF or UDP/TLS/RTP/SAVPF\n}\n...\n```\n",
   "sdp_transport": "### `sdp_transport(pv)`\n\nAssigns common media transport (if any) of 'm' lines to pv argument.\nReturns 1 if common media transport was found, -2 if there was no common\nmedia transport, and -1 in case of error.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsdp_transport(\"$avp(caller_rtp_transport)\");\n...\n```\n",
   "sdp_remove_transport": "### `sdp_remove_transport(type)`\n\nRemove the streams that match on 'm=media port type ...' line. The\nparameter can be static string or variable holding the transport type.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# remove stream with transport RTP/AVP\nsdp_remove_transport(\"RTP/AVP\");\n...\n```\n",
   "sdp_with_codecs_by_id": "### `sdp_with_codecs_by_id(list)`\n\nReturns true if any of the codecs provided in the parameter 'list' from\nall media streams is found in SDP payload. The parameter 'list' must be\none or a comma separated list of numeric codec IDs. The parameter can be\na static string or a variable holding the list of numeric codec IDs.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# test for PCMU\nif(sdp_with_codecs_by_id(\"0\")) { ... }\n# test for PCMU, PCMA or GSM\nif(sdp_with_codecs_by_id(\"0,8,3\")) { ... }\n...\n```\n",
   "sdp_with_codecs_by_name": "### `sdp_with_codecs_by_name(list)`\n\nReturns true if any of the codecs provided in the parameter 'list' from\nall media streams is found in SDP payload. The parameter 'list' must be\none item or a comma separated list of codec names. The parameter can be\na static string or a variable holding the list of codec names.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# test for PCMU\nif(sdp_with_codecs_by_name(\"PCMU\")) { ... }\n# test for PCMU, PCMA or GSM\nif(sdp_with_codecs_by_name(\"PCMU,PCMA,GSM\")) { ... }\n...\n```\n",
   "sdp_print": "### `sdp_print(level)`\n\nPrint the SDP internal structure to log 'level'. The parameter can be\nstatic integer or variable holding the integer value of the log level.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n# print the SDP\nsdp_print(\"1\");\n...\n```\n",
   "sdp_get": "### `sdp_get(avpvar)`\n\nStore the SDP part of message body in an AVP. Return 1 if SDP is found,\n-1 on error and -2 if there is no SDP part in the message body.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsdp_get(\"$avp(sdp)\");\n...\n```\n",
   "sdp_content": "### `sdp_content([sloppy])`\n\nReturn true if the SIP message has SDP body or a SDP part in body. If an\nargument is given, the function does not parse message body, but returns\ntrue if Content-Type is \"application/sdp\" or if that string exists in\n\"multipart/mixed\" body.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(sdp_content()) {\n    ...\n}\n...\n```\n",
   "sdp_with_ice": "### `sdp_with_ice()`\n\nReturn true if the SIP message has SDP body that contains ICE candidate\nattribute(s).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(sdp_with_ice()) {\n    ...\n}\n...\n```\n",
   "sdp_get_line_startswith": "### `sdp_get_line_startswith(avpvar, string)`\n\nStore the search part of SDP body message with line beginning with\n'string' in an AVP. Return 1 if 'string' is found in SDP, -1 on error\nand -2 if there is no SDP part in the message body. The second parameter\ncan contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(sdp_get_line_startswith(\"$avp(mline)\", \"m=\")) {\n    xlog(\"m-line: $avp(mline)\\n\");\n}\n...\n```\n",
   "sdp_get_address_family": "### `sdp_get_address_family()`\n\nIt helps to get IP address family at c line from sdp body. It returns -1\non error, 4 for IP4 and 6 for IP6\n\n```\n...\nif(is_method(\"INVITE\") && has_body(\"application/sdp\")){\n    $avp(af) = sdp_get_address_family();\n    xlog(\"L_INFO\",\"ADDRESS FAMILY OF SDP C line $avp(af) \");\n}\n...\n\n        \n```\n",
   "sdp_iterator_start": "### `sdp_iterator_start(iname)`\n\nStart an iterator for lines in the body of the current SIP message. The\nparameter iname is used to identify the iterator. There can be up to 4\niterators at the same time, with different name.\n\nThe parameter can be a dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsdp_iterator_start(\"s1\");\n...\n```\n",
   "sdp_iterator_end": "### `sdp_iterator_end(iname)`\n\nClose the iterator identified by iname parameter. The iname value must\nbe the same used for sdp_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsdp_iterator_end(\"s1\");\n...\n```\n",
   "sdp_iterator_next": "### `sdp_iterator_next(iname)`\n\nMove the iterator to the next line in the body. It must be called also\nafter sdp_iterator_start() to get the first header.\n\nThe return code is false when there is no other header in the list.\n\nThe SDP line is accessible via variable $sdpitval(iname) - it contains\nalso the EOL chars.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sdp_iterator_start(\"s1\");\n    while(sdp_iterator_next(\"s1\")) {\n        xlog(\"body line: $sdpitval(s1)\");\n    }\n    sdp_iterator_end(\"s1\");\n...\n```\n",
   "sdp_iterator_rm": "### `sdp_iterator_rm(iname)`\n\nRemove the body line at the current iterator position.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sdp_iterator_start(\"s1\");\n    while(sdp_iterator_next(\"s1\")) {\n        if($sdpitval(s1)=~\"abc\") {\n            sdp_iterator_rm(\"s1\");\n        }\n    }\n    sdp_iterator_end(\"s1\");\n...\n```\n",
   "sdp_iterator_append": "### `sdp_iterator_append(iname, text)`\n\nAdd text after the line at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sdp_iterator_start(\"s1\");\n    while(sdp_iterator_next(\"s1\")) {\n        if($sdpitval(s1)=~\"^a=info:xyz\") {\n            sdp_iterator_append(\"s1\", \"a=info:abc\\r\\n\");\n            break;\n        }\n    }\n    sdp_iterator_end(\"s1\");\n...\n```\n",
   "sdp_iterator_insert": "### `sdp_iterator_insert(iname, text)`\n\nAdd text before the line at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    sdp_iterator_start(\"s1\");\n    while(sdp_iterator_next(\"s1\")) {\n        if($sdpitval(s1)=~\"^a=info:xyz\") {\n            sdp_iterator_insert(\"s1\", \"a=info:abc\\r\\n\");\n            break;\n        }\n    }\n    sdp_iterator_end(\"s1\");\n...\n```\n"
  }
 },
 "seas": {
  "overview": "\n",
  "parameters": {},
  "functions": {}
 },
 "secfilter": {
  "overview": "This module has been designed to offer an additional layer of security\nover our communications. To achieve this, the following features are\navailable:\n\n- Blacklist to block user agents, IP addresses, countries, domains and\nusers.\n\n- Whitelist to allow user agents, IP addresses, countries, domains and\nusers.\n\n- Blacklist of destinations where the called number is not allowed.\n\n- SQL injection attacks prevention.\n\nWhen a function is called, it will be searched in the whitelist. If the\nvalue is not found, then the blacklist will be searched.\n\nAll data will be loaded into memory when the module is started. There is\nan RPC reload command to update all the data from database. It is also\npossible to add new data to the blacklist or whitelist using other RPC\ncommands.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nDatabase URL.\n\n*Default value is \"\"*\n\n```\n        ...\n        modparam(\"secfilter\", \"db_url\", \"mysql://user:pass@localhost/kamailio\")\n        ...\n        \n```\n",
   "table_name": "### `table_name` (string)\n\nName of the table used to store the blacklisted and whitelisted values.\n\n*Default value is secfilter*\n\n```\n        ...\n        modparam(\"secfilter\", \"table_name\", \"secfilter\")\n        ...\n        \n```\n",
   "action_col": "### `action_col` (string)\n\nName of database column containing the type of list. The possible values\nare:\n\n- 0 = blacklisted data\n- 1 = whitelisted data\n- 2 = blacklisted destination number\n\n*Default value is action*\n\n```\n        ...\n        modparam(\"secfilter\", \"action_col\", \"action\")\n        ...\n        \n```\n",
   "type_col": "### `type_col` (string)\n\nName of database column containing the type of values. The possible\nvalues are:\n\n- 0 = user-agent (if action=0 or action=1)\n- 0 = destination number (if action=2)\n- 1 = country\n- 2 = domain\n- 3 = IP address\n- 4 = user\n\n*Default value is type*\n\n```\n        ...\n        modparam(\"secfilter\", \"type_col\", \"type\")\n        ...\n        \n```\n",
   "data_col": "### `data_col` (string)\n\nName of database column containing blacklisted and whitelisted values.\n\n*Default value is data*\n\n```\n        ...\n        modparam(\"secfilter\", \"data_col\", \"data\")\n        ...\n        \n```\n",
   "dst_exact_match": "### `dst_exact_match` (integer)\n\nThis value is used in the destinations blacklist and corresponds to the\nnumbers that we want to prevent calling. If the value is *1*, the call\nwill appear as blacklisted if the destination is exactly the same. If\nthe value is *0*, every destination whose number begins with a number\nappearing on the destination blacklist will be rejected.\n\n*Default value is 1*\n\n```\n        ...\n        modparam(\"secfilter\", \"dst_exact_match\", 1)\n        ...\n        \n```\n",
   "reload_delta": "### `reload_delta` (integer)\n\nThe number of seconds that have to be waited before executing a new RPC\nreload. By default there is a rate limiting of maximum one reload in\nfive seconds. If set to *0*, no rate limit is configured.\n\n*Default value is 5*\n\n```\n        ...\n        modparam(\"secfilter\", \"reload_delta\", 1)\n        ...\n        \n```\n",
   "cleanup_interval": "### `cleanup_interval` (integer)\n\nThe number of seconds that have to be wait before cleanup the previous\nvalues from memory after a RPC reload.\n\n*Default value is 60*\n\n```\n        ...\n        modparam(\"secfilter\", \"cleanup_interval\", 120)\n        ...\n        \n```\n"
  },
  "functions": {
   "secf_check_ip": "### `secf_check_ip ()`\n\nIt checks if the source IP address is blacklisted. The search is\napproximate and data stored in the database will be compared as a\nprefix. For example, if we have blacklisted IP address *192.168.1.* all\nmessages from IPs like 192.168.1.% will be rejected.\n\nReturn values are:\n\n- 2 = the value is whitelisted\n- 1 = the value is not found\n- -2 = the value is blacklisted\n\n<!-- -->\n\n\n```\n        ...\n        secf_check_ip();\n        if ($? == -2) {\n                xlog(\"L_ALERT\", \"$rm from $si blocked because IP address is blacklisted\");\n                exit;\n        }\n        ...\n        \n```\n",
   "secf_check_ua": "### `secf_check_ua ()`\n\nIt checks if the user-agent is blacklisted. The search is approximate\nand the comparison will be made using the values of the database as a\nprefix. If we add to the user-agent blacklist the word *sipcli*, every\nmessage whose user-agent is named, for example, *sipcli/1.6* or\n*sipcli/1.8* will be blocked. It is very useful to block different\nversions of the same program.\n\nReturn values are:\n\n- 2 = the value is whitelisted\n- 1 = the value is not found\n- -1 = error\n- -2 = the value is blacklisted\n\n<!-- -->\n\n\n```\n        ...\n        secf_check_ua();\n        if ($? == -2) {\n                xlog(\"L_ALERT\", \"$rm from $si blocked because UserAgent '$ua' is blacklisted\");\n                exit;\n        }\n        ...\n        \n```\n",
   "secf_check_country": "### `secf_check_country (string)`\n\nSimilar to secf_check_ua. It checks if the country (IP address) is\nblacklisted. *Geoip* module must be loaded to get the country code.\n\nReturn values are:\n\n- 2 = the value is whitelisted\n- 1 = the value is not found\n- -1 = error\n- -2 = the value is blacklisted\n\n<!-- -->\n\n\n```\n        ...\n        if (geoip2_match(\"$si\", \"src\")) {\n                secf_check_country($gip2(src=>cc));\n                if ($avp(secfilter) == -2) {\n                        xlog(\"L_ALERT\", \"$rm from $si blocked because Country '$gip2(src=>cc)' is blacklisted\");\n                        exit;\n                }\n        }\n        ...\n        \n```\n",
   "secf_check_from_hdr": "### `secf_check_from_hdr ()`\n\nIt checks if any value of *from header* is blacklisted. It checks if\nfrom name or from user are in the users blacklist or whitelist. It also\nchecks if the from domain is in the domains blacklist or whitelist. The\nblacklisted value will be used as a prefix and if we block, for example,\nthe user *sipvicious*, all users whose name starts with this word will\nbe considered as blacklisted.\n\nReturn values are:\n\n- 4 = from name is whitelisted\n- 3 = from domain is whitelisted\n- 2 = from user is whitelisted\n- 1 = from header not found\n- -1 = error\n- -2 = from user is blacklisted\n- -3 = from domain is blacklisted\n- -4 = from name is blacklisted\n\n<!-- -->\n\n\n```\n        ...\n        secf_check_from_hdr();\n        switch ($?) {\n                case -2:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because From user '$fU' is blacklisted\");\n                        exit;\n                case -3:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because From domain '$fd' is blacklisted\");\n                        exit;\n                case -4:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because From name '$fn' is blacklisted\");\n                        exit;\n        };\n        ...\n        \n```\n",
   "secf_check_to_hdr": "### `secf_check_to_hdr ()`\n\nDo the same as *secf_check_from_hdr* function but with the *to header*.\n\nReturn values are:\n\n- 4 = to name is whitelisted\n- 3 = to domain is whitelisted\n- 2 = to user is whitelisted\n- 1 = to header not found\n- -1 = error\n- -2 = to user is blacklisted\n- -3 = to domain is blacklisted\n- -4 = to name is blacklisted\n\n<!-- -->\n\n\n```\n        ...\n        secf_check_to_hdr();\n        switch ($?) {\n                case -2:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because To user '$tU' is blacklisted\");\n                        exit;\n                case -3:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because To domain '$td' is blacklisted\");\n                        exit;\n                case -4:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because To name '$tn' is blacklisted\");\n                        exit;\n        };\n        ...\n        \n```\n",
   "secf_check_contact_hdr": "### `secf_check_contact_hdr ()`\n\nDo the same as *secf_check_from_hdr* function but with the *contact\nheader*.\n\nReturn values are:\n\n- 3 = contact domain is whitelisted\n- 2 = contact user is whitelisted\n- 1 = contact header not found\n- -1 = error\n- -2 = contact user is blacklisted\n- -3 = contact domain is blacklisted\n\n<!-- -->\n\n\n```\n        ...\n        secf_check_contact_hdr();\n        switch ($?) {\n                case -2:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because Contact user '$ct' is blacklisted\");\n                        exit;\n                case -3:\n                        xlog(\"L_ALERT\", \"$rm to $si blocked because Contact domain '$ct' is blacklisted\");\n                        exit;\n        };\n        ...\n        \n```\n",
   "secf_check_dst": "### `secf_check_dst (string)`\n\nIt checks if the destination number is blacklisted. It must be user for\nINVITE messages. If the value of *dst_exact_match* is *1*, the call will\nappear as blacklisted if the destination is exactly the same. If the\nvalue is *0*, every destination whose number begins with a number\nappearing on the destination blacklist will be rejected.\n\nReturn values are:\n\n- 2 (if the value is whitelisted)\n- 1 (if the value not found)\n- -2 (if the value is blacklisted)\n\n<!-- -->\n\n\n```\n        ...\n        if (is_method(\"INVITE\")) {\n            secf_check_dst($rU);\n            if ($? == -2) {\n                xlog(\"L_ALERT\", \"$rm from $si blocked because destination $rU is blacklisted\");\n                send_reply(\"403\", \"Forbidden\");\n                exit;\n            }\n        }\n        ...\n        \n```\n",
   "secf_check_sqli_hdr": "### `secf_check_sqli_hdr (string)`\n\nSearch for illegal characters in the given value.\n\n```\n        ...\n        secf_check_sqli_hdr($ua);\n        if ($? == -1) {\n                xlog(\"L_ALERT\", \"$rm from $si blocked because possible SQLi found in the user-agent header ($ua)\");\n                exit;\n        }\n\n        ...\n        \n```\n",
   "secf_check_sqli_all": "### `secf_check_sqli_all ()`\n\nSearch for illegal characters in several headers (user-agent, from, to\nand contact). If illegal characters are found the message will be\ndropped.\n\n```\n        ...\n        secf_check_sqli_all();\n        ...\n        \n```\n"
  }
 },
 "secsipid": {
  "overview": "The module implements secure SIP identity specifications - STIR (Secure\nTelephony Identity Revisited) and SHAKEN (Signature-based Handling of\nAsserted information using toKENs) IETF extensions for SIP (RFC8224,\nRFC8588), known together as STIR/SHAKEN.\n\nIt exports the functions to check and generate SIP Identity header.\n\nNote that this module needs \"secsipid_proc.so\" module to be installed,\nbut without loading the \"secsipid_proc.so\" via \"loadmodule\". This module\nloads \"secsipid_proc.so\" in child init callback in order to initialize\nthe \"libsecsipid\" per child process.\n\nThe libsecsipid is provided by secsipidx project:\n<https://github.com/asipto/secsipidx>.\n\nIn case of failure, the functions in this module return error codes (the\nnegative values) listed in the code of libsecsipid, pretty much at the\ntop of:\n<https://github.com/asipto/secsipidx/blob/main/secsipid/secsipid.go>.\n",
  "parameters": {
   "expire": "### `expire` (int)\n\nThe interval in seconds after which the Identity header JWT is\nconsidered to be expired.\n\n*Default value is 300.*\n\n```\n...\nmodparam(\"secsipid\", \"expire\", 600)\n...\n```\n",
   "timeout": "### `timeout` (int)\n\nThe interval in seconds after which the HTTP GET operation to download\nthe public key times out.\n\n*Default value is 5.*\n\n```\n...\nmodparam(\"secsipid\", \"timeout\", 2)\n...\n```\n",
   "cache_dir": "### `cache_dir` (str)\n\nThe path to the directory where to save cached public keys. If set, it\nactivates the public key file caching in the libsecsipid library.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"secsipid\", \"cache_dir\", \"/tmp/kamailio/secsipid\")\n...\n```\n",
   "cache_expire": "### `cache_expire` (int)\n\nThe interval in seconds after which a cached public key is considered\nexpired. This value is passed to the libsecsipid library.\n\n*Default value is 3600.*\n\n```\n...\nmodparam(\"secsipid\", \"cache_expire\", 7200)\n...\n```\n",
   "modproc": "### `modproc` (str)\n\nThe name of or the path to the required per-process API module.\n\n*Default value is \"secsipid_proc.so\".*\n\n```\n...\nmodparam(\"secsipid\", \"modproc\", \"secsipid_proc2.so\")\n...\n```\n",
   "libopt": "### `libopt` (str)\n\nSet a libsecsipid option. The value has to be name=value. The parameter\ncan be set many times.\n\n*Default value is \"\" (not set).*\n\n```\n...\nmodparam(\"secsipid\", \"libopt\", \"CacheExpires=0\")\n...\n```\n"
  },
  "functions": {
   "secsipid_check_identity": "### `secsipid_check_identity(keyPath)`\n\nCheck the validity of the Identity header using the keys stored in the\nfile specified by \"keyPath\". If the parameter is empty, the function is\ndownloading the key using the URL from \"info\" parameter of the Identity\nheader, using the value of \"timeout\" parameter to limit the download\ntime. The validity of the JWT body in the Identity header is also\nchecked against the \"expire\" parameter.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(secsipid_check_identity(\"/secsipid/$si/cert.pem\")) { ... }\n    ...\n    if(secsipid_check_identity(\"\")) { ... }\n    ...\n}\n...\n```\n\nFurther checks can be done with config operations, decoding the JWT\nheader and payload using {s.select} and {s.decode.base64t}\ntransformations together with jansson module.\n",
   "secsipid_check_identity_pubkey": "### `secsipid_check_identity_pubkey(pubkeyVal)`\n\nSimilar to secsipid_check_identity() with the public key value provided\nin the parameter.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n  ...\n  http_client_query(\"https://provider.com/stir-shaken/cert.pem\", \"$var(pubkey)\");\n  ...\n  if(secsipid_check_identity_pubkey(\"$var(pubkey)\")) { ... }\n  ...\n}\n...\n```\n",
   "secsipid_check": "### `secsipid_check(sIdentity, keyPath)`\n\nCheck the validity of the \"sIdentity\" parameter using the keys stored in\nthe file specified by \"keyPath\". If the keyPath parameter is empty, the\nfunction is downloading the key using the URL from \"info\" parameter of\nthe sIdentity, using the value of \"timeout\" parameter to limit the\ndownload time. The validity of the JWT in the sIdentity value is also\nchecked against the \"expire\" parameter.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(secsipid_check(\"...\", \"/secsipid/$si/cert.pem\")) { ... }\n    ...\n    if(secsipid_check(\"...\", \"\")) { ... }\n    ...\n}\n...\n```\n\nFurther checks can be done with config operations, decoding the JWT\nheader and payload using {s.select} and {s.decode.base64t}\ntransformations together with jansson module.\n",
   "secsipid_get_url": "### `secsipid_get_url(url, ovar)`\n\nGet the content of a URL and store the result in a variable.\n\nThe url parameters can contain pseudo-variables and ovar has to be the\nname of a writable pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n  ...\n  if(secsipid_get_url(\"https://$fd/stirshaken/cert.pem\", \"$var(pubkey)\")) { ... }\n  ...\n}\n...\n```\n",
   "secsipid_add_identity": "### `secsipid_add_identity(origTN, destTN, attest, origID, x5u, keyPath)`\n\nAdd Identity header using the key specified by \"keyPath\" to sign the JWT\nbody. If origID is empty, a UUID string is generated to fill the field.\nThe origTN represents the origination telephone number; destTN\nrepresents the destination telephone number; x5u is the HTTP URL\nreferencing to the public key that should be used to verify the\nsignature; attest represents the attestation level (should be \"A\", \"B\"\nor \"C\").\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    secsipid_add_identity(\"$fU\", \"$rU\", \"A\", \"\",\n        \"https://kamailio.org/stir/$rd/cert.pem\", \"/secsipid/$rd/key.pem\");\n    ...\n}\n...\n```\n",
   "secsipid_build_identity": "### `secsipid_build_identity(origTN, destTN, attest, origID, x5u, keyPath)`\n\nBuild Identity value using the key specified by \"keyPath\" to sign the\nJWT body. If origID is empty, a UUID string is generated to fill the\nfield. The origTN represents the origination telephone number; destTN\nrepresents the destination telephone number; x5u is the HTTP URL\nreferencing to the public key that should be used to verify the\nsignature; attest represents the attestation level (should be \"A\", \"B\"\nor \"C\"). On success, the Indentity value is stored in variable\n$secsipid(val). It also sets $secsipid(ret) to the return value of the\nlibsecsipid functions.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(secsipid_build_identity(\"$fU\", \"$rU\", \"A\", \"\",\n            \"https://kamailio.org/stir/$rd/cert.pem\", \"/secsipid/$rd/key.pem\")) {\n        xinfo(\"Identity value: $secsipid(val)\\n\");\n    }\n    ...\n}\n...\n```\n",
   "secsipid_build_identity_prvkey": "### `secsipid_build_identity_prvkey(origTN, destTN, attest, origID, x5u, keyData)`\n\nSimilar to secsipid_build_identity(), but the private key data is\nprovided as parameter instead to the file path.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(secsipid_build_identity_prvkey(\"$fU\", \"$rU\", \"A\", \"\",\n            \"https://kamailio.org/stir/$rd/cert.pem\", \"$var(prvkey)\")) {\n        xinfo(\"Identity value: $secsipid(val)\\n\");\n    }\n    ...\n}\n...\n```\n",
   "secsipid_sign": "### `secsipid_sign(sheaders, spaypload, keyPath)`\n\nBuild Identity value using the key specified by \"keyPath\" to sign the\nJWT body. The sheaders and spayload have to be string representation of\nJSON headers and payload to be signed. On success, the Indentity value\nis stored in variable $secsipid(val). It also sets $secsipid(ret) to\nthe return value of the libsecsipid functions.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(secsipid_sign(\"_JSON_HEADERS_\", \"_JSON_PAYLOAD_\",\n            \"/secsipid/$rd/key.pem\")) {\n        xinfo(\"Identity value: $secsipid(val)\\n\");\n    }\n    ...\n}\n...\n```\n",
   "secsipid_sign_prvkey": "### `secsipid_sign_prvkey(sheaders, spaypload, keyData)`\n\nBuild Identity value using the private key given by \"keyData\" to sign\nthe JWT body. The sheaders and spayload have to be string representation\nof JSON headers and payload to be signed. On success, the Indentity\nvalue is stored in variable $secsipid(val). It also sets\n$secsipid(ret) to the return value of the libsecsipid functions.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(secsipid_sign_prvkey(\"_JSON_HEADERS_\", \"_JSON_PAYLOAD_\",\n            \"_PRIVATE_KEY_\")) {\n        xinfo(\"Identity value: $secsipid(val)\\n\");\n    }\n    ...\n}\n...\n```\n"
  }
 },
 "secsipid_proc": {
  "overview": "The module implements per-child-process C API functions required by\nsecsipid module.\n\nImportant: this module must not be loaded standalone via loadmodule, the\nsecsipid module loads it in each child process. This is required because\nlibsecsipid is multi-threaded and must be initialized per each child\nprocess, after forking, otherwise threads locks and resources are\ninherited and can lead to unpredictable behaviour, such as deadlocks.\n",
  "parameters": {},
  "functions": {}
 },
 "sipcapture": {
  "overview": "The sipcapture module stores incoming/outgoing SIP messages in a\ndatabase.\n\nKamailio can capture SIP messages in three modes\n\n- IPIP encapsulation. (ETHHDR+IPHDR+IPHDR+UDPHDR).\n\n- Monitoring/mirroring port.\n\n- Homer encapsulation protocol mode (HEP v1, v2, v3).\n\nThe capturing can be turned on/off using rpc commands. Example:\n\nkamctl rpc sipcapture.status on\n\nkamctl rpc sipcapture.status off\n",
  "parameters": {
   "db_url": "### `db_url` (str)\n\nDatabase URL.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"sipcapture\", \"db_url\", \"mysql://user:passwd@host/dbname\")\n...\n```\n",
   "table_name": "### `table_name` (str)\n\nName of the table's name used to store the SIP messages. Can contain\nmultiple tables, separated by \"|\".\n\n*Default value is \"sip_capture\". Only for Homer 3. For Homer 5, please\nuse an argument for the sip_capture function.*\n\n```\n...\nmodparam(\"sipcapture\", \"table_name\", \"homer_capture\")\n...\nmodparam(\"sipcapture\", \"table_name\", \"homer_capture1|homer_capture2\");\n...\n```\n",
   "mt_mode": "### `mt_mode` (str)\n\nName of the mode used for storing data in multiple tables. Modes can be\n\"rand\" (random), \"round_robin\" (use a round_robin algorithm) or \"hash\"\n(use hashing to determine the table to store). These modes are only\ntriggered if there is more than one table specified in table_name\nparameter, separated by \"|\".\n\n*Default value is \"rand\".*\n\n```\n...\nmodparam(\"sipcapture\", \"mt_mode\", \"hash\")\n...\n```\n",
   "hash_source": "### `hash_source` (str)\n\nThe field of the SIP message used for hashing, when mt_mode is set to\n\"hash\". The value can be \"call_id\", \"to_user\" or \"from_user\".\n\n*Default value is \"call_id\".*\n\n```\n...\nmodparam(\"sipcapture\", \"hash_source\", \"to_user\")\n...\n```\n",
   "db_insert_mode": "### `db_insert_mode` (integer)\n\nIf set to 1, use INSERT DELAYED to store sip message into capture table\nwhen the DB driver has support for it. If no INSERT DELAYED support is\noffered by DB driver, then standard INSERT is used.\n\nIf set to 2, use ASYNC INSERT to store sip message into capture table\nwhen the DB driver has support for it. If no ASYNC INSERT support is\noffered by DB driver, then standard INSERT is used.\n\nDefault value is 0 (no INSERT DELAYED).\n\n```\nmodparam(\"sipcapture\", \"db_insert_mode\", 1)\n```\n",
   "capture_on": "### `capture_on` (integer)\n\nParameter to enable/disable capture globally (on(1)/off(0))\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"sipcapture\", \"capture_on\", 1)\n...\n```\n",
   "capture_mode": "### `capture_mode` (str)\n\nThis parameter can be used for defining a capture mode which can be used\nin the sip_capture calls as a parameter. A capture mode has a name and\nsome parameters. It must be defined in the format:\nname=>param1=val1;param2=val2;... The parameters are db_url,\ntable_name, mt_mode and hash_source (optional). Multiple capture modes\ncan be defined by using this parameter multiple times. After this, the\ncapture modes can be used like: sip_capture (\"\", \"CAPTURE_MODE\");\n\n```\nmodparam(\"sipcapture\", \"capture_mode\", \"mode1=>db_url=mysql://user:passwd@host/dbname1;table_name=homer_capture1|homer_capture2;mt_mode=hash;hash_source=call_id;\")\nmodparam(\"sipcapture\", \"capture_mode\", \"mode2=>db_url=mysql://user:passwd@host/dbname2;table_name=homer_capture3|homer_capture4;mt_mode=rand;\")\n```\n",
   "hep_capture_on": "### `hep_capture_on` (integer)\n\nParameter to enable/disable capture of HEP (on(1)/off(0))\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"sipcapture\", \"hep_capture_on\", 1)\n...\n```\n",
   "raw_ipip_capture_on": "### `raw_ipip_capture_on` (integer)\n\nParameter to enable/disable IPIP capturing (on(1)/off(0))\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"sipcapture\", \"raw_ipip_capture_on\", 1)\n...\n```\n",
   "raw_moni_capture_on": "### `raw_moni_capture_on` (integer)\n\nParameter to enable/disable monitoring/mirroring port capturing\n(on(1)/off(0)) Only one mode on raw socket can be enabled! Monitoring\nport capturing currently supported only on Linux.\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"sipcapture\", \"raw_moni_capture_on\", 1)\n...\n        \n```\n",
   "raw_socket_listen": "### `raw_socket_listen` (string)\n\nParameter indicate a listen IP address of RAW socket for IPIP capturing.\nYou can also define a port/portrange for IPIP/Mirroring mode, to capture\nSIP messages in specific ports:\n\n\"10.0.0.1:5060\" - the source/destination port of the SIP message must be\nequal 5060\n\n\"10.0.0.1:5060-5090\" - the source/destination port of the SIP message\nmust be equal or be between 5060 and 5090.\n\nThe port/portrange must be defined if you are planning to use mirroring\ncapture! In this case, the part with IP address will be ignored, but to\nmake parser happy, use i.e. 10.0.0.0\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"sipcapture\", \"raw_socket_listen\", \"10.0.0.1:5060-5090\")\n...\nmodparam(\"sipcapture\", \"raw_socket_listen\", \"10.0.0.1:5060\")\n...\n```\n",
   "raw_interface": "### `raw_interface` (string)\n\nName of the interface to bind on the raw socket.\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"sipcapture\", \"raw_interface\", \"eth0\")\n...\n```\n",
   "raw_sock_children": "### `raw_sock_children` (integer)\n\nParameter define how many children that must be created to listen the\nraw socket.\n\n*Default value is \"1\".*\n\n```\n...\nmodparam(\"sipcapture\", \"raw_sock_children\", 6)\n...\n```\n",
   "promiscuous_on": "### `promiscuous_on` (integer)\n\nParameter to enable/disable promiscuous mode on the raw socket. Linux\nonly.\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"sipcapture\", \"promiscuous_on\", 1)\n...\n```\n",
   "raw_moni_bpf_on": "### `raw_moni_bpf_on` (integer)\n\nActivate Linux Socket Filter (LSF based on BPF) on the mirroring\ninterface. The structure is defined in linux/filter.h. The default LSF\naccept a port/portrange from the raw_socket_listen param. Currently LSF\nsupported only on Linux.\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"sipcapture\", \"raw_moni_bpf_on\", 1)\n...\n```\n",
   "capture_node": "### `capture_node` (str)\n\nName of the capture node.\n\n*Default value is \"homer01\".*\n\n```\n...\nmodparam(\"sipcapture\", \"capture_node\", \"homer03\")\n...\n```\n",
   "insert_retries": "### `insert_retries` (integer)\n\nThe number of times Kamailio should retry to write to the Homer database\nin case the first attempt failed. The retry is also limited timewise by\nthe insert_retry_timeout parameter. Values allowed range from 0 to 500.\n\n*Default value is 0 (no retries).*\n\n```\n...\nmodparam(\"sipcapture\", \"insert_retries\", 5)\n...\n            \n```\n",
   "insert_retry_timeout": "### `insert_retry_timeout` (integer)\n\nThe time limit in seconds Kamailio retries to write to the Homer\ndatabase in case the first attempt failed. This parameter is only used\ntogether with the insert_retries parameter. Values allowed range from 0\nto 300.\n\n*Default value is 60 seconds.*\n\n```\n...\nmodparam(\"sipcapture\", \"insert_retry_timeout\", 10)\n...\n            \n```\n",
   "callid_aleg_header": "### `callid_aleg_header` (str)\n\nHeader name used to correlate A-leg with B-leg. It can take a list of\nheaders, separated by semicolon, e.g. \"X-CID0;X-CID1\". First match wins.\n\n*Default value is \"X-CID\".*\n\n```\n...\nmodparam(\"sipcapture\", \"callid_aleg_header\", \"X-CallIDALeg\")\n...\n            \n```\n",
   "topoh_unmask": "### `topoh_unmask` (int)\n\nIf set to 1, call-id will be unmasked using topoh module api (topoh\nmodule must be loaded in this case).\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"sipcapture\", \"topoh_unmask\", 1)\n...\n            \n```\n",
   "nonsip_hook": "### `nonsip_hook` (int)\n\nIf set to 1, event route *sipcapture:siprequest* is run when HEP message\nis received.\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"sipcapture\", \"nonsip_hook\", 1)\n...\n            \n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues can be: 'sipcapture:request'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"sipcapture\", \"event_callback\", \"ksr_sipcapture_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_sipcapture_event(evname)\n    KSR.info(\"===== sipcapture module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "capture_bad_msgs": "### `capture_bad_msgs` (int)\n\nIf set to something different than 0, tries to capture also the broken\nSIP messages.\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"sipcapture\", \"capture_bad_msgs\", 1)\n...\n            \n```\n"
  },
  "functions": {
   "sip_capture": "### `sip_capture([table], [cmode])`\n\nStore the current processed HEP/IPIP SIP message in a database. It is\nstored in the form prior applying changes made to it.\n\nMeaning of the parameters is as follows:\n\n- *table* - The table where HEP SIP message will be stored. Homer 5 use\n  now tables with datestamp. To generate an automatic table's name\n  please use strftime parameters. I.e. $var(table) =\n  \"sip_capture_call_%Y%m%d\" and set the variable as an argument of the\n  sip_capture function.\n\n- *cmode* - The reference to the capture_mode parameter.\n\nThis function can be used from ANY_ROUTE.\n\nDefault value is \"NULL\".\n\n```\n...\nsip_capture();\n...\nsip_capture(\"sip_capture_call_20160124\");\n...\nsip_capture(\"\", \"cmode\");\n...\n```\n",
   "report_capture": "### `report_capture([table], [cid], [data])`\n\nStore the current processed HEP REPORT message in a database.\n\nMeaning of the parameters is as follows:\n\n- *table* - The table where REPORT message will be stored.\n\n- *cid* - The correlation id.\n\n- *data* - The custom report data in JSON format.\n\nThis function can be used from ANY_ROUTE.\n\nDefault value is \"NULL\".\n\n```\n...\nreport_capture();\n...\nreport_capture(\"report_data\", \"$ci\");\n...\nreport_capture(\"report_data\", \"$ci\", \"{\\\"MOS\\\":4.1,\\\"PACKET_LOST\\\":100\"});\n...\n```\n",
   "float2int": "### `float2int(fval, ival)`\n\nReturn the value of atof(fval) * atoi(ival). On case the result is 0,\nthen -1 is returned.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(res) = float2int(\"10.5\", \"1\");\n...\n```\n",
   "sip_capture_forward": "### `sip_capture_forward(uri)`\n\nForward the HEP packet to an address specified by the parameter uri (it\nhas to be a sip uri format). The function should be used inside\nevent_route[sipcapture:request]. After using this function, add a\nreturn 0 in order to stop processing further the packet in the local\nKamailio instance.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    event_route[sipcapture:request] {\n        ...\n        if(src_ip==1.2.3.4) {\n            sip_capture_forward(\"sip:2.3.4.5:5090\");\n            return 0;\n        }\n        ...\n    }\n...\n```\n"
  }
 },
 "sipdump": {
  "overview": "This module writes SIP traffic and some associated details into local\nfiles. It intercepts automatically all the SIP traffic received or sent\nby Kamailio and provides a function to trigger storage from\nconfiguration file.\n\nReceived traffic has the tag 'rcv' and the one to be sent has the tag\n'snd'. The tag value is provided as parameter for the config function.\n\nBesides the SIP packets, the module aims to save details related to\nKamailio runtime environment that are useful for troubleshooting, like\nprocess id, child rank, a.s.o.\n\nThe module should be useful for troubleshooting during development or\ntesting of new deployments, especially when dealing with traffic over\nTLS with forward privacy, when other tools such as wireshark cannot\ndecrypt. For production environments with a lot of SIP traffic, look at\nsiptrace and sipcapture modules for a scalable alternative to capture\nall the SIP traffic and then search using Homer Sipcapture web toolkit.\n",
  "parameters": {
   "enable": "### `enable` (int)\n\nEnable sipdump activity.\n\n*Default value is 0 (0 - off; 1 - on).*\n\n```\n...\nmodparam(\"sipdump\", \"enable\", 1)\n...\n```\n",
   "mode": "### `mode` (int)\n\nSet the type of activity done by the module, the value can be set based\non flags index: 0 (value 1) - write to text files; 1 (value 2) - execute\nevent route; 2 (value 4) - write to pcap files; 3 (value 8) - insert the\nP-KSR-SIPDump header with meta data inside the SIP message written in\npcap file.\n\nTo enable several activity modes, set the parameter to the sum of\ncorresponding values.\n\n*Default value is 1 (write to text files).*\n\n```\n...\nmodparam(\"sipdump\", \"mode\", 3)\n...\n```\n",
   "wait": "### `wait` (int)\n\nWait time (microseconds) when no SIP traffic is received.\n\n*Default value is 100.*\n\n```\n...\nmodparam(\"sipdump\", \"wait\", 2000)\n...\n```\n",
   "rotate": "### `rotate` (int)\n\nTime interval in seconds to rotate files.\n\n*Default value is 7200 (2 hours).*\n\n```\n...\nmodparam(\"sipdump\", \"rotate\", 3600)\n...\n```\n",
   "folder": "### `folder` (str)\n\nPath to the folder where to save the files.\n\n*Default value is \"/tmp\".*\n\n```\n...\nmodparam(\"sipdump\", \"folder\", \"/run/kamailio\")\n...\n```\n",
   "fprefix": "### `fprefix` (str)\n\nFile name prefix. The date is appended to this prefix in the format\nyyyy-mm-dd--hh-mm-ss. The extension of the text file is \".data\", of the\nmeta file is \".meta\" and of the pcap file is \".pcap\".\n\n*Default value is \"kamailio-sipdump-\".*\n\n```\n...\nmodparam(\"sipdump\", \"fprefix\", \"ksipdump-\")\n...\n```\n",
   "fage": "### `fage` (int)\n\nAge of created files (in seconds) to be removed if they become older.\nCleanup is done on a timer routine running every 600 seconds.\n\n*Default value is 0 (no cleanup of created files).*\n\n```\n...\n# cleanup files older than two days\nmodparam(\"sipdump\", \"fage\", 172800)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nName of the KEMI function to be executed instead of the event route.\n\n*Default value is not set.*\n\n```\n...\nmodparam(\"sipdump\", \"event_callback\", \"ksr_sipdump_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_sipdump_event(evname)\n    KSR.info(\"===== sipdump module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n"
  },
  "functions": {
   "sipdump_send": "### `sipdump_send(tag)`\n\nSend the details of the current SIP message to the writer process and\nget it stored in the file.\n\nThe parameter \"tag\" can be any string, it is going to be written in the\ntag attribute inside the storage file.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsipdump_send(\"cfg\");\n...\n```\n"
  }
 },
 "sipjson": {
  "overview": "This module serializes SIP message attributes into a JSON document.\n\nIt can facilitate getting the SIP attributes in a structure inside one\nof the embedded interpreters (e.g., KEMI interpreters, Lua can parse\nJSON in an internal hash table).\n",
  "parameters": {},
  "functions": {
   "sj_serialize": "### `sj_serialize(opt, ovar)`\n\nDo the serialization of SIP message attributes into a JSON document.\n\nWhen there is a match, it uses the corresponding pseudo-variable name\nfor JSON attribute (e.g., 'ru' is the R-URI attribute name).\n\nMeaning of the parameters:\n\n- opt - list of optional groups of attributes to be serialized. Each\n  group of attributes has a corresponding character. These are:\n\n  - 0 - (zero) default attributes to be serialized. They are added even\n    if '0' is not provided as parameter, however, because 'opt'\n    parameter cannot be empty, '0' can be given when only default\n    attributes are wanted.\n\n  - B - (uppercase B) SIP message body\n\n  - c - (lowercase c) CSeq attributes\n\n  - t - (lowercase t) To header attributes\n\n\n- ovar - name of the output pseduo-variable\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsj_serialize(\"0B\", \"$var(json)\");\n...\n```\n"
  }
 },
 "siprepo": {
  "overview": "This module can store and fetch SIP message content in an in-memory hash\ntable.\n",
  "parameters": {
   "hash_size": "### `hash_size (int)`\n\nNumber of slots in the hash table. It should be power of 2.\n\nDefault value: 256.\n\n```\n...\nmodparam(\"siprepo\", \"hash_size\", 1024)\n...\n```\n",
   "expire": "### `expire (int)`\n\nNumber of seconds until the stored message content expires.\n\nDefault value: 180.\n\n```\n...\nmodparam(\"siprepo\", \"expire\", 240)\n...\n```\n",
   "timer_interval": "### `timer_interval (int)`\n\nNumber of seconds to run the timer routine.\n\nDefault value: 10.\n\n```\n...\nmodparam(\"siprepo\", \"timer_interval\", 5)\n...\n```\n",
   "timer_procs": "### `timer_procs (int)`\n\nNumber of timer processes.\n\nDefault value: 1.\n\n```\n...\nmodparam(\"siprepo\", \"timer_procs\", 2)\n...\n```\n"
  },
  "functions": {
   "sr_msg_push": "### `sr_msg_push(msgid)`\n\nPush the message content to hash table and associate it with `msgid`.\nThe Call-Id and msgid are needed to pull the message.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    $var(msgid) = $sruid;\n    if(sr_msg_push(\"$var(msgid)\")) {\n    }\n    ...\n}\n...\n```\n",
   "sr_msg_pull": "### `sr_msg_pull(callid, msgid, rname)`\n\nPull the message content and execute the route block 'rname'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(sr_msg_pull(\"$var(callid)\", \"$var(msgid)\", \"REPOPULL\")) {\n    }\n    ...\n}\n...\n```\n",
   "sr_msg_async_pull": "### `sr_msg_async_pull(callid, msgid, gname, rname)`\n\nPull the message content and execute the route block 'rname' via async\ngroup 'gname'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(sr_msg_async_pull(\"$var(callid)\", \"$var(msgid)\", \"WG01\", \"REPOPULL\")) {\n    }\n    ...\n}\n...\n```\n",
   "sr_msg_rm": "### `sr_msg_rm(callid, msgid)`\n\nRemove the message content.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(sr_msg_rm(\"$var(callid)\", \"$var(msgid)\")) {\n    }\n    ...\n}\n...\n```\n",
   "sr_msg_check": "### `sr_msg_check()`\n\nCheck if the message is stored.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(sr_msg_check()) {\n    }\n    ...\n}\n...\n```\n"
  }
 },
 "sipt": {
  "overview": "Module for updating ISUP encapsulated in SIP (SIP-T/SIP-I)\n\nThe sipt module can be used to update various ss7 headers contained\ninside a message.\n",
  "parameters": {},
  "functions": {
   "sipt_destination": "### `sipt_destination(destination, hops, nai[, terminator=1])`\n\nupdates the IAM in the body if it exists, setting the called party\nnumber to \u201cdestination\u201d with the nature address specified in \u201cnai\u201d and\ndecrementing the hop counter value if present. If the hop counter header\nis missing it will be added with the value of \u201chops\u201d. If \u201cterminator\u201d is\nset to 1, then F will be appended to digit string to indicate the number\nis complete (default).\n\n```\n...\n# update the destination number to our current request uri,\n# setting nature of address to international\n$rU = \"19495551234\";\nsipt_destination($rU, 31, 4);\n...\n```\n",
   "sipt_set_bci_1": "### `sipt_set_bci_1(charge_indicator, called_status, called_category, e2e_indicator)`\n\nupdates the first byte of the backward call indicator in the ACM or COT\nin the body if setting the Charge Indicator to \u201ccharge_indicator\u201d, the\nCalled party's status indicator in \u201ccalled_status\u201d, the Called party's\ncategory indicator in \u201ccalled_category\u201d and the End to End Method\nIndicator with the value of the value of \u201ce2e_indicator\u201d.\n\n```\n...\n# set bci for charging, subscriber free, ordinary, no e2e available\nsipt_set_bci_1(\"2\", \"1\", \"1\", \"0\");\n...\n```\n",
   "sipt_set_calling": "### `sipt_set_calling(origin, nai, presentation, screening)`\n\nupdates the IAM in the body if it exists, setting (or adding) the\ncalling party number to \u201corigin\u201d with the nature address specified in\n\u201cnai\u201d and setting the presentation and screening values to\n\u201cpresentation\u201d and \u201cscreening\u201d.\n\n```\n...\n# update the calling party to the value in the from header\nsipt_set_calling($fU, 4, 0, 3);\n...\n```\n",
   "sipt_forwarding": "### `sipt_forwarding(origin, nai)`\n\nupdates the IAM in the body if it exists, setting (or adding) the\nforwarding number to \u201corigin\u201d with the nature address specified in\n\u201cnai\u201d.\n\n```\n...\n# update the forwarding number to the value in the from header\nsipt_forwarding($avp(s:forwarding_number), 3);\n...\n```\n",
   "sipt_has_isup_body": "### `sipt_has_isup_body()`\n\nThe function returns *true* if the SIP message has an ISUP body\nattached.\n\n```\n...\nif(sipt_has_isup_body())\n{\n    # do interesting stuff here\n}\n...\n```\n"
  }
 },
 "siptrace": {
  "overview": "The SIPtrace module offers a possibility to store incoming and outgoing\nSIP messages in a database and/or duplicate to the capturing server\n(using HEP, the Homer encapsulation protocol, or plain SIP mode). Since\nversion 5.3.0 new levels of tracing are available. Transactions and\ndialogs can be traced.\n\nThere are multiple ways of storing information:\n\n- by calling the sip_trace() method explicitly in the Kamailio\n  configuration file. In this case the original message is processed\n  along with its corresponding transaction/dialog if certain flags are\n  used.\n\n- by setting \u201ctrace_mode\u201d to mirror or store to db all traffic.\n\nThe tracing can be turned on/off using Kamailio RPC commands.\n\nkamctl rpc siptrace.status on\n\nkamctl rpc siptrace.status off\n",
  "parameters": {
   "db_url": "### `db_url` (str)\n\nDatabase URL.\n\n*Default value is \"mysql://kamailio:kamailiorw@localhost/kamailio\".*\n\n```\n...\nmodparam(\"siptrace\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "table": "### `table` (str)\n\nName of the table where to store the SIP messages.\n\n*Default value is \u201csip_trace\u201d.*\n\n```\n...\nmodparam(\"siptrace\", \"table\", \"strace\")\n...\n```\n",
   "trace_flag": "### `trace_flag` (integer)\n\nWhich flag is used to mark messages to trace without traced user.\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"siptrace\", \"trace_flag\", 22)\n...\n```\n",
   "trace_on": "### `trace_on` (integer)\n\nParameter to enable/disable trace (on(1)/off(0))\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"siptrace\", \"trace_on\", 1)\n...\n```\n",
   "traced_user_avp": "### `traced_user_avp` (str)\n\nThe name of the AVP storing the SIP URI of the traced user. If the AVP\nis set, messages are stored in a database table and the \u201ctraced_user\u201d\ncolumn is filled with AVP's value. You can store the message many times\nfor many users by having multiple values for this AVP.\n\n*Default value is \"NULL\" (feature disabled).*\n\n```\n...\nmodparam(\"siptrace\", \"traced_user_avp\", \"$avp(user)\")\n...\n```\n",
   "trace_table_avp": "### `trace_table_avp` (str)\n\nThe name of the AVP storing the name of the table where to store the SIP\nmessages. If it is not set, the value of \u201ctable\u201d parameter is used. In\nthis way one can select dynamically where to store the traced messages.\nThe table must exist, and must have the same structure as the\n\u201csip_trace\u201d table.\n\n*Default value is \"NULL\" (feature disabled).*\n\n```\n...\nmodparam(\"siptrace\", \"trace_table_avp\", \"$avp(i:345)\")\nmodparam(\"siptrace\", \"trace_table_avp\", \"$avp(s:siptrace_table)\")\n...\n```\n",
   "duplicate_uri": "### `duplicate_uri` (str)\n\nThe address in form of a SIP URI where to send a duplicate of traced\nmessage.\n\n*Default value is \"NULL\".*\n\n```\n...\nmodparam(\"siptrace\", \"duplicate_uri\", \"sip:10.1.1.1:5888\")\n...\n```\n",
   "trace_to_database": "### `trace_to_database` (integer)\n\nParameter to enable/disable inserts to the database from this Kamailio.\n\nIn case we only want to send the SIP messages to the \u201cduplicate_uri\u201d and\nnot store the information to the local database we can set this to \"0\".\n\n*Default value is \"1\".*\n\n```\n...\nmodparam(\"siptrace\", \"trace_to_database\", 0)\n...\n```\n",
   "trace_local_ip": "### `trace_local_ip` (str)\n\nThe address to be used in \u201cfromip\u201d field for locally generated messages.\nIf not set, the module sets it to the address of the socket that will be\nused to send the message.\n\n*Default value is \"NULL\".*\n\n```\n...\nmodparam(\"siptrace\", \"trace_local_ip\", \"10.1.1.1:5064\")\n...\n```\n",
   "trace_sl_acks": "### `trace_sl_acks` (integer)\n\nParameter to enable/disable tracing of SL-filtered ACKs (on=1 / off=0).\n\nBy default all ACKs to replies generated by SL module are traced. There\nis no way to select among them. The SL module is able to run an event\nroute when such an ACK arrives (*event_route[sl:filtered-ack]*). You\ncan set this parameter to 0 and then execute sip_trace() in the event\nroute, accompanied by config rules to decide which ACK to trace.\n\n*Default value is \"1\".*\n\n```\n...\nmodparam(\"siptrace\", \"trace_sl_acks\", 0)\n...\n```\n",
   "xheaders_write": "### `xheaders_write` (integer)\n\nParameter to enable/disable writing of x-headers.\n\nStores \u201cfromip\u201d, \u201ctoip\u201d, \u201cmethod\u201d and \u201cdirection\u201d in \u201cX-Siptrace-*\u201d\nheaders. This allows to transmit them to a second Kamailio server using\nthe \u201cduplicate_uri\u201d feature. Because the headers are added after the\ndata is written to the database, the headers only show up in the packets\nsent by duplicate_uri.\n\nSee `xheaders_read`, it should be used on the receiving side.\n\n*Note:* The headers are first read, then written. This allows relaying\nthe information over more than two Kamailio servers by setting both\n`xheaders_write` and `xheaders_read` to \"1\" on the servers in the\nmiddle.\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"siptrace\", \"xheaders_write\", 0)\n...\n```\n",
   "xheaders_read": "### `xheaders_read` (integer)\n\nParameter to enable/disable reading of x-headers.\n\nReads and removes the \u201cX-Siptrace-*\u201d headers. Packets not containing\nthe headers are neither stored to the database nor relayed\n(duplicate_uri). See `xheaders_write` for further information.\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"siptrace\", \"xheaders_read\", 0)\n...\n```\n",
   "hep_mode_on": "### `hep_mode_on` (integer)\n\nParameter to enable/disable Homer encapsulate mode (on(1)/off(0))\n\n*Default value is \"0\".*\n\n```\n...\nmodparam(\"siptrace\", \"hep_mode_on\", 1)\n...\n```\n",
   "hep_version": "### `hep_version` (integer)\n\nThe parameter indicate the version of the HEP protocol. Can be \u201c1\u201d, \u201c2\u201d\nor \u201c3\u201d. In HEPv2 and HEPv3 the timestamp and capture agent ID will be\nincluded in the HEP header.\n\n*Default value is \"1\".*\n\n```\n...\nmodparam(\"siptrace\", \"hep_version\", 3)\n...\n```\n",
   "hep_capture_id": "### `hep_capture_id` (integer)\n\nThe parameter indicate the capture agent ID for the HEPv2 or HEPv3\nprotocol. Limitation: 16-bit integer for HEPv2, 32-bit for HEPv3.\n\n*Default value is \"1\".*\n\n```\n...\nmodparam(\"siptrace\", \"hep_capture_id\", 234)\n...\n```\n",
   "trace_db_mode": "### `trace_db_mode` (integer)\n\nIf set to 1, the module uses \u201cINSERT DELAYED\u201d to store to database (when\nit is available, otherwise falls back to \u201cINSERT\u201d).\n\nIf set to 2, the module uses \u201cASYNC-INSERT\u201d to store to database (when\nit is available, otherwise falls back to \u201cINSERT\u201d).\n\nDefault value is *0 (use \u201cINSERT\u201d)*.\n\n```\n...\nmodparam(\"siptrace\", \"trace_db_mode\", 1)\n...\n```\n",
   "trace_delayed": "### `trace_delayed` (integer)\n\nKept for backward compatibily, use trace_db_mode instead.\n\nIf set to non-zero, ot sets trace_db_mode parameter to 1 when the module\nis initialized.\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"siptrace\", \"trace_delayed\", 1)\n...\n```\n",
   "send_sock_name": "### `send_sock_name` (str)\n\nThe name of the local listen socket from where to send the duplicated\ntraffic via SIP or HEP. In the absence of this parameter Kamailio\nautomatically picks an interface. It has priority over 'send_sock_addr'\nparameter.\n\n```\n...\nmodparam(\"siptrace\", \"send_sock_name\", \"sock1\")\n...\n```\n",
   "send_sock_addr": "### `send_sock_addr` (str)\n\nThe local interface in the form of SIP URI from where to send the\nduplicated traffic. In the absence of this parameter Kamailio\nautomatically picks an interface.\n\n```\n...\nmodparam(\"siptrace\", \"send_sock_addr\", \"sip:10.1.1.2:5000\")\n...\n```\n",
   "force_send_sock": "### `force_send_sock` (str)\n\nIt is the same as 'send_sock_addr' parameter, this being kept for\nbackward compatibility when 'send_sock_name' and 'send_sock_addr' were\nintroduced.\n",
   "trace_init_mode": "### `trace_init_mode` (integer)\n\nControl what tracing modes are initialized.\n\nThe value of the parameter can be a combination of next values:\n\n- 0 - all modes are initialized.\n\n- 1 - module initialized to do tracing only with core callback functions\n  (see also 'trace_mode' parameter).\n\n- 2 - module initialized to do tracing only using config script flags\n  and functions.\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"siptrace\", \"trace_init_mode\", 1)\n...\n```\n",
   "trace_mode": "### `trace_mode` (integer)\n\nIf not set to 0, the module uses core events triggered when receiving or\nsending SIP traffic to store it to database or mirror it to a SIP\ncapture server using HEP or UDP forwarding. It will automatically do the\nhandling of all SIP traffic. It is no longer needed to set the siptrace\nflag per request or execute sip_trace(), if it is done, then the storing\nand mirroring is duplicated.\n\nThe value of the parameter can be a combination of next values:\n\n- 0 - no automatic mirroring or storing of SIP traffic.\n\n- 1 (1st bit set) - mirror the traffic to HEP server.\n\n- 2 (2nd bit set) - store the traffic to database server.\n\n- 4 (3rd bit set) - mirror the traffic to the SIP URI specified by\n  duplicate_uri.\n\nThe trace_on parameter still has to be set, allowing also to control\nthis mode of mirroring via RPC commands.\n\nDefault value is *0*.\n\n```\n...\nmodparam(\"siptrace\", \"trace_on\", 1)\nmodparam(\"siptrace\", \"trace_mode\", 1)\n...\nmodparam(\"siptrace\", \"trace_mode\", 3)\n...\n```\n",
   "auth_key": "### `auth_key` (integer)\n\nA string with an authorization key. Supported on HEPv3 only.\n\nDefault value is empty.\n\n```\n...\nmodparam(\"siptrace\", \"auth_key\", \"spoihepuirthpeuia\")\n...\n```\n",
   "evcb_msg": "### `evcb_msg` (str)\n\nSet the name of KEMI function to be executed instead of\nevent_route[siptrace:msg].\n\nDefault value is empty.\n\n```\n...\nmodparam(\"siptrace\", \"evcb_msg\", \"ksr_siptrace_msg\")\n...\n```\n",
   "trace_dialog_ack": "### `trace_dialog_ack` (str)\n\nEnable tracing of in-dialog ACK. Before this param, one must have set\nthe onsend() route and captured the outgoing ACK there.\n\nDefault value is 1 (enabled).\n\n```\n...\nmodparam(\"siptrace\", \"trace_dialog_ack\", 1)\n...\n```\n",
   "trace_dialog_spiral": "### `trace_dialog_spiral` (str)\n\nEnable tracing of dialog spirals. A spiraled dialog is a dialog\nestablished by a SIP INVITE that loops back to the same kamailio (as\nnext hop). Right now, inside the siptrace code, a spiraled dialog is\nidentified by (*params->param == NULL).\n\nDefault value is 1 (enabled).\n\n```\n...\nmodparam(\"siptrace\", \"trace_dialog_spiral\", 1)\n...\n```\n"
  },
  "functions": {
   "sip_trace": "### `sip_trace([address][, correlation_id][, mode])`\n\nStore or forward the current processed SIP message/transaction/dialog in\na database. It is stored in the form prior applying changes made to it.\nBased on mode, one can trace the current message('m'), the current\ntransaction('t') or the current dialog('d'). If no mode is given, it\nfalls back to the default mode - transaction tracking when trace_flag is\nset, otherwise only the current message.\n\nMeaning of the parameters is as follows:\n\n- *address* - The address in form of SIP URI where to send a duplicate\n  of traced message. This parameter trumps duplicate_uri and allows\n  tracing to more than one server.\n\n- *correlation_id* - A string with a correlation ID to be added to the\n  HEP header when using HEPv3. It's possible to use PVs.\n\n- *mode* - SIP messages to be traced. One can trace the current message\n  (function can be called on either a reply or a request), the current\n  transaction(the route must belong to a request) or the current\n  dialog(the message has to be an invite).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE, BRANCH_ROUTE.\n\nDefault value is \"NULL\".\n\n```\n...\nsip_trace();\n...\nsip_trace(\"sip:10.1.1.2:5085\");\n...\nsip_trace(\"sip:10.1.1.2:5085\", \"$ci-abc\");\n...\n/* trace current dialog; needs to be done on initial INVITE and dialog has to be loaded */\nsip_trace(\"sip:10.1.1.2:5085\", \"$ci-abc\", \"d\");\n...\n```\n",
   "sip_trace_mode": "### `sip_trace_mode(tmode)`\n\nSet the tracing mode: message, transaction or dialog. Only the first\ncharacter of the parameter matters: m or M for message; t or T for\ntransaction; d or D for dialog.\n\nIn message tracing mode only the current message is stored or mirrored.\nIn transaction tracing mode, all the messages of the current transaction\nare stored or mirrored. In dialog tracing mode, all the messages of the\ncurrent dialog are stored or mirrored.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nsip_trace_mode(\"t\");\n...\n```\n",
   "sip_trace_msg": "### `sip_trace_msg(vmsg, saddr, taddr, daddr, corrid)`\n\nSend the value of vmsg to the HEP capture server located at daddr, by\nsetting saddr as source address and taddr as target address for vmsg.\nCorrelation ID can be provided with corrid parameter or left as an empty\nstring. The saddr and taddr have to be provided in socket address format\n(proto:ip:port) and the daddr in SIP URI format.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nsip_trace_msg(\"$var(msg)\", \"udp:127.0.0.1:5062\", \"udp:127.0.0.1:5064\", \"sip:127.0.0.1:5090\", \"\");\n...\n```\n",
   "hlog": "### `hlog([correlation_id,] message)`\n\nSends a log event as a HEP3 packet to the homer host configured in\n*duplicate_uri*.\n\nMeaning of the parameters is as follows:\n\n- *correlation_id* (optional) - Homer correlation ID for this event. If\n  this parameter is not set, the current message's call-id will be used.\n  (This parameter may contain PVs)\n\n- *message* - The text to send to Homer as log event. (This parameter\n  may contain PVs)\n\n<!-- -->\n\n\n```\n...\nhlog(\"[cfg:$cfg(line)] This is a log from kamailio to Homer\");\n...\nhlog(\"$hdr(P-MyID)\", \"Another one with a custom correlation ID\");\n...\n```\n"
  }
 },
 "siputils": {
  "overview": "This module implements various functions and checks related to SIP\nmessage handling and URI handling.\n\nThis module also provides a function to answer OPTIONS requests which\nare directed to the server itself. This means an OPTIONS request which\nhas the address of the server in the request URI, and no username in the\nURI. The request will be answered with a 200 OK with the capabilities of\nthe server.\n\nTo answer OPTIONS request directed to your server is the easiest way for\nis-alive-tests on the SIP (application) layer from remote (similar to\nICMP echo requests, also known as \u201cping\u201d, on the network layer).\n",
  "parameters": {
   "options_accept": "### `options_accept` (string)\n\nThis parameter is the content of the Accept header field. Note: it is\nnot clearly written in RFC3261 if a proxy should accept any content (the\ndefault \u201c*/*\u201d) because it does not care about content. Or if it does\nnot accept any content, which is \u201c\u201d.\n\n*Default value is \u201c\\*/*\u201d.*\n\n```\n...\nmodparam(\"siputils\", \"options_accept\", \"application/*\")\n...\n```\n",
   "options_accept_encoding": "### `options_accept_encoding` (string)\n\nThis parameter is the content of the Accept-Encoding header field.\nPlease do not change the default value because Kamailio does not support\nany encodings yet.\n\n*Default value is \u201c\u201d.*\n\n```\n...\nmodparam(\"siputils\", \"options_accept_encoding\", \"gzip\")\n...\n```\n",
   "contact_flds_separator": "### `contact_flds_separator` (string)\n\nFirst char of this parameter is used as separator for encoding/decoding\nContact header.\n\n<div class=\"warning\">\n\n\nFirst char of this field must be set to a value which is not used inside\nusername, password or other fields of contact. Otherwise it is possible\nfor the decoding step to fail/produce wrong results.\n\n</div>\n\n\n*Default value is \u201c\\*\u201d.*\n\n```\n...\nmodparam(\"siputils\", \"contact_flds_separator\", \"-\")\n...\n```\n\nthen an encoded uri might look\nsip:user-password-ip-port-protocol@PublicIP\n",
   "options_accept_language": "### `options_accept_language` (string)\n\nThis parameter is the content of the Accept-Language header field. You\ncan set any language code which you prefer for error descriptions from\nother devices, but presumably there are not many devices around which\nsupport other languages than the default English.\n\n*Default value is \u201cen\u201d.*\n\n```\n...\nmodparam(\"siputils\", \"options_accept_language\", \"de\")\n...\n```\n",
   "options_support": "### `options_support` (string)\n\nThis parameter is the content of the Support header field, indicating\nSIP extensions. Please do not change the default value, because Kamailio\ncurrently does not support any of the SIP extensions registered at the\nIANA.\n\n*Default value is \u201c\u201d.*\n\n```\n...\nmodparam(\"siputils\", \"options_support\", \"100rel\")\n...\n```\n",
   "rpid_prefix": "### `rpid_prefix` (string)\n\nPrefix to be added to Remote-Party-ID header field just before the URI\nreturned from either radius or database.\n\nDefault value is \u201c\u201d.\n\n```\nmodparam(\"siputils\", \"rpid_prefix\", \"Whatever <\")\n```\n",
   "rpid_suffix": "### `rpid_suffix` (string)\n\nSuffix to be added to Remote-Party-ID header field after the URI\nreturned from either radius or database.\n\nDefault value is \u201c;party=calling;id-type=subscriber;screen=yes\u201d.\n\n```\nmodparam(\"siputils\", \"rpid_suffix\", \"@1.2.3.4>\")\n```\n",
   "rpid_avp": "### `rpid_avp` (string)\n\nFull AVP specification for the AVP which stores the RPID value. It used\nto transport the RPID value from authentication backend modules (auth_db\nor auth_radius) or from script to the auth function append_rpid_hf and\nis_rpid_user_e164.\n\nIf defined to NULL string, all RPID functions will fail at runtime.\n\nDefault value is \u201c$avp(s:rpid)\u201d.\n\n```\nmodparam(\"siputils\", \"rpid_avp\", \"$avp(myrpid)\")\n        \n```\n",
   "e164_max_len": "### `e164_max_len` (int)\n\nThe maximum length for checking e164 numbers, including the leading '+'.\n\nDefault value is \u201c16\u201d.\n\n```\nmodparam(\"siputils\", \"e164_max_len\", 20)\n```\n"
  },
  "functions": {
   "options_reply": "### `options_reply()`\n\nThis function checks if the request method is OPTIONS and if the request\nURI does not contain a username. If both are true the request will be\nanswered stateless with \u201c200 OK\u201d and the capabilities from the modules\nparameters.\n\nIt sends \u201c500 Server Internal Error\u201d for some errors and returns false\nif it is called for a wrong request.\n\nThe check for the request method and the missing username is optional\nbecause it is also done by the function itself. But you should not call\nthis function outside the myself check because in this case the function\ncould answer OPTIONS requests which are sent to you as outbound proxy\nbut with another destination than your proxy (this check is currently\nmissing in the function).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (uri==myself) {\n    if ((method==OPTIONS) && (! uri=~\"sip:.*[@]+.*\")) {\n        options_reply();\n    }\n}\n...\n```\n",
   "is_user": "### `is_user(username)`\n\nCheck if the username in credentials matches the given username.\n\nMeaning of the parameters is as follows:\n\n- *username* - Username string.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_user(\"john\")) {\n    ...\n};\n...\n```\n",
   "has_totag": "### `has_totag()`\n\nCheck if To header field uri contains tag parameter.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (has_totag()) {\n    ...\n};\n...\n```\n",
   "uri_param": "### `uri_param(param, value)`\n\nFind if Request URI has a given parameter with matching value\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name to look for.\n\n- *value* - parameter value to match.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (uri_param(\"param1\",\"value1\")) {\n    ...\n};\n...\n```\n",
   "uri_param_any": "### `uri_param_any(param)`\n\nFind if Request URI has a given parameter with or without value.\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name to look for.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (uri_param_any(\"param1\")) {\n    ...\n}\n...\n```\n",
   "add_uri_param": "### `add_uri_param(param)`\n\nAdd to RURI a parameter (name=value);\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter to be appended in \u201cname=value\u201d format.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nadd_uri_param(\"nat=yes\");\n...\n```\n",
   "get_uri_param": "### `get_uri_param(name, var)`\n\nGet the value of RURI parameter.\n\nMeaning of the parameters is as follows:\n\n- *name* - the name of R-URI parameter\n\n- *var* - the variable where to store the value of the parameter\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nget_uri_param(\"nat\", \"$var(nat)\");\n...\n```\n",
   "uri_param_rm": "### `uri_param_rm(param)`\n\nRemove parameter from Request URI.\n\nMeaning of the parameters is as follows:\n\n- *param* - parameter name.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (uri_param_rm(\"param1\")) {\n    ...\n}\n...\n```\n",
   "tel2sip": "### `tel2sip(uri, hostpart, result)`\n\nConverts URI in first param (pseudo variable or string) to SIP URI, if\nit is a tel URI. If conversion was done, writes resulting SIP URI to\nthird param (pseudo variable). Returns 1 if conversion succeeded, 2 if\nno conversion was needed, and -1 in case of error.\n\nThe conversion follows the rules in RFC 3261 section 19.1.6:\n\n- Visual separators ( \"-\", \".\", \"(\", \")\" ) are removed from tel URI\n  number before converting it to SIP URI userinfo.\n\n- tel URI parameters are downcased before appending them to SIP URI\n  userinfo\n\nThe SIP URI hostpart is taken from second param (pseudo variable or\nstring).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, or ONREPLY_ROUTE.\n\n```\n...\n# $ru: tel:+(34)-999-888-777\n# $fu: sip:test@foo.com\ntel2sip(\"$ru\", $fd\", \"$ru\");\n# $ru:  sip:+34999888777@foo.com;user=phone\n\n# $ru: tel:+12-(34)-56-78;Ext=200;ISUB=+123-456\n# $fu: sip:test@foo.com\ntel2sip(\"$ru\", $fd\", \"$ru\");\n# $ru:  sip:+12345678;ext=200;isub=+123-456@foo.com;user=phone\n...\n```\n",
   "tel2sip2": "### `tel2sip2(uri, hostpart, result)`\n\nAlternative to sip2tel() function that tries to follow closer the RFC\nrequrements (e.g., sort tel: uri parameters copied to the sip: uri in\nthe manner defined in the standard; deletes the phone-context parameter\nif it is a domain, and, takes visual separators from the phone-context\nparameter if it is a telephone number).\n\nIts parameters have the same meaning as for tel2sip().\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, or ONREPLY_ROUTE.\n\n```\n...\n# $ru: tel:+(34)-999-888-777\n# $fu: sip:test@foo.com\ntel2sip2(\"$ru\", $fd\", \"$ru\");\n# $ru:  sip:+34999888777@foo.com;user=phone\n...\n```\n",
   "is_e164": "### `is_e164(pseudo-variable)`\n\nChecks if string value of pseudo variable argument is an E164 number.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE, and\nLOCAL_ROUTE.\n\n```\n...\nif (is_e164(\"$fU\")) {  # Check From header URI user part\n   ...\n}\nif (is_e164(\"$avp(i:705)\") {\n   # Check stgring value stored in avp i:705\n   ...\n};\n...\n```\n",
   "is_uri_user_e164": "### `is_uri_user_e164(pseudo-variable)`\n\nChecks if userpart of URI stored in pseudo variable is E164 number.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_uri_user_e164(\"$fu\")) {  # Check From header URI user part\n   ...\n}\nif (is_uri_user_e164(\"$avp(i:705)\") {\n   # Check user part of URI stored in avp i:705\n   ...\n};\n...\n```\n",
   "is_uri": "### `is_uri(pseudo-variable)`\n\nChecks if string value of pseudo variable argument is a valid uri.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_uri(\"$var(x)\")) {  # Check if variable contains a uri\n   ...\n}\nif (is_uri(\"$avp(i:705)\") {\n   # Check value stored in avp i:705\n   ...\n};\n...\n```\n",
   "is_tel_number": "### `is_tel_number(tval)`\n\nChecks if the parameter value is a telephone number: starting with one\noptional +, followed by digits. The parameter can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_tel_number(\"$rU\")) {  # Test if R-URI user is telephone number\n   ...\n}\nif (is_tel_number(\"+24242424\")) {\n   ...\n}\n...\n```\n",
   "is_numeric": "### `is_numeric(tval)`\n\nChecks if the parameter value consists solely of decimal digits. The\nparameter can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_numeric(\"$rU\")) {  # Test if R-URI user consists of decimal digits\n   ...\n}\n...\n```\n",
   "is_alphanum": "### `is_alphanum(tval)`\n\nChecks if the parameter value consists solely of decimal digits or\nalphabetic ASCII characters. The parameter can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_alphanum(\"$rU\")) {\n   ...\n}\n...\n```\n",
   "is_alphanumex": "### `is_alphanumex(tval, eset)`\n\nChecks if the value of parameter 'tval' consists solely of decimal\ndigits, alphabetic ASCII characters and the characters in the second\nparameter 'eset'. The parameters can include variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_alphanumex(\"$rU\", \"+.-_\")) {\n   ...\n}\n...\n```\n",
   "encode_contact": "### `encode_contact(encoding_prefix, hostpart)`\n\nThis function will encode uri-s inside Contact header in the following\nmanner sip:username:password@ip:port;transport=protocol goes\nsip:encoding_prefix*username*password*ip*port*protocol@hostpart.\n\n* is the default separator and can be changed by setting the\ncontact_flds_separator module parameter.\n\nNote: This function discards all of the URI parameters. Thus, none of\nthe parameters (except the transport parameter which is encoded into the\nuserpart) can be restored.\n\nThe function returns negative on error, 1 on success.\n\nMeaning of the parameters is as follows:\n\n- *encoding_prefix* - Something to allow us to determine that a contact\n  is encoded.\n\n- *hostpart* - An IP address or a hostname.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nif (src_ip == 10.0.0.0/8) encode_contact(\"natted_client\",\"1.2.3.4\");\n...\n```\n",
   "decode_contact": "### `decode_contact()`\n\nThis function will decode the request URI. If the RURI is in the format\nsip:encoding_prefix*username*password*ip*port*protocol@hostpart it\nwill be decoded to sip:username:password@ip:port;transport=protocol. It\nuses the default set parameter for contact encoding separator.\n\nThe function returns negative on error, 1 on success.\n\nMeaning of the parameters is as follows:\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (uri =~ \"^sip:natted_client\") { decode_contact(); }\n...\n```\n",
   "decode_contact_header": "### `decode_contact_header()`\n\nThis function will decode URIs inside Contact header. If the URI in the\nformat sip:encoding_prefix*username*ip*port*protocol@hostpart it\nwill be decoded to sip:username:password@ip:port;transport=protocol. It\nuses the default set parameter for contact encoding separator.\n\nThe function returns negative on error, 1 on success.\n\nMeaning of the parameters is as follows:\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nreply_route[2] {\n    ...\n    decode_contact_header();\n    ...\n}\n...\n```\n",
   "cmp_uri": "### `cmp_uri(str1, str2)`\n\nThe function returns *true* if the two parameters matches as SIP URI.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(cmp_uri(\"$ru\", \"sip:kamailio@kamailio.org\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "cmp_aor": "### `cmp_aor(str1, str2)`\n\nThe function returns *true* if the two parameters matches as AoR. The\nparameters have to be SIP URIs.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(cmp_aor(\"$rU@KaMaIlIo.org\", \"sip:kamailio@$fd\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "cmp_hdr_name": "### `cmp_hdr_name(str1, str2)`\n\nThe function returns *true* (return code 1) if the two parameters\nmatches as header names.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(cmp_hdr_name(\"$var(hname)\", \"From\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "append_rpid_hf": "### `append_rpid_hf(prefix, suffix)`\n\nThis function is the same as [ ](#siputils.f.append_rpid_hf). The only\ndifference is that it accepts two parameters--prefix and suffix to be\nadded to Remote-Party-ID header field. This function ignores rpid_prefix\nand rpid_suffix parameters, instead of that allows to set them in every\ncall.\n\nMeaning of the parameters is as follows:\n\n- *prefix* - Prefix of the Remote-Party-ID URI. The string will be added\n  at the beginning of the body of the header field, just before the URI.\n\n- *suffix* - Suffix of the Remote-Party-ID header field. The string will\n  be appended at the end of the header field. It can be used to set\n  various URI parameters, for example.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\n# Append Remote-Party-ID header field\nappend_rpid_hf(\"\", \";party=calling;id-type=subscriber;screen=yes\");\n...\n```\n",
   "is_rpid_user_e164": "### `is_rpid_user_e164()`\n\nThe function checks if the SIP URI received from the database or radius\nserver and will potentially be used in Remote-Party-ID header field\ncontains an E164 number (+followed by up to 15 decimal digits) in its\nuser part. Check fails, if no such SIP URI exists (i.e. radius server or\ndatabase didn't provide this information).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_rpid_user_e164()) {\n    # do something here\n};\n...\n```\n",
   "set_uri_user": "### `set_uri_user(uri, user)`\n\nSets userpart of SIP URI stored in writable pseudo variable 'uri' to\nvalue of pseudo variable 'user'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(uri) = \"sip:user@host\";\n$var(user) = \"new_user\";\nset_uri_user(\"$var(uri)\", \"$var(user)\");\n...\n```\n",
   "set_uri_host": "### `set_uri_host(uri, host)`\n\nSets hostpart of SIP URI stored in writable pseudo variable 'uri' to\nvalue of pseudo variable 'host'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(uri) = \"sip:user@host\";\n$var(host) = \"new_host\";\nset_uri_host(\"$var(uri)\", \"$var(host)\");\n...\n```\n",
   "is_request": "### `is_request()`\n\nReturn true if the SIP message is a request.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_request()) {\n    ...\n}\n...\n```\n",
   "is_reply": "### `is_reply()`\n\nReturn true if the SIP message is a reply.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_reply()) {\n    ...\n}\n...\n```\n",
   "is_gruu": "### `is_gruu([uri])`\n\nThe function returns true if the uri is GRUU ('gr' parameter is\npresent): 1 - pub-gruu; 2 - temp-gruu.\n\nMeaning of the parameters is as follows:\n\n- *uri* - the SIP URI to check for GRUU parameter. It is optional, when\n  missing, the value of R-URI is used.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(is_gruu()) { ... }\n...\n```\n",
   "is_supported": "### `is_supported(option)`\n\nFunction returns true if given option is listed in Supported header(s)\n(if any) of the request. Currently the following options are known:\npath, 100rel, timer, eventlist, gruu, and outbound.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (is_supported(\"outbound\")) { ... }\n...\n```\n",
   "is_first_hop": "### `is_first_hop([mode])`\n\nThe function returns true if the proxy is first hop after the original\nsender based on a best effort estimation by checking Via and\nRecord-Route headers.\n\nFor incoming SIP requests, it means there is only one Via header.\n\nFor incoming SIP replies, if mode==0, it means that top Record-Route URI\nis 'myself' and source address is not matching local IP (to avoid\ndetecting in case of local loops). Therefore for mode==0 the detection\nis done only when Record-Route has an IP address in its URI (for a\ndomain, it returns -1/false). If mode==1, then the check of local IP is\nno longer done, only if top Record-Route is myself, returning true also\nif there is a domain, assuming that is expected no looping can happen\nbased on config rules.\n\nNote that it does not detect spirals, which can have the condition for\nreplies true also in the case of additional SIP reply reception.\n\nParameter mode is optional and can be an integer or a variable holding\nan integer. If not provided, the behaviour is like mode==0.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(is_first_hop()) { ... }\n...\nif(is_first_hop(\"1\")) { ... }\n...\n```\n",
   "sip_p_charging_vector": "### `sip_p_charging_vector(flags)`\n\nManage the P-Charging-Vector header (RFC7315). The flags can be: 'r' -\nremove; 'g' - generate; 'f' - force (remove + generate).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nsip_p_charging_vector(\"g\");\n...\n```\n",
   "contact_param_encode": "### `contact_param_encode(pname, saddr)`\n\nThis function encodes URI inside Contact headers by building a new URI\nfrom 'saddr' parameter and adding a parameter with the name 'pname'\ncontaining incoming URI encoded in Base64URL format.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the new URI parameter to hold the encoded incoming\n  URI.\n\n- *saddr* - local server address in SIP URI format.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nif (is_method(\"REGISTER\") and src_ip == 10.0.0.0/8) {\n    contact_param_encode(\"ksu\", \"sip:1.2.3.4:5060;transport=tcp\");\n}\n...\n```\n",
   "contact_param_decode": "### `contact_param_decode(pname)`\n\nThis function decodes URI inside Contact headers by building a new URI\nfrom 'pname' parameter, decoding its value from Base64URL.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the incoming URI parameter holding the encoded URI\n  value.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nif (is_method(\"REGISTER\") and src_ip == 1.2.3.4) {\n    contact_param_decode(\"ksu\");\n}\n...\n```\n",
   "contact_param_decode_uri": "### `contact_param_decode_uri(pname)`\n\nThis function decodes R-URI (request URI) by building a new R-URI from\n'pname' parameter, decoding its value from Base64URL.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the incoming URI parameter holding the encoded URI\n  value.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (is_method(\"INVITE\") and src_ip == 1.2.3.4) {\n    contact_param_decode_ruri(\"ksu\");\n}\n...\n```\n",
   "contact_param_rm": "### `contact_param_rm(pname)`\n\nThis function removes the parameter from the URIs inside the Contact\nheaders.\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the URI parameter.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nif (is_method(\"REGISTER\") and src_ip == 1.2.3.4) {\n    contact_param_rm(\"myparam\");\n}\n...\n```\n",
   "contact_param_check": "### `contact_param_check(pname)`\n\nThis function returns true (1) if the URI inside the Contact header\ncontains the parameter with the name 'pname'. Otherwise it returns false\n(-1).\n\nMeaning of the parameters is as follows:\n\n- *pname* - name of the URI parameter.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (contact_param_check(\"myparam\")) {\n}\n...\n```\n",
   "hdr_date_check": "### `hdr_date_check(tdiff)`\n\nReturns true if sip message has Date header and its value is lower than\n'NOW() - tdiff'.\n\nMeaning of the parameters is as follows:\n\n- *tdiff* - time difference in seconds, it can be a variable or static\n  integer value.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (!hdr_date_check(\"10\")) {\n    sl_send_reply(\"403\", \"Outdated date\");\n    exit;\n}\n...\n```\n"
  }
 },
 "sl": {
  "overview": "The SL module allows the SIP server to act as a stateless UA server and\ngenerate replies to SIP requests without keeping state. That is\nbeneficial in many scenarios, in which you wish not to burden server's\nmemory and scale well.\n\nThe SL module needs to filter ACKs sent after a local stateless reply to\nan INVITE was generated. To recognize such ACKs, Kamailio adds a special\n\"signature\" in to-tags. This signature is sought for in incoming ACKs,\nand if included, the ACKs are absorbed.\n\nTo speed up the filtering process, the module uses a timeout mechanism.\nWhen a reply is sent, a timer is set. As long as the timer is valid, the\nincoming ACK requests will be checked using TO tag value. Once the timer\nexpires, all the ACK messages are let through - a long time passed till\nit sent a reply, so it does not expect any ACK that have to be blocked.\n\nThe ACK filtering may fail in some rare cases. If you think these matter\nto you, better use stateful processing (TM module) for INVITE\nprocessing. Particularly, the problem happens when a UA sends an INVITE\nwhich already has a to-tag in it (e.g., a re-INVITE) and the server\nwants to reply to it. Then, it will keep the current to-tag, which will\nbe mirrored in ACK. Kamailio will not see its signature and forward the\nACK downstream. Caused harm is not bad, just a useless ACK is forwarded.\n",
  "parameters": {
   "default_code": "### `default_code` (int)\n\nDefault reply status code.\n\nDefault value is 500.\n\n```\n...\nmodparam(\"sl\", \"default_code\", 505)\n...\n```\n",
   "default_reason": "### `default_reason` (str)\n\nDefault reply reason phrase.\n\nDefault value is 'Internal Server Error'.\n\n```\n...\nmodparam(\"sl\", \"default_reason\", \"Server Error\")\n...\n```\n",
   "bind_tm": "### `bind_tm` (int)\n\nControls if SL module should attempt to bind to TM module in order to\nsend stateful reply when the transaction is created.\n\nDefault value is 1 (enabled).\n\n```\n...\nmodparam(\"sl\", \"bind_tm\", 0)  # feature disabled\n...\n```\n",
   "rich_redirect": "### `rich_redirect` (int)\n\nWhen sending a 3xx class reply, include additional branch info to the\ncontacts such as path vector and branch flags.\n\n- *0* - no extra info is added (default)\n\n- *1* - include branch flags as contact header parameter\n\n- *2* - include path as contact uri Route header\n\nValues may be combined (added).\n\n```\n...\nmodparam(\"sl\", \"rich_redirect\", 3)\n...\n            \n```\n",
   "event_callback_fl_ack": "### `event_callback_fl_ack` (str)\n\nThe name of the KEMI callback function to be executed instead of\nevent_route[sl:filtered-ack]. This function receives a string\nparameter.\n\nDefault value: not set.\n\n```\n...\nmodparam(\"sl\", \"event_callback_fl_ack\", \"ksr_event_sl_filtered_ack\")\n...\n```\n",
   "event_callback_lres_sent": "### `event_callback_lres_sent` (str)\n\nThe name of the KEMI callback function to be executed instead of\nevent_route[sl:local-response]. This function receives a string\nparameter.\n\nDefault value: not set.\n\n```\n...\nmodparam(\"sl\", \"event_callback_lres_sent\", \"ksr_event_sl_local_response\")\n...\n```\n"
  },
  "functions": {
   "sl_send_reply": "### `sl_send_reply(code, reason)`\n\nFor the current request, a reply is sent back having the given code and\ntext reason. The reply is sent stateless, totally independent of the\nTransaction module and with no retransmission for the INVITE's replies.\n\nIf the code is in the range 300-399 (redirect reply), the current\ndestination set is appended to the reply as Contact headers. The\ndestination set contains the request URI (R-URI), if it is modified\ncompared to the received one, plus the branches added to the request\n(e.g., after an append_branch() or lookup(\"location\")). If the R-URI was\nchanged but it is not desired to be part of the destination set, it can\nbe reverted using the function revert_uri().\n\nCustom headers to the reply can be added using append_to_reply()\nfunction from textops module.\n\nMeaning of the parameters is as follows:\n\n- *code* - Return code.\n\n- *reason* - Reason phrase.\n\n<!-- -->\n\n\n```\n...\nsl_send_reply(\"404\", \"Not found\");\n...\n        \n```\n",
   "send_reply": "### `send_reply(code, reason)`\n\nFor the current request, a reply is sent back having the given code and\ntext reason. The reply is sent stateful or stateless, depending of the\nTM module: if a transaction exists for the current request, then the\nreply is sent statefully, otherwise stateless.\n\nMeaning of the parameters is as follows:\n\n- *code* - Return code.\n\n- *reason* - Reason phrase.\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE. It can\nbe used on ONREPLY_ROUTE executed by tm module (upon a t_on_reply()\ncallback).\n\n```\n...\nsend_reply(\"404\", \"Not found\");\n...\nsend_reply(\"403\", \"Invalid user - $fU\");\n...\n```\n",
   "send_reply_mode": "### `send_reply_mode(code, reason, mode)`\n\nSimilar to send_reply() function, with additional third parameter mode,\nwhich can specify extra operations to be done along with sending the SIP\nresponse.\n\nThe parameter mode is a flag-based value and can be a combination of:\n\n- *1* - do not connect to send the response (similar to\n  set_reply_no_connect()).\n\n- *2* - close the connection after sending the response (similar to\n  set_reply_close()).\n\n<!-- -->\n\n\n```\n...\nsend_reply_mode(\"404\", \"Not found\", \"3\");\n...\nsend_reply_mode(\"403\", \"Invalid user - $fU\", \"3\");\n...\n```\n",
   "sl_reply_error": "### `sl_reply_error()`\n\nSends back an error reply describing the nature of the last internal\nerror. Usually this function should be used after a script function that\nreturned an error code.\n\n```\n...\nsl_reply_error();\n...\n        \n```\n",
   "sl_forward_reply": "### `sl_forward_reply([ code, [ reason ] ])`\n\nForward statelessly the current received SIP reply, with the option to\nchange the status code and reason text. The new code has to be in the\nsame class. The received reply is forwarded as well by core when the\nconfig execution ended, unless it is dropped from config.\n\nMeaning of the parameters is as follows:\n\n- *code* - Status code.\n\n- *reason* - Reason phrase.\n\nThis function can be used from ONREPLY_ROUTE.\n\n```\n...\nif(status==\"408\")\n    sl_forward_reply(\"404\", \"Not found\");\n...\n```\n",
   "send_reply_error": "### `send_reply_error()`\n\nFor the current request, the internal error code reply is sent back\nstateful or stateless, depending of the TM module: if a transaction\nexists for the current request, then the reply is sent statefully,\notherwise stateless.\n\nIt can be used from REQUEST_ROUTE, ONREPLY_ROUTE and FAILURE_ROUTE.\n\n```\n...\nsend_reply_error();\n...\n```\n"
  }
 },
 "slack": {
  "overview": "This module provides integration with Slack over webhooks. Slack\nintegration (https://api.slack.com/messaging/webhooks)\n\nIt relays on libcurl through http_client module.\n",
  "parameters": {
   "slack": "### `slack url` (str)\n\nSlack webhook url\n\n*Default value is not set (empty)*\n\n```\n...\nmodparam(\"slack\", \"slack_url\", \"https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX\")\n...\n        \n```\n",
   "channel": "### `channel` (str)\n\nSlack channel name\n\n*Default value is #kamailio*\n\n```\n...\nmodparam(\"slack\", \"channel\", \"#kamailio\")\n...\n```\n",
   "username": "### `username` (str)\n\nSpecify the username for the published message\n\n*Default value is webhookbot.*\n\n```\n...\nmodparam(\"slack\", \"username\", \"webhookbot\")\n...\n```\n",
   "icon_emoji": "### `icon_emoji` (str)\n\nspecify an emoji (using colon shortcodes, eg. :white_check_mark:) to use\nas the profile photo alongside the message.\n\n*Default value is :ghost:*\n\n```\n...\nmodparam(\"slack\", \"icon_emoji\", \":ghost:\")\n...\n```\n"
  },
  "functions": {
   "slack_send": "### `slack_send(format)`\n\nSend a formatted message to slack channel.\n\nThe parameters are:\n\n- format - The formatted string to be sent.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    slack_send(\"Hello from Kamailio! caller=$fU;callee=$tU;callid=$ci\");\n...\n```\n"
  }
 },
 "sms": {
  "overview": "This module provides a way of communication between SIP network (via SIP\nMESSAGE) and GSM networks (via ShortMessageService). Communication is\npossible from SIP to SMS and vice versa. The module provides facilities\nlike SMS confirmation--the gateway can confirm to the SIP user if his\nmessage really reached its destination as a SMS--or multi-part\nmessages--if a SIP messages is too long it will be split and sent as\nmultiple SMS.\n\nErrors occurred because of an invalid number or a too long message or\nbecause of an internal modem malfunction are reported back to the SIP\nuser via a SIP message containing explanations regarding the error.\n",
  "parameters": {
   "modems": "### `modems` (string)\n\nDefine and configure one or more GSM modems.\n\n```\nmodems_value     = modem_definition *( \";\" modem_definition )\nmodem_definition = modem_name \"[\" list_of_params \"]\"\nlist_of_params   = modem_param *( \";\" modem_param )\nmodem_param      = name \"=\" value\n    \n```\n\nThe following parameters can be used:\n\n- d=device (mandatory) - Device associated with modem (/dev/ttyS0,\n  /dev/modem, etc.).\n\n- p=pin (optional) - SIM PIN - default is NULL.\n\n- m=mode (optional) - Modem working mode\n  (\"ASCII\",\"OLD\",\"DIGICOM\",\"NEW\"). Default value is \"NEW\".\n\n- c=SMS_Center (optional) - SMS center number for that modem. Default is\n  the SMS center set on the SIM card.\n\n- b=baudrate (optional) - Default is 19600.\n\n- r=retry (optional) - How many times to try to re-send an SMS that\n  reported error. Default is twice.\n\n- l=looping (optional) - Time for modem to wait before performing a new\n  check for incoming/outgoing SMS/SIP_MSG. Default is 20.\n\n- t=to (optional) - uri for sip header TO. Default is NULL.\n\n- s=scan (optional) - Values: 0: NOT SCAN uri from body sms, use URI in\n  t=to. 1: SCAN uri from body sms (normal mode, default mode, classic\n  mode) 2: SCAN MIX (both modes), First SCAN Default is 1 (SCAN).\n\n<div class=\"note\">\n\n\nNo default value, the parameter is mandatory.\n\n</div>\n\n\n```\n...\nmodparam(\"sms\", \"modems\", \"Nokia[d=/dev/ttyS1;s=0;t=sip:p-cscf@cidra.com.ar]\")\nmodparam(\"sms\", \"modems\", \"Nokia [d=/dev/ttyS1;b=9600;m=new;l=30] \")\nmodparam(\"sms\", \"modems\", \"Nokia[d=/dev/ttyS1];Siemens[d=/dev/ttyS2]\")\n...\n        \n```\n",
   "networks": "### `networks` (string)\n\nDefine and configure used GSM networks.\n\n```\nnetworks_value = net_definition *( \";\" net_definition )\nnet_definition = net_name \"[\" list_of_params \"]\"\nlist_of_params = set_param *( \";\" set_param )\nset_param      = name \"=\" value\n    \n```\n\nThe following parameters can be used:\n\n- m=msx_sms_per_call (optional) - Maximum number of SMS send / received\n  from that net in one modem loop. Default is 10. This parameter was\n  introduced to avoid starvation.\n\n  Example of the starvation--a modem can send SMS for more than 1\n  networks. If you have a huge number of SMS for the first network and\n  the number of incoming SIP messages is equal to the sent SMS per same\n  unit of time, the modem will never get to send SMS for the next\n  networks.\n\n<div class=\"note\">\n\n\nNo default value, the parameter is mandatory.\n\n</div>\n\n\n```\n...\nmodparam(\"sms\", \"networks\", \"D1 [m=10] ;d2[ m=20]\")\n...\n        \n```\n",
   "links": "### `links` (string)\n\nDefine from which network each modem should send SMS.\n\n```\nlinks_value = modem_assoc *( \";\" modem_assoc )\nmodem_assoc = modem_name \"[\" list_of_networks \"]\"\nlist_of_networks = network *( \";\" network )\n    \n```\n\n<div class=\"note\">\n\n\nNo default value, the parameter is mandatory.\n\n</div>\n\n\n```\n...\nmodparam(\"sms\", \"links\", \"NOKIA[D1;d2]\")\n...\n        \n```\n\nThe modem NOKIA will send SMS from D1 and D2 net (in this order !). If\nin a net queue are more than max_sms_per_call SMS the modem will *not\nsleep* before starting the next loop ! Shortly, if messages are waiting\nto be sent, the modem will not go in sleep.\n",
   "default_net": "### `default_net` (string)\n\nThe default network to use. If no one specified, the first defined\nnetwork is used. This parameter is useful only if the \"sms_send_msg\"\nexported function is used (see [Functions](#sms.functions)).\n\n```\n...\nmodparam(\"sms\", \"default_net\", \"D1\")\n...\n        \n```\n",
   "max_sms_parts": "### `max_sms_parts` (integer)\n\nShows in how many parts (SMS messages) a SIP message can be split. If\nexceeded, the SIP message will be sent truncated and the SIP user will\nget back another message containing the unsent part.\n\nDefault value is 4.\n\n```\n...\nmodparam(\"sms\", \"max_sms_parts\", 10)\n...\n        \n```\n",
   "domain": "### `domain` (string)\n\nSpecify a fake domain name to be used by the gateway. The Contact\nheaders and the From header from the request will be constructed based\non this fake domain name. It's useful when the gateway is transparently\nhidden behind a proxy/register (located on different machines).\n\nDefault is the name of the machine the gateway is running on.\n\n```\n...\nmodparam(\"sms\", \"domain\", \"foo.bar\")\n...\n        \n```\n",
   "use_contact": "### `use_contact` (integer)\n\nIf a contact header should be added to the outgoing SIP messages. Even\nif the SIP draft forbids this, some UAS require it.\n\nDefault is 0 (no).\n\n```\n...\nmodparam(\"sms\", \"use_contact\", 1)\n...\n        \n```\n",
   "sms_report_type": "### `sms_report_type` (integer)\n\nIf the modem should ask for SMS confirmation from the SMS Center. If the\nSMSC reply with an error code, the gateway will send back to SIP user a\nSIP message containing the text (or part of it) that couldn't be sent.\nTwo report mechanisms are implemented:\n\n- 1 - the reports are delivered by the GSM device as SMS reports (so far\n  supported only by Nokia modems);\n\n- 2 - the reports are delivered as async. CDS responses (supported by\n  almost all modems, except Ericsson).\n\nDefault is 0 (no report).\n\n```\n...\nmodparam(\"sms\", \"sms_report_type\", 1)\n...\n        \n```\n"
  },
  "functions": {
   "sms_send_msg_to_net": "### `sms_send_msg_to_net(network_name)`\n\nPut the SIP msg in the specified network queue. The function return\nerror if the number encapsulated into SIP message is malformed, if the\ncontent_type is incorrect or because of some internal failures.\n\nMeaning of the parameters is as follows:\n\n- *network_name* - Name of network.\n\n<!-- -->\n\n\n```\n...\nif (sms_send_msg_to_net(\"D1\"))\n{\n    if (!t_reply(\"202\", \"yes sir, SMS sent over\"))\n    {\n        # if replying failed, retry statelessly\n        sl_reply_error();\n    };\n} else {\n    if (!t_reply(\"502\", \"Bad gateway - SMS error\"))\n    {\n        # if replying failed, retry statelessly\n        sl_reply_error();\n    };\n    break;\n};\n...\n        \n```\n",
   "sms_send_msg": "### `sms_send_msg()`\n\nThe same as the previous one, but use the default network queue.\n\n```\n...\nif (sms_send_msg_to_net())\n{\n    if (!t_reply(\"202\", \"yes sir, SMS sent over\"))\n    {\n        # if replying failed, retry statelessly\n        sl_reply_error();\n    };\n} else {\n    if (!t_reply(\"502\", \"Bad gateway - SMS error\"))\n    {\n        # if replying failed, retry statelessly\n        sl_reply_error();\n    };\n    break;\n};\n...\n        \n```\n"
  }
 },
 "smsops": {
  "overview": "This module collects the Transformations for 3GPP-SMS.\n",
  "parameters": {},
  "functions": {
   "isRPDATA": "### `isRPDATA()`\n\nReturns true, if the message contains RP-Data in its body.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (isRPDATA())\n{\n    ...\n}\n...\n```\n",
   "smsdump": "### `smsdump()`\n\nDumps the content of a 3GPP-SMS message to the Debug-Log.\n\nPlease make sure, to have debug-Log enabled. Otherwise, you won't see\nanything.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nsmsdump();\n...\n```\n"
  }
 },
 "snmpstats": {
  "overview": "The SNMPStats module provides an SNMP management interface to Kamailio.\nSpecifically, it provides general SNMP queryable scalar statistics,\ntable representations of more complicated data such as user and contact\ninformation, and alarm monitoring capabilities.\n\nThe MIB has been renamed in version 4.0.0 to reflect the product name.\nPlease note that all the OID names has changed, as well as the MIB\nitself.\n",
  "parameters": {
   "sipEntityType": "### `sipEntityType` (String)\n\nThis parameter describes the entity type for this Kamailio instance, and\nwill be used in determining what is returned for the\nkamailioSIPEntityType scalar. Valid parameters are:\n\n*registrarServer, redirectServer, proxyServer, userAgent,\nedgeproxyServer, sipcaptureServer, other*\n\n```\n...\nmodparam(\"snmpstats\", \"sipEntityType\", \"registrarServer\")\nmodparam(\"snmpstats\", \"sipEntityType\", \"proxyServer\")\n...\n        \n```\n\nNote that as the above example shows, you can define this parameter more\nthan once. This is of course because a given Kamailio instance can take\non more than one role. The edgeproxyServer is an edge server using the\noutbound module and path extensions. The sipcaptureServer is a Homer Sip\nCapture server that collect SIP messages.\n",
   "MsgQueueMinorThreshold": "### `MsgQueueMinorThreshold` (Integer)\n\nThe SNMPStats module monitors the number of bytes waiting to be consumed\nby Kamailio. If the number of bytes waiting to be consumed exceeds a\nminor threshold, the SNMPStats module will send out a\nkamailioMsgQueueDepthMinorEvent trap to signal that an alarm condition\nhas occurred. The minor threshold is set with the MsgQueueMinorThreshold\nparameter.\n\n```\n...\nmodparam(\"snmpstats\", \"MsgQueueMinorThreshold\", 2000)\n...\n        \n```\n\nIf this parameter is not set, then there will be no minor alarm\nmonitoring.\n",
   "MsgQueueMajorThreshold": "### `MsgQueueMajorThreshold` (Integer)\n\nThe SNMPStats module monitors the number of bytes waiting to be consumed\nby Kamailio. If the number of bytes waiting to be consumed exceeds a\nmajor threshold, the SNMPStats module will send out a\nkamailioMsgQueueDepthMajorEvent trap to signal that an alarm condition\nhas occurred. The major threshold is set with the MsgQueueMajorThreshold\nparameter.\n\n```\n...\nmodparam(\"snmpstats\", \"MsgQueueMajorThreshold\", 5000)\n...\n        \n```\n\nIf this parameter is not set, then there will be no major alarm\nmonitoring.\n",
   "dlg_minor_threshold": "### `dlg_minor_threshold` (Integer)\n\nThe SNMPStats module monitors the number of active dialogs. If the\nnumber of active dialogs exceeds a minor threshold, the SNMPStats module\nwill send out a kamailioDialogLimitMinorEvent trap to signal that an\nalarm condition has occurred. The minor threshold is set with the\ndlg_minor_threshold parameter.\n\n```\n...\n  modparam(\"snmpstats\", \"dlg_minor_threshold\", 500)\n...\n        \n```\n\nIf this parameter is not set, then there will be no minor alarm\nmonitoring.\n",
   "dlg_major_threshold": "### `dlg_major_threshold` (Integer)\n\nThe SNMPStats module monitors the number of active dialogs. If the\nnumber of active dialogs exceeds a major threshold, the SNMPStats module\nwill send out a kamailioDialogLimitMajorEvent trap to signal that an\nalarm condition has occurred. The major threshold is set with the\ndlg_major_threshold parameter.\n\n```\n...\n  modparam(\"snmpstats\", \"dlg_major_threshold\", 750)\n...\n        \n```\n\nIf this parameter is not set, then there will be no major alarm\nmonitoring.\n",
   "snmpgetPath": "### `snmpgetPath` (String)\n\nThe SNMPStats module provides the kamailioSIPServiceStartTime scalar.\nThis scalar requires the SNMPStats module to perform a snmpget query to\nthe master agent. You can use this parameter to set the path to your\ninstance of NetSNMP's snmpget program.\n\n*Default value is \u201c/usr/local/bin/\u201d.*\n\n```\n...\nmodparam(\"snmpstats\", \"snmpgetPath\",     \"/my/custom/path/\")\n...\n        \n```\n",
   "snmpCommunity": "### `snmpCommunity` (String)\n\nThe SNMPStats module provides the kamailioSIPServiceStartTime scalar.\nThis scalar requires the SNMPStats module to perform a snmpget query to\nthe master agent. If you have defined a custom community string for the\nsnmp daemon, you need to specify it with this parameter.\n\n*Default value is \u201cpublic\u201d.*\n\n```\n...\nmodparam(\"snmpstats\", \"snmpCommunity\", \"customCommunityString\")\n...\n        \n```\n",
   "snmpVersion": "### `snmpVersion` (String)\n\nThe SNMPStats module provides the kamailioSIPServiceStartTime scalar.\nThis scalar requires the SNMPStats module to perform a snmpget query to\nthe master agent. You can use this parameter to set specific SNMP\nversion.\n\n*Default value is \u201c3\u201d.*\n\n```\n...\nmodparam(\"snmpstats\", \"snmpVersion\", \"2c\")\n...\n        \n```\n",
   "export_registrar": "### `export_registrar` (int)\n\nThe SNMPStats module will export registrar (usrloc) records if this\nparameter is set to 1. This will result in more memory usage and bigger\nexporter structure.\n\nIf you enable this setting and NOT use it (i.e. not check the SNMP\ntables for registrations) an internal memory queue of usrloc changes\nwill keep growing in shared (core) memory. To release the queue memory,\nrun snmpwalk or use a monitoring tool to check the tables with regular\nintervals.\n\n*Default value is \u201c0\u201d (don't export).*\n\n```\n...\nmodparam(\"snmpstats\", \"export_registrar\", 1)\n...\n        \n```\n"
  },
  "functions": {}
 },
 "speeddial": {
  "overview": "This module provides on-server speed dial facilities. A user can store\nrecords consisting of pairs short numbers (2 digits) and SIP addresses\ninto a table of Kamailio. Then it can dial the two digits whenever it\nwants to call the SIP address associated with them.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThe URL of database where the table containing speed dial records.\n\n*Default value is DEFAULT_RODB_URL.*\n\n```\n...\nmodparam(\"speeddial\", \"db_url\", \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n...\n```\n",
   "user_column": "### `user_column` (string)\n\nThe name of column storing the user name of the owner of the speed dial\nrecord.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"speeddial\", \"user_column\", \"userid\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nThe name of column storing the domain of the owner of the speed dial\nrecord.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"speeddial\", \"domain_column\", \"userdomain\")\n...\n```\n",
   "sd_user_column": "### `sd_user_column` (string)\n\nThe name of the column storing the user part of the short dial address.\n\n*Default value is \u201csd_username\u201d.*\n\n```\n...\nmodparam(\"speeddial\", \"sd_user_column\", \"short_user\")\n...\n```\n",
   "sd_domain_column": "### `sd_domain_column` (string)\n\nThe name of the column storing the domain of the short dial address.\n\n*Default value is \u201csd_domain\u201d.*\n\n```\n...\nmodparam(\"speeddial\", \"sd_domain_column\", \"short_domain\")\n...\n```\n",
   "new_uri_column": "### `new_uri_column` (string)\n\nThe name of the column containing the URI that will be use to replace\nthe short dial URI.\n\n*Default value is \u201cnew_uri\u201d.*\n\n```\n...\nmodparam(\"speeddial\", \"new_uri_column\", \"real_uri\")\n...\n```\n",
   "domain_prefix": "### `domain_prefix` (string)\n\nIf the domain of the owner (From URI) starts with the value of this\nparameter, then it is stripped before performing the lookup of the short\nnumber.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"speeddial\", \"domain_prefix\", \"tel.\")\n...\n```\n",
   "use_domain": "### `use_domain` (int)\n\nThe parameter specifies whether or not to use the domain when searching\na speed dial record (0 - no domain, 1 - use domain from From URI, 2 -\nuse both domains, from From URI and from request URI).\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"speeddial\", \"use_domain\", 1)\n...\n```\n"
  },
  "functions": {
   "sd_lookup": "### `sd_lookup(table [, owner])`\n\nThe function lookups the short dial number from R-URI in 'table' and\nreplaces the R-URI with associated address.\n\nMeaning of the parameters is as follows:\n\n- *table* - The name of the table storing the speed dial records.\n\n- *owner* - The SIP URI of the owner of short dialing codes. If not\n  present, URI of From header is used.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\n# 'speed_dial' is the default table name created by kamailio db script\nif(uri=~\"sip:[0-9]{2}@.*\")\n    sd_lookup(\"speed_dial\");\n# use auth username\nif(uri=~\"sip:[0-9]{2}@.*\")\n    sd_lookup(\"speed_dial\", \"sip:$au@$fd\");\n...\n```\n"
  }
 },
 "sqlops": {
  "overview": "The SQLOPS module adds support for raw SQL queries in the configuration\nfile.\n\nAmong the features:\n\n- *Multiple database connections* - the sqlops module can connect to\n  many databases on different servers using different DB driver modules\n  at the same time.\n\n- *Many query results* - the module can store many results of different\n  SQL queries in separate structures at the same time. Thus it is\n  possible to work in parallel with several queries and results.\n\n- *Access via pseudo-variables* - the content of the SQL query result is\n  accessible via pseudo-variables. Please note that only integer and\n  string variables are supported at the moment because of the internal\n  usage of \u201cAVPs\u201d to hold the values. So it is not possible for example\n  to return floating point or big integer values this way.\n\n- *Array indexes* - fast access to result values via array position:\n  [row,column].\n\n- *Persistence in process space* - a result can be used many times in\n  the same worker process. Query once, use many times.\n\n- *Results can be stored in xavps* - columns are accessed by their\n  names, rows by xavp index. Xavp's are available during the\n  transactions lifetime and don't need to be destroyed manually.\n",
  "parameters": {
   "sqlcon": "### `sqlcon` (str)\n\nThe definition of a DB connection. The value of the parameter must have\nthe following format:\n\n- \"connection_name=>database_url\"\n\nThis parameter may be set multiple times to get many DB connections in\nthe same configuration file.\n\n- *connection_name* - string specifying the name of a database\n  connection. This string is used by the \u201csql_query()\u201d function to refer\n  to the DB connection.\n\n- *database_url* - Standardized Kamailio database URL used to connect to\n  database.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"sqlops\",\"sqlcon\",\"cb=>mysql://kamailio:kamailiorw@localhost/kamailio\")\nmodparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "sqlres": "### `sqlres` (str)\n\nThe definition of a database result ID. The value of the parameter can\nbe any string. Results IDs are also added at fixup time when sql_query()\nparameters are parsed, so there is no need to declare them via module\nparameter unless you want to use them from within other modules and be\navailable in all application processes.\n\n*Default value is NULL.*\n\n```\n...\nmodparam(\"sqlops\", \"sqlres\", \"ra\")\n...\n```\n",
   "tr_buf_size": "### `tr_buf_size` (int)\n\nThe size of the transformations for SQL operations.\n\n*Default value is 2048.*\n\n```\n...\nmodparam(\"sqlops\", \"tr_buf_size\", 4096)\n...\n```\n",
   "connect_mode": "### `connect_mode` (int)\n\nControl if the module must stop loading when connecting to database\nserver fails during start up. Values: 0 - stop loading; 1 - continue\neven if connecting to database server fails.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"sqlops\", \"connect_mode\", 1)\n...\n```\n",
   "results_maxsize": "### `results_maxsize` (int)\n\nSet the upper limit of how many result containers are going to be\ndefined.\n\nNote that a result container can be used for different SQL queries, it\nis not required to have result container per SQL query. Use different\ncontainers when the result records are needed at the same time (e.g.,\ncompare a field from one result with a field from another result).\n\n*Default value is 32.*\n\n```\n...\nmodparam(\"sqlops\", \"results_maxsize\", 64)\n...\n```\n"
  },
  "functions": {
   "sql_query": "### `sql_query(connection, query[, result])`\n\nMake an SQL query using 'connection' and store data in 'result'.\n\n- *connection* - the name of the connection to be used for the query\n  (defined via the \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\n- *result* - string name to identify the result. Will be used by\n  $dbr(...) pseudo-variable to access result attributes. If omitted,\n  any resultset will be discarded. The result parameter should normally\n  only be omitted when no result is expected (INSERT, UPDATE, DELETE).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmodparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n...\nsql_query(\"ca\", \"select * from domain\", \"ra\");\nxlog(\"number of rows in table domain: $dbr(ra=>rows)\\n\");\nsql_result_free(\"ra\");\n...\n```\n",
   "sql_xquery": "### `sql_xquery(connection, query, result)`\n\nMake an SQL query using 'connection' and store data in 'result' xavp.\n\n- *connection* - the name of the connection to be used for the query\n  (defined via the \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\n- *result* - string name to identify the result xavp. Each row will be\n  added to this xavp, each column can be accessed by its name.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmodparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n...\nsql_xquery(\"ca\", \"select * from domain\", \"ra\");\nxlog(\"first domain: $xavp(ra=>domain) with id: $xavp(ra=>domain_id)\\n\");\n...\nif (sql_xquery(\"ca\", \"select * from domain\", \"ra\") == 1) {\n    xlog(\"domain: $xavp(ra=>domain) with id: $xavp(ra=>domain_id)\\n\");\n}\n..\n```\n",
   "sql_pvquery": "### `sql_pvquery(connection, query, result)`\n\nMake an SQL query using 'connection' and store data in arbitrary pseudo\nvariables specified by 'result' parameter.\n\n- *connection* - the name of the connection to be used for query\n  (defined via the \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\n- *result* - a list with PV names where to store the result. The format\n  is \u201c$pv;$pv;...\u201d. Every PV that is writable may be used (for example\n  $var, $avp, $xavp, $ru, $du, $sht, etc).\n\n  The PV are assigned values in the following order: last row to first\n  row, first field to last field. Assignment has the same behavior as\n  assigning in the script itself with one exception for avp's, a NULL\n  value will not delete an avp, but will be skipped over.\n\n  Beware that if multiple rows are returned, non-(x)avp variables will\n  only hold the last added value, which corresponds to the first\n  returned row.\n\n  The value type of the PV (string or integer) will be derived from the\n  type of the columns. Please note that only these two datatypes are\n  supported, other datatypes will/may be converted to string.\n\nThis function can be used from ANY_ROUTE. Returns -1 on Error, 1 on\nsuccessful query, 2 if query provided no result set, 3 if result is\nignored (no result parameter given)\n\n```\n...\nmodparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n...\nsql_pvquery(\"ca\", \"select 'col1', 2, NULL, 'sip:test@example.com'\",\n    \"$var(a), $avp(col2), $xavp(item[0]=>s), $ru\");\n...\n```\n",
   "sql_result_free": "### `sql_result_free(result)`\n\nFree data in SQL 'result'.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmodparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n...\nsql_query(\"ca\", \"select * from domain\", \"ra\");\nxlog(\"number of rows in table domain: $dbr(ra=>rows)\\n\");\n...\nsql_result_free(\"ra\");\n...\n```\n",
   "sql_query_async": "### `sql_query_async(connection, query)`\n\nMake an async SQL query using 'connection', if implemented by db driver\nmodule (e.g., db_mysql). The query is executed in another process and\nresult is not available back to config, thus it should be used only for\nsql statements that don't return values (e.g., insert, delete,\nupdate...). Note that async_workers core parameter must be set in order\nto enable the asynchronous framework needed by this function.\n\n- *connection* - the name of the connection to be used for the query\n  (defined via \u201csqlcon\u201d parameter).\n\n- *query* - SQL query string or pseudo-variables containing SQL query.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmodparam(\"sqlops\",\"sqlcon\",\"ca=>dbdriver://username:password@dbhost/dbname\")\n...\nsql_query_async(\"ca\", \"delete from domain\");\n...\n```\n"
  }
 },
 "ss7ops": {
  "overview": "The ss7ops module can currently handle M2UA/MTP-L3/ISUP and convert it\nto JSON. In the future this might gain support for more SIGTRAN\nadoptions and ITU TCAP/GSM MAP.\n",
  "parameters": {},
  "functions": {
   "isup_to_json": "### `isup_to_json`\n\nisup_to_json(proto)\n\nPass the HEP protocol type as parameter (e.g. 8 for M2UA) and the\ncontained ISUP payload will be converted to a JSON string. The result\ncan be accessed using the $isup(1) variable.\n\n```\n...\nisup_to_json(8);\n...\n```\n"
  }
 },
 "sst": {
  "overview": "SIP session timers are used to make sure that a session (dialog) is\nstill alive, even though there may have been a long time since the last\nin-dialog message. If the other end is not responding, the dialog will\nbe hung up automatically. SIP session timers need to be supported by all\nend points for it to work. It's a SIP extension, standardized by the\nIETF.\n\nThe sst module provides a way to update the dialog expiry timer based on\nthe SIP INVITE/200 OK Session-Expires header value. You can use the sst\nmodule in a Kamailio proxy to allow freeing of local resources of dead\ncalls.\n\nYou can also use the sst module to validate the MIN_SE header value and\nreply to any request with a \"422 - Session Timer Too Small\" if the value\nis too small for your Kamailio configuration.\n",
  "parameters": {
   "enable_stats": "### `enable_stats` (integer)\n\nIf the statistics support should be enabled or not. Via statistic\nvariables, the module provides information about the dialog processing.\nSet it to zero to disable or to non-zero to enable it.\n\n*Default value is \u201c1\u201d (enabled).*\n\n```\n...\nmodparam(\"sst\", \"enable_stats\", 0)\n...\n```\n",
   "min_se": "### `min_se` (integer)\n\nThe value is used to set the proxies MIN-SE value and is used in the 422\nerror reply as the proxies MIN-SE: header value if the \u201csstCheckMin()\u201d\nflag is set to true and the check fails.\n\nIf not set and \u201csstCheckMin()\u201d is called with the send-reply flag set to\ntrue, the default 1800 seconds will be used as the compare and the\nMIN-SE: header value if the 422 reply is sent.\n\n*Default value is \u201c1800\u201d seconds.*\n\n```\n...\nmodparam(\"sst\", \"min_se\", 2400)\n...\n```\n",
   "timeout_avp": "### `timeout_avp` (string)\n\nThis parameter must be set to the same value as the dialog module\nparameter of the same name, when it is wanted to update dialog timeout\nusing Session-Expires header value. If this parameter is not set, the\nsst module will not update dialog timeout.\n\nWith this parameter, the sst module knows which avp is expected by the\ndialog module to change to a new expire value.\n\nNote that the avp is set only for requests within dialog, not for the\ninitial INVITE. For this one, it can be done using script operations,\nsee the next example for such solution.\n\n*Default value is \u201cNULL\u201d (not set by default).*\n\n```\n...\nmodparam(\"dialog\", \"timeout_avp\", \"$avp(dlgtimeout)\")\n# Set the sst modules timeout_avp to be the same value\nmodparam(\"sst\", \"timeout_avp\", \"$avp(dlgtimeout)\")\n...\nrequest_route {\n    ...\n    # when wanting to use Session-Expires value for initial INVITE\n    if(is_method(\"INVITE\") and !has_totag()) {\n        if(is_present_hf(\"Session-Expires\")) {\n            $avp(dlgtimeout) = $(hdr(Session-Expires){s.int});\n        }\n    }\n    ...\n}\n...\n```\n",
   "reject_to_small": "### `reject_to_small` (integer)\n\nIn the initial INVITE if the UAC has requested a Session-Expires: and\nits value is smaller than our local policies Min-SE (see min_se above),\nthen the proxy has the right to reject the call by replying to the\nmessage with a \u201c422 Session Timer Too Small\u201d and state our local Min-SE:\nvalue. The INVITE is NOT forwarded on through the proxy.\n\nIf this flag is true, the SST module will reject the INVITE with a 422\nresponse. If false, the INVITE is forwarded through the PROXY without\nany modifications.\n\n*Default value is \u201c1\u201d (true/on).*\n\n```\n...\nmodparam(\"sst\", \"reject_to_small\", 0)\n...\n```\n",
   "sst_flag": "### `sst_flag` (integer)\n\nKeeping with Kamailio, the module will not do anything to any message\nunless instructed to do so via the kamailio.cfg script. You must set the\nsst_flag value in the setflag() call of the INVITE you want the sst\nmodule to process. But before you can do that, you need to tell the sst\nmodule which flag value you are assigning to sst.\n\nIn most cases whenever you set the dialog flag you will want to set the\nsst flag. If the dialog flag is not set and the sst flag is set, it will\nnot have any effect.\n\n*This parameter must be set or the module will not load.*\n\n*Default value is \u201cNot set!\u201d.*\n\n```\n...\nmodparam(\"dialog\", \"dlg_flag\", 5)\nmodparam(\"sst\", \"sst_flag\", 6)\n...\nroute {\n  ...\n  if (method==\"INVITE\") {\n    setflag(5); # set the dialog flag\n    setflag(6); # set the sst flag\n  }\n  ...\n}\n```\n"
  },
  "functions": {
   "sstCheckMin": "### `sstCheckMin(send_reply_flag)`\n\nCheck the current Session-Expires / MIN-SE values against the sst_min_se\nparameter value. If the Session-Expires or MIN_SE header value is less\nthan the modules minimum value, this function will return true.\n\nIf the function is called with the send_reply_flag set to true (1) and\nthe requested Session-Expires / MIN-SE values are too small, a 422 reply\nwill be sent for you. The 422 will carry a MIN-SE: header with the sst\nmin_se parameter value set.\n\nMeaning of the parameters is as follows:\n\n- *min_allowed* - The value to compare the MIN_SE header value to.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"dialog\", \"timeout_avp\", \"$avp(i:4242)\")\nmodparam(\"dialog\", \"dlg_flag\", 5)\n...\nmodparam(\"sst\", \"sst_flag\", 6)\nmodparam(\"sst\", \"timeout_avp\", \"$avp(i:4242)\")\nmodparam(\"sst\", \"min_se\", 2400) # Must be >= 90\n...\n\nroute {\n  if (method==\"INVITE\") {\n    if (sstCheckMin(\"1\")) {\n        xlog(\"L_ERR\", \"422 Session Timer Too Small reply sent.\\n\");\n        exit;\n    }\n    # track the session timers via the dialog module\n    setflag(5);\n    setflag(6);\n  }\n}\n\n... or ...\n\nroute {\n  if (method==\"INVITE\") {\n    if (sstCheckMin(\"0\")) {\n        xlog(\"L_ERR\", \"Session Timer Too Small, dropping request\\n\");\n        exit;\n    }\n    # track the session timers via the dialog module\n    setflag(5);\n    setflag(6);\n  }\n}\n...\n```\n"
  }
 },
 "statistics": {
  "overview": "The Statistics module is a wrapper over the internal statistics manager,\nallowing the script writer to dynamically define and use of statistic\nvariables.\n\nBy bringing the statistics support into the script, it takes advantage\nof the script flexibility in defining logics, making possible\nimplementation of any kind of statistic scenario.\n",
  "parameters": {
   "variable": "### `variable` (string)\n\nName of a new statistic variable. The name may be followed by additional\nflag which describe the variable behavior:\n\n- *no_reset* : variable cannot be reset.\n\n<!-- -->\n\n\n```\nmodparam(\"statistics\", \"variable\", \"register_counter\")\nmodparam(\"statistics\", \"variable\", \"active_calls/no_reset\")\n```\n"
  },
  "functions": {
   "update_stat": "### `update_stat(variable,value)`\n\nUpdates the value of the statistic variable with the new value.\n\nMeaning of the parameters is as follows:\n\n- *variable* - variable to be updated (it can be a string or a\n  pseudovariable);\n\n- *value* - value to update with; it may be also negative (it can be a\n  string or pseudovariable).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nupdate_stat(\"register_counter\", \"+1\");\n...\n$var(a_calls) = \"active_calls\";\nupdate_stat(\"$var(a_calls)\", \"-1\");\n...\n```\n",
   "reset_stat": "### `reset_stat(variable)`\n\nResets to zero the value of the statistic variable.\n\nMeaning of the parameters is as follows:\n\n- *variable* - variable to be reset (it can be a string or a\n  pseudovariable).\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nFAILURE_ROUTE and ONREPLY_ROUTE.\n\n```\n...\nreset_stat(\"register_counter\");\n...\n$var(reg_counter) = \"register_counter\";\nupdate_stat(\"$var(reg_counter)\");\n...\n```\n"
  }
 },
 "statsc": {
  "overview": "This module provides a statistics collector engine. It can track the\nvalues of various internal Kamailio statistics for a specific period of\ntime, allowing to retrieve them or a report over them via RPC commands.\n",
  "parameters": {
   "interval": "### `interval` (int)\n\nTimer interval when to record the value for statistics.\n\n*Default value is 900 (15min).*\n\n```\n...\nmodparam(\"statsc\", \"interval\", 300)\n...\n```\n",
   "items": "### `items` (int)\n\nHow many items to store for each statistic.\n\nNote: it must be set before any 'track' parameter.\n\n*Default value is 100.*\n\n```\n...\nmodparam(\"statsc\", \"items\", 200)\n...\n```\n",
   "track": "### `track` (str)\n\nSpecify the statistics to track. The parameter can be set many times and\none value can specify many statistics.\n\nThe format is \"rname=sname\", where the rname is the name for report and\nsname is internal Kamailio statistic name.\n\nNext statistics are tracked by default:\n\n- *shm.free* - the internal statistic 'free_size' (from group 'shmem').\n\n- *shm.used* - the internal statistic 'used_size' (from group 'shmem').\n\n- *shm.real_used* - the internal statistic 'real_used_size' (from group\n  'shmem').\n\n*Default value is \"\".*\n\n```\n...\nmodparam(\"statsc\", \"track\", \"req.received=rcv_requests\")\nmodparam(\"statsc\", \"track\", \"req.received=rcv_requests;rpl.received=rcv_replies\")\n...\n```\n"
  },
  "functions": {}
 },
 "statsd": {
  "overview": "The module provides the ability to send commands to statsd (you can use\nInfluxDB too) with different types of information. It provides native\nintegration with statsd (https://github.com/etsy/statsd/) and graphite\n(http://graphite.wikidot.com/).\n\nThe module does not have any special dependency, it does a direct socket\nconnection to Graphite.\n",
  "parameters": {
   "ip": "### `ip`(string)\n\nStatsd server IP address.\n\nDefaults to 127.0.0.1\n\n```\n...\nmodparam(\"statsd\", \"ip\", \"127.0.0.1\")\n...\n                \n```\n",
   "port": "### `port`(string)\n\nStatsd server port number\n\nDefaults to 8125\n\n```\n...\nmodparam(\"statsd\", \"port\", \"8125\")\n...\n                \n```\n"
  },
  "functions": {
   "statsd_set": "### `statsd_set(key, value)`\n\nSets count the number of unique values passed to a key.\n\nIf this method is called multiple times with the same userid in the same\nsample period, that userid will only be counted once.\n\nThis function can be used in ALL ROUTES.\n\n```\n...\nfailure_route[tryagain] {\n...\n    statsd_set(\"customerFailure\", 1);\n...\n}\n...\n                \n```\n",
   "statsd_gauge": "### `statsd_gauge(key, value)`\n\nGauges are a constant data type. They are not subject to averaging and\nthey don't change unless you change them. That is, once you set a gauge\nvalue, it will be a flat line on the graph until you change it again.\n\nGauges are useful for things that are already averaged, or don't need to\nreset periodically\n\nThis function can be used in ALL ROUTES.\n\nThe statsd server collects gauges under the stats.gauges prefix.\n\n```\n...\nroute [gauge_method]{\n    statsd_gauge(\"method\"+$rm, \"+1\");\n    statsd_gauge(\"customer_credit\"+$var(customer),\"$var(customer_credit)\");\n}\n...\n                \n```\n",
   "statsd_histogram": "### `statsd_histogram(key, value)`\n\nThe histograms are a measure of time, but they are calculated at the\nserver side. As the data exported by the client is the same, this is\njust an alias for the Timer type.\n\nThis function can be used in ALL ROUTES.\n\nThe statsd server collects histograms under the stats.histograms prefix.\n\n```\n...\n    statsd_histogram(\"latency\", 1000);\n...\n                \n```\n",
   "statsd_start": "### `statsd_start(key)`\n\nstatsd_start set an avp with the key name, and when statsd_stop(key) is\nused, the module will send statsd the difference in milliseconds. This\nis useful to know the time of a SQL query, or how much time your replies\ntake.\n\nThis function can be used in all routes.\n\nThe statsd server collects all timers under the stats.timers prefix and\nwill calculate the lower bound, mean, 90th percentile, upper bound, and\ncount of each timer for each period (by the time it can be seen in\ngraphite, that's usually per minute).\n\n```\n...\nstatsd_start(\"long_mysql_query\");\nsql_query(\"ca\", \"select sleep(0.2)\", \"ra\");\nstatsd_stop(\"long_mysql_query\");\n...\n                \n```\n",
   "statsd_stop": "### `statsd_stop(key)`\n\nstatsd_stop(key) get the avp string with the key and calculate the\ndifference from the start time. When finished the milliseconds used will\nbe sent to statsd.\n\nThis function can be used in all routes.\n\n```\n...\nstatsd_start(\"long_mysql_query\");\nsql_query(\"ca\", \"select sleep(0.2)\", \"ra\");\nstatsd_stop(\"long_mysql_query\");\n...\n                \n```\n",
   "statsd_incr": "### `statsd_incr(key)`\n\nIncrement a statsd counter\n\nThis function can be used in all routes.\n\n```\n...\nif(geoip_match(\"$si\", \"src\")){\n    statsd_incr(\"country.\"+$(gip(src=>cc)));\n}\n...\n                \n```\n",
   "statsd_decr": "### `statsd_decr(key)`\n\nDecrement a counter\n\nThis function can be used in all routes.\n\n```\n...\nif (t_check_status(\"408\")) {\n    statsd_decr(\"kamailio.successfulCalls\");\n    statsd_incr(\"kamailio.reply.timeout\");\n}\n...\n                \n```\n"
  }
 },
 "stirshaken": {
  "overview": "This module implements STIR (Secure Telephony Identity Revisited) and\nSHAKEN (Signature-based Handling of Asserted information using toKENs)\n(RFC8224, RFC8588), with X509 certificate path check (ATIS\n\"Signature-based Handling of Asserted information using toKENs\n(SHAKEN)\", RFC5280 \"6. Certification Path Validation\").\n\nstirshaken module exports the functions to check and to generate\nPASSporT, wrapped into SIP Identity header. For call authentication two\nfunctions are available: stirshaken_add_identity(...) and\nstirshaken_add_identity_with_key(key). stirshaken_add_identity() uses\ndefault key (through Authentication Service),\nstirshaken_add_identity_with_key(..., key) uses key specified as\nargument. For call verification three methods are available:\nstirshaken_check_identity() (through Verification Service),\nstirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert). stirshaken_check_identity()\noffers the most comprehensive check as only this method may download\ncertificate (if needed), cache it, and check it with X509 certificate\npath check algorithm. This method is therefore to be used as a default\nverification mechanism, while stirshaken_check_identity_with_key(key)\nand stirshaken_check_identity_with_cert(cert) are only for completeness.\n",
  "parameters": {
   "as_default_key": "### `as_default_key` (str)\n\nSSL private key to be used as default. Default key must be set if calls\nto stirshaken_add_identity() are executed. When set, module starts\nAuthentication Service which makes each call to\nstirshaken_add_identity() using this key. Default key doesn't need to be\nset (Authentication Service doesn't need to be running) for the\nstirshaken_add_identity_with_key(..., key) to be available. This param\nhas no meaning for calls to stirshaken_add_identity_with_key(..., key).\n\n*Default value is \"\" (not set).*\n\n```\n...\nmodparam(\"stirshaken\", \"as_default_key\", \"/path/to/key\")\n...\n```\n",
   "vs_verify_x509_cert_path": "### `vs_verify_x509_cert_path` (int)\n\nIf set, then stirshaken_check_identity() will execute X509 certificate\npath check on certificate referenced in PASSporT. This param has no\nmeaning for calls to stirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is 1, (turned on).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_verify_x509_cert_path\", 1)\n...\n```\n",
   "vs_ca_dir": "### `vs_ca_dir` (str)\n\nThe path to folder containing CA root certificates with names hashed. If\nset then must point to existing directory. This must be set when enabled\nX509 certificate path check, otherwise no end entity certificate will\npass that check. This param has no meaning for calls to\nstirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is \"\" (not set).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_ca_dir\", \"/path/to/ca_dir\")\n...\n```\n",
   "vs_crl_dir": "### `vs_crl_dir` (str)\n\nThe path to folder containing CRLs. If set, then must point to existing\ndirectory. This is optional when X509 certificate path check is enabled,\nonly vs_ca_dir is mandatory. If X509 certificate path check is enabled,\nand vs_crl_dir is set, then CRLs are loaded from this directory, which\nrenders revoked certificates invalid (not trusted). This param has no\nmeaning for calls to stirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is \"\" (not set).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_crl_dir\", \"/path/to/crl_dir\")\n...\n```\n",
   "vs_identity_expire_s": "### `vs_identity_expire_s` (int)\n\nThis parameter defines a maximum time in seconds for which PASSporT is\nconsidered valid.\n\n*Default value is 60 seconds.*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_identity_expire_s\", 20)\n...\n```\n",
   "vs_connect_timeout_s": "### `vs_connect_timeout_s` (int)\n\nDuring a call verification with stirshaken_check_identity() a blocking\nHTTP(s) call is executed to download certificate referenced in PASSporT\n(unless certificate caching is turned on and a valid cert is found in\ncache). This parameter defines a maximum time in seconds for this\nblocking HTTP(s) connection to be established. After this time had\npassed and connection did not succeed (could not resolve host, address\nunreachable or other network errors) a call to\nstirshaken_check_identity() will return with error. This param has no\nmeaning for calls to stirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is 5 seconds.*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_connect_timeout_s\", 10)\n...\n```\n",
   "vs_cache_certificates": "### `vs_cache_certificates` (int)\n\nIf set, then certificates caching is turned on. This means that\ncertificates downloaded during call verification with\nstirshaken_check_identity() are cached inside vs_cache_dir, and will be\nloaded from that cache as long as they are not there for more than\nvs_cache_expire_s seconds (see vs_cache_expire_s). If\nvs_cache_certificates is set then vs_cache_dir must be set too and\npointing to existing directory. This param has no meaning for calls to\nstirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is 0 (turned off).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_cache_certificates\", 1)\n...\n```\n",
   "vs_cache_dir": "### `vs_cache_dir` (str)\n\nIf vs_cache_certificates is set then vs_cache_dir must be set too and\npointing to existing directory. Cached certificates are saved in this\ndirectory and loaded from there when needed during a call verification\nexecuted with stirshaken_check_identity(), as long as they are not there\nfor more than vs_cache_expire_s seconds. This param has no meaning for\ncalls to stirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is \"\" (not set).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_cache_dir\", \"/tmp/cert_cache\")\n...\n```\n",
   "vs_cache_expire_s": "### `vs_cache_expire_s` (int)\n\nIf vs_cache_certificates is set then cached certificates are saved in\nvs_cache_dir directory and loaded from there when needed during a call\nverification executed with stirshaken_check_identity(), as long as they\nare not there for more than vs_cache_expire_s seconds. If they are in\ncache for more than vs_cache_expire_s seconds, then a blocking HTTP(s)\ncall is executed to download a new version of (expired) certificate. If\nthis is successful then old version is removed and new version is saved\nin cache. This param has no meaning for calls to\nstirshaken_check_identity_with_key(key) and\nstirshaken_check_identity_with_cert(cert).\n\n*Default value is 120 seconds.*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_cache_expire_s\", 15)\n...\n```\n",
   "vs_certsubject_pvname": "### `vs_certsubject_pvname` (str)\n\nIf vs_certsubject_pvname is set then the Subject of the authenticated\nx509 certificate will be written to this pseudo-variable when\nstirshaken_check_identity() is executed. If the Identity header cannot\nbe fully authenticated the pseudo-variable will be set to $null.\n\n*Default value is blank (disabled).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_certsubject_pvname\", \"$vn(certsubject)\")\n...\n```\n",
   "vs_pptgrants_pvname": "### `vs_pptgrants_pvname` (str)\n\nIf vs_pptgrants_pvname is set then the JSON string of the authenticated\nPASSporT's grants will be written to this pseudo-variable when\nstirshaken_check_identity() is executed. If the Identity header cannot\nbe fully authenticated the pseudo-variable will be set to $null.\n\n*Default value is blank (disabled).*\n\n```\n...\nmodparam(\"stirshaken\", \"vs_pptgrants_pvname\", \"$vn(grants)\")\n...\n```\n"
  },
  "functions": {
   "stirshaken_check_identity": "### `stirshaken_check_identity()`\n\nCheck the validity of the Identity header by decoding PASSporT's\nsignature with a certificate referenced in its x5u header and\n(optionally) checking that certificate for being trusted by X509\ncertificate check with CA root certificates in vs_ca_dir (and optionally\nCRLs in vs_crl_dir). PASSporT's iat grant is also checked for being too\nfresh or expired against vs_identity_expire_s seconds. This function\nexecutes a call to a callback which may supply certificates from cache\n(see vs_cache_certificates param). If certificate needs to be downloaded\nthis call will block for a maximum of vs_connect_timeout_s seconds (see\nvs_connect_timeout_s param);\n\nThis function takes no parameters (only SIP message is passed\nimplicitly).\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nmodparam(\"stirshaken\", \"vs_verify_x509_cert_path\", 1)\nmodparam(\"stirshaken\", \"vs_ca_dir\", \"/path/to/ca\")\nmodparam(\"stirshaken\", \"vs_cache_certificates\", 1)\nmodparam(\"stirshaken\", \"vs_cache_dir\", \"/path/to/cert_cache\")\nmodparam(\"stirshaken\", \"vs_cache_expire_s\", 100)\n\nrequest_route {\n    ...\n        if (1 == stirshaken_check_identity()) {\n            xlog(\"Shaken Identity is OK\\n\");\n        } else {\n            xlog(\"Shaken Identity is invalid\\n\");\n        }\n    ...\n}\n...\n```\n",
   "stirshaken_check_identity_with_key": "### `stirshaken_check_identity_with_key(keyPath)`\n\nCheck the validity of the Identity header by decoding PASSporT's\nsignature with a key read from the location provided. PASSporT's iat\ngrant is also checked for being too fresh or expired against\nvs_identity_expire_s seconds. This method does not involve HTTP(s)\ntranscations. This method does not execute a call to a callback\n(vs_cache_certificates param has no meaning for this method). WARNING:\nThis method only checks if SIP Identity Header was signed by a key\ncorresponding to specified public key. This method doesn't attempt to\nobtain certificate referenced in PASSporT (but PASSporT should be\nchecked with key corresponding to that certificate). Therefore it is\npossible that this check will be successful, while PASSporT is not valid\n(could be signed with key that doesn't match certificate referenced in\nx5u header). If you want a complete Shaken check or if you are not sure\nwhat you're doing, then you should execute w_stirshaken_check_identity()\ninstead (and configure Verification Service to perform X509 certificate\npath verification with stirshaken_vs_verify_x509_cert_path param set to\n1).\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n        if (1 == stirshaken_check_identity_with_key(\"/path/to/key\")) {\n            xlog(\"Shaken Identity is OK\\n\");\n        } else {\n            xlog(\"Shaken Identity is invalid\\n\");\n        }\n    ...\n}\n...\n```\n",
   "stirshaken_check_identity_with_cert": "### `stirshaken_check_identity_with_cert(certPath)`\n\nSame as stirshaken_check_identity_with_key(keyPath) but the key is read\nfrom the certificate which is read from the location provided.\n\nThe parameters can contain pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n        if (1 == stirshaken_check_identity_with_cert(\"/path/to/cert\")) {\n            xlog(\"Shaken Identity is OK\\n\");\n        } else {\n            xlog(\"Shaken Identity is invalid\\n\");\n        }\n    ...\n}\n...\n```\n",
   "stirshaken_add_identity": "### `stirshaken_add_identity(x5u, attest, origtn_val, desttn_val, origid)`\n\nAdd SIP Identity Header to the call using default private key (see\nas_default_key param). Authenticate call with STIR-Shaken. If origID is\nempty, a UUID string is generated to fill the field. The origtn_val\nrepresents the origination telephone number; desttn_val, represents the\ndestination telephone number; x5u is the HTTP(s) URL referencing to the\npublic key that should be used to verify the signature; attest\nrepresents the attestation level (should be \"A\", \"B\" or \"C\").\n\nThe parameters can contain pseudo-variables. If origid is empty, an\nunique identifier will be generated with libuuid, e.g.\n\"3f31bd2b-9fc4-4084-b0b0-566506c46292\".\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n        if (1 == stirshaken_add_identity(\"https://sp.com/sp.pem\", \"B\", \"+44100\", \"+44200\", \"origid\")) {\n            xlog(\"Shaken authentication added (SIP Identity Header created)\\n\");\n        } else {\n            xlog(\"Failed\\n\");\n        }\n    ...\n}\n...\n```\n\nIf origid is empty, an unique identifier will be generated with libuuid,\ne.g. \"3f31bd2b-9fc4-4084-b0b0-566506c46292\".\n\n```\n...\nrequest_route {\n    ...\n        if (1 == stirshaken_add_identity(\"https://sp.com/sp.pem\", \"B\", \"+44100\", \"+44200\", \"\")) {\n            xlog(\"Shaken authentication added (SIP Identity Header created)\\n\");\n        } else {\n            xlog(\"Failed\\n\");\n        }\n    ...\n}\n...\n```\n",
   "stirshaken_add_identity_with_key": "### `stirshaken_add_identity_with_key(x5u, attest, origtn_val, desttn_val, origid, keyPath)`\n\nSame as stirshaken_add_identity() but using the key read from the\nlocation provided as a last parameter.\n\nThe parameters can contain pseudo-variables. If origid is empty, an\nunique identifier will be generated with libuuid, e.g.\n\"3f31bd2b-9fc4-4084-b0b0-566506c46292\".\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n        if (1 == stirshaken_add_identity_with_key(\"https://sp.com/sp.pem\", \"B\", \"+44100\", \"+44200\", uuid, \"/path/to/key\")) {\n            xlog(\"Shaken authentication added (SIP Identity Header created)\\n\");\n        } else {\n            xlog(\"Failed\\n\");\n        }\n    ...\n}\n...\n```\n"
  }
 },
 "stun": {
  "overview": "This module provides limited STUN server (RFC 5389) support for\nKamailio. It's built for providing STUN support in the SIP signalling\nchannel, not being a standalone STUN/TURN server.\n",
  "parameters": {},
  "functions": {}
 },
 "sworker": {
  "overview": "This module can delegate processing of SIP requests to a group of\nworkers in the configuration file by using\nevent_route[core:pre-routing]. The async workers have to be defined\nwith the global parameter. The worker process that received the message\ninternally does the usual execution of the config script, running\nrequest_route or reply_route.\n\nNote: the behaviour is different than the async module, because it does\nnot create the transaction (obviously also not performing suspend).\n\nNote: it does not propagate anything set in the event_route, therefore\nany set flag, or avp, etc. are lost. The SIP message is processed by the\ndelegated worker as it was fresh received from the network (including\nparsing).\n",
  "parameters": {
   "xdata": "### `xdata (str)`\n\nName of a script variable from where to take additional data to be\npassed to special worker along with the SIP message. Same variable will\nbe set by the special worker, therefore it has to be a writable\nvariable. Moreover, it must be a variable that can be set without the\nSIP message structure, like $var(name), otherwise it can lead to a\ncrash.\n\nDefault value: not set.\n\n```\n...\nmodparam(\"sworker\", \"xdata\", \"$var(xdata)\")\n...\n```\n"
  },
  "functions": {
   "sworker_active": "### `sworker_active()`\n\nReturn 1 (true) if the processing happens in an async process, or -1\n(false) if the processing is happening in a SIP receiving process.\n\nThis function can be used from REQUEST_ROUTE|CORE_REPLY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    if(sworker_active()) {\n    }\n    ...\n}\n...\n```\n",
   "swork_task": "### `swork_task(gname)`\n\nDelegate the processing of SIP message to a group of async workers. The\nfunction is restricted to be used inside\nevent_route[core:pre-routing].\n\nThe parameter gname provides the name of the group workers, it can\ncontain pseudo-variables.\n\nThe function returns 1 (true) in case the task is delegated. After that,\n'drop' must be used so processing of the message does not continue to\nrequest_route or reply_route in the same process, it is going to be done\nby the delegated group of workers. It returns -1 (false) in case there\nwas a problem delegating the processing.\n\nThis function can be used from REQUEST_ROUTE|CORE_REPLY_ROUTE.\n\n```\n...\nevent_route[core:pre-routing] {\n    if(sworker_task(\"default\")) {\n        xinfo(\"===== delegate processing [$Tf] [$si:$sp]\\n\");\n        drop;\n    }\n    xinfo(\"===== processing continues [$Tf] [$si:$sp]\\n\");\n    ...\n}\n...\n```\n"
  }
 },
 "systemdops": {
  "overview": "It provides a collection of features to make easier the integration with\nsystemd.\n",
  "parameters": {},
  "functions": {}
 },
 "tcpops": {
  "overview": "This module allows Kamailio to control the TCP connection options (such\nas the keepalive mechanism), on demand, and on a per-socket basis.\n\n*Note*: the keepalive functions only work on systems with the\nHAVE_TCP_KEEPIDLE, HAVE_TCP_KEEPCNT and HAVE_TCP_KEEPINTVL macros\ndefined (Linux, FreeBSD, DragonFly BSD, NetBSD).\n",
  "parameters": {
   "closed_event": "### `closed_event` (int)\n\nIf set to 0 (globally disabled), the \"tcp:closed\" event route will never\nbe called on TCP disconnections.\n\nIf set to 1 (globally enabled), the \"tcp:closed\" event route will always\nbe called on TCP disconnections.\n\nIf set to 2 (\"manual\" mode), the \"tcp:closed\" event route will only be\ncalled on TCP connections for which `tcp_enable_closed_event()` has been\napplied, when a disconnection occurs.\n\n*Default value is 1 (globally enabled).*\n\n```\n...\nmodparam(\"tcpops\", \"closed_event\", 0)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event, the\nvalues are: 'tcp:closed', 'tcp:timeout', 'tcp:reset'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"tcpops\", \"event_callback\", \"ksr_tcpops_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_tcpops_event(evname)\n    KSR.info(\"===== tcpops module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n"
  },
  "functions": {
   "tcp_conid_alive": "### `tcp_conid_alive(conid)`\n\nCheck the state of a TCP or WS connection ID\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id (as in the\n  *$conid* pseudovariable).\n\nReturn values:\n\n1: Connection is OK\n\n-1: Connection has errors, does not exist or is about to be closed)\n\n```\n...\n    $var(conid) = $conid;\n    if(!tcp_conid_alive(\"$var(conid)\")) {\n        xlog(\"L_ERR\", \"Connection $conid can no longer be used\\n\");\n    }\n...\n            \n```\n",
   "tcp_conid_state": "### `tcp_conid_state(conid)`\n\nCheck the state of a TCP or WS connection ID\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id (as in the\n  *$conid* pseudovariable).\n\nReturn values:\n\n1: Connection is OK\n\n2: Socket is accepting incoming connections\n\n3: Socket is setting up outgoing connection\n\n-1: Connection does not exist (or was closed)\n\n-2: Socket has reached EOF\n\n-3: Socket error has occurred. Connection will likely close.\n\n-4: Socket is in unknown bad state. Connection will likely close.\n\n```\n...\n    if(!tcp_conid_state(\"$var(conid)\")) {\n        xlog(\"L_ERR\", \"Connection $conid is closed or malfunctional\\n\");\n    }\n...\n            \n```\n",
   "tcp_keepalive_enable": "### `tcp_keepalive_enable([conid], idle, count, interval)`\n\nEnables keepalive on a TCP connection.\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id on which TCP\n  keepalive will be enabled. If no parameter is given, the keepalive\n  mechanism will be enabled on the current message source connection.\n\n- *idle* (seconds): the time before the first keepalive packet is sent\n  out.\n\n- *count*: number of non-acked keepalive before resetting the\n  connection.\n\n- *interval* (seconds): time between two keepalive probes.\n\nReturns 1 on success, -1 on failure.\n\n```\nrequest_route {\n    if (is_method(\"INVITE\")) {\n        $avp(caller_conid) = $conid;\n        t_on_reply(\"foo\");\n    }\n    ...\n}\n\nonreply_route[foo] {\n    if (is_method(\"INVITE\") && status == 200) {\n        # enable on callee's connection\n        tcp_keepalive_enable(\"60\", \"5\", \"5\");\n        # enable on caller's connection\n        tcp_keepalive_enable(\"$avp(caller_conid)\", \"60\", \"5\", \"2\");\n    }\n    ...\n}\n            \n```\n",
   "tcp_keepalive_disable": "### `tcp_keepalive_disable([conid])`\n\nDisables keepalive on a TCP connection.\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id on which TCP\n  keepalive will be disabled. If no parameter is given, the keepalive\n  mechanism will be disabled on the current message source connection.\n\nReturns 1 on success, -1 on failure.\n\n```\nrequest_route {\n    ...\n    if (is_method(\"BYE\")) {\n        $avp(bye_conid) = $conid;\n        t_on_reply(\"foo\");\n    }\n    ...\n}\n\nonreply_route[foo] {\n    ...\n    if (is_method(\"BYE\") && status == 200) {\n        tcp_keepalive_disable();\n        tcp_keepalive_disable(\"$avp(bye_conid)\");\n    }\n    ...\n}\n            \n```\n",
   "tcp_set_connection_lifetime": "### `tcp_set_connection_lifetime([conid], lifetime)`\n\nSets the connection lifetime of a connection (TCP).\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id on which to\n  set the new lifetime. If no parameter is given, it will be set on the\n  current message source connection.\n\n- *lifetime* (seconds): the new connection lifetime.\n\nReturns 1 on success, -1 on failure.\n\n```\n...\n# use 10s as default lifetime\ntcp_connection_lifetime=10\n...\n\nrequest_route {\n        ...\n        if (is_method(\"REGISTER\") && pv_www_authenticate(\"$td\", \"xxx\", \"0\")) {\n                # raise the TCP lifetime to a bigger value\n                tcp_set_connection_lifetime(\"3605\");\n        }\n        ...\n}\n                        \n```\n",
   "tcp_enable_closed_event": "### `tcp_enable_closed_event([conid])`\n\nExplicitly enables the \"tcp:closed\" event route on a TCP connection.\n\nMeaning of the parameters is as follows:\n\n- *conid* (optional): the Kamailio internal connection id. If no\n  parameter is given, it will be enabled on the current message source\n  connection.\n\nReturns 1 on success, -1 on failure.\n\n```\n...\n# \"tcp:closed\" event route is \"manual\" mode\nmodparam(\"tcpops\", \"closed_event\", 2)\n...\n\nrequest_route {\n    ...\n    if (is_method(\"REGISTER\") && pv_www_authenticate(\"$td\", \"xxx\", \"0\")) {\n        # it will be called for this specific connection\n        tcp_enable_closed_event();\n    }\n    ...\n\n}\n\nevent_route[tcp:closed] {\n    xlog(\"connection $conid was closed\");\n}\n```\n",
   "tcp_get_conid": "### `tcp_get_conid(hostport, pvname)`\n\nGet the connection id based on target host:port. The connection id is\nset in the variable named by pvname parameter.\n\nMeaning of the parameters is as follows:\n\n- *hostport* - target \"host:port\" address, the port can be omitted\n  (default to 5060) and the parameter can contain variables.\n\n- *pvname* - target variable name.\n\nReturn values:\n\n1: connection was found\n\n-1: connection was not found or an error occurred\n\n```\n...\n    if(tcp_get_conid(\"127.0.0.1:5060\", \"$var(conid)\")) {\n        xlog(\"connection id is: $var(conid)\\n\");\n    }\n...\n            \n```\n",
   "tcp_set_otcpid": "### `tcp_set_otcpid(conid)`\n\nSet the value for outbound tcp connection id.\n\nMeaning of the parameters is as follows:\n\n- *conid* - the value of tcp connection id. It can be an integer number\n  or a variable holding an interver value.\n\nReturn values:\n\n- 1: success\n\n- -1: failure\n\n<!-- -->\n\n\n```\n...\n    $var(conid) = 10;\n    tcp_set_otcpid(\"$var(conid)\");\n...\n            \n```\n",
   "tcp_set_otcpid_flag": "### `tcp_set_otcpid_flag(mode)`\n\nSet or reset the internal flag for using or not the outbound tcp\nconnection id for sending out. The outbound connection id can be set by\nmodule or by config using tcp_set_otcpid(...) function. An example of a\nmodule setting the otcpid is register via lookup location function,\nwhich sets the filed to the connection id used to receive the\nregistration request.\n\nMeaning of the parameters is as follows:\n\n- *mode* - if 0, then the flag is reset, otherwise it is set.\n\nReturn values:\n\n- 1: success\n\n- -1: failure\n\nNote: if you set the flag to use the outbound tcp connection id, then\ncustom config changes to the destination address, like updating the\nr-uri ($ru) or dst uri ($du) are not resetting it, so the same already\nset connection id is used and the SIP request might be sent to the\nunexpected destination. Reset the flag in such case, if you set it\npreviously.\n\n```\n...\n    $var(cmode) = 1;\n    tcp_set_otcpid_flag(\"$var(cmode)\");\n...\n            \n```\n",
   "tcp_close_connection": "### `tcp_close_connection([conid])`\n\nTrigger a close of the connection corresponding to current SIP message\nor to connection id 'conid'.\n\nMeaning of the parameters is as follows:\n\n- *conid* - the value of tcp connection id. It can be an integer number\n  or a variable holding an interver value.\n\nReturn values:\n\n- 1: success\n\n- -1 (or other negative values): failure\n\n<!-- -->\n\n\n```\n...\n    $var(conid) = 10;\n    tcp_close_connection(\"$var(conid)\");\n...\n            \n```\n"
  }
 },
 "textops": {
  "overview": "The module implements text based operations over the SIP message\nprocessed by Kamailio. SIP is a text based protocol and the module\nprovides a large set of very useful functions to manipulate the message\nat text level, e.g., regular expression search, replace or\nsubstitutions, checks for method type, header presence, insert of new\nheader and date, string comparisons, multi-part body operations, etc.\n\nIf not stated otherwise, the regular expressions parameters for search,\nreplace or substitute have to be in POSIX format. For PCRE regular\nexpression matching, see the pcre or dialplan modules.\n",
  "parameters": {},
  "functions": {
   "search": "### `search(re)`\n\nSearches for the re in the message.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\nNote: it performs Posix regex matching and the 're' parameter is\ncompiled with the flags REG_EXTENDED|REG_ICASE|REG_NEWLINE.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif ( search(\"[Ss][Ii][Pp]\") ) { /*....*/ };\n...\n```\n",
   "search_body": "### `search_body(re)`\n\nSearches for the re in the body of the message.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif ( search_body(\"[Ss][Ii][Pp]\") ) { /*....*/ };\n...\n```\n",
   "search_str": "### `search_str(text, re)`\n\nSearches for the re in the body of the message.\n\nMeaning of the parameters is as follows:\n\n- *text* - text to perform regex searching over it.\n\n- *re* - regular expression to match over the 'text' parameter.\n\nBoth parameters can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif ( search_str(\"$ru\", \";transport=tcp\") ) { /*....*/ };\n...\n```\n",
   "search_hf": "### `search_hf(hf, re, flags)`\n\nSearches for the re in the body of a header field.\n\nMeaning of the parameters is as follows:\n\n- *hf* - header field name.\n\n- *re* - regular expression.\n\n- *flags* - control flags - it has to be one of: a - all headers\n  matching the name; f - only first header matching the name; l - only\n  the last header matching the name.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif ( search_hf(\"From\", \":test@\", \"a\") ) { /*....*/ };\n...\n```\n",
   "search_append": "### `search_append(re, txt)`\n\nSearches for the first match of re and appends txt after it.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String to be appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nsearch_append(\"[Oo]pen[Ss]er\", \" SIP Proxy\");\n...\n```\n",
   "search_append_body": "### `search_append_body(re, txt)`\n\nSearches for the first match of re in the body of the message and\nappends txt after it.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String to be appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nsearch_append_body(\"[Oo]pen[Ss]er\", \" SIP Proxy\");\n...\n```\n",
   "replace": "### `replace(re, txt)`\n\nReplaces the first occurrence of re with txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nreplace(\"server\", \"Kamailio SIP Proxy\");\n...\n```\n",
   "replace_body": "### `replace_body(re, txt)`\n\nReplaces the first occurrence of re in the body of the message with txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nreplace_body(\"server\", \"Kamailio SIP Proxy\");\n...\n```\n",
   "replace_hdrs": "### `replace_hdrs(re, txt)`\n\nReplaces the first occurrence of re in the SIP headers of the message\nwith txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nreplace_hdrs(\"Kamailio\", \"Kamailio SIP Proxy\");\n...\n```\n",
   "replace_all": "### `replace_all(re, txt)`\n\nReplaces all occurrence of re with txt.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nreplace_all(\"server\", \"Kamailio SIP Proxy\");\n...\n```\n",
   "replace_body_all": "### `replace_body_all(re, txt)`\n\nReplaces all occurrence of re in the body of the message with txt.\nMatching is done on a per-line basis.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nreplace_body_all(\"server\", \"Kamailio SIP Proxy\");\n...\n```\n",
   "replace_body_atonce": "### `replace_body_atonce(re, txt)`\n\nReplaces all occurrence of re in the body of the message with txt.\nMatching is done over the whole body.\n\nMeaning of the parameters is as follows:\n\n- *re* - Regular expression.\n\n- *txt* - String.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\n# strip the whole body from the message:\nif(has_body() && replace_body_atonce(\"^.+$\", \"\"))\n        remove_hf(\"Content-Type\");\n...\n```\n",
   "replace_str": "### `replace_str(match, repl, mode)`\n\nReplaces the first or all occurrence of 'match' with 'repl' by doing\nstring comparison for matching. It is applied over headers and message\nbody (not over the first line).\n\nMeaning of the parameters is as follows:\n\n- *match* - string to be matched.\n\n- *repl* - string to be used as replacement.\n\n- *mode* - 'f' - replace only first match; 'a' - replace all matches.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nreplace_str(\"Kamailio\", \"Kamailio SIP Proxy\", \"a\");\n...\n```\n",
   "replace_body_str": "### `replace_body_str(match, repl, mode)`\n\nReplaces the first or all occurrence of 'match' with 'repl' by doing\nstring comparison for matching. It is applied over the message body.\n\nMeaning of the parameters is as follows:\n\n- *match* - string to be matched.\n\n- *repl* - string to be used as replacement.\n\n- *mode* - 'f' - replace only first match; 'a' - replace all matches.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nreplace_body_str(\"Kamailio\", \"Kamailio SIP Proxy\", \"a\");\n...\n```\n",
   "replace_hdrs_str": "### `replace_hdrs_str(match, repl, mode)`\n\nReplaces the first or all occurrence of 'match' with 'repl' by doing\nstring comparison for matching. It is applied over the part with headers\nof the SIP message.\n\nMeaning of the parameters is as follows:\n\n- *match* - string to be matched.\n\n- *repl* - string to be used as replacement.\n\n- *mode* - 'f' - replace only first match; 'a' - replace all matches.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nreplace_hdrs_str(\"Kamailio\", \"Kamailio SIP Proxy\", \"a\");\n...\n```\n",
   "subst": "### `subst('/re/repl/flags')`\n\nReplaces re with repl.\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\n# replace the uri in to: with the message uri (just an example)\nif ( subst('/^To:(.*)sip:[^@]*@[a-zA-Z0-9.]+(.*)$/t:\\1\\u\\2/ig') ) {};\n\n# replace the uri in to: with the value of avp sip_address (just an example)\nif ( subst('/^To:(.*)sip:[^@]*@[a-zA-Z0-9.]+(.*)$/t:\\1$avp(sip_address)\\2/ig') ) {};\n\n...\n```\n",
   "subst_uri": "### `subst_uri('/re/repl/flags')`\n\nRuns the re substitution on the message uri (like subst but works only\non the uri)\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\n# adds 3463 prefix to numeric uris, and save the original uri (\\0 match)\n# as a parameter: orig_uri (just an example)\nif (subst_uri('/^sip:([0-9]+)@(.*)$/sip:3463\\1@\\2;orig_uri=\\0/i')){$\n\n# adds the avp 'uri_prefix' as prefix to numeric uris, and save the original\n# uri (\\0 match) as a parameter: orig_uri (just an example)\nif (subst_uri('/^sip:([0-9]+)@(.*)$/sip:$avp(uri_prefix)\\1@\\2;orig_uri=\\0/i')){$\n\n...\n```\n",
   "subst_user": "### `subst_user('/re/repl/flags')`\n\nRuns the re substitution on the message uri (like subst_uri but works\nonly on the user portion of the uri)\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\n# adds 3463 prefix to uris ending with 3642 (just an example)\nif (subst_user('/3642$/36423463/')){$\n\n...\n# adds avp 'user_prefix' as prefix to username in r-uri ending with 3642\nif (subst_user('/(.*)3642$/$avp(user_prefix)\\13642/')){$\n\n...\n```\n",
   "subst_body": "### `subst_body('/re/repl/flags')`\n\nReplaces re with repl in the body of the message.\n\nMeaning of the parameters is as follows:\n\n- *'/re/repl/flags'* - sed like regular expression. flags can be a\n  combination of i (case insensitive), g (global) or s (match newline\n  don't treat it as end of line).\n\n  're' - is regular expression\n\n  'repl' - is replacement string - may contain pseudo-variables\n\n  'flags' - substitution flags (i - ignore case, g - global)\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif ( subst_body('/^o=(.*) /o=$fU /') ) {};\n\n...\n```\n",
   "subst_hf": "### `subst_hf(hf, subexp, flags)`\n\nSubstitutions in the body of a header field.\n\nMeaning of the parameters is as follows:\n\n- *hf* - header field name.\n\n- *subexp* - substitution expression in the same format as of the\n  'subst' function parameter.\n\n- *flags* - control flags - it has to be one of: a - all headers\n  matching the name; f - only first header matching the name; l - only\n  the last header matching the name.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif ( subst_hf(\"From\", \"/:test@/:best@/\", \"a\") ) { /*....*/ };\n...\n```\n",
   "set_body": "### `set_body(txt, content_type)`\n\nSet body to a SIP message.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nset_body(\"test\", \"text/plain\");\n...\n```\n",
   "set_reply_body": "### `set_reply_body(txt, content_type)`\n\nSet body to a SIP reply to be generated by Kamailio.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\nset_reply_body(\"test\", \"text/plain\");\n...\n```\n",
   "filter_body": "### `filter_body(content_type)`\n\nFilters multipart/mixed body by leaving out all other body parts except\nthe first body part of given type.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - Content type to be left in the body.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif (has_body(\"multipart/mixed\")) {\n    if (filter_body(\"application/sdp\")) {\n        remove_hf(\"Content-Type\");\n        append_hf(\"Content-Type: application/sdp\\r\\n\");\n    } else {\n        xlog(\"Body part application/sdp not found\\n\");\n    }\n}\n...\n```\n",
   "append_to_reply": "### `append_to_reply(txt)`\n\nAppend txt as header to the reply that is going to be generated by\nKamailio (e.g., via sl_send_reply(...)).\n\nMeaning of the parameters is as follows:\n\n- *txt* - String which may contains pseudo-variables. Note that the\n  value has to be ended with \"\\r\\n\" (end of header characters sequence).\n\nThis function can be used from REQUEST_ROUTE, BRANCH_ROUTE,\nFAILURE_ROUTE, ERROR_ROUTE.\n\n```\n...\nappend_to_reply(\"Foo: bar\\r\\n\");\nappend_to_reply(\"Foo: $rm at $Ts\\r\\n\");\n...\n```\n",
   "append_hf": "### `append_hf(txt[, hdr])`\n\nAppends 'txt' as header at the end of all the headers, or after last\nheader named 'hdr' if the second parameter is provided.\n\nMeaning of the parameters is as follows:\n\n- *txt* - Header field to be appended. The value can contain\n  pseudo-variables which will be replaced at run time. Note that the\n  value has to be ended with \"\\r\\n\" (end of header characters sequence).\n\n- *hdr* - Header name after which the 'txt' is appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nappend_hf(\"P-hint: VOICEMAIL\\r\\n\");\nappend_hf(\"From-username: $fU\\r\\n\", \"Call-ID\");\n...\n```\n",
   "insert_hf": "### `insert_hf(txt[, hdr])`\n\nInserts 'txt' as header before the first header field, or before first\nheader named 'hdr' if the second parameter is provided.\n\nMeaning of the parameters is as follows:\n\n- *txt* - Header field to be inserted. The value can contain\n  pseudo-variables which will be replaced at run time. Note that the\n  value has to be ended with \"\\r\\n\" (end of header characters sequence).\n\n- *hdr* - Header name before which the 'txt' is inserted.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\ninsert_hf(\"P-hint: VOICEMAIL\\r\\n\");\ninsert_hf(\"To-username: $tU\\r\\n\");\ninsert_hf(\"P-hint: VOICEMAIL\\r\\n\", \"Call-ID\");\ninsert_hf(\"To-username: $tU\\r\\n\", \"Call-ID\");\n...\n```\n",
   "append_urihf": "### `append_urihf(prefix, suffix)`\n\nAppend header field name with original Request-URI in middle.\n\nMeaning of the parameters is as follows:\n\n- *prefix* - string (usually at least header field name).\n\n- *suffix* - string (usually at least line terminator).\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\nappend_urihf(\"CC-Diversion: \", \"\\r\\n\");\n...\n```\n",
   "is_present_hf": "### `is_present_hf(hf_name)`\n\nReturn true if a header field is present in message.\n\n<div class=\"note\">\n\n\nThe function is also able to distinguish the compact names. For example\n\u201cFrom\u201d will match with \u201cf\u201d.\n\n</div>\n\n\nMeaning of the parameters is as follows:\n\n- *hf_name* - Header field name (long or compact form). It can be only a\n  static string value.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif (is_present_hf(\"From\")) xlog(\"From HF Present\");\n...\n```\n",
   "is_present_hf_pv": "### `is_present_hf_pv(hf_name)`\n\nSame as is_present_hf() function, but the parameter can contain\nvariables.\n\n```\n...\nif (is_present_hf_pv(\"$var(hname)\")) xinfo(\"Header $var(hname) is present\\n\");\n...\n```\n",
   "is_present_hf_re": "### `is_present_hf_re(hf_name_re)`\n\nReturn true if a header field whose name matches regular expression\n'hf_name_re' is present in message.\n\nMeaning of the parameters is as follows:\n\n- *hf_name_re* - Regular expression to match header field name. It can\n  be only a static string value.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif (is_present_hf_re(\"^P-\"))\n    xlog(\"There are headers starting with P-\\n\");\n...\n```\n",
   "is_present_hf_re_pv": "### `is_present_hf_re_pv(hf_name_re)`\n\nSame as is_present_hf_re() function, but the parameter can contain\nvariables.\n\n```\n...\nif (is_present_hf_re_pv_(\"^$var(prefix)\"))\n    xlog(\"There are headers starting with $var(prefix)\\n\");\n...\n```\n",
   "append_time": "### `append_time()`\n\nAdds a time header to the reply of the request. You must use it before\nfunctions that are likely to send a reply, e.g., save() from 'registrar'\nmodule. Header format is: \u201cDate: %a, %d %b %Y %H:%M:%S GMT\u201d, with the\nlegend:\n\n- *%a* abbreviated week of day name (locale)\n\n- *%d* day of month as decimal number\n\n- *%b* abbreviated month name (locale)\n\n- *%Y* year with century\n\n- *%H* hour\n\n- *%M* minutes\n\n- *%S* seconds\n\nReturn true if a header was successfully appended.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\nappend_time();\n...\n```\n",
   "append_time_to_request": "### `append_time_to_request()`\n\nAdds a time header to the request. Header format is: \u201cDate: %a, %d %b %Y\n%H:%M:%S GMT\u201d, with the legend:\n\n- *%a* abbreviated week of day name (locale)\n\n- *%d* day of month as decimal number\n\n- *%b* abbreviated month name (locale)\n\n- *%Y* year with century\n\n- *%H* hour\n\n- *%M* minutes\n\n- *%S* seconds\n\nReturn true if a header was successfully appended.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, BRANCH_ROUTE.\n\n```\n...\nif(!is_present_hf(\"Date\"))\n    append_time_to_request();\n...\n```\n",
   "is_method": "### `is_method(name)`\n\nCheck if the method of the message matches the name. If name is a known\nmethod (invite, cancel, ack, bye, options, info, update, register,\nmessage, subscribe, notify, refer, prack), the function performs method\nID testing (integer comparison) instead of ignore case string\ncomparison.\n\nThe 'name' can be a list of methods in the form of\n'method1|method2|...'. In this case, the function returns true if the\nSIP message's method is one from the list. IMPORTANT NOTE: in the list\nmust be only methods defined in Kamailio with ID (invite, cancel, ack,\nbye, options, info, update, register, message, subscribe, notify, refer,\nprack, publish; for more see:\n<http://www.iana.org/assignments/sip-parameters>).\n\nIf used for replies, the function tests the value of method field from\nCSeq header.\n\nMeaning of the parameters is as follows:\n\n- *name* - SIP method name\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE, and BRANCH_ROUTE.\n\n```\n...\nif(is_method(\"INVITE\"))\n{\n    # process INVITEs here\n}\nif(is_method(\"OPTION|UPDATE\"))\n{\n    # process OPTIONs and UPDATEs here\n}\n...\n```\n",
   "remove_hf": "### `remove_hf(hname)`\n\nRemove from message all headers with name \u201chname\u201d. Header matching is\ncase-insensitive. Matches and removes also the compact header forms.\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *hname* - header name to be removed. It can be only a static string\n  (because of the optimizations done at startup to speed up execution at\n  runtime).\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif(remove_hf(\"User-Agent\"))\n{\n    # User Agent header removed\n}\n# compact form: remove \"Contact\" or \"m\" header\nremove_hf(\"Contact\");\n# compact form: remove \"Contact\" or \"m\" header\nremove_hf(\"m\");\n...\n```\n",
   "remove_hf_pv": "### `remove_hf_pv(hname)`\n\nSame as remove_hf() function, but the parameter can contain variables.\n\n```\n...\nremove_hf_pv(\"$var(hname)\");\n...\n```\n",
   "remove_hf_re": "### `remove_hf_re(re)`\n\nRemove from message all headers with name matching regular expression\n\u201cre\u201d\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *re* - regular expression to match the header name to be removed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(remove_hf_re(\"^P-\"))\n{\n    # All headers starting with \"P-\" removed\n}\n...\n```\n",
   "remove_hf_re_pv": "### `remove_hf_re_pv(re)`\n\nSame as remove_hf_re() function, but the parameter can contain\nvariables.\n\n```\n...\nif(remove_hf_re_pv(\"^$var(prefix)\"))\n{\n    # All headers starting with $var(prefix) value removed\n}\n...\n```\n",
   "remove_hf_exp": "### `remove_hf_exp(expmatch, expskip)`\n\nRemove from message all headers with name matching regular expression\n\u201cexpmatch\u201d, but not matching regular expression \u201cexpskip\u201d.\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *expmatch* - regular expression to match the header name to be\n  removed.\n\n- *expskip* - regular expression to match the header name to be skipped\n  from removal.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(remove_hf_exp(\"^P-\", \"^P-Keep-\"))\n{\n    # All headers starting with \"P-\" removed,\n    # except the ones starting with \"P-Keep-\"\n}\n...\n```\n",
   "remove_hf_exp_pv": "### `remove_hf_exp_pv(expmatch, expskip)`\n\nSame as remove_hf_exp() function, but the parameters can contain\nvariables.\n\n```\n...\nif(remove_hf_exp_pv(\"^$var(match)\", \"^$var(keep)\"))\n{\n    # All headers starting with $var(match) value removed,\n    # except the ones starting with $var(keep) value\n}\n...\n```\n",
   "remove_hf_idx": "### `remove_hf_idx(hname, idx)`\n\nRemove from message the headers matching by name 'hname' with the index\n'idx'.\n\nReturns true if the header is removed.\n\nMeaning of the parameters is as follows:\n\n- *hname* - header name.\n\n- *idx* - index of the header, starting from 0 with first header;\n  negative values count from the end of the headers, -1 being the last\n  header matching the name.\n\nThe parameters can be config variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nremove_hf_idx(\"X-My-Header\", \"-1\");\n...\n```\n",
   "remove_hf_match": "### `remove_hf_match(hname, op, expr)`\n\nRemove from message all headers with name 'hname' matching the body with\nexpression \u201cexpr\u201d, based on operator \u201cop\u201d.\n\nReturns true if at least one header is found and removed.\n\nMeaning of the parameters is as follows:\n\n- *hanem* - name of the header.\n\n- *op* - operator - it can be: 'eq' - equal; 'ne' - not equal; 'in' -\n  include; 're' - regular expression match.\n\n- *expr* - expression to match.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(remove_hf_match(\"X-Info\", \"in\", \"^data\")) {\n    # all headers with name \"X-Info\" that have the body matching regular\n    # expression \"^data\" are removed\n}\n...\n```\n",
   "has_body": "### `has_body()`, `has_body(mime)`\n\nThe function returns *true* if the SIP message has a body attached. The\ncheck includes also the \u201cContent-Length\u201d header presence and value.\n\nIf a parameter is given, the mime described will be also checked against\nthe \u201cContent-Type\u201d header.\n\nMeaning of the parameters is as follows:\n\n- *mime* - mime to be checked against the \u201cContent-Type\u201d header. If not\n  present or 0, this check will be disabled.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif(has_body(\"application/sdp\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "is_audio_on_hold": "### `is_audio_on_hold()`\n\nThe function returns *true* if the SIP message has a body attached and\nat least one audio stream in on hold. The return code of the function\nindicates the detected hold type:\n\n- *1* - RFC2543 hold type: null connection IP detected\n\n- *2* - RFC3264 hold type: inactive or sendonly attributes detected\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif(is_audio_on_hold())\n{\n    switch ($rc) {\n    case 1:\n        # RFC2543 hold type\n        # do interesting stuff here\n        break;\n    case 2:\n        # RFC3264 hold type\n        # do interesting stuff here\n        break;\n}\n...\n```\n",
   "is_privacy": "### `is_privacy(privacy_type)`\n\nThe function returns *true* if the SIP message has a Privacy header\nfield that includes the given privacy_type among its privacy values. See\n<http://www.iana.org/assignments/sip-priv-values> for possible privacy\ntype values.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif(is_privacy(\"id\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "in_list": "### `in_list(subject, list, separator)`\n\nFunction checks if subject string is found in list string where list\nitems are separated by separator string. Subject and list strings may\ncontain pseudo variables. Separator string needs to be one character\nlong. Returns 1 if subject is found and -1 otherwise.\n\nFunction can be used from all kinds of routes.\n\n```\n...\n$var(subject) = \"fi\";\n$var(list) = \"dk,fi,no,se\";\nif (in_list(\"$var(subject)\", \"$var(list)\", \",\")) {\n    xlog(\"L_INFO\", \"subject is found in list\\n\");\n}\n...\n            \n```\n",
   "in_list_prefix": "### `in_list_prefix(subject, list, separator)`\n\nFunction checks if any element in list string is a prefix for subject\nstring where list items are separated by separator string. Subject and\nlist strings may contain pseudo variables. Separator string needs to be\none character long. Returns 1 if subject is found and -1 otherwise.\n\nFunction can be used from all kinds of routes.\n\n```\n...\n$var(subject) = \"final\";\n$var(list) = \"dk,fi,no,se\";\nif (in_list_prefix(\"$var(subject)\", \"$var(list)\", \",\")) {\n    xlog(\"L_INFO\", \"prefix for subject is found in list\\n\");\n}\n...\n            \n```\n",
   "cmp_str": "### `cmp_str(str1, str2)`\n\nThe function returns *true* if the two parameters matches as string case\nsensitive comparison.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif(cmp_str(\"$rU\", \"kamailio\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "cmp_istr": "### `cmp_istr(str1, str2)`\n\nThe function returns *true* if the two parameters matches as string case\ninsensitive comparison.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif(cmp_istr(\"$rU@you\", \"kamailio@YOU\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "starts_with": "### `starts_with(str1, str2)`\n\nThe function returns *true* if the first string starts with the second\nstring.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif (starts_with(\"$rU\", \"+358\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "ends_with": "### `ends_with(str1, str2)`\n\nThe function returns *true* if the first string ends with the second\nstring. The parameters can contain variables.\n\nThis function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,\nFAILURE_ROUTE and BRANCH_ROUTE.\n\n```\n...\nif (ends_with(\"$rU\", \"8800\"))\n{\n    # do interesting stuff here\n}\n...\n```\n",
   "str_find": "### `str_find(str1, str2)`\n\nThe function returns *true* (greater than 0) if the str2 string is found\nin str1, case sensitive comparison.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (str_find(\"$rU\", \"8800\")) {\n    # do interesting stuff here\n}\n...\n```\n",
   "str_ifind": "### `str_ifind(str1, str2)`\n\nThe function returns *true* (greater than 0) if the str2 string is found\nin str1, case insensitive comparison.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (str_ifind(\"$rU\", \"Alice\")) {\n    # do interesting stuff here\n}\n...\n```\n",
   "str_any_in": "### `str_any_in(txt, clist)`\n\nReturn 1 (true) if any character in \"clist\" is found inside \"txt\". Both\nparamters can contain variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif (str_any_in(\"$hdr(X-Hdr)\", \";',:\")) {\n    # do interesting stuff here\n}\n...\n```\n",
   "set_body_multipart": "### `set_body_multipart([txt, content_type][, boundary])`\n\nSet multipart body to a SIP message. If called with no parameters, will\nconvert present body to multipart.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\n- *boundary* - string to use as boundary, can include pseudo-variables.\n  Default: unique-boundary-1\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n```\n...\nset_body_multipart(\"test\", \"text/plain\", \"delimiter\");\nmsg_apply_changes();\nappend_body_part(...);\nmsg_apply_changes();\n\n...\n\n# Will produce:\n\n...\nContent-Type: multipart/mixed;boundary=\"delimiter\"\nMime-Version: 1.0\n\n--delimiter\nContent-Type: text/plain\n\ntext\n\n--delimiter\n...\n```\n",
   "append_body_part": "### `append_body_part(txt, content_type[, content_disposition])`\n\nAppend a part on multipart body SIP message. Will use\n\"unique-boundary-1\" as boundary.\n\nMeaning of the parameters is as follows:\n\n- *txt* - text for the multipart body, can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\n- *content_disposition* - value of Content-Disposition header, can\n  include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n```\n...\n$var(b) = \"7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\";\nappend_body_part(\"$var(b)\", \"application/vnd.cirpack.isdn-ext\", \"signal;handling=required\");\nmsg_apply_changes();\n...\n\n# Will append this to the body:\n\n...\nContent-Type: application/vnd.cirpack.isdn-ext\nContent-Disposition: signal;handling=required\n\n7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\n\n--unique-boundary-1\n...\n```\n\nIf other headers should be added to a MIME body part, they can be\nappended after the value of the content-type parameter, separated by\n`\\r\\n` (at the very end do not add the '\\r\\n').\n\n```\n...\n$var(b) = \"7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\";\nappend_body_part(\"$var(b)\", \"application/vnd.cirpack.isdn-ext\\r\\nX-Header: xyz\", \"signal;handling=required\");\nmsg_apply_changes();\n...\n\n# Will append this to the body:\n\n...\nContent-Type: application/vnd.cirpack.isdn-ext\nX-Header: xyz\nContent-Disposition: signal;handling=required\n\n7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c\n\n--unique-boundary-1\n...\n```\n",
   "append_body_part_hex": "### `append_body_part_hex(txt, content_type[, content_disposition])`\n\nAppend a part on multipart body SIP message, with the content provided\nin hexa format. Will use \"unique-boundary-1\" as boundary.\n\nMeaning of the parameters is as follows:\n\n- *txt* - content for the multipart body in hexa format. Spaces can be\n  used between the pairs of hexa digits to make it easier to read in the\n  config, they are ignored and not added in the body part. The parameter\n  can include pseudo-variables.\n\n- *content_type* - value of Content-Type header, can include\n  pseudo-variables.\n\n- *content_disposition* - value of Content-Disposition header, can\n  include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n```\n...\n$var(b) = \"6b 61 6d 61 69 6c 69 6f\";\nappend_body_part_hex(\"$var(b)\", \"application/my-custom-ext\");\nmsg_apply_changes();\n...\n\n# Will append this to the body:\n\n...\nContent-Type: application/my-custom-ext\n\nkamailio\n\n--unique-boundary-1\n...\n```\n\nIf other headers should be added to a MIME body part, see the docs for\nappend_body_part(...) function.\n",
   "get_body_part": "### `get_body_part(content_type, opv)`\n\nReturn the content of a multipart body SIP message, storing it in opv.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - value of Content-Type header of the part to be\n  returned. If more than one exists the first occurrence will be\n  returned.\n\n- *opv* - variable name where to store the result.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nget_body_part(\"application/vnd.cirpack.isdn-ext\", \"$var(pbody)\");\n...\n```\n",
   "get_body_part_raw": "### `get_body_part_raw(content_type, opv)`\n\nReturn the content of a multipart body SIP message, including headers\nand boundary string, storing it in opv.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - value of Content-Type header of the part to be\n  returned. If more than one exists the first occurrence will be\n  returned.\n\n- *opv* - variable name where to store the result.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, ONREPLY_ROUTE.\n\n```\n...\nget_body_part(\"application/vnd.cirpack.isdn-ext\", \"$var(hbody)\");\n...\n```\n",
   "remove_body_part": "### `remove_body_part(content_type)`\n\nRemove a part on a multipart body SIP message.\n\nMeaning of the parameters is as follows:\n\n- *content_type* - value of Content-Type header of the part to be\n  removed. If more than one exists the first occurrence will be removed.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nThe core will take care of the last boundary ending with \"--\", detecting\nwhich one is the last and fixing the others if needed.\n\nNote: it may be required that msg_apply_changes() from textopsx module\nhas to be executed if there are other operations over the new body.\n\n```\n...\nremove_body_part(\"application/vnd.cirpack.isdn-ext\");\nmsg_apply_changes();\n...\n```\n",
   "regex_substring": "### `regex_substring(itext, regexp, mindex, mcount, dpv)`\n\nSearch in text with given regular expression then set dpv\npseudo-variable with the matched token at provided index.\n\nMeaning of the parameters is as follows:\n\n- *itext* - text to be searched (dynamic string)\n\n- *regexp* - regular expression (dynamic string)\n\n- *mindex* - index of the matched token (int or variable holding int)\n\n- *mcount* - the number of maximum expected matches (int or variable\n  holding int)\n\n- *dpv* - variable to be set with matched token (static string with a\n  name of a variable)\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\nNote that the regular expression extended is used. More info at:\n<https://www.regular-expressions.info/posix.html>.\n\n```\n    ...\n    regex_substring(\"___ abc123def ___ ghi456 ___\", \"([a-z]*)([0-9]+)([a-z]*)\",\n            1, 3, \"$var(asd)\");\n    xlog(\"L_WARN\",\"RESULT: $var(asd)\\r\\n\");\n    ------\n    result:\n    abc\n    ----\n    ...\n    \n```\n",
   "via_param_rm": "### `via_param_rm(name, idx)`\n\nRemove parameter matching by name from Via body at the specified index.\nThe index starts from 0 (first Via body). Negative index counts from the\nend of the list for Via header bodies (-1 is the last Via body).\n\nMeaning of the parameters is as follows:\n\n- *name* - name of the parameter\n\n- *idx* - index of the Via body.\n\nThe parameters can also be variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nvia_param_rm(\"p1\", \"0\");\n...\n```\n"
  }
 },
 "textopsx": {
  "overview": "This module implements functions for SIP message text operations in\nrouting block configurations. It adds new features similar to the\ntextops module (textops eXtentions).\n\nNote: If you add or remove message parts (header, body etc..) it may be\nrequired to execute msg_apply_changes() from this module if there are\nother operations done on the SIP message later on.\n",
  "parameters": {},
  "functions": {
   "msg_apply_changes": "### `msg_apply_changes()`\n\nUse this function to apply changes performed on SIP message content. Be\ncareful when using this function; due to special handling of changes to\nthe SIP message buffer so far, using this function might change the\nbehaviour of your config. Do test your config properly!\n\nThe function returns true (1) on success. If it is failure before the\nnew content is built, the function returns false (-1), the old content\nis still in place. If parsing of the new content is failing, the\nfunction stops executions of the config file (the internal structure is\nno longer valid for config processing, like it happens when a broken\nmessage is received from network).\n\nThis function can be used from REQUEST_ROUTE or core REPLY_ROUTE.\n\nNote: It must be used before the transaction is created in request_route\nand not inside the onreply_route[name] executed by tm module. Also, do\nnot use after resuming a suspended request or reply, at that moment the\ntransaction is already created.\n\n```\n...\nappend_hf(\"My-Header: yes\\r\\n\");\nif(msg_apply_changes())\n{\n    # msg buffer has a new content\n    if(is_present_hf(\"My-Header\"))\n    {\n        # will get here always\n    }\n}\n...\n```\n",
   "msg_set_buffer": "### `msg_set_buffer(data)`\n\nSet the content of the SIP message buffer, replacing the exiting data.\nThe parameter can contain variables, its value must be a valid SIP\nrequest or reply, a matter of what the old message is.\n\nThis function can be used from REQUEST_ROUTE or core REPLY_ROUTE.\n\nNote: It must be used before the transaction is created in request_route\nand not inside the onreply_route[name] executed by tm module. Also, do\nnot use after resuming a suspended request or reply, at that moment the\ntransaction is already created.\n\n```\n...\nmsg_set_buffer(\"INVITE sip:...\");\n...\n```\n",
   "change_reply_status": "### `change_reply_status(code, reason)`\n\nIntercept a SIP reply (in an onreply_route) and change its status code\nand reason phrase prior to forwarding it.\n\nMeaning of the parameters is as follows:\n\n- *code* - Status code.\n\n- *reason* - Reason phrase.\n\nThis function can be used from ONREPLY_ROUTE.\n\n```\n...\nreply_route {\n    if (status == \"603\") {\n        change_reply_status(404, \"Not Found\");\n        exit;\n    }\n}\n...\n        \n```\n",
   "change_reply_status_code": "### `change_reply_status_code(vcode)`\n\nChange the status code for a SIP reply .\n\nMeaning of the parameters is as follows:\n\n- *vcode* - the new status code.\n\nThis function can be used from ONREPLY_ROUTE.\n\n```\n...\nreply_route {\n    if (status == \"604\") {\n        change_reply_status_code(\"404\");\n        exit;\n    }\n}\n...\n        \n```\n",
   "remove_body": "### `remove_body()`\n\nUse this function to remove the body of SIP requests or replies.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nremove_body();\n...\n```\n",
   "keep_hf": "### `keep_hf([regexp])`\n\nRemove headers that don't match the regular expression regexp. Several\nheader are ignored always (thus not removed): Via, From, To, Call-ID,\nCSeq, Content-Length, Content-Type, Max-Forwards, Contact, Route,\nRecord-Route -- these can be removed one by one with remove_hf(). If\nregexp is missing, then only the headers listed above are kept, the rest\nare removed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nkeep_hf(\"User-Agent\");\n...\n```\n",
   "fnmatch": "### `fnmatch(value, expr [, flags])`\n\nMatch the value against the expr using shell-style pattern for file name\nmatching (see man page for C function fnmatch()). It is known to be\nfaster and use less-memory than regular expressions.\n\nParameter 'flags' is optional and can be 'i' to do case insensitive\nmatching.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nif(fnmatch(\"$rU\", \"123*\"))\n{\n    ...\n}\n...\n```\n",
   "append_hf_value": "### `append_hf_value(hf, hvalue)`\n\nAppend new header value after an existing header, if no index acquired\nappend at the end of list. Note that a header may consist of comma\ndelimited list of values.\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field to be appended. Format: HFNAME [ [IDX] ]. If\n  index is not specified new header is inserted at the end of message.\n  The index 1 corresponds to the first header.\n\n- *hvalue* - Value to be added, config var formatting supported.\n\n<!-- -->\n\n\n```\n...\nappend_hf_value(\"foo\", \"gogo;stamp=$Ts\")   # add new header\nappend_hf_value(\"foo[1]\", \"gogo\")  # add new value behind first value\nappend_hf_value(\"foo[-1]\", \"$var(Bar)\") # try add value to the last header, if not exists add new header\n...\n        \n```\n",
   "insert_hf_value": "### `insert_hf_value(hf, hvalue)`\n\nInsert new header value before an existing header, if no index acquired\ninsert before first hf header. Note that a header may consist of comma\ndelimited list of values. To insert a value behind the last value use\n`append_hf_value`.\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field to be appended. Format: HFNAME [ [IDX] ]. If\n  index is not specified new header is inserted at the top of message.\n  The index 1 corresponds to the first header.\n\n- *hvalue* - Value to be added, config var formatting supported.\n\n<!-- -->\n\n\n```\n...\ninsert_hf_value(\"foo[2]\", \"gogo\")\ninsert_hf_value(\"foo\", \"$avp(foo)\")   # add new header at the top of list\ninsert_hf_value(\"foo[1]\", \"gogo\") # try add to the first header\n...\n        \n```\n",
   "remove_hf_value": "### `remove_hf_value(hf_par)`\n\nRemove the header value from existing header, Note that a header may\nconsist of comma delimited list of values.\n\nMeaning of the parameters is as follows:\n\n- *hf_par* - Header field/param to be removed. Format: HFNAME [ [IDX]\n  ] [. PARAM ] If asterisk is specified as index then all values are\n  affected. The index 1 corresponds to the first header.\n\n<!-- -->\n\n\n```\n...\nremove_hf_value(\"foo\")  # remove foo[1]\nremove_hf_value(\"foo[*]\")  # remove all foo's headers\nremove_hf_value(\"foo[-1]\") # last foo\nremove_hf_value(\"foo.bar\")  # delete parameter\nremove_hf_value(\"foo[*].bar\") # for each foo delete bar parameters\n...\n        \n```\n",
   "remove_hf_value2": "### `remove_hf_value2(hf_par)`\n\nRemove specified header or parameter. It is expected header in\nAuthorization format (comma delimiters are not treated as multi-value\ndelimiters).\n\nMeaning of the parameters is as follows:\n\n- *hf_par* - Header/param to be removed. Format: HFNAME [ [IDX] ]\n  [. PARAM ] If asterisk is specified as index then all values are\n  affected. The index 1 corresponds to the first header.\n\n<!-- -->\n\n\n```\n...\nremove_hf_value2(\"foo\")  # remove foo[1]\nremove_hf_value2(\"foo[*]\")  # remove all foo's headers, the same as remove_hf_header(\"foo[*]\");\nremove_hf_value2(\"foo[-1]\") # last foo\nremove_hf_value2(\"foo.bar\")  # delete parameter\nremove_hf_value2(\"foo[*].bar\") # for each foo delete bar parameters\n...\n        \n```\n",
   "assign_hf_value": "### `assign_hf_value(hf, hvalue)`\n\nAssign value to specified header value / param.\n\nMeaning of the parameters is as follows:\n\n- *hf_para* - Header field value / param to be appended. Format: HFNAME\n  [ [IDX] ] [. PARAM] If asterisk is specified as index then all\n  values are affected. The index 1 corresponds to the first header.\n\n- *hvalue* - Value to be assigned, config var formatting supported. If\n  value is empty then no equal sign appears in param.\n\n<!-- -->\n\n\n```\n...\nassign_hf_value(\"foo\", \"gogo\")  # foo[1]\nassign_hf_value(\"foo[-1]\", \"gogo\")  # foo[last_foo]\n\nassign_hf_value(\"foo.bar\", \"\")\nassign_hf_value(\"foo[3].bar\", \"\")\nassign_hf_value(\"foo[*]\", \"\")  # remove all foo's, empty value remains\nassign_hf_value(\"foo[*].bar\", \"\")  # set empty value (ex. lr)\n...\n        \n```\n",
   "assign_hf_value2": "### `assign_hf_value2(hf, hvalue)`\n\nAssign value to specified header. It is expected header in Authorization\nformat (comma delimiters are not treated as multi-value delimiters).\n\nMeaning of the parameters is as follows:\n\n- *hf_para* - Header field value / param to be appended. Format: HFNAME\n  [ [IDX] ] [. PARAM] If asterisk is specified as index then all\n  values are affected. The index 1 corresponds to the first header.\n\n- *hvalue* - Value to be assigned, config var formatting supported. If\n  value is empty then no equal sign appears in param.\n\n<!-- -->\n\n\n```\n...\nassign_hf_value2(\"Authorization.integrity-protected\", \"\\\"yes\\\"\")\nassign_hf_value2(\"foo[-1]\", \"gogo\")  # foo[last_foo]\nassign_hf_value2(\"foo[*].bar\", \"\")  # set empty value (ex. lr)\n...\n        \n```\n",
   "include_hf_value": "### `include_hf_value(hf, hvalue)`\n\nAdd value in set if not exists, eg. \"Supported: path,100rel\".\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field name to be affected.\n\n- *hvalue* - config var formatting supported.\n\n<!-- -->\n\n\n```\n...\ninclude_hf_value(\"Supported\", \"path\");\n...\n        \n```\n",
   "exclude_hf_value": "### `exclude_hf_value(hf, hvalue)`\n\nRemove value from set if exists, eg. \"Supported: path,100rel\".\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field name to be affected.\n\n- *hvalue* - config formatting supported.\n\n<!-- -->\n\n\n```\n...\nexclude_hf_value(\"Supported\", \"100rel\");\n...\n        \n```\n",
   "hf_value_exists": "### `hf_value_exists(hf, hvalue)`\n\nCheck if value exists in set. Alternate select\n*@hf_value_exists.HF.VALUE* may be used. It returns one or zero.\n\nMeaning of the parameters is as follows:\n\n- *hf* - Header field name to be affected. Underscores are treated as\n  dashes.\n\n- *hvalue* - config var formatting supported.\n\n<!-- -->\n\n\n```\n...\nif (hf_value_exists(\"Supported\", \"100rel\")) {\n\n}\n\nif (@hf_value_exists.supported.path == \"1\") {\n\n}\n...\n        \n```\n",
   "hf_iterator_start": "### `hf_iterator_start(iname)`\n\nStart an iterator for headers in the current SIP message. The parameter\niname is used to identify the iterator. There can be up to 4 iterators\nat the same time, with different name.\n\nThe parameter can be a dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nhf_iterator_start(\"i1\");\n...\n```\n",
   "hf_iterator_end": "### `hf_iterator_end(iname)`\n\nClose the iterator identified by iname parameter. The iname value must\nbe the same used for hf_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nhf_iterator_end(\"i1\");\n...\n```\n",
   "hf_iterator_next": "### `hf_iterator_next(iname)`\n\nMove the iterator to the next header. It must be called also after\nhf_iterator_start() to get the first header.\n\nThe return code is false when there is no other header in the list.\n\nThe item name and value are accessible via variables: $hfitname(iname)\nand $hfitbody(iname).\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        xlog(\"hdr[$hfitname(i1)] is: $hfitbody(i1)\\n\");\n    }\n    hf_iterator_end(\"i1\");\n...\n```\n",
   "hf_iterator_prev": "### `hf_iterator_prev(iname)`\n\nMove the iterator to the previous header. It must be called also after\nhf_iterator_start() and hf_iterator_next().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    hf_iterator_start(\"i1\");\n    hf_iterator_next(\"i1\");\n...\n    hf_iterator_next(\"i1\");\n...\n    hf_iterator_prev(\"i1\");\n...\n    hf_iterator_end(\"i1\");\n...\n```\n",
   "hf_iterator_rm": "### `hf_iterator_rm(iname)`\n\nRemove the header at the current iterator position.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        if($hfitname(i1)==\"My-Header\") {\n            hf_iterator_rm(\"i1\");\n        }\n    }\n    hf_iterator_end(\"i1\");\n...\n```\n",
   "hf_iterator_append": "### `hf_iterator_append(iname, htext)`\n\nAdd headers after the one at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        if($hfitname(i1)==\"My-Header\") {\n            hf_iterator_append(\"i1\", \"My-New-Header: abc\\r\\n\");\n            break;\n        }\n    }\n    hf_iterator_end(\"i1\");\n...\n```\n",
   "hf_iterator_insert": "### `hf_iterator_insert(iname, htext)`\n\nAdd headers before the one at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        if($hfitname(i1)==\"My-Header\") {\n            hf_iterator_insert(\"i1\", \"My-New-Header: abc\\r\\n\");\n            break;\n        }\n    }\n    hf_iterator_end(\"i1\");\n...\n```\n",
   "bl_iterator_start": "### `bl_iterator_start(iname)`\n\nStart an iterator for lines in the body of the current SIP message. The\nparameter iname is used to identify the iterator. There can be up to 4\niterators at the same time, with different name.\n\nThe parameter can be a dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nbl_iterator_start(\"b1\");\n...\n```\n",
   "bl_iterator_end": "### `bl_iterator_end(iname)`\n\nClose the iterator identified by iname parameter. The iname value must\nbe the same used for bl_iterator_start().\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nbl_iterator_end(\"b1\");\n...\n```\n",
   "bl_iterator_next": "### `bl_iterator_next(iname)`\n\nMove the iterator to the next line in the body. It must be called also\nafter bl_iterator_start() to get the first header.\n\nThe return code is false when there is no other header in the list.\n\nThe body line accessible via variable $blitval(iname) - it contains\nalso the EOL chars.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    bl_iterator_start(\"b1\");\n    while(bl_iterator_next(\"b1\")) {\n        xlog(\"body line: $blitval(b1)\");\n    }\n    bl_iterator_end(\"b1\");\n...\n```\n",
   "bl_iterator_rm": "### `bl_iterator_rm(iname)`\n\nRemove the body line at the current iterator position.\n\nThe parameter can be dynamic string with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    bl_iterator_start(\"b1\");\n    while(bl_iterator_next(\"b1\")) {\n        if($blitval(b1)=~\"abc\") {\n            bl_iterator_rm(\"b1\");\n        }\n    }\n    bl_iterator_end(\"b1\");\n...\n```\n",
   "bl_iterator_append": "### `bl_iterator_append(iname, text)`\n\nAdd text after the line at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    bl_iterator_start(\"b1\");\n    while(bl_iterator_next(\"b1\")) {\n        if($blitval(b1)=~\"^a=info:xyz\") {\n            bl_iterator_append(\"b1\", \"a=info:abc\\r\\n\");\n            break;\n        }\n    }\n    bl_iterator_end(\"b1\");\n...\n```\n",
   "bl_iterator_insert": "### `bl_iterator_insert(iname, text)`\n\nAdd text before the line at the current iterator possition.\n\nThe parameters can be dynamic strings with variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n    bl_iterator_start(\"b1\");\n    while(bl_iterator_next(\"b1\")) {\n        if($blitval(b1)=~\"^a=info:xyz\") {\n            bl_iterator_insert(\"b1\", \"a=info:abc\\r\\n\");\n            break;\n        }\n    }\n    bl_iterator_end(\"b1\");\n...\n```\n"
  }
 },
 "timer": {
  "overview": "The module supports triggering a specific route block on a specific\ntimer. The timer can be activated and de-activated from the routing\nscript at runtime.\n",
  "parameters": {
   "declare_timer": "### `declare_timer` (string)\n\nDeclares timer route which will be called in specific interval.\n\nThe format is:\n\n```\n            declare_timer = declare_timer_syntax\n            \n```\n\n- timer_id\n  is timer identifier.\n- route\n  is handler to be called when timer is triggered. It has to be a route\n  block name when native scripting is used, or Kemi function name. The\n  Kemi function name receives one string parameter (for now it has a\n  static value, respectively the module name).\n- interval\n  is timer interval in milliseconds,\n- slow_fast\n  determines if handler will be hooked in slow or fast timer queue, fast\n  timer handler returns as quickly as possible, slow timer handler may\n  spend longer time, see kamailio/doc/timers.txt documentation.\n- enable\n  - enable timer when Kamailio is starting, otherwise use\n  timer_enable\n  to start it later.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"timer\", \"declare_timer\", \"MY_TIMER=MY_TIMER_ROUTE,10,slow,enable\");\n...\n                \n```\n"
  },
  "functions": {
   "timer_enable": "### `timer_enable(timer_id, enable_disable)`\n\nEnable/disable timer route specified by `timer_id`. Because of timer\ncore API the callback is not disabled immediately but is removed from\nhandler by itself not to decrease performance. Disabling and enabling in\nsequence may be tricky.\n\n- timer_id\n  references to timer declared by\n  declare_timer\n  .\n- enable_disable\n  - set to 1 to enable timer, to 0 to disable.\n\n<!-- -->\n\n\n```\n...\ntimer_enable(\"MY_TIMER\", 1);\n...\n                \n```\n"
  }
 },
 "tls": {
  "overview": "This module implements the TLS transport for Kamailio using the [OpenSSL\nlibrary](http://www.openssl.org) (http://www.openssl.org). To enable the\nKamailio TLS support this module must be loaded and *enable_tls=yes*\ncore setting must be added to the Kamailio config file.\n\nIMPORTANT: the tls module must be loaded before any other Kamailio\nmodule that uses libssl (OpenSSL library). A safe option is to have the\ntls module loaded first (be in the first \"loadmodule\" in Kamailio.cfg).\n\nIMPORTANT: using this module compiled with newer versions of libssl\n(e.g., v1.1+) may require Kamailio to be started with *--atexit=no*\ncommand line parameters to avoid calling C atexit callbacks inside the\nprocess ending during daemonize procedure as well as during shut down,\nwhich can lead to crashes because it destroys and then accesses shared\nmemory. For example, such case has been reported for Ubuntu 20.04 or\nRedHat 8.\n\nNote: with some particular combination of OS, openssl and mysql-client\nlibraries, there were reports of random crashes, in such case try to set\nthe db_mysql module parameter opt_ssl_mode to 1.\n",
  "parameters": {
   "tls_method": "### `tls_method` (string)\n\nSets the TLS protocol method. Possible values are:\n\n- *TLSv1.3+* - TLSv1.3 or newer (TLSv1.3, ...) connections are accepted\n  (available starting with openssl/libssl v1.1.1)\n\n- *TLSv1.3* - only TLSv1.3 connections are accepted (available starting\n  with openssl/libssl v1.1.1)\n\n- *TLSv1.2+* - TLSv1.2 or newer (TLSv1.3, ...) connections are accepted\n  (available starting with openssl/libssl v1.1.1)\n\n- *TLSv1.2* - only TLSv1.2 connections are accepted (available starting\n  with openssl/libssl v1.0.1e)\n\n- *TLSv1.1+* - TLSv1.1 or newer (TLSv1.2, ...) connections are accepted\n  (available starting with openssl/libssl v1.0.1)\n\n- *TLSv1.1* - only TLSv1.1 connections are accepted (available starting\n  with openssl/libssl v1.0.1)\n\n- *TLSv1+* - TLSv1.0 or newer (TLSv1.1, TLSv1.2, ...) connections are\n  accepted.\n\n- *TLSv1* - only TLSv1 (TLSv1.0) connections are accepted. This is the\n  default value.\n\n- *SSLv3* - only SSLv3 connections are accepted. Note: you shouldn't use\n  SSLv3 for anything which should be secure.\n\n- *SSLv2* - only SSLv2 connections, for old clients. Note: you shouldn't\n  use SSLv2 for anything which should be secure. Newer versions of\n  OpenSSL libraries don't include support for it anymore.\n\n- *SSLv23* - any of the SSLv2, SSLv3 and TLSv1 or newer methods will be\n  accepted.\n\n  From the OpenSSL manual: \"A TLS/SSL connection established with these\n  methods may understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2\n  protocols. If extensions are required (for example server name) a\n  client will send out TLSv1 client hello messages including extensions\n  and will indicate that it also understands TLSv1.1, TLSv1.2 and\n  permits a fallback to SSLv3. A server will support SSLv3, TLSv1,\n  TLSv1.1 and TLSv1.2 protocols. This is the best choice when\n  compatibility is a concern.\"\n\n  Note: For older OpenSSL library versions, this option allows SSLv2,\n  with hello messages done over SSLv2. You shouldn't use SSLv2 or SSLv3\n  for anything which should be secure.\n\nIf RFC 3261 conformance is desired, at least TLSv1 must be used. For\ncompatibility with older clients SSLv23 is the option, but again, be\naware of security concerns, SSLv2/3 as well as TLS v1.0 and v1.1 are\nbeing considered very insecure and are therefore deprecated since March\n2021 (RFC 8996). For current information about what's considered secure,\nplease consult, IETF BCP 195, currently RFC 9325 - \"Recommendations for\nSecure Use of Transport Layer Security (TLS) and Datagram Transport\nLayer Security (DTLS)\"\n\n```\n...\nmodparam(\"tls\", \"tls_method\", \"TLSv1\")\n...\n        \n```\n",
   "certificate": "### `certificate` (string)\n\nSets the certificate file name. The certificate file can also contain\nthe private key in PEM format.\n\nIf the file name starts with a '.' the path will be relative to the\nworking directory (*at runtime*). If it starts with a '/' it will be an\nabsolute path and if it starts with anything else the path will be\nrelative to the main config file directory (e.g.: for kamailio -f\n/etc/kamailio/kamailio.cfg it will be relative to /etc/kamailio/).\n\nThe default value is /usr/local/etc/kamailio/cert.pem\n\n```\n...\nmodparam(\"tls\", \"certificate\", \"/usr/local/etc/kamailio/my_certificate.pem\")\n...\n        \n```\n",
   "private_key": "### `private_key` (string)\n\nSets the private key file name. The private key can be in the same file\nas the certificate or in a separate file, specified by this\nconfiguration parameter.\n\nIf the file name starts with a '.' the path will be relative to the\nworking directory (*at runtime*). If it starts with a '/' it will be an\nabsolute path and if it starts with anything else the path will be\nrelative to the main config file directory (e.g.: for kamailio -f\n/etc/kamailio/kamailio.cfg it will be relative to /etc/kamailio/).\n\nNote: the private key can be contained in the same file as the\ncertificate (just append it to the certificate file, e.g.: cat pkey.pem\n>> cert.pem)\n\nThe default value is /usr/local/etc/kamailio/cert.pem\n\n```\n...\nmodparam(\"tls\", \"private_key\", \"/usr/local/etc/kamailio/my_pkey.pem\")\n...\n        \n```\n",
   "ca_list": "### `ca_list` (string)\n\nSets the CA list file name. This file contains a list of all the trusted\nCAs certificates used when connecting to other SIP implementations. If a\nsignature in a certificate chain belongs to one of the listed CAs, the\nverification of that certificate will succeed.\n\nIf the file name starts with a '.' the path will be relative to the\nworking directory (*at runtime*). If it starts with a '/' it will be an\nabsolute path and if it starts with anything else the path will be\nrelative to the main config file directory (e.g.: for kamailio -f\n/etc/kamailio/kamailio.cfg it will be relative to /etc/kamailio/).\n\nBy default the CA file is not set.\n\nAn easy way to create the CA list is to append each trusted trusted CA\ncertificate in the PEM format to one file, e.g.:\n\n```\nfor f in trusted_cas/*.pem ; do cat \"$f\" >> ca_list.pem ; done\n        \n```\n\nSee also *verify_certificate*, *verify_depth*, *require_certificate* and\n*crl*.\n\n```\n...\nmodparam(\"tls\", \"ca_list\", \"/usr/local/etc/kamailio/ca_list.pem\")\n...\n        \n```\n",
   "ca_path": "### `ca_path` (str)\n\nSets the path with the trusted CA files, to be given as parameter\nSSL_CTX_load_verify_locations(). The certificates in ca_path are only\nlooked up when required, e.g. when building the certificate chain or\nwhen actually performing the verification of a peer certificate. They\nare not given to the client (not loaded to be provided to\nSSL_CTX_set_client_CA_list()), only the ones in ca_list files are sent\nto the client. It requires to use c_rehash to generate the hash map for\ncertificate search, for more see the manual of libssl for\nSSL_CTX_load_verify_locations() function.\n\nBy default it is not set.\n\n```\n...\nmodparam(\"tls\", \"ca_path\", \"/usr/local/etc/kamailio/ca\")\n...\n        \n```\n",
   "crl": "### `crl` (string)\n\nSets the certificate revocation list (CRL) file name. This file contains\na list of revoked certificates. Any attempt to verify a revoked\ncertificate will fail.\n\nIf not set, no CRL list will be used.\n\nIf the file name starts with a '.' the path will be relative to the\nworking directory (*at runtime*). If it starts with a '/' it will be an\nabsolute path and if it starts with anything else the path will be\nrelative to the main config file directory (e.g.: for kamailio -f\n/etc/kamailio/kamailio.cfg it will be relative to /etc/kamailio/).\n\n<div class=\"note\">\n\n\nIf set, `require_certificate` should also be set or it will not have any\neffect.\n\n</div>\n\n\nBy default the CRL file name is not set.\n\nTo update the CRL in a running Kamailio, make sure you configure TLS via\na separate TLS config file (the `config` modparam) and issue a\ntls.reload RPC call, e.g.:\n\n```\n $ kamcmd tls.reload\n        \n```\n\nA quick way to create the CRL in PEM format, using OpenSSL is:\n\n```\n $ openssl ca -gencrl -keyfile cacert.key -cert cacert.pem -out my_crl.pem\n        \n```\n\nmy_crl.pem will contain the signed list of the revoked certificates.\n\nTo revoke a TLS certificate use something like:\n\n```\n $ openssl ca -revoke bad_cert.pem -keyfile cacert.key -cert cacert.pem\n        \n```\n\nand then refresh the crl file using the command above.\n\nTo display the CRL contents use:\n\n```\n $ openssl crl -in crl.pem -noout -text\n        \n```\n\nSee also *ca_list*, *verify_certificate*, *verify_depth* and\n*require_certificate*.\n\n```\n...\nmodparam(\"tls\", \"crl\", \"/usr/local/etc/kamailio/crl.pem\")\n...\n        \n```\n",
   "verify_certificate": "### `verify_certificate` (boolean)\n\nIf enabled it will force certificate verification when connecting to\nother SIP servers.. For more information see the\n[verify(1)](https://www.openssl.org/docs/manmaster/man1/verify.html)\nOpenSSL man page.\n\nNote: the certificate verification will always fail if the ca_list is\nempty.\n\nSee also: `ca_list`, `require_certificate`, `verify_depth`.\n\nBy default the certificate verification is off.\n\n```\n...\nmodparam(\"tls\", \"verify_certificate\", 1)\n...\n        \n```\n",
   "verify_depth": "### `verify_depth` (integer)\n\nSets how far up the certificate chain will the certificate verification\ngo in the search for a trusted CA.\n\nSee also: `ca_list`, `require_certificate`, `verify_certificate`,\n\nThe default value is 9.\n\n```\n...\nmodparam(\"tls\", \"verify_depth\", 9)\n...\n        \n```\n",
   "require_certificate": "### `require_certificate` (boolean)\n\nWhen enabled Kamailio will require a certificate from a client\nconnecting to the TLS port. If the client does not offer a certificate\nand `verify_certificate` is on, certificate verification will fail.\n\nThe default value is off.\n\n```\n...\nmodparam(\"tls\", \"require_certificate\", 1)\n...\n        \n```\n",
   "cipher_list": "### `cipher_list` (string)\n\nSets the list of accepted ciphers. The list consists of cipher strings\nseparated by colons. For more information on the cipher list format see\nthe\n[cipher(1)](https://www.openssl.org/docs/manmaster/man1/ciphers.html)\nOpenSSL man page.\n\nThe default value is not set (all the OpenSSL supported ciphers are\nenabled).\n\n```\n...\nmodparam(\"tls\", \"cipher_list\", \"HIGH\")\n...\n        \n```\n",
   "server_name": "### `server_name` (string)\n\nSets the Server Name Indication (SNI) value.\n\nThis is a TLS extension enabling one TLS server to serve multiple host\nnames with unique certificates.\n\nThe default value is empty (not set).\n\n```\n...\nmodparam(\"tls\", \"server_name\", \"kamailio.org\")\n...\n        \n```\n",
   "connection_timeout": "### `connection_timeout` (int)\n\nSets the amount of time after which an idle TLS connection will be\nclosed, if no I/O ever occurred after the initial open. If an I/O event\noccurs, the timeout will be extended with tcp_connection_lifetime. The\nvalue is expressed in seconds.\n\nThe default value is 10 min.\n\nIf the value set is -1, the connection will never be close on idle.\n\nThis setting can be changed also at runtime, via the RPC interface and\nconfig framework. The config variable name is *tls.connection_timeout*.\n\n```\n...\nmodparam(\"tls\", \"connection_timeout\", 60)\n...\n        \n\n $ kamcmd cfg.set_now_int tls connection_timeout 180\n        \n```\n",
   "tls_disable_compression": "### `tls_disable_compression` (boolean)\n\nIf set compression over TLS will be disabled. Note that compression uses\na lot of memory (about 10x more than with the compression disabled), so\nif you want to minimize memory usage is a good idea to disable it. TLS\ncompression also expose you for the\n[CRIME](<https://en.wikipedia.org/wiki/CRIME_(security_exploit>)) security\nvulnerability.\n\nBy default TLS compression is disabled.\n\n```\n...\nmodparam(\"tls\", \"tls_disable_compression\", 0) # enable\n...\n        \n```\n",
   "ssl_release_buffers": "### `ssl_release_buffers` (integer)\n\nRelease internal OpenSSL read or write buffers as soon as they are no\nlonger needed. Combined with `ssl_freelist_max_len` has the potential of\nsaving a lot of memory ( ~ 32k per connection in the default\nconfiguration, or 16k + `ssl_max_send_fragment`). For Kamailio versions\n> 3.0 it makes little sense to disable it (0) since the tls module\nalready has its own internal buffering.\n\nA value of -1 would not change this option from its openssl default. Use\n0 or 1 for enable/disable.\n\nBy default the value is 1 (enabled).\n\n<div class=\"note\">\n\n\nThis option is supported only for OpenSSL versions >= *1.0.0*. On all\nthe other versions attempting to change the default will trigger an\nerror.\n\n</div>\n\n\n```\nmodparam(\"tls\", \"ssl_release_buffers\", 1)\n        \n```\n",
   "ssl_freelist_max_len": "### `ssl_freelist_max_len` (integer)\n\nSets the maximum number of free memory chunks, that OpenSSL will keep\nper connection. Setting it to 0 would cause any unused memory chunk to\nbe immediately freed, reducing the memory footprint. A too large value\nwould result in extra memory consumption.\n\nShould be combined with `ssl_release_buffers`.\n\nA value of -1 has a special meaning: the OpenSSL default will be used\n(no attempt on changing the value will be made). For OpenSSL 1.0 the\ninternal default is 32.\n\nBy default the value is 0 (no freelist).\n\n<div class=\"note\">\n\n\nThis option is supported only for OpenSSL versions >= *1.0.0*. On all\nthe other versions attempting to change the default will trigger an\nerror.\n\n</div>\n\n\n```\nmodparam(\"tls\", \"ssl_freelist_max_len\", 0)\n        \n```\n",
   "ssl_max_send_fragment": "### `ssl_max_send_fragment` (integer)\n\nSets the maximum number of bytes (from the clear text) sent into one TLS\nrecord. Valid values are between 512 and 16384. Note however that even\nvalid low values might not be big enough to allow a successful handshake\n(try minimum 1024).\n\nLower values would lead to less memory usage, but values lower than the\ntypical Kamailio write size would incur a slight performance penalty.\nGood values are bigger than the size of the biggest SIP packet one\nnormally expects to forward. For example in most setups 2048 would be a\ngood value.\n\n<div class=\"note\">\n\n\nValues on the lower side, even if valid (> 512), might not allow for a\nsuccessful initial handshake. This happens if the certificate does not\nfit inside one send fragment. Values lower than 1024 should not be used.\nEven with higher values, if the handshake fails, try increasing the\nvalue.\n\n</div>\n\n\nA value of -1 has a special meaning: the OpenSSL default will be used\n(no attempt on changing the value will be made).\n\nBy default the value is -1 (the OpenSSL default, which at least in\nOpenSSL 1.0.0 is ~ 16k).\n\n<div class=\"note\">\n\n\nThis option is supported only for OpenSSL versions >= *0.9.9*. On all\nthe other versions attempting to change the default will trigger an\nerror.\n\n</div>\n\n\n```\nmodparam(\"tls\", \"ssl_max_send_fragment\", 4096)\n        \n```\n",
   "ssl_read_ahead": "### `ssl_read_ahead` (boolean)\n\nEnables read ahead, reducing the number of internal OpenSSL BIO read()\ncalls. This option has only debugging value, in normal circumstances it\nshould not be changed from the default.\n\nWhen disabled OpenSSL will make at least 2 BIO read() calls per received\nrecord: one to get the record header and one to get the rest of the\nrecord.\n\nThe TLS module buffers internally all read()s and defines its own fast\nBIO so enabling this option would only cause more memory consumption and\na minor slow-down (extra memcpy).\n\nA value of -1 has a special meaning: the OpenSSL default will be used\n(no attempt on changing the value will be made).\n\nBy default the value is 0 (disabled).\n\n```\nmodparam(\"tls\", \"ssl_read_ahead\", 1)\n        \n```\n",
   "send_close_notify": "### `send_close_notify` (boolean)\n\nEnables/disables sending close notify alerts prior to closing the\ncorresponding TCP connection. Sending the close notify prior to TCP\nshutdown is \"nicer\" from a TLS point of view, but it has a measurable\nperformance impact. Default: off. Can be set at runtime\n(tls.send_close_notify).\n\nThe default value is 0 (off).\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is tls.send_close_notify.\n\n```\n...\nmodparam(\"tls\", \"send_close_notify\", 1)\n...\n        \n\n $ kamcmd cfg.set_now_int tls send_close_notify 1\n        \n```\n",
   "con_ct_wq_max": "### `con_ct_wq_max` (integer)\n\nSets the maximum allowed per connection clear-text send queue size in\nbytes. This queue is used when data cannot be encrypted and sent\nimmediately because of an ongoing TLS level renegotiation.\n\nThe default value is 65536 (64 Kb).\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is tls.con_ct_wq_max.\n\n```\n...\nmodparam(\"tls\", \"con_ct_wq_max\", 1048576)\n...\n        \n\n $ kamcmd cfg.set_now_int tls con_ct_wq_max 1048576\n        \n```\n",
   "ct_wq_max": "### `ct_wq_max` (integer)\n\nSets the maximum total number of bytes queued in all the clear-text send\nqueues. These queues are used when data cannot be encrypted and sent\nimmediately because of an ongoing TLS level renegotiation.\n\nThe default value is 10485760 (10 Mb).\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is `tls.ct_wq_max`.\n\n```\n...\nmodparam(\"tls\", \"ct_wq_max\", 4194304)\n...\n        \n\n $ kamcmd cfg.set_now_int tls ct_wq_max 4194304\n        \n```\n",
   "ct_wq_blk_size": "### `ct_wq_blk_size` (integer)\n\nMinimum block size for the internal clear-text send queues (debugging /\nadvanced tuning). Good values are multiple of typical datagram sizes.\n\nThe default value is 4096.\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is `tls.ct_wq_blk_size`.\n\n```\n...\nmodparam(\"tls\", \"ct_wq_blk_size\", 2048)\n...\n        \n\n $ kamcmd cfg.set_now_int tls ct_wq_blk_size 2048\n        \n```\n",
   "tls_log": "### `tls_log` (int)\n\nSets the log level at which TLS related messages will be logged.\n\nThe default value is 3 (L_DBG).\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is `tls.log`.\n\n```\n...\n# ignore TLS messages if Kamailio is started with debug less than 10\nmodparam(\"tls\", \"tls_log\", 10)\n...\n        \n\n $ kamcmd cfg.set_now_int tls log 10\n        \n```\n",
   "tls_debug": "### `tls_debug` (int)\n\nSets the log level at which TLS debug messages will be logged. Note that\nTLS debug messages are enabled only if the TLS module is compiled with\ndebugging enabled (e.g. -DTLS_WR_DEBUG, -DTLS_RD_DEBUG or\n-DTLS_BIO_DEBUG).\n\nThe default value is 3 (L_DBG).\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is `tls.debug`.\n\n```\n...\n# ignore TLS debug messages if Kamailio is started with debug less than 10\nmodparam(\"tls\", \"tls_debug\", 10)\n...\n        \n\n $ kamcmd cfg.set_now_int tls debug 10\n        \n```\n",
   "low_mem_threshold1": "### `low_mem_threshold1` (integer)\n\nSets the minimal free memory from which attempts to open or accept new\nTLS connections will start to fail. The value is expressed in KB.\n\nThe default value depends on whether the OpenSSL library used handles\nlow memory situations in a good way (openssl bug #1491). As of this\nwriting this is not true for any OpenSSL version (including 0.9.8e).\n\nIf an ill-behaved OpenSSL version is detected, a very conservative value\nis chosen, which depends on the maximum possible number of\nsimultaneously created TLS connections (and hence on the process\nnumber).\n\nThe following values have a special meaning:\n\n- -1 - use the default value\n\n- 0 - disable (TLS connections will not fail preemptively)\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is `tls.low_mem_threshold1`.\n\nSee also `tls.low_mem_threshold2`.\n\n```\n...\nmodparam(\"tls\", \"low_mem_threshold1\", -1)\n...\n    \n\n $ kamcmd cfg.set_now_int tls low_mem_threshold1 2048\n        \n```\n",
   "low_mem_threshold2": "### `low_mem_threshold2` (integer)\n\nSets the minimal free memory from which TLS operations on already\nestablished TLS connections will start to fail preemptively. The value\nis expressed in KB.\n\nThe default value depends on whether the OpenSSL library used handles\nlow memory situations (openssl bug #1491). As of this writing this is\nnot true for any OpenSSL version (including 0.9.8e).\n\nIf an ill-behaved OpenSSL version is detected, a very conservative value\nis chosen, which depends on the maximum possible number of\nsimultaneously created TLS connections (and hence on the process\nnumber).\n\nThe following values have a special meaning:\n\n- -1 - use the default value\n\n- 0 - disable (TLS operations will not fail preemptively)\n\nIt can be changed also at runtime, via the RPC interface and config\nframework. The config variable name is `tls.low_mem_threshold2`.\n\nSee also `tls.low_mem_threshold1`.\n\n```\n...\nmodparam(\"tls\", \"low_mem_threshold2\", -1)\n...\n    \n\n $ kamcmd cfg.set_now_int tls low_mem_threshold2 1024\n        \n```\n",
   "tls_force_run": "### `tls_force_run` (boolean)\n\nIf enabled Kamailio will start even if some of the OpenSSL sanity checks\nfail (turn it on at your own risk).\n\nIf any of the following sanity checks fail, Kamailio will not start:\n\n- the version of the library the TLS module was compiled with is \"too\n  different\" from the library used at runtime. The versions should have\n  the same major, minor and fix level (e.g.: 0.9.8a and 0.9.8c are ok,\n  but 0.9.8 and 0.9.9 are not)\n\n- the OpenSSL library used at compile time and the one used at runtime\n  have different Kerberos options\n\nBy default tls_force_run is disabled.\n\n```\n...\nmodparam(\"tls\", \"tls_force_run\", 11)\n...\n    \n```\n",
   "session_cache": "### `session_cache` (boolean)\n\nIf enabled Kamailio will do caching of the TLS sessions data, generation\na session_id and sending it back to client.\n\nBy default TLS session caching is disabled (0).\n\n```\n...\nmodparam(\"tls\", \"session_cache\", 1)\n...\n    \n```\n",
   "session_id": "### `session_id` (str)\n\nThe value for session ID context, making sense when session caching is\nenabled.\n\nBy default TLS session_id is \"kamailio-tls-5.x.y\".\n\n```\n...\nmodparam(\"tls\", \"session_id\", \"my-session-id-context\")\n...\n    \n```\n",
   "renegotiation": "### `renegotiation` (boolean)\n\nIf enabled Kamailio will allow renegotiations of TLS connection\ninitiated by the client. This may expose to a security risk if the\nclient is not a trusted peer and keeps renegotiating, consuming CPU and\nbandwidth resources.\n\nBy default TLS renegotiation is disabled (0).\n\n```\n...\nmodparam(\"tls\", \"renegotiation\", 1)\n...\n    \n```\n",
   "init_mode": "### `init_mode` (int)\n\nAllow setting flags that control how the module is initialized and works\nat runtime. Many flags (bits) can be set at the same time (set the\nparameter to the sum of corresponding values). The flags are refered\nwith 0-indexing.\n\nIf flag (bit) at index 0 is set (value 1), the memory management\noperations registered for TLS are wrapped within a pthread mutex lock.\nIt can be useful with newer versions of libssl and libcrypto, which have\na more pthread multi-threading oriented design.\n\nIf flag (bit) at index 1 is set (value 2), the module executes openssl\nfork prepare API functions (see\n<https://www.openssl.org/docs/man1.1.1/man3/OPENSSL_fork_prepare.html>).\nIt is done only for openssl version greater or equal with 1.1.1.\n\nDefault value is 0.\n\n```\n...\nmodparam(\"tls\", \"init_mode\", 1)\n...\n    \n```\n",
   "config": "### `config` (string)\n\nSets the name of the TLS specific configuration file or configuration\ndirectory.\n\nIf set the TLS module will load a special configuration file or\nconfiguration files from configuration directory, in which different TLS\nparameters can be specified on a per role (server or client) and domain\nbasis (for now only IPs). The corresponding module parameters will be\nignored if a separate configuration file is used.\n\nIf the file or directory name starts with a '.' the path will be\nrelative to the working directory (*at runtime*). If it starts with a\n'/' it will be an absolute path and if it starts with anything else the\npath will be relative to the main config file directory (e.g.: for\nkamailio -f /etc/kamailio/kamailio.cfg it will be relative to\n/etc/kamailio/).\n\nBy default no TLS configuration file is specified.\n\nThe following parameters can be set in the config file, for each domain:\n\n- tls_method - (str) - TLS methods\n\n- verify_certificate - (bool) - see modparam\n\n- require_certificate - (bool) - see modparam\n\n- verify_client - (str) - see modparam\n\n- private_key - (str) - see modparam\n\n- certificate - (str) - see modparam\n\n- verify_depth - (int) - see modparam\n\n- ca_list - (str) - see modparam\n\n- crl - (str) - see modparam\n\n- cipher_list - (str) - see modparam\n\n- server_name - (str) - SNI (server name identification)\n\n- server_name_mode - (int) - how to match server_name\n\n- server_id - (str) - server id\n\nThe value for server_name_mode specifies how to match the server_name\n(SNI). If set to 1, match the domain and all its subdomains. If set to\n2, match only the subdomains. If set to 0 (or anything else), match only\nthe domain given in server_name.\n\nThe value for server_id can be any string, being used to match TLS\nclient config profile, overriding the match on ip:port and server_name.\nThis is the recommended way for selecting a specific TLS client config\nprofile, because the local or remote port is hard to predict for a\nstream connection - see parameter `xavp_cfg` to learn how to enable it.\n\nAll the parameters that take filenames as values will be resolved using\nthe same rules as for the tls config filename itself: starting with a\n'.' means relative to the working directory, a '/' means an absolute\npath and anything else a path relative to the directory of the current\nKamailio main config file.\n\nKamailio acts as a server when it accepts a connection and as a client\nwhen it initiates a new connection by itself (it connects to something).\n\nThe tls.cfg consists on a set of server and client TLS domain profiles.\nA server TLS domain profile starts with [server:domain]. A client TLS\ndomain profile starts with [client:domain]. The tokens 'server' and\n'client' are static values. The 'domain' part can be: 'ip:port' - the IP\naddress and port to match with the TLS connection; 'default' - (static\nstring) for client and server profiles to be used when no other profile\nis matched; 'any' - (static string) for client and server profiles to be\nmatched based on 'server_name', no matter of IP and port of the TLS\nconnection.\n\nThere can be only one of each [server:default] and [client:default]\nprofile definitions. Other profiles can be defined many times with the\nsame domain ('ip:port' or 'any'), but in that case they must have\n'server_name' set for matching SNI.\n\nIt is highly recommended to have [server:default] and\n[client:default] profile definitions. They are needed when SNI is not\nyet available. If SNI is provided, then the profile definition is\nsearched again to match on 'server_name'.\n\n```\n...\n[server:default]\nmethod = TLSv1\nverify_certificate = yes\nrequire_certificate = yes\nprivate_key = default_key.pem\ncertificate = default_cert.pem\nca_list = default_ca.pem\ncrl = default_crl.pem\n\n[client:default]\nverify_certificate = yes\nrequire_certificate = yes\n\n# more relaxed for connection on the loopback interface\n[server:127.0.0.1:5061]\nmethod = TLSv1\nverify_certificate = yes\nrequire_certificate = no\nprivate_key = local_kamailio_org_key.pem\ncertificate = local_kamailio_org_cert.pem\nverify_depth = 3\nca_list = local_ca.pem\nserver_name = kamailio.org\n\n[client:127.0.0.1:5061]\nmethod = TLSv1\nverify_certificate = yes\nrequire_certificate = yes\nprivate_key = default_key.pem\ncertificate = default_cert.pem\nca_list = default_ca.pem\ncrl = default_crl.pem\nserver_name = kamailio.org\nserver_id = kamailio.org\n\n# server profile on any address\n[server:any]\nmethod = TLSv1\nverify_certificate = yes\nrequire_certificate = no\nprivate_key = kamailio_net_key.pem\ncertificate = kamailio_net_cert.pem\nverify_depth = 3\nca_list = local_ca.pem\nserver_name = kamailio.net\nserver_name_mode = 1\n...\n    \n```\n\nFor a more complete example check the *tls.cfg* distributed with the\nKamailio source (kamailio/modules/tls/tls.cfg).\n\n```\n...\nmodparam(\"tls\", \"config\", \"/usr/local/etc/kamailio/tls.cfg\")\n...\n    \n```\n\nThe file can be changed at runtime. The new config will not be loaded\nimmediately, but after the first `tls.reload` RPC call.\n\n```\n $ kamcmd cfg.set_now_string tls config \"/usr/local/etc/kamailio/new_tls.cfg\"\n $ kamcmd tls.reload\n            \n```\n",
   "xavp_cfg": "### `xavp_cfg` (string)\n\nSets the name of XAVP that stores attributes for TLS connections.\n\nThe following (inner) attributes can be set:\n\n- server_name - SNI to be used for outbound connections\n\n- server_id - string value to be used to match TLS config profile for\n  client (outbound) connections. If it is set, matching the TLS config\n  profile is done first on server_id and then on ip:port and\n  server_name. This is the recommended way for selecting a specific TLS\n  client config profile as the local or remote port is hard to predict\n  for a stream connection.\n\nThe default value is empty (not set).\n\n```\n...\n  modparam(\"tls\", \"xavp_cfg\", \"tls\")\n ...\n  $xavp(tls=>server_name) = \"kamailio.org\";\n  $xavp(tls[0]=>server_id) = \"kamailio.org\";\n  $du = \"sip:kamailio.org:5061;transport=tls\";\n  route(RELAY);\n...\n        \n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks specific for tls module.\n\nThe function has one string parameter, the value is the name of the\nevent_route block, respectively \"tls:connection-out\".\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"tls\", \"event_callback\", \"ksr_tls_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_tls_event(evname)\n    KSR.info(\"===== tls module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "rand_engine": "### `rand_engine` (str)\n\nSet the random number generator engine for libssl.\n\nNote: the default random number generator (PRNG) engine of libssl v1.1.x\nis not designed for multi-process applications and can result in a\ncrash. Therefore set the PRNG engine to one of the options listed in\nthis section. If libssl 1.1.x (or newer) is detected at compile time,\nthen the PRNG engine is set to \"cryptorand\".\n\nThe following options are available:\n\n- krand - use internal kam_rand() function\n\n- fastrand - use internal fastrand (ISAAC) function\n\n- cryptorand - use internal cryptorand (Fortuna) function\n\n- kxlibssl - default libssl rand engine wrapped by a Kamailio mutex\n\nNote: the krand and fastrand engines are not recommended for use on\nsystems requiring strong security, as they may not generate numbers with\nenough randomness and are not cryptographically secure.\n\nThe default value is empty (not set) for libssl v1.0.x or older, and\n\"cryptorand\" for libssl v1.1.x or newer.\n\n```\n...\nmodparam(\"tls\", \"rand_engine\", \"fastrand\")\n...\n        \n```\n",
   "engine": "### `engine` (string)\n\nIf OpenSSL is compiled with engine support this will allow algorithms to\nbe offloaded and private keys from HSM to be used. Currently only a\nsingle global engine is supported. However, private keys can be\nspecified per_domain.\n\nTo use private keys from the HSM, the name is the HSM key label prefixed\nby `/engine:`.\n\n```\n...\n## example for the Gem engine\nmodparam(\"tls\", \"engine\", \"gem\")\n# can also be set per-domain in tls.cfg\nmodparam(\"tls\", \"private_key\", \"/engine:my_HSM_key_label\")\n\n## example for engine_pkcs11\nmodparam(\"tls\", \"engine\", \"pkcs11\")\nmodparam(\"tls\", \"private_key\", \"/engine:pkcs11:token=MYTOKEN;object=MYKEYLABEL\")\n\nmodparam(\"tls\", \"engine_config\", \"/usr/local/etc/kamailio/openssl.cnf\")\nmodparam(\"tls\", \"engine_algorithms\", \"ALL\")\n...\n                \n```\n\nBy default OpenSSL engine support is disabled (NONE). This global param\nis not supported in the tls config file.\n",
   "engine_config": "### `engine_config` (string)\n\nAn OpenSSL configuration file to initialize the engine. Typically used\nto send PIN to HSMs to unlock private keys. See the HSM howto for an\nexample. This global param is not supported in the tls config file.\n",
   "engine_algorithms": "### `engine_algorithms` (string)\n\nA list of cryptographic methods to be set as default in the engine. This\nis a comma-separated list of values from ALL RSA DSA DH EC RAND CIPHERS\nDIGESTS PKEY PKEY_CRYPTO PKEY_ASN1. Not all methods are supported by\nevery engine.\n\nThe default is not to set any methods as default. This global param is\nnot supported in the tls config file.\n",
   "verify_client": "### `verify_client` (string)\n\nProvides an alternative to verify_certificate and require_certificate\nmodparam and tls.cfg parameters, and creates an additional opportunistic\nconnection establishment option for connections with with unverifiable\ncertificates (optional_no_ca).\n\nThis is useful for allowing connections from SIP phones with self-signed\ncertificates, signed by unrecognized root CAs, expired certificates,\netc.\n\nThe following values have respective behaviors:\n\n- off - no client certificate request performed.\n\n- on - require a verified certificate from the client.\n\n- optional - ask client for certificate. If one is provided, it must be\n  verified. Allowing missing certificate.\n\n- optional_no_ca - ask client for certificate. Opportunistically try to\n  verify certificate. Allow connection regardless of whether there is no\n  certificate or whether certificate is present (verified or not). Note\n  that verification status can be retrieved via $tls_peer_verified.\n\nDefault value is 'off' (no client certificate request performed).\n\nRecommendation: when using this parameter, do not use verify_certificate\nor require_certificate parameters. Conversion table is as follows:\n\n- verify_certificate=0, require_certificate=0 => verify_client=\"off\"\n\n- verify_certificate=1, require_certificate=0 =>\n  verify_client=\"optional\"\n\n- verify_certificate=1, require_certificate=1 => verify_client=\"on\"\n\n<!-- -->\n\n\n```\n...\nmodparam(\"tls\", \"verify_client\", \"on\")\n...\n        \n\n...\n[server:1.2.3.4:5061]\nmethod = TLSv1\nverify_client = on\n...\n\n[server:5.6.7.8:5061]\nmethod = TLSv1.2\nverify_client = optional_no_ca\n...\n        \n```\n"
  },
  "functions": {
   "is_peer_verified": "### `is_peer_verified()`\n\nReturns true if the connection on which the message was received is TLS,\nthe peer presented an X509 certificate and the certificate chain\nverified ok.\n\nIt can be used only in a request route.\n\n```\n...\n    if (proto==TLS && !is_peer_verified()) {\n        sl_send_reply(\"400\", \"No certificate or verification failed\");\n        exit;\n    }\n...\n```\n",
   "tls_set_connect_server_id": "### `tls_set_connect_server_id(srvid)`\n\nSet the server id of the tls profile to be used by next client connect,\nbeing reset after use. It is an alternative to the use of xavp to\nspecify server id of a client profile for the cases when xavps are no\nlonger available (e.g., after event_route[tm:local-request]).\n\nIf the parameter is an empty string, then the value is reset.\n\nIt can be used only in ANY_ROUTE.\n\n```\n...\n    tls_set_connect_server_id(\"clientone\");\n...\n```\n"
  }
 },
 "tls_wolfssl": {
  "overview": "This module implements the TLS transport for Kamailio using the [wolfSSL\nlibrary](https://www.wolfssl.com) (https://www.wolfssl.com). To enable\nthe Kamailio TLS support this module must be loaded and *enable_tls=yes*\ncore setting must be added to the Kamailio config file.\n\nThis module is derived from the tls module and adapted to wolfSSL using\nthe OpenSSL-compatibility layer. Credit goes to the authors of the tls\nmodule.\n\nThis module is based on wolfSSL 5.2.0 and 5.3.0 and is not fully\ncompatible with the tls module (protocol versions < 1.1 not supported\nit the Debian package for example.\n\nThis user is referred to the documentation of the tls module for\nconfiguration and other information. Not all configuration keys are\nimplemented (e.g., protocol versions \u2014 defaults to 1.2+ and cipher\nsuites).\n",
  "parameters": {},
  "functions": {}
 },
 "tlsa": {
  "overview": "This is a pseudo module that builds TLS module compiled statically\nagainst libssl and libcrypto (from [OpenSSL\nproject](http://www.openssl.org)). Its C code files simply include the\nfiles from TLS module, setting a different module name.\n\nIt is a replacement for tls module, with the same modparams and\nfunctions. Just replace ' loadmodule \"tls.so\" ' with ' loadmodule\n\"tlsa.so\" ' and ' modparam(\"tls\", ...) ' with ' modparam(\"tlsa\", ...) '.\nSee the docs of TLS module for all the details related to its\nparameters, functions, rpc commands, variables, ...\n\nThe benefit of this module is having the libssl and libcrypto embedded\nin the module object file, thus not sharing the SSL/TLS context with any\nother modules that may link indirectly to libssl (e.g., like http_client\nthat links against libcurl, which uses libssl). In this way, the\ninitialization of SSL context (e.g., setting shared memory management\nfunctions) by tlsa module does not impact the other modules.\n\nAnother benefit could be the ability to link a specific libssl version\n(e.g., using source build), not being bound to the version shipped with\nthe operating system.\n\nThe drawback is that updates to the libssl done via operating system\nupgrades are not reflected in the tlsa module. It has to be recompiled\nevery time a new libssl version is installed and it is wanted to be used\nby tlsa module.\n\nNOTE: the module is known to work to be compiled with GCC on Linux\n(tested on Debian Stable 10.x). Other compilers (e.g., clang, icc) may\nnot support same static linking options. Also, some operating systems\nmay provide only dynamic libssl and libcrypto libraries via their\npackages.\n\nNOTE: edit the Makefile in the module folder and update it accordingly\nto set the path to libssl and libcrypto libraries specific to own system\nwhen not wanting to use \"pkg-config\" (e.g., when having these libraries\ncompiled from sources).\n",
  "parameters": {},
  "functions": {}
 },
 "tm": {
  "overview": "The TM module enables stateful processing of SIP transactions. Stateful\nlogic is costly in terms of memory and CPU. The main use is services\nthat inherently need state. For example, transaction-based accounting\n(module acc) needs to process transaction state as opposed to individual\nmessages. Any kind of forking must be implemented transaction\nstatefully. By using transaction states you trade CPU caused by\nretransmission processing for memory. That only makes sense if CPU\nconsumption per request is huge. For example, if you want to avoid\ncostly DNS resolution for every retransmission of a request to an\nunresolvable destination, use stateful mode. Then, only the initial\nmessage burdens server by DNS queries, subsequent retransmissions will\nbe dropped and will not result in more processes blocked by DNS\nresolution. The price is more memory consumption and higher processing\nlatency.\n\nFrom the admin's perspective, these are the major functions : t_relay,\nt_relay_to_udp and t_relay_to_tcp. All of them setup transaction state,\nabsorb retransmissions from upstream, generate downstream\nretransmissions and correlate replies to requests. t_relay forwards to\ncurrent URI (be it original request's URI or a URI changed by some of\nURI-modifying functions, such as sethost). t_relay_to_udp and\nt_relay_to_tcp forward to a specific address over UDP or TCP\nrespectively.\n\nIn general, if TM is used, it copies clones of received SIP messages in\nshared memory. That costs memory and also CPU time (memcpys, lookups,\nshmem locks, etc.) Note that non-TM functions operate over the received\nmessage in private memory, that means that any core operations will have\nno effect on statefully processed messages after creating the\ntransactional state. For example, calling record_route *after* t_relay\nis pretty useless, as the RR is added to privately held message whereas\nits TM clone is being forwarded.\n\nThe TM module is quite big and uneasy to program --lots of mutexes,\nshared memory access, malloc and free, timers--you really need to be\ncareful when you do anything. To simplify TM programming, there is the\ninstrument of callbacks. The callback mechanisms allow programmers to\nregister their functions to a specific event. See t_hooks.h for a list\nof possible events.\n\nOther things programmers may want to know is UAC--it is a very\nsimplistic code which allows you to generate your own transactions.\nParticularly useful for things like NOTIFYs or IM gateways. The UAC\ntakes care of all the transaction machinery: retransmissions, FR\ntimeouts, forking, etc. See t_uac prototype in uac.h for more details.\nIf you want to see the transaction result the code can register for a\ncallback.\n\n<div class=\"note\">\n\n\nSeveral Kamailio TM module functions are now implemented in the TMX\nmodule. Check it to see if what you are looking for is there.\n\n</div>\n",
  "parameters": {
   "fr_timer": "### `fr_timer` (integer)\n\nTimer which hits if no final reply for a request or ACK for a negative\nINVITE reply arrives (in milliseconds).\n\nDefault value is 30000 ms (30 seconds).\n\nSee also: `t_set_fr()`, `max_noninv_lifetime`.\n\n```\n...\nmodparam(\"tm\", \"fr_timer\", 10000)\n...\n        \n```\n",
   "fr_inv_timer": "### `fr_inv_timer` (integer)\n\nTimer which hits if no final reply for an INVITE arrives after a\nprovisional message was received (in milliseconds).\n\nNote: This timer can be restarted when a provisional response is\nreceived. For more details see `restart_fr_on_each_reply`.\n\nDefault value is 120000 ms (120 seconds).\n\nSee also: `t_set_fr()`, `max_inv_lifetime`.\n\n```\n...\nmodparam(\"tm\", \"fr_inv_timer\", 180000)\n...\n        \n```\n",
   "max_inv_lifetime": "### `max_inv_lifetime` (integer)\n\nMaximum time an INVITE transaction is allowed to be active (in\nmilliseconds). After this interval has passed from the transaction\ncreation, the transaction will be either moved into the wait state or in\nthe final response retransmission state, irrespective of the transaction\n`fr_inv_timer` and `fr_timer` values.\n\nAn INVITE transaction will be kept in memory for maximum:\n`max_inv_lifetime`+`fr_timer`(from the ACK to the final reply\nwait)+`wt_timer`.\n\nThe main difference between this timer and `fr_inv_timer` is that the\n`fr_inv_timer` is per branch, while `max_inv_lifetime` is per the whole\ntransaction. Even on a per branch basis `fr_inv_timer` could be\nrestarted. For example, by default if `restart_fr_on_each_reply` is not\ncleared, the `fr_inv_timer` will be restarted for each received\nprovisional reply. Even if `restart_fr_on_each_reply` is not set the\n`fr_inv_timer` will still be restarted for each increasing reply (e.g.\n180, 181, 182, ...). Another example when a transaction can live\nsubstantially more than its `fr_inv_timer` and where `max_inv_lifetime`\nwill help is when DNS failover is used (each failed DNS destination can\nintroduce a new branch).\n\nThe default value is 180000 ms (180 seconds - the rfc3261 timer C\nvalue).\n\nSee also: `max_noninv_lifetime`, `t_set_max_lifetime()` (allows changing\n`max_inv_lifetime` on a per transaction basis), `t_reset_max_lifetime`\n`fr_timer`, `wt_timer`, `restart_fr_on_each_reply`.\n\n```\n...\nmodparam(\"tm\", \"max_inv_lifetime\", 150000)\n...\n        \n```\n",
   "max_noninv_lifetime": "### `max_noninv_lifetime` (integer)\n\nMaximum time a non-INVITE transaction is allowed to be active (in\nmilliseconds). After this interval has passed from the transaction\ncreation, the transaction will be either moved into the wait state or in\nthe final response retransmission state, irrespective of the transaction\n`fr_timer` value. It's the same as `max_inv_lifetime`, but for\nnon-INVITEs.\n\nA non-INVITE transaction will be kept in memory for a maximum of:\n`max_noninv_lifetime`+`wt_timer`.\n\nThe main difference between this timer and `fr_timer` is that the\n`fr_timer` is per branch, while `max_noninv_lifetime` is per the whole\ntransaction. An example when a transaction can live substantially more\nthan its `fr_timer` and where `max_noninv_lifetime` will help is when\nDNS failover is used (each failed DNS SRV destination can introduce a\nnew branch).\n\nThe default value is 32000 ms (32 seconds - the RFC3261 timer F value).\n\nSee also: `max_inv_lifetime`, `t_set_max_lifetime()` (allows changing\n`max_noninv_lifetime` on a per transaction basis),\n`t_reset_max_lifetime` `fr_timer`, `wt_timer`.\n\n```\n...\nmodparam(\"tm\", \"max_noninv_lifetime\", 30000)\n...\n        \n```\n",
   "wt_timer": "### `wt_timer` (integer)\n\nTime for which a transaction stays in memory to absorb delayed messages\nafter it completed (in milliseconds); also, when this timer hits,\nretransmission of local CANCEL requests is stopped (a puristic but\ncomplex behavior would be not to enter wait state until local branches\nare finished by a final reply or FR timer--we simplified).\n\nDefault value is 5000 ms (5 seconds).\n\n```\n...\nmodparam(\"tm\", \"wt_timer\", 1000)\n...\n        \n```\n",
   "retr_timer1": "### `retr_timer1` (integer)\n\nInitial retransmission period (in milliseconds).\n\nDefault value is 500 milliseconds.\n\n```\n...\nmodparam(\"tm\", \"retr_timer1\", 1000)\n...\n        \n```\n",
   "retr_timer2": "### `retr_timer2` (integer)\n\nMaximum retransmission period (in milliseconds). The retransmission\ninterval starts with `retr_timer1` and increases until it reaches this\nvalue. After this it stays constant at `retr_timer2`.\n\nDefault value is 4000 milliseconds.\n\n```\n...\nmodparam(\"tm\", \"retr_timer2\", 2000)\n...\n        \n```\n",
   "noisy_ctimer": "### `noisy_ctimer` (integer)\n\nIf set, INVITE transactions that time-out (FR INV timer) will be always\nreplied. If it's not set, the transaction has only one branch and no\nresponse was ever received on this branch, it will be silently dropped\n(no 408 reply will be generated) This behavior is overridden if a\nrequest is forked, the transaction has a failure route or callback, or\nsome functionality explicitly turned it on for a transaction (like the\nACC module does to avoid unaccounted transactions due to expired timer).\nTurn this off only if you know the client UACs will timeout and their\ntimeout interval for INVITEs is lower or equal than tm's `fr_inv_timer`.\n\nDefault value is 1 (on).\n\n```\n...\nmodparam(\"tm\", \"noisy_ctimer\", 1)\n...\n        \n```\n",
   "restart_fr_on_each_reply": "### `restart_fr_on_each_reply` (integer)\n\nIf set (default), the `fr_inv_timer` for an INVITE transaction will be\nrestarted for each provisional reply received (rfc3261 mandated\nbehaviour). If not set, the `fr_inv_timer` will be restarted only for\nthe first provisional replies and for increasing replies greater or\nequal 180 (e.g. 180, 181, 182, 185, ...).\n\nSetting it to 0 is especially useful when dealing with bad UAs that\ncontinuously retransmit 180s, not allowing the transaction to timeout\n(and thus making impossible the implementation of certain services, like\nautomatic voicemail after x seconds).\n\nDefault value is 1 (on).\n\nSee also: `fr_inv_timer`, `max_inv_lifetime`.\n\n```\n...\nmodparam(\"tm\", \"restart_fr_on_each_reply\", 0)\n...\n        \n```\n",
   "auto_inv_100": "### `auto_inv_100` (integer)\n\nIf set (default) tm will automatically send a 100 reply to INVITEs.\n\nSetting it to 0 can be used to enable first running some tests or\npre-processing on the INVITE and only if some conditions are met\nmanually send a 100 (using `t_reply()`). Note however that in this case\nall the 100s have to be sent \"by hand\". `t_set_auto_inv_100()` might\nhelp to selectively turn off this feature only for some specific\ntransactions.\n\nDefault value is 1 (on).\n\nSee also: `t_set_auto_inv_100()` `auto_inv_100_reason`.\n\n```\n...\nmodparam(\"tm\", \"auto_inv_100\", 0)\n...\n        \n```\n",
   "auto_inv_100_reason": "### `auto_inv_100_reason` (string)\n\nSet reason text of the automatically sent 100 to an INVITE.\n\nDefault value is \"trying -- your call is important to us\".\n\nSee also: `auto_inv_100`.\n\n```\n...\nmodparam(\"tm\", \"auto_inv_100_reason\", \"Trying\")\n...\n        \n```\n",
   "unix_tx_timeout": "### `unix_tx_timeout` (integer)\n\nUnix socket transmission timeout, in milliseconds.\n\nIf UNIX sockets are used (e.g.: to communicate with sems) and sending a\nmessage on a UNIX socket takes longer than `unix_tx_timeout`, the send\nwill fail.\n\nThe default value is 500 milliseconds.\n\n```\n...\nmodparam(\"tm\", \"unix_tx_timeout\", 250)\n...\n        \n```\n",
   "aggregate_challenges": "### `aggregate_challenges` (integer)\n\nIf set (default), the final response is a 401 or a 407 and more than one\nbranch received a 401 or 407, then all the WWW-Authenticate and\nProxy-Authenticate headers from all the 401 and 407 replies will be\naggregated in a new final response. If only one branch received the\nwinning 401 or 407 then this reply will be forwarded (no new one will be\nbuilt).\n\nIf disabled (set to 0) only the first 401, or if no 401 was received the\nfirst 407, will be forwarded (no header aggregation).\n\nDefault value is 1 (required by RFC 3261).\n\n```\n...\nmodparam(\"tm\", \"aggregate_challenges\", 0)\n...\n        \n```\n",
   "reparse_invite": "### `reparse_invite` (integer)\n\nIf set (default), the CANCEL and negative ACK requests are constructed\nfrom the INVITE message which was sent out instead of building them from\nthe received request. The disadvantage is that the outgoing INVITE has\nto be partially re-parsed, the advantage is that the CANCEL/ACK is\nalways RFC 3261-compliant, it always contains the same route-set as the\nINVITE message. Do not disable the INVITE re-parsing for example in the\nfollowing cases:\n\n- The INVITE contains a preloaded route-set, and Kamailio forwards the\nmessage to the next hop according to the \"Route\" header. The \"Route\"\nheader is not removed in the CANCEL without `reparse_invite`=1.\n\n- Kamailio record-routes, thus an in-dialog INVITE contains a \"Route\"\nheader which is removed during loose routing. If the in-dialog INVITE is\nrejected, the negative ACK still contains the \"Route\" header without\n`reparse_invite`=1.\n\nDefault value is 1.\n\n```\n...\nmodparam(\"tm\", \"reparse_invite\", 0)\n...\n        \n```\n",
   "ac_extra_hdrs": "### `ac_extra_hdrs` (string)\n\nHeader fields prefixed by this parameter value are included in the\nCANCEL and negative ACK messages if they were present in the outgoing\nINVITE.\n\nNote, that the parameter value effects only those headers which are not\ncovered by RFC 3261 (which are neither mandatory nor prohibited in\nCANCEL and ACK), and the parameter can be used only together with\n`reparse_invite`=1.\n\nDefault value is \"\".\n\n```\n...\nmodparam(\"tm\", \"ac_extra_hdrs\", \"myfavoriteheaders-\")\n...\n        \n```\n",
   "blst_503": "### `blst_503` (integer)\n\nIf set and the Kamailio blocklist support is enabled, every 503 reply\nsource is added to the blocklist. The initial blocklist timeout (or ttl)\ndepends on the presence of a \"Retry-After\" header in the reply and the\nvalues of the following tm parameters: `blst_503_def_timeout`,\n`blst_503_min_timeout` and `blst_503_max_timeout`.\n\n*WARNING:*blindly allowing 503 blocklisting could be very easily\nexploited for DOS attacks in most network setups.\n\nThe default value is 0 (disabled due to the reasons above).\n\n```\n...\nmodparam(\"tm\", \"blst_503\", 1)\n...\n        \n```\n",
   "blst_503_def_timeout": "### `blst_503_def_timeout` (integer)\n\nBlocklist interval in seconds for a 503 reply with no \"Retry-After\"\nheader. See also `blst_503`, `blst_503_min_timeout` and\n`blst_503_max_timeout`.\n\nThe default value is 0, which means that if no \"Retry-After\" header is\npresent, the 503 reply source will not be blocklisted (RFC 3261\nconformant behaviour).\n\n```\n...\nmodparam(\"tm\", \"blst_503_def_timeout\", 120)\n...\n        \n```\n",
   "blst_503_min_timeout": "### `blst_503_min_timeout` (integer)\n\nMinimum blocklist interval in seconds for a 503 reply with a\n\"Retry-After\" header. It will be used if the \"Retry-After\" value is\nsmaller than this value.\n\nSee also `blst_503`, `blst_503_def_timeout` and `blst_503_max_timeout`.\n\nThe default value is 0\n\n```\n...\nmodparam(\"tm\", \"blst_503_min_timeout\", 30)\n...\n        \n```\n",
   "blst_503_max_timeout": "### `blst_503_max_timeout` (integer)\n\nMaximum blocklist interval in seconds for a 503 reply with a\n\"Retry-After header\". It will be used if the \"Retry-After\" value is\ngreater than this limit.\n\nSee also `blst_503`, `blst_503_def_timeout` and `blst_503_min_timeout`.\n\nThe default value is 3600\n\n```\n...\nmodparam(\"tm\", \"blst_503_max_timeout\", 604800)\n...\n        \n```\n",
   "blst_methods_add": "### `blst_methods_add` (unsigned integer)\n\nBitmap of method types that trigger blocklisting on transaction\ntimeouts. (This setting has no effect on blocklisting because of send\nfailures.)\n\nThe following values are associated to the request methods: INVITE=1,\nCANCEL=2, ACK=4 (not retransmitted, thus, never times-out), BYE=8,\nINFO=16, REGISTER=32, SUBSCRIBE=64, NOTIFY=126, OTHER=256 (all the\nunknown types). Check parser/msg_parser.h for farther details.\n\nChange the value carefully, because requests that don't get a\nprovisional response (everything but INVITE) can easily cause the next\nhop to be inserted into the blocklist by mistake. For example the next\nhop is a proxy, it is alive, but waiting for the response of the UAS,\nand has higher fr_timer value.\n\nThe default value is 1, only INVITEs trigger blocklisting\n\n```\n...\n# INVITEs and REGISTERs trigger blocklisting\nmodparam(\"tm\", \"blst_methods_add\", 33)\n...\n        \n```\n",
   "blst_methods_lookup": "### `blst_methods_lookup` (unsigned integer)\n\nBitmap of method types that are looked-up in the blocklist before being\nforwarded statefully. See also `blst_methods_add`\n\nThe default value is 4294967287, every method type except BYE. (We try\nto deliver BYEs no matter what)\n\n```\n...\n# lookup only INVITEs\nmodparam(\"tm\", \"blst_methods_lookup\", 1)\n...\n        \n```\n",
   "cancel_b_method": "### `cancel_b_method` (integer)\n\nMethod used when attempting to CANCEL an unreplied transaction branch (a\nbranch where no response was received). The possible values are 0, 1,\nand 2.\n\n- *0* will immediately stop the request (INVITE) retransmission on the\nbranch and it will behave as if the branch was immediately replied with\na 487 (a fake internal 487 reply). The advantage is the unreplied\nbranches will be terminated immediately. However it introduces a race\nrisk with a possible slightly delayed 2xx reply. In this case we could\nhave an UA receiving a 2xx after a 487. Moreover this risk is greatly\namplified by packet loss (e.g. if an 180 is lost the branch will look as\nunreplied and a CANCEL will silently drop the branch, but a 2xx can\nstill come at a later time). This is the behaviour for SER versions\nolder than 2.1.\n\n- *1* will keep retransmitting the request on unreplied branches. If a\nprovisional answer is received a CANCEL will be immediately sent back\n(attempting to quickly trigger a 487). This approach is race free and\navoids the 2xx after 487 problem, but it's more resource intensive:\nfaced with a branch towards and UA that doesn't answer, a CANCEL attempt\nwill keep the transaction alive for the whole timeout interval\n(`fr_timer`).\n\n- *2* will send and retransmit CANCEL even on unreplied branches,\nstopping the request retransmissions. This has the same advantages as\n*1* and also avoids the extra roundtrip in the case of the provisional\nreply, but it's not RFC 3261 conforming (the RFC allows sending CANCELs\nonly on pending branches).\n\nThe default value is 1.\n\n```\n...\nmodparam(\"tm\", \"cancel_b_method\", 1)\n...\n        \n```\n",
   "reparse_on_dns_failover": "### `reparse_on_dns_failover` (integer)\n\nIf set to 1, the SIP message after a DNS failover is constructed from\nthe outgoing message buffer of the failed branch instead of from the\nreceived request.\n\nIt must be set if multiple branches are installed, the SIP message is\nmodified differently in them, and at least one of them can result in DNS\nfailover. If the parameter is not set the per-branch modifications are\nlost after the failover.\n\nNote: If the parameter is set, branch route block and TMCB_REQUEST_FWDED\ncallback are not called in case of the failover.\n\nDisadvantage: only the via header is replaced in the message buffer, so\nthe outgoing socket address is not corrected in any other part of the\nmessage. It is dangerous on multihomed hosts: when the new SIP request\nafter the DNS failover is sent via different interface than the first\nrequest, the message can contain incorrect IP address in the\nRecord-Route header.\n\nDefault value is 1.\n\n```\n...\nmodparam(\"tm\", \"reparse_on_dns_failover\", 0)\n...\n        \n```\n",
   "on_sl_reply": "### `on_sl_reply` (string)\n\nSets reply route block, to which control is passed when a reply is\nreceived that has no associated transaction. The reply is passed to the\ncore for stateless forwarding after the route block execution unless\ndrop is executed (or it returns 0).\n\nIf KEMI is used, the parameter has to be the KEMI function name, which\nreceives a string parameter with the event name, respectively\n\"on_sl_reply\".\n\n```\n...\nmodparam(\"tm\", \"on_sl_reply\", \"stateless_replies\")\n...\n\nonreply_route[\"stateless_replies\"] {\n    # do not allow stateless replies to be forwarded\n    return 0;\n}\n        \n\n...\nmodparam(\"tm\", \"on_sl_reply\", \"ksr_slreply\")\n...\n-- event callback function implemented in javascript\nfunction ksr_slreply(evname) {\n    # the evname is set to \"on_sl_reply\"\n    # do not allow stateless replies to be forwarded\n    KSR.x.drop();\n}\n        \n```\n",
   "contacts_avp": "### `contacts_avp` (string)\n\nThis is the name of an XAVP that the `t_load_contacts()` function uses\nto store contacts of the destination set and that `t_next_contacts()`\nfunction uses to restore those contacts.\n\n*Default value is \"NULL\" (t_load_contacts()/t_next_contacts() functions\nare disabled).*\n\n```\n...\nmodparam(\"tm\", \"contacts_avp\", \"tm_contacts\")\n...\n```\n",
   "contact_flows_avp": "### `contact_flows_avp` (string)\n\nThis is the name of an XAVP that the `t_next_contacts()` function uses\nto store contacts (if any) that it skipped, because they contained same\n+sip.instance value than some other contact, and that\n`t_next_contact_flows()` function uses to restore those contacts.\n\n*Default value is \"NULL\". This parameter MUST be set if variable\ncontacts_avp is set.*\n\n```\n...\nmodparam(\"tm\", \"contact_flows_avp\", \"tm_contact_flows\")\n...\n```\n",
   "fr_timer_avp": "### `fr_timer_avp` (string)\n\nThe value of fr_timer timer can be overridden on per-transaction basis.\nThe administrator can provide a value to be used for a particular\ntransaction in an AVP. This parameter contains the name of the AVP that\nwill be checked. If the AVP exists then its value will be used for the\nfr_timer timer, effectively overriding the value configured in\n`fr_timer` parameter for the current transaction.\n\n<div class=\"note\">\n\n\nThe value of the AVP is expected to be expressed in *seconds* and not\nmilliseconds (unlike the rest of the timers).\n\n</div>\n\n\nThis parameter is kept for backwards compatibility (hence its value\nexpressed in seconds instead of milliseconds and its arcane way of\nspecifying the avps). The recommended replacement is using `t_set_fr()`\non a per transaction basis.\n\nSee also: `t_set_fr()`, `fr_timer`.\n\nIn Kamailio compatibility mode (defined by #!KAMAILIO), the value of\nthe parameter must be the name of an AVP in pseudo-variable format:\n$avp(name). In SER compatibility mode it must be just AVP name.\n\n```\n...\n# Kamailio mode\nmodparam(\"tm\", \"fr_timer_avp\", \"$avp(i:708)\")\n# Old SER mode\nmodparam(\"tm\", \"fr_timer_avp\", \"i:708\")\n...\n            \n```\n",
   "fr_inv_timer_avp": "### `fr_inv_timer_avp` (string)\n\nThe value of fr_inv_timer timer can be overridden on per-transaction\nbasis. The administrator can provide a value to be used for a particular\ntransaction in an AVP. This parameter contains the name of the AVP that\nwill be checked. If the AVP exists, is non-empty and non-zero then its\nvalue will be used for the fr_inv_timer timer, effectively overriding\nthe value configured in `fr_inv_timer` parameter for the current\ntransaction.\n\n<div class=\"note\">\n\n\nThe value of the AVP is expected to be expressed in *seconds* and not\nmilliseconds (unlike the rest of the timers).\n\n</div>\n\n\nThis parameter is kept for backwards compatibility (hence its value\nexpressed in seconds instead of milliseconds and its arcane way of\nspecifying the avps). The recommended replacement is using `t_set_fr()`\non a per transaction basis.\n\nSee also: `t_set_fr()`, `fr_inv_timer`.\n\nIn Kamailio compatibility mode (defined by #!KAMAILIO), the value of\nthe parameter must be the name of an AVP in pseudo-variable format:\n$avp(name). In SER compatibility mode it must by just AVP name.\n\n```\n...\n# Kamailio mode\nmodparam(\"tm\", \"fr_inv_timer_avp\", \"$avp(my_fr_inv_timer)\")\n# Old SER mode\nmodparam(\"tm\", \"fr_inv_timer_avp\", \"my_fr_inv_timer\")\n...\n            \n```\n",
   "unmatched_cancel": "### `unmatched_cancel` (integer)\n\nThis parameter selects between forwarding CANCELs that do not match any\ntransaction statefully (0, default value), statelessly (1) or dropping\nthem (2). Note that the stateful forwarding has an additional hidden\nadvantage: the tm module will be able to recognize INVITEs that arrive\nafter their CANCEL. Note also that this feature could be used to try a\nmemory exhaustion DOS attack against a proxy that authenticates all\nrequests, by continuously flooding the victim with CANCELs to random\ndestinations (since the CANCEL cannot be authenticated, each received\nbogus CANCEL will create a new transaction that will live by default\n30s).\n\nDefault value is 0.\n\n```\n...\nmodparam(\"tm\", \"unmatched_cancel\", 2)\n...\n            \n```\n",
   "ruri_matching": "### `ruri_matching` (integer)\n\nIf set the TM module will try to match the request URI when doing SIP\n1.0 (pre-RFC 3261) transaction matching (the \"Via\" header branch\nparameter does not contain the 3261 cookie).\n\nThe only reason to have it not set is for interoperability with old,\nbroken implementations.\n\nDefault value is 1 (on).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm ruri_matching 0\n        \n\n...\nmodparam(\"tm\", \"ruri_matching\", 1)\n...\n        \n```\n",
   "via1_matching": "### `via1_matching` (integer)\n\nIf set the TM module will try to match the topmost \"Via\" header when\ndoing SIP 1.0 (pre-RFC 3261) transaction matching (the \"Via\" header\nbranch parameter does not contain the 3261 cookie).\n\nThe only reason to have it not set is for interoperability with old,\nbroken implementations.\n\nDefault value is 1 (on).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm via1_matching 0\n        \n\n...\nmodparam(\"tm\", \"via1_matching\", 1)\n...\n        \n```\n",
   "callid_matching": "### `callid_matching` (integer)\n\nIf set the TM module will try to match the callid when doing transaction\nmatching.\n\nTurn on if you don't want replies/requests from broken clients who send\na mangled Call-ID to match the transaction. For example when the other\nside won't recognise the response anyway because of a changed Call-ID,\nthis setting will prevent accounting records to be created or\nfailure_route to be skipped.\n\nDefault value is 0 (off).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm callid_matching 0\n        \n\n...\nmodparam(\"tm\", \"callid_matching\", 1)\n...\n        \n```\n",
   "callid_cseq_matching": "### `callid_cseq_matching` (int)\n\nIf set to something other than 0, will do transaction matching using\ncallid and cseq header values instead of via branch md5 value. *Note\nthat this behavior is non-RFC conpliant!*\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"tm\", \"callid_cseq_matching\", 0)\n...\n\nkamcmd cfg.set_now_int tm callid_cseq_matching 1\n        \n```\n",
   "pass_provisional_replies": "### `pass_provisional_replies` (integer)\n\nIf set, TMCB_LOCAL_RESPONSE_OUT tm registered callbacks will be called\nalso for provisional replies.\n\nDefault value is 0 (off).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm pass_provisional_replies 1\n        \n\n...\nmodparam(\"tm\", \"pass_provisional_replies\", 1)\n...\n        \n```\n",
   "default_code": "### `default_code` (integer)\n\nDefault response code sent by `t_reply()` if it cannot retrieve its\nparameters (e.g. inexistent avp). Valid values are between 400 and 699.\n\nDefault value is 500.\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm default_code 505\n        \n\n...\nmodparam(\"tm\", \"default_code\", 501)\n...\n        \n```\n",
   "default_reason": "### `default_reason` (string)\n\nDefault SIP reason phrase sent by `t_reply()` if it cannot retrieve its\nparameters (e.g. inexistent avp).\n\nDefault value is \"Server Internal Error\".\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_string tm default_reason \"Unknown error\"\n        \n\n...\nmodparam(\"tm\", \"default_reason\", \"Unknown reason\")\n...\n        \n```\n",
   "disable_6xx_block": "### `disable_6xx_block` (integer)\n\nIf set the TM module will treat all the 6xx replies like normal replies\n(warning: this would be non-RFC conformant behaviour).\n\nIf not set (default) receiving a 6xx will cancel all the running\nparallel branches, will stop DNS failover and forking. However serial\nforking using `append_branch()` in the `failure_route` will still work.\n\nIt can be overwritten on a per transaction basis using\n`t_set_disable_6xx()`.\n\nDefault value is 0 (off, rfc conformant behaviour).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm disable_6xx_block 0\n        \n```\n\nSee also: `t_set_disable_6xx()`.\n\n```\n...\nmodparam(\"tm\", \"disable_6xx_block\", 1)\n...\n        \n```\n",
   "local_ack_mode": "### `local_ack_mode` (integer)\n\nThis setting controls where locally generated ACKs for 2xx replies to\nlocal transactions (transactions created via `t_uac*()` either through\nthe TM api or via RPC/mi/fifo) are sent.\n\nIt has 3 possible values:\n\n- *0* - the ACK destination is choosen according to the RFC: the next\n  hop is found using the contact and the route set and then DNS\n  resolution is used on it.\n\n- *1* - the ACK is sent to the same address as the corresponding INVITE\n  branch.\n\n- *2* - the ACK is sent to the source of the 2xx reply.\n\n<div class=\"note\">\n\n\nModes 1 and 2 do not follow RFC 3261, but are useful to deal with some\nsimple UAs behind a NAT (no different routing for the ACK and the\ncontact contains an address behind the NAT).\n\n</div>\n\n\nThe default value is 0 (RFC conformant behaviour).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm local_ack_mode 0\n        \n\n...\nmodparam(\"tm\", \"local_ack_mode\", 1)\n...\n        \n```\n",
   "failure_reply_mode": "### `failure_reply_mode` (integer)\n\nThis parameter controls how branches are managed and replies are\nselected for failure_route handling: keep all, drop all, drop last\nbranches in SIP serial forking handling.\n\nTo control per transaction see `t_drop_replies()`.\n\nIt has 4 possible values:\n\n- *0* - all branches are kept, no matter a new leg of serial forking has\n  been started. Beware that if the new leg fails, you may get in\n  failure_route a reply code from a branch of previous serial forking\n  legs (e.g., if in first leg you got a 3xx, then you handled the\n  redirection in failure route, sent to a new destination and this one\n  timeout, you will get again the 3xx). Use t_drop_replies() on per\n  transaction fashion to control the behavior you want. It is the\n  default behaviour coming from SER 2.1.x.\n\n- *1* - all branches are discarded by default. You can still overwrite\n  the behaviour via t_drop_replies()\n\n- *2* - by default only the branches of previous leg of serial forking\n  are discarded\n\n- *3* - all previous branches are discarded if there is a new serial\n  forking leg. This is the default behaviour coming from Kamailio 1.5.x.\n  Use this mode if you don't want to handle in a per transaction fashion\n  with t_drop_replies(). It ensures that you will get the winning reply\n  from the branches of last serial forking step (e.g., if in first step\n  you get 3xx, then you forward to a new destination, you will get in\n  failure_route the reply coming from that destination or a local\n  timeout).\n\nThe default value is 3.\n\n```\n...\nmodparam(\"tm\", \"failure_reply_mode\", 0)\n...\n        \n```\n",
   "faked_reply_prio": "### `faked_reply_prio` (integer)\n\nIt controls how branch selection is done. It allows to give a penalty to\nfaked replies such as the infamous 408 on branch timeout.\n\nInternally, every reply is assigned a priority between 0 (high prio) and\n32000 (low prio). With this parameter the priority of fake replies can\nbe adjusted.\n\n- *0* - disabled (default)\n\n- *< 0* - priority is increased by given amount.\n\n- *> 0* - priority is decreased by given amount. Do not make it higher\n  than 10000 or faked replies will even loose from 1xx class replies.\n\nThe default value is 0.\n\nTo let received replies win from a locally generated 408, set this value\nto 2000.\n\n```\n...\nmodparam(\"tm\", \"faked_reply_prio\", 2000)\n...\n        \n```\n",
   "local_cancel_reason": "### `local_cancel_reason` (boolean)\n\nEnables/disables adding reason headers (RFC 3326) for CANCELs generated\ndue to receiving a final reply. The reason header added will look like:\n\"Reason: SIP;cause=<final_reply_code>\".\n\nDefault value is 1 (enabled).\n\nCan be set at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm local_cancel_reason 0\n            \n```\n\nSee also: `e2e_cancel_reason`.\n\n```\n...\nmodparam(\"tm\", \"local_cancel_reason\", 0)\n...\n            \n```\n",
   "e2e_cancel_reason": "### `e2e_cancel_reason` (boolean)\n\nEnables/disables adding reason headers (RFC 3326) for CANCELs generated\ndue to a received CANCEL. If enabled the reason headers from received\nCANCELs will be copied into the generated hop-by-hop CANCELs.\n\nDefault value is 1 (enabled).\n\nCan be changed at runtime, e.g.:\n\n```\n    $ kamcmd cfg.set_now_int tm e2e_cancel_reason 0\n            \n```\n\nSee also: `t_set_no_e2e_cancel_reason()` and `local_cancel_reason`.\n\n```\n...\nmodparam(\"tm\", \"e2e_cancel_reason\", 0)\n...\n            \n```\n",
   "remap_503_500": "### `remap_503_500` (boolean)\n\nEnables/disables conversion of 503 response code to 500. By default it\nis enabled, based on the SIP RFC requirement. This is global setting for\nall received replies handled by TM. To do it per transaction basis, let\nthis option disabled, set a failure route and then do t_reply(\"500\",\n\"...\") inside it.\n\nDefault value is 1 (enabled).\n\n```\n...\nmodparam(\"tm\", \"remap_503_500\", 0)\n...\n            \n```\n",
   "failure_exec_mode": "### `failure_exec_mode` (boolean)\n\nAdd local failed branches in timer to be considered for failure routing\nblocks. If disabled, relay functions will return false in case the\nbranch could not be forwarded (default behaviour before v4.1.0).\n\nDefault value is 0 (disabled).\n\n```\n...\nmodparam(\"tm\", \"failure_exec_mode\", 1)\n...\n            \n```\n",
   "dns_reuse_rcv_socket": "### `dns_reuse_rcv_socket` (boolean)\n\nControl reuse of the receive socket for additional branches added by DNS\nfailover. If set to 1, the receive socket is used for sending out the\nnew branches, unless the socket is forced explicitely in configuration\nfile. If set to 0, selected socket is done depending on value of global\nparameter \"mhomed\" (if mhomed=0, then the first listen socket is used,\notherwise the socket is selected based on routing rules).\n\nDo enable it with caution, it might create troubles on DNS results with\ndifferent transport layer. Better let it be disabled and enable\n\"mhomed\".\n\nDefault value is 0 (disabled).\n\n```\n...\nmodparam(\"tm\", \"dns_reuse_rcv_socket\", 1)\n...\n            \n```\n",
   "xavp_contact": "### `xavp_contact` (string)\n\nThe name of XAVP storing the attributes per contact. This must be the\nsame as the usrloc parameter `xavp_contact`.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"tm|usrloc\", \"xavp_contact\", \"ulattrs\")\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[tm:local-request] block. The function receives a string\nparameter with the name of the event, respectively \"tm:local-request\".\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"tm\", \"event_callback\", \"ksr_tm_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_tm_event(evname)\n    KSR.info(\"===== tm module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "event_callback_lres_sent": "### `event_callback_lres_sent` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[tm:local-response] block. The function receives a string\nparameter with the name of the event, respectively \"tm:local-response\".\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"tm\", \"event_callback_lres_sent\", \"ksr_tm_event_response_sent\")\n...\n-- event callback function implemented in Lua\nfunction ksr_tm_event_response_sent(evname)\n    KSR.info(\"===== tm module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "relay_100": "### `relay_100` (str)\n\nThis parameter controls whether or not a SIP 100 response is proxied.\nNote that this is not valid behavior when operating in stateful mode per\nRFC 3261 Section 21.1.1, and therefore is useful only when operating as\na stateless proxy. When using this feature, it is possible to control\nwhich 100 responses are proxied and which are not by detecting whether\nthey are part of an existing transaction and setting up the appropriate\nlogic in onreply_route.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"tm\", \"relay_100\", 1)\n...\n```\n",
   "rich_redirect": "### `rich_redirect` (int)\n\nWhen sending a 3xx class reply, include additional branch info to the\ncontacts such as path vector and branch flags.\n\n- *0* - no extra info is added (default)\n\n- *1* - include branch flags as contact header parameter\n\n- *2* - include path as contact uri Route header\n\nValues may be combined (added).\n\n```\n...\nmodparam(\"tm\", \"rich_redirect\", 3)\n....\n            \n```\n",
   "exec_time_check": "### `exec_time_check` (int)\n\nDuration in milliseconds for executing transaction failure callbacks and\nfailure_route block after which to do a safety check if transaction is\nstill active.\n\nSet it to 0 in order to disable this check.\n\n*Default value is 5000 (5 seconds).*\n\n```\n...\nmodparam(\"tm\", \"exec_time_check\", 0)\n...\n```\n",
   "reply_relay_mode": "### `reply_relay_mode` (int)\n\nIf set to 1, a received 200 OK response that was suspended is no longer\nforwarded in the transactional context if another final response was\nforwarded while 200 OK was suspended. Forwarding the 200 OK, even it was\nreceived first, results in overwriting the transaction response buffer\nthat can impact matching of incoming ACKs.\n\nSet it to 0 in order to disable this behaviour and attempt to forward\nsuspended 200 OK in the transaction context. This was the behaviour\nbefore the commit 18410da0.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"tm\", \"reply_relay_mode\", 0)\n...\n```\n",
   "enable_uac_fr": "### `enable_uac_fr` (int)\n\nEnable failure route trigger, for uac. This will copy the tm uac into\nuas. Thus, failure route can be triggered even for uac messages. The\ndefault is 0 (disabled).\n\n```\n...\nmodparam(\"tm\", \"enable_uac_fr\", 1)\n....\n            \n```\n",
   "failover_reply_codes": "### `failover_reply_codes` (string)\n\nThis parameter defines the response codes (only codes >= 300 and class\n>= 3), which enable dns failover to continue to try next ips when\nprevious one fail. It is a list separated by colons, where you may\ndefine either a single code (e.g. \"code=408\" would accept 408 as an\nadditional response code) or a class of responses, you want to accept\n(e.g. \"class=3\" would accept everything from 300 to 999 as valid\nresponse). (with default behaviour only 503 code or no response from\nprevious one will try next ip).\n\n*Default value is \u201c\u201d*\n\n```\n...\nmodparam(\"tm\", \"failover_reply_codes\", \"code=403;code=488;class=5\")\n...\n```\n"
  },
  "functions": {
   "t_relay": "### `t_relay([host, port])`\n\nRelay a SIP request statefully either to the destination indicated in\nthe current URI (if called without any parameters) or to the specified\nhost and port. In the later case (host and port specified) the protocol\nused is the same protocol on which the message was received. It creates\nthe SIP transaction, if none was created before (e.g., with\nt_newtran()).\n\n`t_relay()` is the stateful version for `forward()` while\n`t_relay(host, port)` is similar to `forward(host, port)`.\n\nIn the forward to uri case (`t_relay()`), if the original URI was\nrewritten (by UsrLoc, RR, strip/prefix, etc.) the new URI will be\ntaken). The destination (including the protocol) is determined from the\nuri, using SIP specific DNS resolving if needed (NAPTR, SRV a.s.o\ndepending also on the dns options).\n\nReturns a negative value on failure -- you may still want to send a\nnegative reply upstream statelessly not to leave upstream UAC in lurch.\n\n```\n...\nif (!t_relay())\n{\n    send_reply_error();\n    break;\n};\n...\n        \n```\n",
   "t_relay_to_udp": "### `t_relay_to_udp([ip, port])`\n\nRelay a message statefully using a fixed protocol either to the\nspecified fixed destination or to a destination derived from the message\nuri (if the host address and port are not specified). These along with\n`t_relay` are the functions most users want to use--all other are mostly\nfor programming. Programmers interested in writing TM logic should\nreview how t_relay is implemented in tm.c and how TM callbacks work.\n\nMeaning of the parameters is as follows:\n\n- *ip* - IP address where the message should be sent.\n\n- *port* - Port number.\n\nIf no parameters are specified the message is sent to a destination\nderived from the message uri (using sip specific DNS lookups), but with\nthe protocol corresponding to the function name.\n\n```\n...\nif (src_ip==10.0.0.0/8)\n    t_relay_to_udp(\"1.2.3.4\", \"5060\"); # sent to 1.2.3.4:5060 over udp\nelse\n    t_relay_to_tcp(); # relay to msg. uri, but over tcp\n...\n        \n```\n",
   "t_relay_to_tcp": "### `t_relay_to_tcp([ip, port])`\n\nSee function `t_relay_to_udp([ip, port])`.\n",
   "t_relay_to_tls": "### `t_relay_to_tls([ip, port])`\n\nSee function `t_relay_to_udp([ip, port])`.\n",
   "t_relay_to_sctp": "### `t_relay_to_sctp([ip, port])`\n\nSee function `t_relay_to_udp([ip, port])`.\n",
   "t_on_failure": "### `t_on_failure(failure_route)`\n\nSets failure routing block, to which control is passed after a\ntransaction completed with a negative result but before sending a final\nreply. In the referred block, you can either start a new branch (good\nfor services such as forward_on_no_reply) or send a final reply on your\nown (good for example for message silo, which received a negative reply\nfrom upstream and wants to tell upstream \"202 I will take care of it\").\nNote that the set of commands which are usable within failure_routes is\nstrictly limited to rewriting URI, initiating new branches, logging, and\nsending stateful replies (`t_reply`). Any other commands may result in\nunpredictable behavior and possible server failure. Note that whenever\nfailure_route is entered, uri is reset to value which it had on\nrelaying. If it temporarily changed during a reply_route processing,\nsubsequent reply_route will ignore the changed value and use again the\noriginal one.\n\nMeaning of the parameters is as follows:\n\n- *failure_route* - Failure route block to be called.\n\n<!-- -->\n\n\n```\n...\nroute {\n    t_on_failure(\"1\");\n    t_relay();\n}\n\nfailure_route[1] {\n    revert_uri();\n    setuser(\"voicemail\");\n    append_branch();\n}\n...\n        \n```\n\nSee `misc/examples/mixed/onr.cfg` for a more complex example of\ncombination of serial with parallel forking.\n",
   "t_on_branch_failure": "### `t_on_branch_failure(branch_failure_route)`\n\nSets the branch_failure routing block, to which control is passed on\neach negative response to a transaction. This route is run before\ndeciding if the transaction is complete. In the referred block, you can\nstart a new branch which is required for failover of multiple outbound\nflows (RFC 5626). Note that the set of commands which are usable within\na branch_failure route is limited to a subset of the failure_route\ncommands including logging, rewriting URI and initiating new branches.\nAny other commands may generate errors or result in unpredictable\nbehavior. Note that whenever failure_route is entered, uri is reset to\nvalue which it had on relaying. If it temporarily changed during a\nreply_route processing, subsequent reply_route will ignore the changed\nvalue and use again the original one.\n\nFunction Parameters:\n\n- *branch_failure_route* - Name of the branch_failure route block to be\n  called (it is prefixed internally with 'tm:branch-failure:').\n\n<!-- -->\n\n\n```\n...\nroute {\n    t_on_branch_failure(\"myroute\");\n    t_relay();\n}\n\nevent_route[tm:branch-failure:myroute] {\n    if (t_check_status(\"430|403\") {\n        unregister(\"location\", \"$tu\", \"$T_reply_ruid\");\n    }\n}\n...\n        \n```\n",
   "t_on_reply": "### `t_on_reply(onreply_route)`\n\nSets the reply routing block, to which control is passed when a reply\nfor the current transaction is received. Note that the set of commands\nwhich are usable within onreply_routes is limited.\n\nMeaning of the parameters is as follows:\n\n- *onreply_route* - Onreply route block to be called.\n\n<!-- -->\n\n\n```\n...\nloadmodule \"/usr/local/lib/ser/modules/nathelper.so\"\n...\nroute {\n    /* if natted */\n    t_on_reply(\"1\");\n    t_relay();\n}\n\nonreply_route[1] {\n    if (status=~ \"(183)|2[0-9][0-9]\"){\n        force_rtp_proxy();\n        search_append('^(Contact|m)[ \\t]*:.*sip:[^>[:cntrl:]]*', ';nat=yes');\n    }\n    if (nat_uac_test(\"1\")){\n        fix_nated_contact();\n    }\n}\n        \n```\n",
   "t_on_branch": "### `t_on_branch(branch_route)`\n\nSets the branch routing block, to which control is passed after forking\n(when a new branch is created). For now branch routes are intended only\nfor last minute changes of the SIP messages (like adding new headers).\nNote that the set of commands which are usable within branch_routes is\nvery limited. It is not possible to generate a reply.\n\nMeaning of the parameters is as follows:\n\n- *branch_route* - branch route block to be called.\n\n<!-- -->\n\n\n```\n...\nroute {\n    t_on_branch(\"1\");\n    t_relay();\n}\n\nbranch_route[1] {\n    if (uri=~\"sip:[0-9]+\"){\n        append_hf(\"P-Warn: numeric uri\\r\\n\");\n    }\n}\n        \n```\n",
   "t_newtran": "### `t_newtran()`\n\nCreates a new transaction, returns a negative value on error. Typically,\nit is used to deploy a UAS.\n\nNote: once the t_newtran() is executed, the new message flag operations\n(i.e., setflag() and resetflag()) are not synchronized to the\ntransaction, being stored only in the private memory SIP message\nstructure. Use the tmx module function t_flush_flags() to synchronize\nthe modified message flags to the already created transaction.\n\n```\n...\nif (t_newtran()) {\n    xlog(\"the transaction has been created\\n\");\n    t_reply(\"999\",\"hello\");\n} else {\n    sl_reply_error();\n}\n...\n        \n```\n\nSee `misc/examples/mixed/uas.cfg` for more examples.\n",
   "t_reply": "### `t_reply(code, reason_phrase)`\n\nSends a stateful reply after a transaction has been established. See\n`t_newtran` for usage.\n\nIf the code is in the range 300-399 (redirect reply), the current\ndestination set is appended to the reply as Contact headers. The\ndestination set contains the request URI (R-URI), if it is modified\ncompared to the received one, plus the branches added to the request\n(e.g., after an append_branch() or lookup(\"location\")). If the R-URI was\nchanged but it is not desired to be part of the destination set, it can\nbe reverted using the function revert_uri().\n\nCustom headers to the reply can be added using append_to_reply()\nfunction from textops module.\n\nMeaning of the parameters is as follows:\n\n- *code* - Reply code number.\n\n- *reason_phrase* - Reason string.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE.\n\n```\n...\nt_reply(\"404\", \"Not found\");\n...\n        \n```\n",
   "t_reply_error": "### `t_reply_error()`\n\nSends a stateful reply based in internal error code, similar to\nsl_send_error() from sl module.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nONREPLY_ROUTE.\n\n```\n...\nt_reply_error();\n...\n        \n```\n",
   "t_send_reply": "### `t_send_reply(code, reason)`\n\nCreates the transaction if it does not exist (executing internally\nt_newtran()) and sends a stateful reply (executing internally\nt_reply()). If transaction exists, this function does not stop the\nexecution of config, t_reply() being still executed.\n\nFor more, see the docs for t_newtran() and t_reply().\n\nMeaning of the parameters is as follows:\n\n- *code* - Reply code number.\n\n- *reason* - Reason string.\n\n<!-- -->\n\n\n```\n...\nt_send_reply(\"404\", \"Not found\");\n...\n        \n```\n",
   "t_lookup_request": "### `t_lookup_request()`\n\nChecks if a transaction exists. Returns a positive value if so, negative\notherwise. Most likely you will not want to use it, as a typical\napplication of a look-up is to introduce a new transaction if none was\nfound. However this is safely (atomically) done using `t_newtran`.\n\n```\n...\nif (t_lookup_request()) {\n    ...\n};\n...\n        \n```\n",
   "t_retransmit_reply": "### `t_retransmit_reply()`\n\nRetransmits a reply sent previously by UAS transaction.\n\n```\n...\nt_retransmit_reply();\n...\n        \n```\n",
   "t_release": "### `t_release()`\n\nRemove transaction from memory (it will be first put on a wait timer to\nabsorb delayed messages).\n\n```\n...\nt_release();\n...\n        \n```\n",
   "t_forward_nonack": "### `t_forward_nonack([ip, port])`\n\nMainly for internal usage -- forward a non-ACK request statefully.\nVariants of this functions can enforce a specific transport protocol.\n\nMeaning of the parameters is as follows:\n\n- *ip* - IP address where the message should be sent.\n\n- *port* - Port number.\n\n<!-- -->\n\n\n```\n...\nt_forward_nonack(\"1.2.3.4\", \"5060\");\n...\n        \n```\n",
   "t_forward_nonack_udp": "### `t_forward_nonack_udp(ip, port)`\n\nSee function `t_forward_nonack([ip, port])`.\n",
   "t_forward_nonack_tcp": "### `t_forward_nonack_tcp(ip, port)`\n\nSee function `t_forward_nonack([ip, port])`.\n",
   "t_forward_nonack_tls": "### `t_forward_nonack_tls(ip, port)`\n\nSee function `t_forward_nonack([ip, port])`.\n",
   "t_forward_nonack_sctp": "### `t_forward_nonack_sctp(ip, port)`\n\nSee function `t_forward_nonack([ip, port])`.\n",
   "t_set_fr": "### `t_set_fr(fr_inv_timeout [, fr_timeout])`\n\nSets the fr_inv_timeout and optionally fr_timeout for the current\ntransaction or for transactions created during the same script\ninvocation, after calling this function. If the transaction is already\ncreated (e.g called after `t_relay()` or in an onreply_route) all the\nbranches will have their final response timeout updated on-the-fly. If\none of the parameters is 0, its value won't be changed.\n\nMeaning of the parameters is as follows:\n\n- *fr_inv_timeout* - new final response timeout (in milliseconds) for\n  INVITEs. See also `fr_inv_timer`.\n\n- *fr_timeout* - new final response timeout (in milliseconds) for\n  non-INVITE transaction, or INVITEs which haven't received yet a\n  provisional response. See also `fr_timer`.\n\nSee also: `fr_timer`, `fr_inv_timer`, `t_reset_fr()`.\n\n```\n...\nroute {\n    t_set_fr(10000); # set only fr invite timeout to 10s\n    t_on_branch(\"1\");\n    t_relay();\n}\n\nbranch_route[1] {\n    # if we are calling the pstn, extend the invite timeout to 50s\n    # for all the branches, and set the no-reply-received timeout to 2s\n    if (uri=~\"sip:[0-9]+\"){\n        t_set_fr(50000, 2000);\n    }\n}\n        \n```\n",
   "t_reset_fr": "### `t_reset_fr()`\n\nResets the `fr_inv_timer` and `fr_timer` for the current transaction to\nthe default values (set using the tm module parameters `fr_inv_timer`\nand `fr_timer`).\n\nIt will effectively cancel any previous calls to `t_set_fr` for the same\ntransaction.\n\nSee also: `fr_timer`, `fr_inv_timer`, `t_set_fr`.\n\n```\n...\nroute {\n...\n        t_reset_fr();\n...\n}\n        \n```\n",
   "t_set_max_lifetime": "### `t_set_max_lifetime(inv_lifetime, noninv_lifetime)`\n\nSets the maximum lifetime for the current INVITE or non-INVITE\ntransaction, or for transactions created during the same script\ninvocation, after calling this function (that's why it takes values for\nboth INVITE and non-INVITE). If one of the parameters is 0, its value\nwon't be changed.\n\nIt works as a per transaction `max_inv_lifetime` or\n`max_noninv_lifetime`.\n\nMeaning of the parameters is as follows:\n\n- *inv_lifetime* - maximum INVITE transaction lifetime (in\n  milliseconds). See also `max_inv_lifetime`.\n\n- *noninv_lifetime* - maximum non-INVITE transaction lifetime (in\n  milliseconds). See also `max_noninv_lifetime`.\n\nSee also: `max_inv_lifetime`, `max_noninv_lifetime`,\n`t_reset_max_lifetime`.\n\n```\n...\nroute {\n    if (src_ip=1.2.3.4)\n        t_set_max_lifetime(120000, 0); # set only max_inv_lifetime to 120s\n    else\n        t_set_max_lifetime(90000, 15000); # set the maximum lifetime to 90s if\n                                          # the current transaction is an\n                                          # INVITE and to 15s if not\n}\n\n        \n```\n",
   "t_reset_max_lifetime": "### `t_reset_max_lifetime()`\n\nResets the maximum lifetime for the current INVITE or non-INVITE\ntransaction to the default value (set using the tm module parameter\n`max_inv_lifetime` or `max_noninv_lifetime`).\n\nIt will effectively cancel any previous calls to `t_set_max_lifetime`\nfor the same transaction.\n\nSee also: `max_inv_lifetime`, `max_noninv_lifetime`,\n`t_set_max_lifetime`.\n\n```\n...\nroute {\n...\n        t_reset_max_lifetime();\n...\n}\n        \n```\n",
   "t_set_retr": "### `t_set_retr(retr_t1_interval, retr_t2_interval)`\n\nSets the retr_t1_interval and retr_t2_interval for the current\ntransaction or for transactions created during the same script\ninvocation, after calling this function. If one of the parameters is 0,\nits value won't be changed. If the transaction is already created (e.g\ncalled after `t_relay()` or in an onreply_route) all the existing\nbranches will have their retransmissions intervals updated on-the-fly:\nif the retransmission interval for the branch has not yet reached T2 the\ninterval will be reset to retr_t1_interval, else to retr_t2_interval.\nNote that the change will happen after the current interval expires\n(after the next retransmission, the next-next retransmission will take\nplace at retr_t1_interval or retr_t2_interval). All new branches of the\nsame transaction will start with the new values. This function will work\neven if it's called in the script before a transaction creating function\n(e.g.: t_set_retr(500, 4000); t_relay()). All new transaction created\nafter this function call, during the same script invocation will use the\nnew values.\n\nMeaning of the parameters is as follows:\n\n- *retr_t1_interval* - new T1 retransmission interval (in milliseconds).\n  See also `retr_t1_timeout`.\n\n- *retr_t2_interval* - new T2 (or maximum) retransmission interval (in\n  milliseconds). See also `retr_t2_timeout`.\n\nSee also: `retr_timer1`, `retr_timer2`, `t_reset_retr()`.\n\n```\n...\nroute {\n    t_set_retr(250, 0); # set only T1 to 250 ms\n    t_on_branch(\"1\");\n    t_relay();\n}\n\nbranch_route[1] {\n    # if we are calling the a remote pstn, extend T1 and decrease T2\n    # for all the branches\n    if (uri=~\"sip:[0-9]+\"){\n        t_set_retr(500, 2000);\n    }\n}\n        \n```\n",
   "t_reset_retr": "### `t_reset_retr()`\n\nResets the `retr_timer1` and `retr_timer2` for the current transaction\nto the default values (set using the tm module parameters `retr_timer1`\nand `retr_timer2`).\n\nIt will effectively cancel any previous calls to `t_set_retr` for the\nsame transaction.\n\nSee also: `retr_timer1`, `retr_timer2`, `t_set_retr`.\n\n```\n...\nroute {\n...\n        t_reset_retr();\n...\n}\n        \n```\n",
   "t_set_auto_inv_100": "### `t_set_auto_inv_100(0|1)`\n\nSwitch automatically sending 100 replies to INVITEs on/off on a per\ntransaction basis. It overrides the `auto_inv_100` value for the current\ntransaction.\n\nSee also: `auto_inv_100`.\n\n```\n...\nroute {\n...\n    if (src_ip==1.2.3.0/24)\n        t_set_auto_inv_100(0); # turn off automatic 100 replies\n...\n}\n        \n```\n",
   "t_branch_timeout": "### `t_branch_timeout()`\n\nReturns true if the failure route is executed for a branch that did\ntimeout. It can be used from FAILURE_ROUTE and BRANCH_FAILURE_ROUTE\nevent route.\n\n```\n...\nfailure_route[0]{\n    if (t_branch_timeout()){\n        log(\"timeout\\n\");\n        # ...\n    }\n}\n        \n```\n",
   "t_branch_replied": "### `t_branch_replied()`\n\nReturns true if the failure route is executed for a branch that did\nreceive at least one reply in the past (the \"current\" reply is not taken\ninto account). It can be used from *failure_route* and *branch-failure*\nevent route.\n\n```\n...\nfailure_route[0]{\n    if (t_branch_timeout()){\n        if (t_branch_replied())\n            log(\"timeout after receiving a reply (no answer?)\\n\");\n        else\n            log(\"timeout, remote side seems to be down\\n\");\n        # ...\n    }\n}\n        \n```\n",
   "t_any_timeout": "### `t_any_timeout()`\n\nReturns true if at least one of the current transactions branches did\ntimeout.\n\n```\n...\nfailure_route[0]{\n    if (!t_branch_timeout()){\n        if (t_any_timeout()){\n            log(\"one branch did timeout\\n\");\n            sl_send_reply(\"408\", \"Timeout\");\n        }\n    }\n}\n        \n```\n",
   "t_any_replied": "### `t_any_replied()`\n\nReturns true if at least one of the current transactions branches did\nreceive some reply in the past. If called from a failure or onreply\nroute, the \"current\" reply is not taken into account.\n\n```\n...\nonreply_route[0]{\n    if (!t_any_replied()){\n        log(\"first reply received\\n\");\n        # ...\n    }\n}\n        \n```\n",
   "t_grep_status": "### `t_grep_status(&quot;code&quot;)`\n\nReturns true if \"code\" is the final reply received (or locally\ngenerated) in at least one of the current transactions branches.\n\n```\n...\nonreply_route[0]{\n    if (t_grep_status(\"486\")){\n        /* force a 486 reply, even if this is not the winning branch */\n        t_reply(\"486\", \"Busy\");\n    }\n}\n        \n```\n",
   "t_is_canceled": "### `t_is_canceled()`\n\nReturns true if the current transaction was canceled.\n\n```\n...\nfailure_route[0]{\n    if (t_is_canceled()){\n        log(\"transaction canceled\\n\");\n        # ...\n    }\n}\n        \n```\n",
   "t_is_expired": "### `t_is_expired()`\n\nReturns true if the current transaction has already expired, i.e. the\nmax_inv_lifetime/max_noninv_lifetime interval has already elapsed.\n\n```\n...\nfailure_route[0]{\n    if (t_is_expired()){\n        log(\"transaction expired\\n\");\n        # There is no point in adding a new branch.\n    }\n}\n        \n```\n",
   "t_relay_cancel": "### `t_relay_cancel()`\n\nForwards the CANCEL if the corresponding INVITE transaction exists. The\nfunction is supposed to be used at the very beginning of the script,\nbecause the CANCELs can be caught and the rest of the script can be\nbypassed this way. Do not disable `reparse_invite` module parameter, and\ncall `t_relay_cancel()` right after the sanity tests.\n\nReturn value is 0 (drop) if the corresponding INVITE was found and the\nCANCELs were successfully sent to the pending branches, true if the\nINVITE was not found, and false in case of any error.\n\n```\nif (method == CANCEL) {\n    if (!t_relay_cancel()) {  # implicit drop if relaying was successful,\n                                  # nothing to do\n\n        # corresponding INVITE transaction found but error occurred\n        sl_reply(\"500\", \"Internal Server Error\");\n        drop;\n    }\n    # bad luck, corresponding INVITE transaction is missing,\n    # do the same as for INVITEs\n}\n        \n```\n",
   "t_lookup_cancel": "### `t_lookup_cancel([1])`\n\nReturns true if the corresponding INVITE transaction exists for a CANCEL\nrequest. The function can be called at the beginning of the script to\ncheck whether or not the CANCEL can be immediately forwarded bypassing\nthe rest of the script. Note however that `t_relay_cancel` includes\n`t_lookup_cancel` as well, therefore it is not needed to explicitly call\nthis function unless something has to be logged for example.\n\nIf the function parameter (optional) is set to 1, the message flags are\noverwritten with the flags of the INVITE. isflagset() can be used to\ncheck the flags of the previously forwarded INVITE in this case.\n\n```\nif (method == CANCEL) {\n    if (t_lookup_cancel()) {\n        log(\"INVITE transaction exists\");\n        if (!t_relay_cancel()) {  # implicit drop if\n                                          # relaying was successful,\n                                          # nothing to do\n\n            # corresponding INVITE transaction found\n            # but error occurred\n            sl_reply(\"500\", \"Internal Server Error\");\n            drop;\n        }\n    }\n    # bad luck, corresponding INVITE transaction is missing,\n    # do the same as for INVITEs\n}\n        \n```\n",
   "t_drop_replies": "### `t_drop_replies([mode])`\n\nDrops all the previously received replies in failure_route block to make\nsure that none of them is picked up again.\n\nThe parameter 'mode' controls which replies are dropped: 'a' or\nmissing - all replies are dropped; 'l' - replies received for last set\nof branches are dropped; 'n' - no reply is dropped.\n\nDropping replies works only if a new branch is added to the transaction,\nor it is explicitly replied in the script!\n\n```\n...\nfailure_route[0]{\n    if (t_check_status(\"5[0-9][0-9]\")){\n        # I do not like the 5xx responses,\n        # so I give another chance to \"foobar.com\",\n        # and I drop all the replies to make sure that\n        # they are not forwarded to the caller.\n        t_drop_replies();\n\n        rewritehostport(\"foobar.com\");\n        append_branch();\n        t_relay();\n    }\n}\n        \n```\n",
   "t_save_lumps": "### `t_save_lumps()`\n\nForces the modifications of the processed SIP message to be saved in\nshared memory before t_relay() is called. The new branches which are\ncreated in failure_route will contain the same modifications, and any\nother modification after t_save_lumps() will be lost.\n\nNote that t_relay() automatically saves the modifications when it is\ncalled the first time, there is no need for t_save_lumps() unless\nmessage changes between t_save_lumps() and t_relay() must not be\npropagated to failure_route.\n\nThe transaction must be created by t_newtran() before calling\nt_save_lumps().\n\n```\nroute {\n    ...\n    t_newtran();\n    append_hf(\"hf1: my first header\\r\\n\");\n    ...\n    t_save_lumps();\n    append_hf(\"hf2: my second header\\r\\n\");\n    ...\n    t_on_failure(\"1\");\n    t_relay();\n}\n\nfailure_route[1] {\n    append_branch();\n    append_hf(\"hf3: my third header\\r\\n\");\n    #\n    # This branch contains hf1 and hf3, but does\n    # not contain hf2 header.\n    # hf2 would be also present here without\n    # t_save_lumps().\n    ...\n    t_relay();\n}\n        \n```\n",
   "t_load_contacts": "### `t_load_contacts([mode])`\n\nThis is the first of the three functions that can be used to implement\nserial/parallel forking based on q and +sip.instance values of\nindividual branches in the destination set.\n\nFunction `t_load_contacts()` removes all branches from the current\ndestination set and stores them into the XAVP whose name is configured\nwith the parameter `contacts_avp`. Note that you have to configure this\nparameter before you can use the function, the parameter is set to NULL\nby default, which disables the function.\n\nIf the destination set contains only one branch, the function does\nnothing.\n\nIf the current destination set contains more than one branch, the\nfunction sorts them according to the algorithm selected with the 'mode'\nparameter and then stores the branches in reverse order into the XAVP.\n\nThe q parameter of a branch contains a value from range 0-1.0 and it\nexpresses relative preference of the branch among all branches in the\ndestination set. The higher the q value the more preference the user\nagent gave to the branch. The parameter 'mode' controls which type of\nalgorithm kamailio will apply to sort the branches based on the q\nvalues:\n\n- '0' or missing: branches with higher q values will be tried before\nbranches with lower ones when serial forking takes place Equals q values\nwill result in a parallel forking.\n\n- '1': branches are ordered using a proportional algorithm that uses to\nq value as the weight of the branch. Higher is the q value, higher is\nthe probability to be tried as first. Equals q values means equals\nprobability to be tried. Differently from the previous mode there is no\npossibility to have parallel forking. Branches with q values equals to 0\nor lower are not considered by the ordering algorithm, but just added at\nthe end of the list as backup option if all other branches fail. This\nalgorithm can be useful in case of endpoints in ACTIVE-ACTIVE\nconfiguration to load-balance the calls.\n\nAfter calling `t_load_contacts()`, function `t_next_contacts()` and\npossibly also `t_next_contact_flow()` need to be called one or more\ntimes in order to retrieve the branches based on their order.\n\nFunction returns 1 if loading of contacts succeeded or there was nothing\nto do. In case of an error, function returns -1 (see syslog).\n\nThis function can be used from REQUEST_ROUTE and FAILURE_ROUTE.\n\n```\n...\nif (!t_load_contacts()) {\n        sl_send_reply(\"500\", \"Server Internal Error - Cannot load contacts\");\n        exit;\n};\n...\n```\n",
   "t_next_contacts": "### `t_next_contacts()`\n\nFunction `t_next_contacts()` is the second of the three functions that\ncan be used to implement serial/parallel forking based on the q value of\nthe individual branches in a destination set.\n\nThe function adds to request a new destination set that includes the\nhighest priority contacts in contacts_avp, but only one contact with the\nsame +sip.instance value is included. Duplicate contacts are added to\ncontact_flows_avp for later consumption by function\n`next_contact_flow()`. Upon each call, Request URI is rewritten with the\nfirst contact and the remaining contacts (if any) are added as branches.\nThen all highest priority contacts are removed from contacts_avp.\n\nFunction does nothing if `contact_avp` has no values.\n\nFunction returns 1 if contacts_avp was not empty and a destination set\nwas successfully added, returns -2 if contacts_avp was empty and thus\nthere was nothing to do, and returns -1 in case of an error (see\nsyslog). Function can be called from REQUEST_ROUTE and FAILURE_ROUTE.\n\nNote that if you use `t_load_contacts` and `t_next_contacts` functions\nthen you should also set the value of `restart_fr_on_each_reply`\nparameter to 0. If you do not do that, it can happen that a broken user\nagent that retransmits 180 periodically will keep resetting the\nfr_inv_timer value and serial forking never happens.\n\nBefore calling t_relay(), you can check if the previous call of\n`next_contacts()` consumed all branches by checking if `contact_avp` and\n`contact_flows_avp` are not anymore set. Based on that test, you can\nthen use t_set_fr() function to set timers according to your needs.\n\n```\n...\n# First call after t_load_contacts() when transaction does not exist yet\n# and contacts should be available\nif (!t_next_contacts()) {\n        sl_send_reply(\"500\", \"Server Internal Error - Cannot get contacts\");\n} else {\n        t_relay();\n};\n...\n# Following call, when transaction exists and there may or may not be\n# contacts left\nif (!t_next_contacts()) {\n        t_reply(\"408\", \"Request Timeout\");\n} else {\n        t_relay();\n};\n...\n```\n",
   "t_next_contact_flow": "### `t_next_contact_flow()`\n\nFunction `t_next_contact_flow()` is the last of the three functions that\ncan be used to implement serial/parallel forking based on the q value\nand instance value of individual branches in a destination set.\n\nFunction adds a new branch to the request that includes the first\ncontact from `contact_flows_avp` that matches the +sip.instance value of\nthe flow that has failed. Upon each call, Request URI is rewritten with\nthe contact. The used contact is removed from `contact_flows_avp`.\n\nFunction does nothing if there are no `contact_flows_avp` values.\n\nFunction returns 1 if `contact_flows_avp` was not empty and a\ndestination set was successfully added, returns -2 if `contacts_avp` was\nempty and thus there was nothing to do, and returns -1 in case of an\nerror (see syslog). This function can be used from a\nBRANCH_FAILURE_ROUTE event route.\n\n```\n...\nevent_route[tm:branch-failure:outbound]\n{\n    if (t_next_contact_flow())\n    {\n        t_relay();\n    } else {\n        xlog(\"L_INFO\", \"No more flows\\n\");\n    }\n...\n```\n",
   "t_check_status": "### `t_check_status(re)`\n\nReturns true if the regular expression \u201cre\u201d match the reply code of the\nresponse message as follows:\n\n- *in routing block* - the code of the last sent reply.\n\n- *in on_reply block* - the code of the current received reply.\n\n- *in on_failure block* - the code of the selected negative final reply.\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nif (t_check_status(\"(487)|(408)\")) {\n    log(\"487 or 408 negative reply\\n\");\n}\n...\n```\n",
   "t_check_trans": "### `t_check_trans()`\n\n`t_check_trans()` can be used to quickly check if a message belongs or\nis related to a transaction. It behaves differently for different types\nof messages:\n\n- For a SIP Reply it returns true if the reply belongs to an existing\n  transaction and false otherwise.\n\n- For a CANCEL it behaves exactly as `t_lookup_cancel()`: returns true\n  if a corresponding INVITE transaction exists for the CANCEL and false\n  otherwise.\n\n- For ACKs to negative replies or for ACKs to local transactions it will\n  terminate the script if the ACK belongs to a transaction (it would\n  make very little sense to process an ACK to a negative reply for an\n  existing transaction in some other way then to simply pass it to tm)\n  or return false if not.\n\n- For end-to-end ACKs (ACKs to 2xx responses for forwarded INVITE\n  transactions) it will return true if the corresponding INVITE\n  transaction is found and still active and false if not.\n\n  <div class=\"note\">\n\n\n  Note that the e2e ACK matching is more of a hint then a certainty. A\n  delayed e2e ACK might arrive after the transaction wait time elapses,\n  when the INVITE transaction no longer exists and thus would not match\n  anything. There are also cases when tm would not keep all the\n  information needed for e2e ACK matching (since this is not needed for\n  a stateful proxy and it requires additional memory, tm will not keep\n  this information unless needed by some other module or callbacks).\n\n  </div>\n\n\n- For other requests (non ACKs and non CANCELs), in case of a\n  retransmission matching a transaction, it resends the last reply for\n  that transaction and terminates the config execution. Otherwise, it\n  returns false (in case of new requests for which no transaction exists\n  yet).\n\n<div class=\"note\">\n\n\nAn important difference from kamailio version is that for an ACK to\nnegative reply or for a local transaction, the script execution will be\nimmediately stopped and the message handled by tm, instead of returning\ntrue.\n\n</div>\n\n\n`t_check_trans()` functionality for requests, except for the e2e ACK\nmatching, can be replicated in the script using `t_lookup_cancel()` and\n`t_lookup_request()`.\n\nSee also: `t_lookup_request()`, `t_lookup_cancel()`.\n\n```\nif ( method == \"CANCEL\" && !t_check_trans())\n    sl_reply(\"403\", \"cancel out of the blue forbidden\");\n# note: in this example t_check_trans() can be replaced by t_lookup_cancel()\n\n        \n```\n",
   "t_set_disable_6xx": "### `t_set_disable_6xx(0|1)`\n\nTurn off/on 6xx replies special rfc conforming handling on a per\ntransaction basis. If turned off (`t_set_disable_6xx(&quot;1&quot;)`) 6XXs will be\ntreated like normal replies.\n\nIt overrides the `disable_6xx_block` value for the current transaction.\n\nSee also: `disable_6xx_block`.\n\n```\n...\nroute {\n...\n    if (src_ip==1.2.3.4) # bad user agent that sends 603\n        t_set_disable_6xx(1); # turn off 6xx special handling\n...\n}\n        \n```\n",
   "t_set_disable_failover": "### `t_set_disable_failover(0|1)`\n\nTurn off/on dns failover on a per transaction basis.\n\nSee also: `use_dns_failover`.\n\n```\n...\nroute {\n...\n    if (uri=~\"@foo.bar$\")\n        t_set_disable_failover(1); # turn off dns failover\n...\n}\n        \n```\n",
   "t_set_disable_internal_reply": "### `t_set_disable_internal_reply(0|1)`\n\nTurn off/on sending internally a SIP reply in case of relay errors.\n\n```\n...\nt_set_disable_internal_reply(1); # turn off sending internal reply on error\nif(!t_relay()) {\n   send_reply(\"500\", \"Server error\");\n}\n...\n        \n```\n",
   "t_replicate": "### `t_replicate([params])`\n\nReplicate the SIP request to a specific address. Return values are the\nsame as for `t_relay()`. Note that responses to the replicated request\nare suppressed and will not show up in any reply_route.\n\nThere are several function prototypes:\n\n- `t_replicate([uri])`,\n\n- `t_replicate(host, port)`,\n\n- `t_replicate_udp(host, port)`\n\n- `t_replicate_tcp(host, port)`\n\n- `t_replicate_tls(host, port)`\n\n- `t_replicate_sctp(host, port)`\n\n- `t_replicate_to(proto, hostport)`\n\nMeaning of the parameters is as follows:\n\n- *uri* - SIP URI where the message should be sent. It can be given via\n  a script variable. It is optional - when missing, the dst-uri or r-uri\n  are used as next hop address.\n\n- *host* - host address where the message should be sent.\n\n- *port* - port number.\n\n- *proto* - transport protocol to be used.\n\n- *hostport* - address in \"host:port\" format. It can be given via an\n  AVP.\n\n<!-- -->\n\n\n```\n...\n# sent to 1.2.3.4:5060 over tcp\nt_replicate(\"sip:1.2.3.4:5060;transport=tcp\");\n\n# sent to 1.2.3.4:5061 over tls\n$var(h) = \"1.2.3.4:5061\";\nt_replicate(\"sip:$var(h);transport=tls\");\n\n# sent to 1.2.3.4:5060 over udp\nt_replicate_to_udp(\"1.2.3.4\", \"5060\");\n...\n        \n```\n",
   "t_relay_to": "### `t_relay_to(proxy, flags)`\n\nForward the SIP request to a specific address, controlling internal\nbehavior via flags.\n\nThere are several function prototypes:\n\n- `t_relay_to()`,\n\n- `t_relay_to(proxy)`,\n\n- `t_relay_to(flags)`\n\n- `t_relay_to(proxy, flags)`\n\nMeaning of the parameters is as follows:\n\n- *proxy* - address where the request should be sent. Format is:\n  \"proto:host:port\" - any of proto or port can be omitted, along with\n  the semicolon after or before.\n\n- *flags* - bitmask integer value to control the internal behavior. Bits\n  can be:\n\n  - *0x01* - do not generate 100 reply.\n\n  - *0x02* - do not generate reply on internal error.\n\n  - *0x04* - disable dns failover.\n\n<!-- -->\n\n\n```\n...\n# sent to 1.2.3.4:5060 over tcp\nt_relay_to(\"tcp:1.2.3.4:5060\");\n\n# sent to 1.2.3.4 over tls\nt_relay_to(\"tls:1.2.3.4\");\n\n# sent to dst URI or R-URI without a 100 reply\nt_relay_to(\"0x01\");\n...\n        \n```\n",
   "t_set_no_e2e_cancel_reason": "### `t_set_no_e2e_cancel_reason(0|1)`\n\nEnables/disables reason header (RFC 3326) copying from the triggering\nreceived CANCEL to the generated hop-by-hop CANCEL. 0 enables and 1\ndisables.\n\nIt overrides the `e2e_cancel_reason` setting (module parameter) for the\ncurrent transaction.\n\nNote: the function has to be used when processing the INVITE (not when\nprocessing the CANCEL).\n\nSee also: `e2e_cancel_reason`.\n\n```\n...\nroute {\n...\n    if (src_ip!=10.0.0.0/8) #  don't trust CANCELs from the outside\n        t_set_no_e2e_cancel_reason(1); # turn off CANCEL reason header copying\n...\n}\n        \n```\n",
   "t_is_set": "### `t_is_set(target)`\n\nReturn true if the attribute specified by 'target' is set for\ntransaction.\n\nThe target parameter can be:\n\n- *branch_route* - the function returns true if a branch route is set to\n  be executed.\n\n- *failure_route* - the function returns true if a failure route is set\n  to be executed.\n\n- *onreply_route* - the function returns true if an onreply route is set\n  to be executed.\n\n<!-- -->\n\n\n```\n...\nif(!t_is_set(\"failure_route\"))\n    LM_DBG(\"no failure route will be executed for current transaction\\n\");\n...\n        \n```\n",
   "t_use_uac_headers": "### `t_use_uac_headers()`\n\nSet internal flags to tell tm to use UAC side for building headers for\nlocal generated requests (ACK, CANCEL) - useful when changing From/To\nheaders using other functions than uac_replace_[from|to]().\n\nIt returns true.\n\n```\n...\nt_use_uac_headers();\n...\n        \n```\n",
   "t_is_retr_async_reply": "### `t_is_retr_async_reply()`\n\nCheck to see if the reply is a retransmitted reply on a transaction that\nis currently suspended asynchronously (suspended during reply\nprocessing). Right now the check is only on the transaction, we don't\nactually check to see if the reply message is an actual retransmission\nof the suspended reply. This is expected as you should not process\nanother reply until the suspended reply processing has been completed.\nThe trick here is to make sure you don't suspend for too long or even\nworse, indefinitely.\n\nreturns true if the transaction is currently reply suspended or false if\nnot.\n\n```\n...\nif (t_is_retr_async_reply()) {\n    xlog(\"L_DBG\", \"Dropping retransmitted reply which is still currently suspended\\n\");\n        drop();\n}\n...\n        \n```\n",
   "t_uac_send": "### `t_uac_send(method, ruri, nexthop, socket, headers, body)`\n\nSend a UAC request.\n\nIt returns true (1) if successful, false (-1) on failure.\n\nThe parameters:\n\n- *method* - SIP method.\n\n- *ruri* - request URI.\n\n- *nexthop* - destination URI (can be empty).\n\n- *socket* - local send socket (can be empty).\n\n- *headers* - SIP headers. At least From and To have to be provided. It\n  can include From/To tags, Call-ID, CSeq. If body is provided, then\n  Content-Type header must exist.\n\n- *body* - SIP message body (can be empty).\n\n<!-- -->\n\n\n```\n...\nt_uac_send(\"OPTIONS\", \"sip:alice@kamailio.org\", \"\", \"\",\n    \"From: bob@kamailio.org;tag=2w3e\\r\\nTo: bob@kamailio.org\", \"\");\n...\n        \n```\n",
   "t_get_status_code": "### `t_get_status_code()`\n\nReturn the status code for transaction - the most relevant SIP reply\nstatus code, or -1 in case of error or no status code was set.\n\n```\n...\n$var(ts) = t_get_status_code();\nif($var(ts) == 500) { ... }\n...\n        \n```\n",
   "t_clean": "### `t_clean()`\n\nCleans active but very old transactions. Returns true (1). Can be called\nfrom any route.\n\n```\n...\nt_clean();\n...\n        \n```\n",
   "t_exists": "### `t_exists()`\n\nReturn true if a transaction for the current message exists, without\nsetting the global references.\n\n```\n...\nreply_route {\n    if (!t_exists()) {\n        drop();\n    }\n}\n...\n        \n```\n"
  }
 },
 "tmrec": {
  "overview": "This module provides time recurrence matching functions. The format of\nrecurrence definitions is based on Internet Calendaring and Scheduling\nCore Object Specification (Calendar COS - RFC 2445). It also provides a\nport of the Perl Time::Period module for generic time period matching.\n",
  "parameters": {
   "separator": "### `separator` (str)\n\nSeparator character used to delimit attributes in time recurrence\ndefinitions.\n\n*Default value is '|'.*\n\n```\n...\nmodparam(\"tmrec\", \"separator\", \";\")\n...\n```\n"
  },
  "functions": {
   "tmrec_match": "### `tmrec_match(timerec [, timestamp])`\n\nMatch a time recurrence rule against the timestamp (UNIX epoch format).\nIf the timestamp parameter is missing, the current UNIX epoch time is\nused.\n\nThe parameters can include pseudo-variables.\n\nThe timerec paramter is a list of attributes defined by RFC2445,\ndelimited by the 'separator' (module parameter) character. The format of\ntimerec parameter, using '|' as the separator, is (all in one line\nwithout white spaces):\n\n```\n...\n[startdate]|[duration]|[frequency]|[until]|[interval]|[byday]\n  |[bymonthday]|[byyearday]|[byweekno]|[bymonth]\n...\n```\n\nWhen an attribute is not specified, the corresponding place must be left\nempty, provided that one or more additional attributes follow.\n\nDescription of time recurrence attributes:\n\n- *startdate* - date for the start of the first period.\n\n- *duration* - the duration of the time period. For a recurring\n  interval, the \u201cduration\u201d parameter MUST be small enough such that\n  subsequent intervals do not overlap. For non-recurring intervals,\n  durations of any positive length are permitted. Zero-length duration\n  means \u201cforever\u201d. Negative-length durations are not allowed.\n\n  See RFC 2445 for the format of duration. In short for common cases\n  when the duration doesn't exceed a data, it must start with PT\n  followed by the value for hours, minutes or seconds - e.g., a duration\n  of 8 hours must be written as PT8H.\n\n- *frequency* - can be one of the following values: \u201cdaily\u201d - specify\n  repeating periods based on an interval of a day or more; \u201cweekly\u201d -\n  specify repeating periods based on an interval of a week or more;\n  \u201cmonthly\u201d - specify repeating periods based on an interval of a month\n  or more; \u201cyearly\u201d - specify repeating periods based on an interval of\n  a year or more. These values are case-insensitive.\n\n- *until* - defines an iCalendar COS DATE or DATE-TIME value which\n  bounds the recurrence rule in an inclusive manner. If the value\n  specified by \u201cuntil\u201d is synchronized with the specified recurrence,\n  this date or date-time becomes the last instance of the recurrence. If\n  it is not present, the recurrence is considered to repeat forever.\n\n- *interval* - a positive integer representing how often the recurrence\n  rule repeats. The default value is \u201c1\u201d, meaning every day for a\n  \u201cdaily\u201d rule, every week for a \u201cweekly\u201d rule, every month for a\n  \u201cmonthly\u201d rule and every year for a \u201cyearly\u201d rule.\n\n- *byday* - a comma-separated list short codes of days of the week. The\n  days are specified as: \u201cMO\u201d for Monday; \u201cTU\u201d for Tuesday; \u201cWE\u201d for\n  Wednesday; \u201cTH\u201d for Thursday; \u201cFR\u201d for Friday; \u201cSA\u201d for Saturday; \u201cSU\u201d\n  for Sunday. These values are case insensitive.\n\n  Each \u201cbyday\u201d value can also be prefixed by a positive (+n) or negative\n  (-n) integer. If present, this indicates the n-th occurrence of the\n  specific day within the \u201cmonthly\u201d or \u201cyearly\u201d recurrence. For example,\n  within a \u201cmonthly\u201d rule, +1MO (or simply 1MO) represents the first\n  Monday within the month, whereas -1MO represents the last Monday of\n  the month. If an integer modifier is not present, it means all days of\n  this type within the specified frequency. For example, within a\n  \u201cmonthly\u201d rule, MO represents all Mondays within the month.\n\n- *bymonthday* - a comma-separated list of days of the month. Valid\n  values are 1 to 31 or -31 to -1. For example, -10 represents the tenth\n  to the last day of the month.\n\n- *byyearday* - a comma-separated list of days of the year. Valid values\n  are 1 to 366 or -366 to -1. For example, -1 represents the last day of\n  the year (December 31st) and -306 represents the 306th day before the\n  last day of the year (March 1st).\n\n- *byweekno* - a comma-separated list of ordinals specifying weeks of\n  the year. Valid values are 1 to 53 or -53 to -1.\n\n- *bymonth* - parameter specifies a comma-separated list of months of\n  the year. Valid values are 1 to 12.\n\nA recurrence is specified by including the \u201cfrequency\u201d parameter, which\nindicates the type of the recurrence rule. Parameters other than\n\u201cstartdate\u201d and \u201cduration\u201d SHOULD NOT be specified unless \u201cfrequency\u201d is\nset.\n\nIf invalid byxxx parameter values are found (ie, bymonthday=\u201c30\u201d in\nFebruary), they are simply ignored.\n\nByxxx parameters modify the recurrence rule matching. The Byxxx rule, as\nan attribute for a period of time which is greater than or equal to the\nfrequency, generally reduces or limits the number of occurrences for the\nrecurrence definition. For example, frequency=\u201cdaily\u201d bymonth=\u201c3\u201d\nreduces the number of recurrence instances from all days (if the\n\u201cbymonth\u201d parameter is not present) to all days in March. Byxxx\nparameters for a period of time less than the frequency generally\nincreases or expands the number of occurrences of the recurrence. For\nexample, frequency=\u201cyearly\u201d bymonth=\u201c8,9\u201d increases the number of days\nwithin the yearly recurrence set from 1 (if \u201cbymonth\u201d parameter is not\npresent) to 2.\n\nIf multiple Byxxx parameters are specified, then after evaluating the\nspecified \u201cfrequency\u201d and \u201cinterval\u201d parameters, the Byxxx parameters\nare applied to the current set of evaluated occurrences in the following\norder: \u201cbymonth\u201d, \u201cbyweekno\u201d, \u201cbyyearday\u201d, \u201cbymonthday\u201d, \u201cbyday\u201d; then\n\u201cuntil\u201d is evaluated.\n\nNext is an example of evaluating multiple Byxxx parameters.\n\nstartdate=\u201c20100101T093000\u201d duration=\u201cPT10H30M\u201d frequency=\u201cyearly\u201d\ninterval=\u201c4\u201d bymonth=\u201c3\u201d byday=\u201cSU\u201d\n\nFirst, the interval=\u201c4\u201d would be applied to frequency=\u201cyearly\u201d to match\non \u201cevery 4th year\u201d . Then, bymonth=\u201c1\u201d would be applied to match on\n\u201cevery March, every 4th year\u201d. Then, byday=\u201cSU\u201d would be applied to\nmatch on \u201cevery Sunday in March, every 4th year, from 9:30 to 20:00 \u201d.\nThe start and end hours:minutes have been retrieved from the \u201cstartdate\u201d\nand \u201cduration\u201d parameters.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\n    if(tmrec_match(\"20120101T000000|PT24H|weekly|||SA,SU\")\n        xdbg(\"it is weekend!\\n\");\n    if(tmrec_match(\"20120101T083000|PT10H|weekly|||MO,TU,WE,TH,FR\")\n        xdbg(\"it is with working hours\\n\");\n...\n```\n",
   "is_leap_year": "### `is_leap_year([year])`\n\nReturn true if the value from parameter is a leap year. If the parameter\nis missing, then the year from the current time is taken.\n\nThe parameter can be pseudo-variable.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nif(is_leap_year(\"2010\"))\n...\n```\n",
   "time_period_match": "### `time_period_match(period [, timestamp])`\n\nMatches the point in time specified by the timestamp parameter, or the\ncurrent time if the parameter is missing, against the given period\nspecification. Returns 1 if it matches, -1 if it doesn't, and a value\n<= -2 if there was an error.\n\nThe time period specification follows the Perl Time::Period module. It\nis a string and consists of zero or more sub-period specifications,\nseparated by commas. The period matches if at least one of the\nsub-periods matches, or if no sub-periods were given at all (an empty\nstring).\n\nEach sub-period is a list of one or more scale definitions, optionally\nseparated by space characters. The sub-period matches if all of the\ngiven scales within that sub-period match. For each scale given, a\nsingle value or a range of values (which is two values separated by a\nhyphen) can be specified. Multiple values or multiple ranges (or a\ncombination thereof) within a single scale is also possible. If a\ncertain scale is specified more than once, the previous values or ranges\nfor that scale are extended by the newly given ones. If a particular\nscale is not mentioned at all within a sub-period, then no matching is\nperformed for that scale.\n\nThe following scales are supported and understood. Each scale also has a\nrespective short code, either one can be used. A single scale definition\nconsists of the scale name, followed by an opening brace, followed by\nthe list of values, followed by a closing brace.\n\n- *year* or *yr* - Either given as a full 4-digit number >= 1970, or as\n  a 2-digit number, in which case it will be understood to be within the\n  current century.\n\n- *month* or *mo* - Month of the year, either a number between 1 and 12,\n  or at least the first 3 letters of a spelled out month name, e.g.\n  \u201cjan\u201d, \u201cjanua\u201d or \u201cjanuary\u201d will all work.\n\n- *week* or *wk* - Week of the month, a number between 1 and 6. The\n  first day of the week is Sunday.\n\n- *yday* or *yd* - Day of the year, a number between 1 and 366.\n\n- *mday* or *md* - Day of the month, a number between 1 and 31.\n\n- *wday* or *wd* - Day of the week, either a number between 1 and 7, or\n  at least the first 2 letters of a spelled out weekday name (analogous\n  to the \u201cmonth\u201d scale). Sunday is the first day of the week.\n\n- *hour* or *hr* - A number between 0 and 23. Unlike the Perl\n  Time::Period module, \u201cam\u201d or \u201cpm\u201d specifications are not supported.\n\n- *minute* or *min* - A number between 0 and 59.\n\n- *second* or *sec* - A number between 0 and 60 (to allow for leap\n  seconds).\n\nThe parameters can include pseudo-variables. Whitespace (more precisely,\nthe space character only) can occur anywhere, but is optional. Ranges in\nall scales (with the exception of the \u201cyear\u201d scale) are allowed to\nwrap-around, e.g. a weekday scale of \u201c{fri-tue}\u201d is equivalent to\n\u201c{fri-sat,sun-tue}\u201d.\n\n```\n...\nif(time_period_match(\"wd{2-6} hr{8-16}, wd{2-6} hr{17} min{0-29}\"))\n    xdbg(\"Monday to Friday, 8:00 to 17:30\\n\");\n\nif(time_period_match(\"wday { sat sun }, wday {mo-fr} hr {17-8},wd{mo-wed}hr{15 16 9}\"))\n    xdbg(\"We're closed - open only Monday to Wednesday 10:00-15:00, Thursday and Friday 9:00-17:00\");\n...\n```\n"
  }
 },
 "tmx": {
  "overview": "This module collects extensions from Kamailio TM module.\n\nKamailio TM (Transaction Management) module documentation is available\nat: <https://www.kamailio.org/docs/modules/stable/modules/tm.html>\n",
  "parameters": {
   "precheck_trans": "### `precheck_trans` (int)\n\nEnable/disable transaction pre-check via t_precheck_trans() function. If\nset to 0, the internal structures are not created at startup and the\nfunction will return false always.\n\nDefault value is *1* (enabled).\n\n```\n...\nmodparam(\"tmx\", \"precheck_trans\", 0)\n...\n```\n"
  },
  "functions": {
   "t_cancel_branches": "### `t_cancel_branches(which)`\n\nCancel branches of an active SIP transaction. The function can be called\nfor a SIP reply that will identify the current branch.\n\nParameter can be:.\n\n- *all* - cancel all branches.\n\n- *others* - cancel all branches but the current one.\n\n- *this* - cancel current branch.\n\nThis function can be used in ONREPLY_ROUTE.\n\n```\n...\nif (t_cancel_branches(\"all\")) {\n    xlog(\"cancelled all branches\\n\");\n}\n...\n```\n",
   "t_cancel_callid": "### `t_cancel_callid(callid, cseq, flag [, rcode])`\n\nCancel first INVITE transaction identified by callid and cseq. It sets\nthe flag if the value is greater than zero\n\nParameters:.\n\n- *callid* - call-id value.\n\n- *cseq* - cseq number.\n\n- *flag* - index of the flag to set.\n\n- *rcode* - code to be added as cause attribute in Reason header for\n  generated CANCEL request. This parameter is optional.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nif (t_cancel_callid(\"123qaz\", \"5\", \"22\")) {\n    xlog(\"transaction cancelled\\n\");\n}\n...\nif (t_cancel_callid(\"123qaz\", \"5\", \"22\", \"200\")) {\n    xlog(\"transaction cancelled with [Reason: cause=200]\\n\");\n}\n...\n```\n",
   "t_reply_callid": "### `t_reply_callid(callid, cseq, code, reason)`\n\nSend reply to first transaction identified by callid and cseq.\n\nParameters:.\n\n- *callid* - call-id value.\n\n- *cseq* - cseq number.\n\n- *code* - reply code.\n\n- *reason* - reply reason.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nif (t_reply_callid(\"123qaz\", \"5\", \"458\", \"Replied remotely\")) {\n    xlog(\"transaction replied\\n\");\n}\n...\n```\n",
   "t_flush_flags": "### `t_flush_flags()`\n\nFlush the flags from current SIP message into the already created\ntransaction. It makes sense only in routing block if the transaction was\ncreated via t_newtran() and the flags have been altered since.\n\nIt is not needed to execute this function when using t_relay() (or\nsimilar tm relay functions, flags are synchronized automatically in that\ncase).\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nt_flush_flags();\n...\n```\n",
   "t_flush_xflags": "### `t_flush_xflags()`\n\nFlush the extended flags from current SIP message into the already\ncreated transaction. It makes sense only in routing block if the\ntransaction was created via t_newtran() and the extended flags have been\naltered since.\n\nIt is not needed to execute this function when using t_relay() (or\nsimilar tm relay functions, xflags are synchronized automatically in\nthat case).\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nt_flush_xflags();\n...\n```\n",
   "t_is_failure_route": "### `t_is_failure_route()`\n\nReturns true if the top-executed route block is failure_route.\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nfailure_route[xyz] {\n    route(abc);\n}\n\nroute[abc] {\n    if(t_is_failure_route()) { ... }\n}\n...\n```\n",
   "t_is_branch_route": "### `t_is_branch_route()`\n\nReturns true if the top-executed route block is branch_route.\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nbranch_route[xyz] {\n    route(abc);\n}\n\nroute[abc] {\n    if(t_is_branch_route()) { ... }\n}\n...\n```\n",
   "t_is_reply_route": "### `t_is_reply_route()`\n\nReturns true if the top-executed route block is reply_route.\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nreply_route[xyz] {\n    route(abc);\n}\n\nroute[abc] {\n    if(t_is_reply_route()) { ... }\n}\n...\n```\n",
   "t_is_request_route": "### `t_is_request_route()`\n\nReturns true if the top-executed route block is request_route.\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nrequest_route[xyz] {\n    route(abc);\n}\n\nroute[abc] {\n    if(t_is_request_route()) { ... }\n}\n...\n```\n",
   "t_suspend": "### `t_suspend()`\n\nSuspend the execution of SIP request in a transaction. If transaction\nwas not created yet, it is created by this function. Returns true in\ncase of success and internal transaction index and label are available\nvia $T(id_index) and $T(id_label).\n\nThis function can be used from ANY_ROUTE .\n\n```\n...\nif(t_suspend())\n{\n    xlog(\"processing suspended in transaction [$T(id_index):$T(id_label)]\\n\");\n    exit;\n}\n...\n```\n",
   "t_continue": "### `t_continue(tindex, tlabel, rtname)`\n\nContinue the execution of the transaction identified by tindex and\ntlabel with the actions defined in route[rtname].\n\nParameters:.\n\n- *tindex* - internal index of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *tlabel* - internal label of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *rtname* - the name of the route block to execute. Can be a static\n  string value or a dynamic string with pseudo-variables.\n\nImportant note: the route[rtname] is executed in the context of a\nfailure (same behaviour for functions as they were used in a\nfailure_route block).\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nt_continue('123', '456', 'MYROUTE');\n...\nroute[MYROUTE] {\n  xlog(\"executed by t continue\\n\");\n  ...\n}\n...\n```\n",
   "t_drop": "### `t_drop([rcode])`\n\nDrops the transaction with response code (500 default).\n\nParameters:.\n\n- *rcode* - response code to set in uas status.\n\nThis function can be used in ANY_ROUTE.\n\n```\n...\nroute[MYREQ]\n{\n...\n    if (!t_newtran()) {\n        xlog(\"L_ERROR\", \"$ci|log|failed to create transaction\\n\");\n        drop;\n    }\n\n    t_on_failure(\"TR_ERROR\");\n    t_on_reply(\"TR_OK\");\n    t_relay();\n}\n\nfailure_route[TR_ERROR]\n{\n    xlog(\"L_INFO\", \"$ci|log|failed $T_reply_code $T_reply_reason\\n\");\n    t_drop();\n}\n\nonreply_route[TR_OK]\n{\n   xlog(\"L_INFO\", \"$ci|log|checking transaction result\\n\");\n   if(status=~\"60[0-9]\") {\n      t_drop();\n   }\n...\n}\n...\n```\n",
   "t_reuse_branch": "### `t_reuse_branch()`\n\nCreates new \"main\" branch by making copy of branch-failure branch.\nCurrently the following branch attributes are copied from branch-failure\nbranch: request-uri, ruid, path, instance, and branch flags.\n\nThis function can be used from tm:branch-failure event_route.\n\n```\n...\nevent_route [tm:branch-failure:contact] {\n    t_reuse_branch();\n    setbflag(10);\n    t_relay();\n    exit;\n}\n...\n```\n",
   "t_precheck_trans": "### `t_precheck_trans()`\n\nCheck if current processed message is handled by other process. This\nfunction is useful to catch retransmissions before transaction is\ncreated. The function returns true if the request is handled by another\nprocess.\n\nNote that ACK and CANCEL requests are not tracked by this function, the\nreturn code being false for them.\n\nThis function can be used from REQUEST_ROUTE .\n\n```\n...\n    # handle retransmissions\n    if(t_precheck_trans()) {\n        t_check_trans();\n        exit;\n    }\n    t_check_trans();\n...\n```\n"
  }
 },
 "topoh": {
  "overview": "This module hides the SIP routing headers that show topology details. It\nis not affected by the server being transaction stateless or stateful.\nThe script interpreter gets the SIP messages decoded, so all existing\nfunctionality is preserved.\n\nThe module is transparent for the configuration writer. It only needs to\nbe loaded (tune the parameters if needed). The SIP server can be\nrestarted without affecting ongoing calls - once it is up, can\nencode/decode topology details, thus no call will be lost.\n\nBy using same mask_key, many SIP servers can decode the message, for\nexample, applicable for servers behind load balancers.\n",
  "parameters": {
   "mask_key": "### `mask_key` (str)\n\nKeyword to mask the headers.\n\n*Default value is \"_static_value_\".*\n\n```\n...\nmodparam(\"topoh\", \"mask_key\", \"some secret here\")\n...\n```\n",
   "mask_ip": "### `mask_ip` (str)\n\nIP address to be used in masked headers to build valid SIP URIs. Can be\nany IP address, even a private-space or non-existing IP address (e.g.,\n192.168.1.1, 127.0.0.2), including the SIP server address, but must not\nbe an address potentially used by clients. If set to empty string, the\nadvertised IP of the incoming or outgoing socket is used when specified,\notherwise the IP of the socket is used. Note that the value is actually\nnot used at all for SIP routing.\n\n*Default value is \"127.0.0.8\".*\n\n```\n...\nmodparam(\"topoh\", \"mask_ip\", \"192.168.0.1\")\n...\n```\n",
   "mask_callid": "### `mask_callid` (integer)\n\nWhether to encode the Call-id: header. Some SIP extensions include the\nCall-id in the SIP message payload or header, so it is safe to not\nencode Call-id in such cases. Well-known extensions such as call\ntransfer or conference join will be added to work with encoded Call-id.\n\nNOTE: if you are using dialog module to terminate calls and this\nparameter is enabled, you must set the dialog module parameter\n'lreq_callee_headers' to include the header: 'TH: dlh\\r\\n'.\n\n*Default value is 0 (do not mask).*\n\n```\n...\nmodparam(\"topoh\", \"mask_callid\", 1)\n...\n```\n",
   "mask_mode": "### `mask_mode` (integer)\n\nControl when and what parts of SIP message are masked.\n\nIt works as a bitmask value. The following options are available: (1) -\nskip masking Contact headers in 3XX (redirect) replies.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"topoh\", \"mask_mode\", 1)\n...\n```\n",
   "uparam_name": "### `uparam_name` (str)\n\nName of URI parameter where to store encoded value.\n\n*Default value is \"line\".*\n\n```\n...\nmodparam(\"topoh\", \"uparam_name\", \"myparam\")\n...\n```\n",
   "uparam_prefix": "### `uparam_prefix` (str)\n\nPrefix to be added in encoded URI parameters.\n\n*Default value is \"sr-\".*\n\n```\n...\nmodparam(\"topoh\", \"uparam_prefix\", \"xyz\")\n...\n```\n",
   "vparam_name": "### `vparam_name` (str)\n\nName of Via: parameter used to store encoded value.\n\n*Default value is \"branch\".*\n\n```\n...\nmodparam(\"topoh\", \"vparam_name\", \"myv\")\n...\n```\n",
   "vparam_prefix": "### `vparam_prefix` (str)\n\nPrefix to be added in encoded Via: parameters.\n\n*Default value is \"z9hG4bKsr-\".*\n\n```\n...\nmodparam(\"topoh\", \"vparam_prefix\", \"xyz\")\n...\n```\n",
   "callid_prefix": "### `callid_prefix` (str)\n\nPrefix to be added in encoded Call-ID: headers.\n\n*Default value is \"!!:\".*\n\n```\n...\nmodparam(\"topoh\", \"callid_prefix\", \"***\")\n...\n```\n",
   "sanity_checks": "### `sanity_checks` (integer)\n\nIf set to 1, topoh module will bind to sanity module in order to perform\nsanity checks over received SIP request. Default sanity checks are done.\nIt is useful to check if received request is well formatted before\nproceeding to encoding/decoding.\n\n*Default value is 0 (do not bind to sanity module).*\n\n```\n...\nmodparam(\"topoh\", \"sanity_checks\", 1)\n...\n```\n",
   "uri_prefix_checks": "### `uri_prefix_checks` (integer)\n\nIf set to 1, topoh module will check if URIs to be decoded match the\nexpected prefix composed from mask IP and parameter name prefix. It can\nmake the topoh processing safer by avoiding to try decoding URIs which\nwere not encoded previously by topoh.\n\nNote: do not enable this option if you have SIP devices that can alter\nthe URI values it takes from Contact or Record-Route headers (like\nadding port 5060 when no port is in received URIs, or that introduces\nnew parameters at an unknown position).\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"topoh\", \"uri_prefix_checks\", 1)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the KEMI configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"topoh\", \"event_callback\", \"ksr_topoh_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_topoh_event(evname)\n    KSR.info(\"===== topoh module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "event_mode": "### `event_mode` (int)\n\nControl what event_route blocks to be executed. It is a bitmask of: 1 -\nexecute event_route[topoh:msg-outgoing]; 2 - execute\nevent_route[topoh:msg-sending].\n\n*Default value is 3 (execute both event_route blocks).*\n\n```\n...\nmodparam(\"topoh\", \"event_mode\", 2)\n...\n```\n",
   "use_mode": "### `use_mode` (int)\n\nControl how the module is initialized. If set to 1, the module is only\ninitialized to be used as a library via inter-module API functions. If\nset to 0, the module is initialized for SIP messages processing.\n\n*Default value is 0 (to process SIP messages).*\n\n```\n...\nmodparam(\"topoh\", \"use_mode\", 1)\n...\n```\n"
  },
  "functions": {}
 },
 "topos": {
  "overview": "This module offers topology hiding for INVITE-based dialogs, by\nstripping the SIP routing headers that show topology details . The\nscript interpreter gets the SIP messages with full content, so all\nexisting functionality is preserved.\n\nThe module is transparent for the configuration writer. It only needs to\nbe loaded (tune the module parameters if needed).\n\nIt also works for SIP MESSAGE or other requests that do not create a\ndialog (e.g., OPTIONS) -- record_route() must be used for them as well,\nthe headers are not going to be in the messages sent to the network,\nthey are needed to know local addresses used to communicate with each\nside. This module is designed to work for presence (SUBSCRIBE-based)\ndialogs too.\n\nThe REGISTER and PUBLISH requests are skipped from processing by this\nmodule, expected to be terminated on a local SIP server.\n",
  "parameters": {
   "storage": "### `storage` (str)\n\nType of storage, valid types are:\n\n- *db* - Database Backend\n\n- *redis* - Redis Backend\n\n*Default value is \u201cdb\u201d.*\n\n```\n...\nmodparam(\"topos\", \"storage\", \"redis\")\n...\n```\n",
   "db_url": "### `db_url` (str)\n\nDatabase URL.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"topos\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "mask_callid": "### `mask_callid` (int)\n\nWhether to encode the Call-id: header. Some SIP extensions include the\nCall-id in the SIP message payload or header, so it is safe to not\nencode Call-id in such cases. Well-known extensions such as call\ntransfer or conference join will be added to work with encoded Call-id.\nTopoh module should be loaded with use_mode parameter set to 1\n\n*Default value is 0 (do not mask).*\n\n```\n...\nmodparam(\"topos\", \"mask_callid\", 1)\n...\n```\n",
   "sanity_checks": "### `sanity_checks` (int)\n\nIf set to 1, topos module will bind to sanity module in order to perform\nsanity checks over received SIP request. Default sanity checks are done.\nIt is useful to check if received request is well formatted before\nproceeding to encoding/decoding.\n\n*Default value is 0 (do not bind to sanity module).*\n\n```\n...\nmodparam(\"topos\", \"sanity_checks\", 1)\n...\n```\n",
   "branch_expire": "### `branch_expire` (int)\n\nInterval in seconds after which the branch records are deleted.\n\n*Default value is 180 (3 min).*\n\n```\n...\nmodparam(\"topos\", \"branch_expire\", 300)\n...\n```\n",
   "dialog_expire": "### `dialog_expire` (int)\n\nInterval in seconds after which the dialog records are deleted. Keep in\nmind that the module does not update the dialog timestamp after the\ninitial call setup on re-INVITEs or other in-dialog messages. So set a\nlarge enough value (according your longest call duration) to prevent\nproblems in re-writing messages. This key is only relevant for INVITE\ndialog. SUBSCRIBE dialog records lifetime are based on value set in\nexpires header. Moreover each re-SUBSCRIBEs update the dialog timestamp.\n\n*Default value is 10800 (3 hours).*\n\n```\n...\nmodparam(\"topos\", \"dialog_expire\", 3600)\n...\n```\n",
   "clean_interval": "### `clean_interval` (int)\n\nInterval in seconds to run the clean up of stored records.\n\n*Default value is 60 (1 min).*\n\n```\n...\nmodparam(\"topos\", \"clean_interval\", 30)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the KEMI configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks.\n\nThe function receives a string parameter with the name of the event.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"topos\", \"event_callback\", \"ksr_topos_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_topos_event(evname)\n    KSR.info(\"===== topos module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "event_mode": "### `event_mode` (int)\n\nControl what event_route blocks to be executed. It is a bitmask of: 1 -\nexecute event_route[topos:msg-outgoing]; 2 - execute\nevent_route[topos:msg-sending]; 4 execute\nevent_route[topos:msg-incoming]; 8 execute\nevent_route[topos:msg-receiving];.\n\n*Default value is 3 (execute both event_route blocks).*\n\n```\n...\nmodparam(\"topos\", \"event_mode\", 2)\n...\n```\n",
   "contact_host": "### `contact_host` (str)\n\nYou may need to control the host part of the Contact header added by\ntopos. If the xavu_field_contact_host parameter is set, this value is\nignored. For example when using TLS with TOPOS the remote UAS must be\nable to open a new TLS socket to the contact header. In this case, the\ncontact header must contain a domain name with a trusted CA signed\ncertitificate.\n\n*Default value is taken from the Record-Route URI.*\n\n```\n...\nmodparam(\"topos\", \"contact_host\", \"proxy.domain.com\")\n...\n```\n",
   "contact_mode": "### `contact_mode` (int)\n\nControl the mode where the key to lookup the message data from the\ndatabase or redis server is stored. The default is to use the Contact\nuser (0), alternatively a Contact URI parameter can be used (1) with\nvalues from the SIP message, or from AVP variables (2). This can be\nuseful for interoperating which gateways that need a certain user part\nin the Contact URI.\n\nIn mode (1) the a-side contact user is taken from the request URI and\nthe b-side contact user from the Contact header of the processed initial\nSIP request.\n\nIf you use the mode (2), you need to configure the\n*xavu_field_a_contact* and *xavu_field_b_contact* parameter. Furthermore\nyou need to assign values to them during the processing of the initial\nSIP request.\n\nThe name of the Contact URI parameter can be customized with the\n*cparam_name* parameter.\n\n*Default value is 0 - use the Contact user*\n\n```\n...\nmodparam(\"topos\", \"contact_mode\", 1)\n...\n```\n",
   "cparam_name": "### `cparam_name` (int)\n\nName of the Contact URI parameter to store the database or redis server\nkey for message lookup.\n\nThis parameter is only used when the *contact_mode* parameter is set to\n*1* or *2*.\n\n*Default value is \u201ctps\u201d.*\n\n```\n...\nmodparam(\"topos\", \"cparam_name\", \"xyz\")\n...\n```\n",
   "xavu_cfg": "### `xavu_cfg` (str)\n\nName of root XAVU to hold config-specific values to be used by module at\nruntime.\n\nNote: this parameter must be set if any other parameter prefixed with\n`xavu_field_` is used.\n\n*Default value is \u201cNULL\u201d (disabled).*\n\n```\n...\nmodparam(\"topos\", \"xavu_cfg\", \"_tps_\")\nmodparam(\"topos\", \"xavu_field_a_contact\", \"a_contact\")\n...\n    $xavu(_tps_=>a_contact) = \"...\";\n...\n```\n",
   "xavu_field_a_contact": "### `xavu_field_a_contact` (str)\n\nName of the field inside root XAVU specified by `xavu_cfg` to evaluate\nfor the A-side Contact Header user part. This parameter is only\nnecessary in contact_mode (2).\n\n*Default value is \u201cNULL\u201d (disabled).*\n\n```\n...\nmodparam(\"topos\", \"xavu_cfg\", \"_tps_\")\nmodparam(\"topos\", \"xavu_field_a_contact\", \"a_contact\")\n...\n    $xavu(_tps_=>a_contact) = \"...\";\n...\n```\n",
   "xavu_field_b_contact": "### `xavu_field_b_contact` (str)\n\nName of the field inside root XAVU specified by `xavu_cfg` to evaluate\nfor the B-side Contact Header user part. This parameter is only\nnecessary in contact_mode (2).\n\n*Default value is \u201cNULL\u201d (disabled).*\n\n```\n...\nmodparam(\"topos\", \"xavu_cfg\", \"_tps_\")\nmodparam(\"topos\", \"xavu_field_b_contact\", \"b_contact\")\n...\n    $xavu(_tps_=>b_contact) = \"...\";\n\n...\n```\n",
   "xavu_field_contact_host": "### `xavu_field_contact_host` (str)\n\nControl from where to take the host part of the Contact header added by\ntopos. This parameter allows to take the value from an XAVU during\nrun-time, it specifies the field inside XAVU \"xavu_cfg\". If this\nparameter is set, the contact_host parameter is ignored. For example\nwhen using TLS with TOPOS the remote UAS must be able to open a new TLS\nsocket to the contact header. In this case, the contact header must\ncontain a domain name with a trusted CA signed certitificate.\n\n*Default value is empty, not set.*\n\n```\n...\nmodparam(\"topos\", \"xavu_cfg\", \"_tps_\")\nmodparam(\"topos\", \"xavu_field_contact_host\", \"contact_host\")\n...\n    $xavu(_tps_=>contact_host) = \"kamailio.org\";\n...\n```\n",
   "rr_update": "### `rr_update` (int)\n\nIf set to 1, topos module will track and update record route changes on\nre-invite.\n\n*Default value is 0 (do not update record route changes within dialog).*\n\n```\n...\nmodparam(\"topos\", \"rr_update\", 1)\n...\n```\n",
   "context": "### `context` (str)\n\nSet the global context for topos instance.\n\nThe value has to be maximum 12 characters.\n\n*Default value is \u201cNULL\u201d (disabled).*\n\n```\n...\nmodparam(\"topos\", \"context\", \"srvone\")\n...\n```\n",
   "methods_nocontact": "### `methods_nocontact` (str)\n\nList of SIP methods to skip adding Contact header for.\n\n*Default value is \u201cBYE,CANCEL,PRACK\u201d.*\n\n```\n...\nmodparam(\"topos\", \"methods_nocontact\", \"CANCEL,PRACK\")\n...\n```\n",
   "header_mode": "### `header_mode` (int)\n\nList of headers to disable multiple comma separated values inserted in\ncompact form. Altough compact form is RFC compliant this paramter gives\npossibilty to disable compact form header values for UA that don't\nsupport or can't handle it. The following options are available: (1) -\ndisable multiple comma separated values for Via header (2) - disable\nmultiple comma separated values for Record-Route header (4) - disable\nmultiple comma separated values for Route header\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"topos\", \"header_mode\", 1)\n...\n```\n",
   "methods_noinitial": "### `methods_noinitial` (str)\n\nList of SIP methods to skip doing topos if it is an initial request (no\nTo-tag).\n\n*Default value is \u201c\u201d (no method).*\n\n```\n...\nmodparam(\"topos\", \"methods_noinitial\", \"OPTIONS,NOTIFY\")\n...\n```\n",
   "version_table": "### `version_table` (integer)\n\nIf set to 0, the module will skip checking the version of the tables.\n\nDefault value is \u201c1 (check for table version)\u201d.\n\n```\n...\nmodparam(\"topos\", \"version_table\", 0)\n...\n        \n```\n"
  },
  "functions": {
   "tps_set_context": "### `tps_set_context(ctx)`\n\nUpdate the context at runtime. If the value is emtpy string, then the\nruntime context is reset.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nrequest_route {\n    ...\n    tps_set_context(\"srvone\");\n    ...\n}\n...\n```\n"
  }
 },
 "topos_redis": {
  "overview": "This module offers REDIS storage support for TOPOS module.\n",
  "parameters": {
   "serverid": "### `serverid` (str)\n\nThe name of the REDIS server to be used as provided to the 'name'\nattribute of 'server' parameter for NDB_REDIS module.\n\nThe 'storage' parameter for TOPOS module must be set to 'redis'.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\n# ----- ndb_redis params -----\nmodparam(\"ndb_redis\", \"server\", \"name=srv8;addr=127.0.0.1;port=6379;db=8\")\n\n# ----- topos params -----\nmodparam(\"topos\", \"storage\", \"redis\")\n\n# ----- topos_redis params -----\nmodparam(\"topos_redis\", \"serverid\", \"srv8\")\n...\n```\n"
  },
  "functions": {}
 },
 "tsilo": {
  "overview": "This module provides transaction storage for the Kamailio SIP Server\nPlatform. It stores in an internal table transactions for a Request-URI\n(R-URI) and adds branches to them later if new contacts for the AOR are\nadded.\n\nFor each message, the module stores \u201cRequest-URI\u201d (\u201cR-URI\u201d), URI and the\ninternal transaction index and label.\n\nWhen a transaction is destroyed by the *TM* module, it is removed from\nthe module's table too.\n",
  "parameters": {
   "hash_size": "### `hash_size` (integer)\n\nThe size of the hash table internally used to keep the transaction. A\nlarger table is much faster but consumes more memory. The hash size must\nbe a power of two, otherwise it will be rounded down to the nearest\npower of two.\n\n*Default value is \u201c2048\u201d.*\n\n```\n...\nmodparam(\"tsilo\", \"hash_size\", 1024)\n...\n```\n",
   "use_domain": "### `use_domain` (integer)\n\nSpecify if the domain part of the URI should be also saved and used for\nstoring and retrieving users' transactions. Useful in multi domain\nscenarios. Non 0 value means true.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"tsilo\", \"use_domain\", 1)\n...\n```\n"
  },
  "functions": {
   "ts_store": "### `ts_store([uri])`\n\nThe method stores uri, tindex and tlabel of the current transaction. If\nthe uri parameter is missing, then the value is taken from r-uri. The\nuri parameter can contain variables.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (is_method(\"INVITE\")) {\n    if (t_newtran()) {\n        ts_store();\n        # ts_store(\"sip:alice@$td\");\n    }\n}\n...\n```\n",
   "ts_append": "### `ts_append(domain, ruri)`\n\nThe method add branches to all the stored transactions for the SIP ruri\npassed as parameter, performing a contact lookup on the table specified\nby the domain parameter. The method should be called when a REGISTER\nrequest is received.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for looking up new\n  contacts for r-uri.\n\n- *ruri* - The r-uri for which we want to check existing transactions\n  and add them new branches. Can be a static string value or a dynamic\n  string with pseudo-variables.\n\nReturn codes:\n\n- *1* - branches added.\n\n  *-1* - an internal error has produced (parsing error, memory error).\n\n  *-2* - no records found for the r-uri.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (is_method(\"REGISTER\")) {\n    ts_append(\"location\", \"$tu\");\n}\n...\n```\n",
   "ts_append_by_contact": "### `ts_append_by_contact(domain, ruri [, contact])`\n\nHas almost the same intention as the ts_append(), but gives a\npossibility to append branches only for a specific location record\n(Contact URI). The contact's URI value can be either taken from the\ncurrently processed REGISTER or (optionally) given as a third parameter.\nIf the Contact URI for a lookup is given as the parameter, it is\npossible to provide it as a pseudo-variable. The contact lookup is\nperformed on the table specified by the domain parameter. The method\nshould be called when a REGISTER request is received.\n\nMeaning of the parameters is as follows:\n\n- *domain* - Name of table that should be used for looking up new\n  contacts for r-uri.\n\n- *ruri* - The r-uri for which we want to check existing transactions\n  and add them new branches. Can be a static string value or a dynamic\n  string with pseudo-variables.\n\n- *contact* - Optional, a value of the location record (contact URI)\n  based on which to perform the branch appending. If not given, the\n  value will be taken from the currently processed REGISTER. If a\n  location lookup based on this Contact URI fails (no location record\n  found), then the branch append will not happen.\n\nReturn codes:\n\n- *1* - branches added.\n\n  *-1* - an internal error has produced (parsing error, memory error).\n\n  *-2* - no records found for the r-uri.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (is_method(\"REGISTER\")) {\n    $var(formatted_ct) = $(x_hdr(Contact){nameaddr.uri});\n    ts_append_by_contact(\"location\", \"$tu\", \"$var(formatted_ct)\");\n}\n...\n```\n",
   "ts_append_to": "### `ts_append_to(tindex, tlabel, domain, [uri])`\n\nThe method add branches to the transaction identified by tindex and\ntlabel, performing a contacts lookup on the table specified by the\ndomain parameter. The method should be called when a REGISTER request is\nreceived.\n\nMeaning of the parameters is as follows:\n\n- *tindex* - internal index of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *tlabel* - internal label of transaction. Can be an integer or a\n  pseudo-variable.\n\n- *domain* - Name of table that should be used for looking up new\n  contacts for r-uri.\n\n- *uri* (optional) - uri for which to do lookup for new destinations.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE.\n\n```\n...\nif (is_method(\"REGISTER\")) {\n    $var(tindex) = ...\n    $var(tlabel) = ...\n    ts_append_to(\"$var(tindex)\", \"$var(tlabel)\", \"location\");\n}\n...\n```\n"
  }
 },
 "uac": {
  "overview": "The UAC (User Agent Client) module provides some basic UAC\nfunctionalities like sending SIP requests, registering with a remote\nservice, From: header manipulation (anonymization) and client\nauthentication.\n\nThe UAC module also supports sending a SIP request from the\nconfiguration file. See variable $uac_req(name) and the function\nuac_req_send().\n\nIn addition, the module supports database-driven SIP registration\nfunctionality. See the uac_reg_lookup() function and dedicated section\nfor remote registration configuration.\n\nKnown limitations in this version:\n\n- Authentication does not support qop auth-int, just qop auth;\n\n- CSeq is not increased automatically by uac_auth() during\n  authentication - the follow up request may be rejected. CSeq can be\n  increased when authenticating INVITE requests - dialog module has to\n  be used, with CSeq tracking feature enabled (see the readme of dialog\n  module).\n\n- The \u201cuac_replace_*\u201d functions can only be run once on the same SIP\n  request. Try to save needed changes in a pseudovariable and apply them\n  once.\n\n  There is also a limitation regarding the use of the\n  \u201cmsg_apply_changes()\u201d function together with the \u201cuac_replace_*\u201d\n  functions for messages that are loose-routed (e.g. Re-INVITE\n  requests). In this case you need to call the \u201cloose_route()\u201d function\n  after the replace and msg_apply_changes. Otherwise Kamailio can create\n  replies with wrong From/To headers (e.g. for the 100 - Trying reply in\n  the Re-INVITE example).\n",
  "parameters": {
   "rr_from_store_param": "### `rr_from_store_param` (string)\n\nName of Record-Route header parameter that will be used to store an\nencoded version of the original FROM URI.\n\n*The default value is \u201cvsf\u201d.*\n\n```\n...\nmodparam(\"uac\",\"rr_from_store_param\",\"my_param\")\n...\n                \n```\n",
   "rr_to_store_param": "### `rr_to_store_param` (string)\n\nName of Record-Route header parameter that will be used to store\n(encoded) the original TO URI.\n\n*The default value is \u201cvst\u201d.*\n\n```\n...\nmodparam(\"uac\",\"rr_to_store_param\",\"my_param\")\n...\n                \n```\n",
   "restore_mode": "### `restore_mode` (string)\n\nThere are 3 modes of restoring the original FROM URI and the original TO\nURI:\n\n- \u201cnone\u201d - no information about original URI is stored; restoration is\n  not possible.\n\n- \u201cmanual\u201d - all following replies will be restored, but not also the\n  sequential requests - this must be manually updated based on original\n  URI.\n\n- \u201cauto\u201d - all sequential requests and replies will be automatically\n  updated based on stored original URI. For this option you have to set\n  \u201cmodparam(\"rr\", \"append_fromtag\", 1)\u201d.\n\n*The default value is \u201cauto\u201d.*\n\n```\n...\nmodparam(\"uac\",\"restore_mode\",\"auto\")\n...\n                \n```\n",
   "restore_dlg": "### `restore_dlg` (int)\n\nIf set to 1, the module uses dialog variables to store initial and new\nvalues for From/To headers. The Dialog module has to be loaded and all\ncalls that involve changes to From/To headers must be tracked.\n\n*Default value of this parameter is 0.*\n\n```\n...\nmodparam(\"uac\", \"restore_dlg\", 1)\n...\n                \n```\n",
   "restore_passwd": "### `restore_passwd` (string)\n\nString password to be used to encrypt the RR storing parameters. If\nempty, no encryption will be used.\n\n*Default value of this parameter is empty.*\n\n```\n...\nmodparam(\"uac\",\"restore_passwd\",\"my_secret_passwd\")\n...\n                \n```\n",
   "restore_from_avp": "### `restore_from_avp` (string)\n\nIf defined and restore_mode is manual or auto, the avp is used to save\nthe original from uri in order to be able to restore it in replies. That\nmakes sense, if the original-uri can not be extracted from the original\nrequest, e.g. if msg_apply_changes() was used after calling\nuac_replace_from() or uac_replace_to().\n\nIf you create a dialog ( with dlg_manage() ) before calling\nuac_replace_from(), this avp will not be needed. The values of the uris\nwill be stored as dialog variables.\n\n*Default value of this parameter is empty.*\n\n```\n...\nmodparam(\"uac\",\"restore_from_avp\",\"$avp(original_uri_from)\")\n...\n                \n```\n",
   "restore_to_avp": "### `restore_to_avp` (string)\n\nIf defined and restore_mode is manual or auto, the avp is used to save\nthe original To URI in order to be able to restore it in replies. That\nmakes sense if the original-uri can not be extracted from the original\nrequest, e.g. if msg_apply_changes() was used after calling\nuac_replace_to()\n\nIf you create a dialog ( with dlg_manage() ) before calling or\nuac_replace_to(), this avp will not be needed. The values of the uris\nwill be stored as dialog variables.\n\n*Default value of this parameter is empty.*\n\n```\n...\nmodparam(\"uac\",\"restore_to_avp\",\"$avp(original_uri_to)\")\n...\n                \n```\n",
   "credential": "### `credential` (string)\n\nContains a multiple definition of credentials used to perform\nauthentication.\n\n*This parameter is required if UAC authentication is used.*\n\n```\n...\nmodparam(\"uac\",\"credential\",\"username:domain:password\")\n...\n                \n```\n",
   "auth_realm_avp": "### `auth_realm_avp` (string)\n\nThe definition of a PV that might contain the realm to be used to\nperform authentication.\n\nWhen the PV value is an empty string or NULL when uac_auth() is called,\nthe realm is taken from the reply and only username matching is done.\nThis can be used if the realm upstream will be using is not known in\nadvance.\n\n*If you define it, you also need to define \u201cauth_username_avp\u201d ([\n(string)](#uac.p.auth_username_avp)) and \u201cauth_password_avp\u201d ([\n(string)](#uac.p.auth_password_avp)).*\n\n```\n...\nmodparam(\"uac\",\"auth_realm_avp\",\"$avp(arealm)\")\n...\n                \n```\n",
   "auth_username_avp": "### `auth_username_avp` (string)\n\nThe definition of an AVP that might contain the username to be used to\nperform authentication.\n\n*If you define it, you also need to define \u201cauth_realm_avp\u201d ([\n(string)](#uac.p.auth_realm_avp)) and \u201cauth_password_avp\u201d ([\n(string)](#uac.p.auth_password_avp)).*\n\n```\n...\nmodparam(\"uac\",\"auth_username_avp\",\"$avp(auser)\")\n...\n                \n```\n",
   "auth_password_avp": "### `auth_password_avp` (string)\n\nThe definition of an AVP that might contain the password to be used to\nperform authentication.\n\n*If you define it, you also need to define \u201cauth_realm_avp\u201d ([\n(string)](#uac.p.auth_realm_avp)) and \u201cauth_username_avp\u201d ([\n(string)](#uac.p.auth_username_avp)).*\n\n```\n...\nmodparam(\"uac\",\"auth_password_avp\",\"$avp(apasswd)\")\n...\n                \n```\n",
   "reg_db_url": "### `reg_db_url` (string)\n\nDB URL to fetch account profiles for registration. This parameter must\nbe set in order to enable remote registrations feature.\n\nThe default value is \"\" (no value).\n\n```\n...\nmodparam(\"uac\", \"reg_db_url\",\n    \"mysql://kamailio:kamailiorw@localhost/kamailio\")\n...\n                \n```\n",
   "reg_timer_interval": "### `reg_timer_interval` (int)\n\nTimer interval (in seconds) at which registrations are managed, e.g.\nrenewed as needed.\n\n*The default value is 90 seconds.*\n\n```\n...\nmodparam(\"uac\", \"reg_timer_interval\", 60)\n...\n                \n```\n",
   "reg_retry_interval": "### `reg_retry_interval` (int)\n\nFailed registration attempts will be retried after this interval (in\nseconds). The interval is not exact, retries may be attempted as much as\nreg_timer_interval secs earlier. If set to 0, failed registrations will\nbe disabled permanently.\n\nThe default value is 0 sec (disabled)\n\n```\n...\nmodparam(\"uac\", \"reg_retry_interval\", 300)\n...\n                \n```\n",
   "reg_random_delay": "### `reg_random_delay` (int)\n\nSet a random reg_delay for each registration that has reg_delay set to 0\nin the database. If set to 0, randomization will be disabled.\n\nThe default value is 0 sec (disabled)\n\n```\n...\nmodparam(\"uac\", \"reg_random_delay\", 300)\n...\n                \n```\n",
   "reg_hash_size": "### `reg_hash_size` (int)\n\nThe number of entries of the hash table used by uac_reg to store the\nregistration records is 2^hash_size. For hash_size=4, the number of\nslots of the hash table is 16.\n\n*Default value is \u201c4\u201d (16 slots).*\n\n```\n...\nmodparam(\"uac\", \"reg_hash_size\", 10)\n...\n                \n```\n",
   "reg_db_table": "### `reg_db_table` (string)\n\nDB table name to fetch user profiles for registration.\n\n*The default value is \u201cuacreg\u201d.*\n\n```\n...\nmodparam(\"uac\", \"reg_db_table\", \"uacreg\")\n...\n                \n```\n",
   "reg_contact_addr": "### `reg_contact_addr` (string)\n\nAddress to be used to build contact address. Must be at least host part,\ncan have port and parameters. Must not include 'sip:'. The username part\nof the Contact: URI will be the L_UUID field in the database.\n\nA contact_addr value in the uacreg table will override the parameter for\nthis particular entry.\n\n```\n...\nmodparam(\"uac\", \"reg_contact_addr\", \"192.168.1.2:5080\")\n...\n                \n```\n",
   "reg_keep_callid": "### `reg_keep_callid` (int)\n\nIf set to 0 (default), a new Call-Id will be generated for each\nregistration attempt. If set to non-zero, the same Call-Id will be used\nfor re-registrations, as recommended by RFC3261 section 10.2.4. A new\nCall-Id will be generated when a previous registration had failed.\n\n```\n...\nmodparam(\"uac\", \"reg_keep_callid\", 1)\n...\n                \n```\n",
   "reg_active": "### `reg_active` (int)\n\nIf set to 0, no remote regisrations are done. In other words, it can\ncontrol at once if the module should do remote registrations or not. It\ncan be changed at runtime via rpc command 'uac.reg_active 0|1'.\n\nThe default value is 1 (active).\n\n```\n...\nmodparam(\"uac\", \"reg_active\", 0)\n...\n                \n```\n",
   "reg_gc_interval": "### `reg_gc_interval` (int)\n\nTimer interval (in seconds) at which remote registrations are cleaned up\nin case of failure or removed. When setting it take in consideration the\nmaximum value for retransmission timeout, this param should be greater\nthan it. This value also impacts how often the reload for remote\nregistrations table can be executed -- the RPC command will fail if\nexecuted in less than reg_gc_interval value since the last reload.\n\n*The default value is 150 seconds.*\n\n```\n...\nmodparam(\"uac\", \"reg_gc_interval\", 60)\n...\n                \n```\n",
   "reg_use_domain": "### `reg_use_domain` (int)\n\nIf set to 1, domain part of URIs is used by functions doing lookup on\nuser name.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"uac\", \"reg_use_domain\", 1)\n...\n                \n```\n",
   "default_socket": "### `default_socket` (str)\n\nDefault socket to be used for generating registration requests and\nsending requests with the function uac_req_send(). Useful e.g. when\nseveral public interfaces are available.\n\nA send socket in the $uac_reg variable used together with the\nuac_req_send() function will override this parameter. A socket value in\nthe uacreg table will also override the parameter for this particular\nentry.\n\n*By default no default socket is defined, the send socket is choosen\nfrom the \u201ctm\u201d module when the requests is sent out.*\n\nIf you want to force a certain TCP port (e.g. 5060), you will need to\nset the *tcp_reuse_port=yes* core parameter as well.\n\n```\n ...\n modparam(\"uac\", \"default_socket\", \"udp:192.168.0.125:5060\")\n ...\n \n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[uac:reply] block.\n\nThe function receives a string parameter with the name of the event, the\nvalue can be: 'uac:reply'.\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n ...\nmodparam(\"uac\", \"event_callback\", \"ksr_uac_event\")\n\nfunction ksr_uac_event(evname)\n    KSR.info(\"===== uac module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n ...\n \n```\n"
  },
  "functions": {
   "uac_replace_from": "### `uac_replace_from(uri)`\n\nReplace in FROM header the *URI* part without altering the display name.\n\n*URI* parameter can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE and from BRANCH_ROUTE.\n\n```\n...\nuac_replace_from(\"sip:batman@gotham.org\");\n...\n                \n```\n",
   "uac_restore_from": "### `uac_restore_from()`\n\nThis function will check if the FROM URI was modified and will use the\ninformation stored in header parameter to restore the original FROM URI\nvalue.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nuac_restore_from();\n...\n                \n```\n",
   "uac_replace_to": "### `uac_replace_to(uri)`\n\nReplace in TO header the *URI* part without altering the display name.\n\n*URI* parameter can include pseudo-variables.\n\nThis function can be used from REQUEST_ROUTE and from BRANCH_ROUTE.\n\nIf you set restore_mode to AUTO, the URI will be modified automatically\nin all subsequent requests and replies in that dialog.\n\nThere are two ways in which the AUTO mode can be achieved.\n\nOne uses the rr module and appends to the Record-Route header a\nparameter containing some strings from which the original and new URI\ncan be computed. The problem with this mode is that it relies on the\nfact the parties will send the Route exactly as it was received. In case\nthere is a change, the resulting URIs will not be correct.\n\nThe other one uses the dialog module to store the original and new URI.\nIf you already use dialog module in your configuration, this is the\nadvisable mode. All you need to do to use this is to call dlg_manage()\nbefore calling uac_replace_to(). It works by storing the URIs as dialog\nvariables and registering callbacks in dialog module for in dialog\nrequests.\n\n```\n...\nuac_replace_to(\"sip:batman@gotham.org\");\n...\n                \n```\n",
   "uac_restore_to": "### `uac_restore_to()`\n\nThis function will check if the TO URI was modified and will use the\ninformation stored in header parameter to restore the original TO URI\nvalue.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nuac_restore_to();\n...\n                \n```\n",
   "uac_auth": "### `uac_auth([mode])`\n\nThis function can be called only from failure route and will build the\nauthentication response header and insert it into the request without\nsending anything.\n\nIf mode is set to 1, then the password has to be provided in HA1 format.\nThe parameter can be a static integer or a variable holding an integer\nvalue.\n\nThis function can be used from FAILURE_ROUTE and BRANCH_FAILURE_ROUTE\nevent route.\n\n```\n...\nmodparam(\"uac\",\"auth_username_avp\",\"$avp(auser)\")\nmodparam(\"uac\",\"auth_password_avp\",\"$avp(apass)\")\nmodparam(\"uac\",\"auth_realm_avp\",\"$avp(arealm)\")\n\nrequest_route {\n   ...\n   if(is_method(\"INVITE\")) {\n      t_on_failure(\"TRUNKAUTH\");\n   }\n   ...\n}\n\nfailure_route[TRUNKAUTH] {\n\n    if (t_is_canceled()) {\n        exit;\n    }\n    if(t_check_status(\"401|407\")) {\n        $avp(auser) = \"test\";\n        $avp(apass) = \"test\";\n        # $avp(apass) = \"36d0a02793542b4961e8348347236dbf\";\n        # if (uac_auth(\"1\")) {\n        if (uac_auth()) {\n            t_relay();\n        }\n        exit;\n    }\n}\n...\n                \n```\n",
   "uac_auth_mode": "### `uac_auth_mode(vmode)`\n\nThis function can be called only from failure route and will build the\nauthentication response header and insert it into the request without\nsending anything.\n\nIf mode is set to 1, then the password has to be provided in HA1 format.\nThe parameter can be a static integer or a variable holding an integer\nvalue.\n\nThis function can be used from FAILURE_ROUTE and BRANCH_FAILURE_ROUTE\nevent route.\n\n```\n...\nmodparam(\"uac\",\"auth_username_avp\",\"$avp(auser)\")\nmodparam(\"uac\",\"auth_password_avp\",\"$avp(apass)\")\nmodparam(\"uac\",\"auth_realm_avp\",\"$avp(arealm)\")\n\nrequest_route {\n   ...\n   if(is_method(\"INVITE\")) {\n      t_on_failure(\"TRUNKAUTH\");\n   }\n   ...\n}\n\nfailure_route[TRUNKAUTH] {\n\n    if (t_is_canceled()) {\n        exit;\n    }\n    if(t_check_status(\"401|407\")) {\n        $avp(auser) = \"test\";\n        $avp(apass) = \"test\";\n        # $avp(apass) = \"36d0a02793542b4961e8348347236dbf\";\n        if (uac_auth_mode(\"1\")) {\n            t_relay();\n        }\n        exit;\n    }\n}\n...\n                \n```\n",
   "uac_req_send": "### `uac_req_send()`\n\nThis function sends a SIP message from the configuration file. The\nmessage is built out of $uac_req(...) pseudo-variable.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE, ONREPLY_ROUTE, LOCAL_ROUTE.\n\n```\n...\n$uac_req(method)=\"OPTIONS\";\n$uac_req(ruri)=\"sip:kamailio.org\";\n$uac_req(furi)=\"sip:kamailio.org\";\n$uac_req(turi)=\"sip:kamailio.org\";\n$uac_req(callid)=$(mb{s.md5});\nuac_req_send();\n...\n                \n```\n",
   "uac_reg_lookup": "### `uac_reg_lookup(uuid, dst)`\n\nThis function sets the PV dst to SIP URI that correspond to uuid in uac\nregistrations table. uuid and dst must be pseudo-variables.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n\nif(uac_reg_lookup(\"$rU\", \"$ru\"))\n{\n    lookup(\"location\");\n}\n...\n                \n```\n",
   "uac_reg_lookup_uri": "### `uac_reg_lookup_uri(uri, dst)`\n\nThis function sets the PV dst to SIP URI that correspond to the URI user\nin uac registrations table. The uri can contain pseudo-variables and dst\nmust be the name of a pseudo-variable.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n\nif(uac_reg_lookup(\"$var(uri)\", \"$ru\"))\n{\n    lookup(\"location\");\n}\n...\n                \n```\n",
   "uac_reg_status": "### `uac_reg_status(uuid)`\n\nThis function returns the current registration status for the uuid.\n\nReturn values:\n\n- 1 - a valid registration exists.\n\n- -1 - uuid does not exist or an error occurred while executing the\n  function.\n\n- -2 - a registration attempt is ongoing (and currently there is no\n  valid registration).\n\n- -3 - registration is disabled.\n\n- -99 - no valid registration, waiting for new registration attempt.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\n$var(status) = uac_reg_status(\"$rU\");\n...\n                \n```\n",
   "uac_reg_request_to": "### `uac_reg_request_to(user, mode)`\n\nThis function can be used to send an authenticated request to a remote\nuser in the uac registrations table. It sets the request-uri, dst-uri\nand auth_*_avp variables to the values that correspond to the\nsupplied user.\n\nThe mode is a bitwise set of flags controlling how the matching of the\nrecord is done and what field is used to set auth_password_avp:\n\n- indicates whether the user should match the local uuid (bit value=0),\n  or the username (bit value=1, int value=1).\n\n- indicates whether the auth_password value is used to set\n  auth_password_avp (bit value=0), or the auth_ha1 value (bit value=1,\n  int value=2).\n\nThe auth_*_avp module parameters must be set to valid pv's.\n\nThis function can be used from REQUEST_ROUTE, FAILURE_ROUTE,\nBRANCH_ROUTE.\n\n```\n...\n\nif(uac_reg_request_to(\"$fU\", 0))\n{\n    xlog(\"L_NOTICE\", \"Found remote user [$rU] on [$rd] via [$du]\");\n    t_on_failure(\"REMOTE_AUTH\");\n\n    t_relay()\n}\n...\nfailure_route[REMOTE_AUTH] {\n    if ($T_reply_code == 401 or $T_reply_code == 407) {\n        xlog(\"L_NOTICE\", \"Remote asked for authentication\");\n        uac_auth();\n    }\n}\n...\n                \n```\n",
   "uac_reg_enable": "### `uac_reg_enable(attr, val)`\n\nEnable a remote registration record based on a filter specified by\nattribute and value. The attribute can be: l_uuid, l_username,\nr_username or auth_username. The value is what should be matched against\nthe value of the attribute in the remote registration record.\n\nThe SIP processing is done on the next timer routine.\n\n```\n...\n   uac_reg_enable(\"l_uuid\", \"account123\");\n...\n            \n```\n",
   "uac_reg_disable": "### `uac_reg_disable(attr, val)`\n\nDisable a remote registration record based on a filter specified by\nattribute and value. The attribute can be: l_uuid, l_username,\nr_username or auth_username. The value is what should be matched against\nthe value of the attribute in the remote registration record.\n\nThe SIP processing is done on the next timer routine.\n\n```\n...\n   uac_reg_disable(\"l_uuid\", \"account123\");\n...\n            \n```\n",
   "uac_reg_refresh": "### `uac_reg_refresh(luuid)`\n\nRefresh the uac remote registration record based on local uuid. If the\nrecord was already loaded, new values are taken from database, otherwise\na new record is created.\n\n```\n...\n   uac_reg_refresh(\"account123\");\n...\n            \n```\n"
  }
 },
 "uac_redirect": {
  "overview": "UAC REDIRECT - User Agent Client redirection - module enhances Kamailio\nwith the functionality of being able to handle (interpret, filter, log\nand follow) redirect responses (3xx replies class).\n\nUAC REDIRECT module offers stateful processing, gathering the contacts\nfrom all 3xx branches of a call.\n\nThe module provides a powerful mechanism for selecting and filtering the\ncontacts to be used for the new redirect:\n\n- *number based* - limits like the number of total contacts to be used\n  or the maximum number of contacts per branch to be selected.\n\n- *Regular Expression based* - combinations of deny and accept filters\n  allow a strict control of the contacts to be used for redirection.\n\nWhen selecting from a 3xx branch the contacts to be used, the contacts\nwill be ordered and prioritized based on the \u201cq\u201d value.\n",
  "parameters": {
   "default_filter": "### `default_filter` (string)\n\nThe default behavior in filtering contacts. It may be \u201caccept\u201d or\n\u201cdeny\u201d.\n\n*The default value is \u201caccept\u201d.*\n\n```\n...\nmodparam(\"uac_redirect\",\"default_filter\",\"deny\")\n...\n                \n```\n",
   "deny_filter": "### `deny_filter` (string)\n\nThe regular expression for default deny filtering. It makes sense to be\ndefined only if the `default_filter` parameter is set to \u201caccept\u201d. All\ncontacts matching the `deny_filter` will be rejected; the rest of them\nwill be accepted for redirection.\n\nThe parameter may be defined only once - multiple definition will\noverwrite the previous definitions. If more regular expression need to\nbe defined, use the `set_deny_filter()` scripting function.\n\n*The default value is NULL.*\n\n```\n...\nmodparam(\"uac_redirect\",\"deny_filter\",\".*@siphub\\.net\")\n...\n                \n```\n",
   "accept_filter": "### `accept_filter` (string)\n\nThe regular expression for default accept filtering. It makes sense to\nbe defined only if the `default_filter` parameter is set to \u201cdeny\u201d. All\ncontacts matching the `accept_filter` will be accepted; the rest of them\nwill be rejected for redirection.\n\nThe parameter may be defined only once - multiple definition will\noverwrite the previous definitions. If more regular expression need to\nbe defined, use the `set_accept_filter()` scripting function.\n\n*The default value is NULL.*\n\n```\n...\nmodparam(\"uac_redirect\",\"accept_filter\",\".*@siphub\\.net\")\n...\n                \n```\n",
   "acc_function": "### `acc_function` (string)\n\nSpecifies the accounting function to be used. Just by defining this\nparameter, the accounting is not done automatically, it has to be\nrequested via parameters of `set_accept_filter()` or other scripting\nfunction.\n\nSet it to empty string in order to disable binding to acc module.\n\nIts values may be:\n\n- *acc_log_request*\n\n- *acc_db_request*\n\n- *acc_request*\n\n*The default value is \u201cacc_log_request\u201d.*\n\n```\n...\nmodparam(\"uac_redirect\",\"acc_function\",\"acc_db_request\")\n...\n                \n```\n",
   "acc_db_table": "### `acc_db_table` (string)\n\nSpecifies the accounting table to be used if DB accounting was chosen\n(`acc_function` was set to \u201cacc_db_request\u201d or \u201cacc_request\u201d).\n\n*The default value is \u201cacc\u201d.*\n\n```\n...\nmodparam(\"uac_redirect\",\"acc_db_table\",\"acc_redirect\")\n...\n                \n```\n",
   "bflags": "### `bflags` (int)\n\nThis parameter defines the branch-flags to be set for new, added branch.\n\n*The default value is 0.*\n\n```\n...\nmodparam(\"uac_redirect\",\"bflags\", 1)\n...\n\nbranch_route[1] {\n    if (isbflagset(1)) {\n        log(1, \"This branch comes from a 302 Forward Request.\\n\");\n    } else {\n        log(1, \"This is a regular branch.\\n\");\n    }\n}\n                \n```\n",
   "flags_hdr_mode": "### `flags_hdr_mode` (int)\n\nSpecifies if and how a Contact's flags header parameter must be used. If\nset, and a flags header parameter is set, its value will be set as\nbranch flags for that contact.\n\nIts values may be:\n\n- *0* - ignore flags header parameter, just use bflags module parameter\n\n- *1* - use flags header parameter if present, ignore bflags module\n  parameter\n\n- *2* - use flags header parameter if present and merge (binary or) it\n  with the bflags module parameter\n\n*The default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"uac_redirect\",\"flags_hdr_mode\",2)\n...\n                \n```\n",
   "q_value": "### `q_value` (int)\n\nSpecifies the q-value to assign to contacts without one. Because\nKamailio doesn't support float parameter types, the value in the\nparameter is divided by 1000 and stored as float. For example, if you\nwant q value to be 0.38, use value 380 here.\n\n*The default value is 10 (0.01).*\n\n```\n...\nmodparam(\"uac_redirect\",\"q_value\",0)\n...\n                \n```\n"
  },
  "functions": {
   "set_deny_filter": "### `set_deny_filter(filter, flags)`\n\nSets additional deny filters. Maximum 6 may be combined. This additional\nfilter will apply only to the current message - it will not have a\nglobal effect.\n\nDefault or previous added deny filter may be reset depending of the\n*flag* parameter value:\n\n- *reset_all* - reset both default and previous added deny filters;\n\n- *reset_default* - reset only the default deny filter;\n\n- *reset_added* - reset only the previous added deny filters;\n\n- *empty* - no reset, just add the filter.\n\nThis function can be used from FAILURE_ROUTE.\n\n```\n...\nset_deny_filter(\".*@domain2.net\",\"reset_all\");\nset_deny_filter(\".*@domain1.net\",\"\");\n...\n                \n```\n",
   "set_accept_filter": "### `set_accept_filter(filter, flags)`\n\nSets additional accept filters. Maximum 6 may be combined. This\nadditional filter will apply only to the current message - it will not\nhave a global effect.\n\nDefault or previous added deny filter may be reset depending of the\n*flag* parameter value:\n\n- *reset_all* - reset both default and previous added accept filters;\n\n- *reset_default* - reset only the default accept filter;\n\n- *reset_added* - reset only the previous added accept filters;\n\n- *empty* - no reset, just add the filter.\n\nThis function can be used from FAILURE_ROUTE.\n\n```\n...\nset_accept_filter(\".*@domain2.net\",\"reset_added\");\nset_accept_filter(\".*@domain1.net\",\"\");\n...\n                \n```\n",
   "get_redirects": "### `get_redirects(max, reason)`\n\nThe function has same functionality as `get_redirects(max)` function,\nbut it will produce accounting records.\n\nThe accounting records will be marked by the *reason* phrase.\n\nIf this function appears in the script, at startup, the module will\nimport the accounting function. Otherwise not.\n\nThis function can be used from FAILURE_ROUTE.\n\n```\n...\nget_redirects(\"4:1\",\"Redirected\");\n...\n                \n```\n"
  }
 },
 "uid_avp_db": {
  "overview": "This module contains several functions that can be used to manipulate\nthe contents of AVPs (Attribute-Value pairs). The AVPs are variables\nattached to the SIP message being processed. Each variable has its name\nand value. AVPs can be used to store arbitrary data or as a means of\ninter-module communication.\n\nYou may also want to check the avpops module which is more flexible and\ncontains more functions. In future SER releases the avp module will be\nprobably deprecated in favor of avpops module.\n\nDomain module operates in caching mode. Domain module reads the default\nvalues of AVPs into cache memory when the module is loaded. After that\ndefault values is re-read only when module is given avp_list_reload fifo\ncommand. Any changes in usr_preferences_types table must thus be\nfollowed by avp_list_reload command in order to reflect them in module\nbehavior.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nThe URL of the database to be used.\n\nDefault value is \"mysql://ser:heslo@localhost/ser\".\n",
   "user_attrs_table": "### `user_attrs_table` (string)\n\nName of the table with user attributes.\n\nDefault value is \"user_attrs\".\n",
   "uri_attrs_table": "### `uri_attrs_table` (string)\n\nName of the table with uri attributes.\n\nDefault value is \"uri_attrs\".\n",
   "uid_column": "### `uid_column` (string)\n\nName of the column that stores UID in the user attributes table.\n\nDefault value is \"uid\".\n",
   "username_column": "### `username_column` (string)\n\nName of the column containing the username of the subscriber in uri\nattributes table.\n\nDefault value is \"username\".\n",
   "did_column": "### `did_column` (string)\n\nName of the column in uri attributes table containing the ID of domain\nthat the subscriber belongs to.\n\nDefault value is \"did\".\n",
   "name_column": "### `name_column` (string)\n\nThe name of the column containing attribute names.\n\nDefault value is \"name\".\n",
   "value_column": "### `value_column` (string)\n\nThe name of the column containing attribute values.\n\nDefault value is \"value\".\n",
   "type_column": "### `type_column` (string)\n\nThe name of the column containing attribute value type.\n\nDefault value is \"type\".\n",
   "flags_column": "### `flags_column` (string)\n\nThe name of the column containing attribute flags.\n\nDefault value is \"flags\".\n",
   "scheme_column": "### `scheme_column` (string)\n\nThe name of the column containing subscriber's scheme in uri attributes.\n\nDefault value is \"scheme\".\n",
   "attr_group": "### `attr_group` (string)\n\n'Extra attribute' group definition. It can be repeated to define more\nattribute groups.\n\nThe group definition contains one or more assignments in the form\nkey=value. Possible keys are:\n\nid  \nAttribute group identifier. Must be set.\n\ntable  \nTable name used for storing attributes from this attribute group. Must\nbe set.\n\nflag  \nAttribute flag name used to mark attributes in this group. Must be set.\n\nkey_column  \nColumn name holding key. Default value is \u201cid\u201d.\n\nname_column  \nColumn name used for storing attribute name. Default value is \u201cname\u201d.\n\nvalue_column  \nColumn name used for storing attribute value. Default value is \u201cvalue\u201d.\n\ntype_column  \nColumn name used for storing attribute type. Default value is \u201ctype\u201d.\n\nflags_column  \nColumn name used for storing attribute flags. Default value is \u201cflags\u201d.\n\nNone defined by default.\n\n```\nmodparam(\"avp_db\", \"attr_group\", \"id=dlg,flag=dialog_flag,table=dlg_attrs,key_column=dlg_id\");\n```\n\nTable used for these attributes:\n\n```\nmysql> describe dlg_attrs;\n+--------+------------------+------+-----+---------+-------+\n| Field  | Type             | Null | Key | Default | Extra |\n+--------+------------------+------+-----+---------+-------+\n| dlg_id | varchar(256)     | NO   | MUL |         |       |\n| name   | varchar(32)      | NO   |     |         |       |\n| value  | varchar(255)     | YES  |     | NULL    |       |\n| type   | int(11)          | NO   |     | 0       |       |\n| flags  | int(10) unsigned | NO   |     | 0       |       |\n+--------+------------------+------+-----+---------+-------+\n5 rows in set (0.00 sec)\n    \n```\n\nSetting flags from code (all attrs beginning with \u201cdlg_\u201d):\n\n```\navpflags dialog_flag;\n...\nroute {\n    ...\n    setavpflag(\"$f./^dlg_/\", \"dialog_flag\");\n    ...\n}\n```\n",
   "auto_unlock_extra_attrs": "### `auto_unlock_extra_attrs` (string)\n\nDetermines the action when any of the 'extra attributes' lock is\ndetected when routing script execution was finished. When the value of\nthis parameter is zero (default) BUG level message is logged, but the\nlock is kept, so another process trying to obtain the lock might get\nstuck. If the value is nonzero, DEBUG level message is sent to the log\nand all the locks are released.\n\nDefault value is 0.\n"
  },
  "functions": {
   "load_attrs": "### load_attrs (track, id)\n\nLoads attributes from the database.\n\ntrack  \n$fu  \nLoad user attributes into from track. In this case the second parameter\nis UID used to search attributes.\n\n$tu  \nLoad user attributes into to track. In this case the second parameter is\nUID used to search attributes.\n\n$fr  \nLoad uri attributes into from track. In this case the second parameter\nis URI used to search attributes.\n\n$tr  \nLoad uri attributes into to track. In this case the second parameter is\nURI used to search attributes.\n\nid  \nIdentifier used for searching attributes. When searching for user\nattributes it is UID, when searching uri attributes it is URI.\n",
   "load_extra_attrs": "### load_extra_attrs (group_id, id)\n\nLoads 'extra attributes' stored by previous call to save_extra_attrs.\n\ngroup_id  \nIdentifies attribute group, see [ (string)](#extra_attr_group).\n\nid  \nIdentifies attributes which should be loaded.\n",
   "save_extra_attrs": "### save_extra_attrs (group_id, id)\n\nSaves 'extra attributes' flagged by group flag under given id.\n\ngroup_id  \nIdentifies attribute group, see [ (string)](#extra_attr_group).\n\nid  \nIdentifier stored with flagged attributes.\n",
   "remove_extra_attrs": "### remove_extra_attrs (group_id, id)\n\nRemoves all extra attributes with given id.\n\ngroup_id  \nIdentifies attribute group, see [ (string)](#extra_attr_group).\n\nid  \nIdentifies attributes which should be removed.\n",
   "lock_extra_attrs": "### lock_extra_attrs (group_id, id)\n\nLocks extra attributes. Currently locks whole attribute group (not only\nid).\n\ngroup_id  \nIdentifies attribute group, see [ (string)](#extra_attr_group).\n\nid  \nIdentifies attributes which should be locked.\n",
   "unlock_extra_attrs": "### unlock_extra_attrs (group_id, id)\n\nUnlocks extra attributes. Currently unlocks whole attribute group (not\nonly id).\n\ngroup_id  \nIdentifies attribute group, see [ (string)](#extra_attr_group).\n\nid  \nIdentifies attributes which should be unlocked.\n"
  }
 },
 "uri_db": {
  "overview": "Various checks related to SIP URI.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nURL of the database to be used.\n\nIf the db_url string is empty, the default database URL will be used.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"db_url\", \"mysql://username:password@localhost/kamailio\")\n...\n```\n",
   "db_table": "### `db_table` (string)\n\nThe DB table that should be used. It is possible to use the \u201csubscriber\u201d\nand \u201curi\u201d table. If the \u201curi\u201d table should be used, an additional\nparameter \u201cuse_uri_table\u201d) must be set.\n\n*Default value is \u201csubscriber\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"db_table\", \"uri\")\n...\n```\n",
   "user_column": "### `user_column` (string)\n\nColumn holding usernames in the table.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"user_column\", \"username\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nColumn holding domain in the table.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"domain_column\", \"domain\")\n...\n```\n",
   "uriuser_column": "### `uriuser_column` (string)\n\nColumn holding URI username in the table.\n\n*Default value is \u201curi_user\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"uriuser_column\", \"uri_user\")\n...\n```\n",
   "use_uri_table": "### `use_uri_table` (integer)\n\nSpecify if the \u201curi\u201d table should be used for checking instead of\n\u201csubscriber\u201d table. A non-zero value means true.\n\n*Default value is \u201c0 (false)\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"use_uri_table\", 1)\n...\n```\n",
   "use_domain": "### `use_domain` (integer)\n\nSpecify if the domain part of the URI should be used to identify the\nusers (along with username). This is useful in multi domain setups, a\nnon-zero value means true.\n\nThis parameter is only evaluated for calls to \u201cdoes_uri_exist\u201d, all\nother functions checks the digest username and realm against the given\nusername, if the \u201curi\u201d table is used.\n\n*Default value is \u201c0 (false)\u201d.*\n\n```\n...\nmodparam(\"uri_db\", \"use_domain\", 1)\n...\n```\n"
  },
  "functions": {
   "check_to": "### `check_to()`\n\nCheck \u201cTo\u201d username against URI table (if use_uri_table is set) or\ndigest credentials (no DB backend required).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (check_to()) {\n    ...\n};\n...\n```\n",
   "check_from": "### `check_from()`\n\nCheck \u201cFrom\u201d username against URI table (if use_uri_table is set) or\ndigest credentials (no DB backend required).\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (check_from()) {\n    ...\n};\n...\n```\n",
   "check_uri": "### `check_uri(uri)`\n\nCheck the username from the given uri against URI table (if\nuse_uri_table is set) or digest credentials (no DB backend required).\n\nDescription of parameters:\n\n- *uri* Has to be a valid SIP URI, used to extract the username from.\n  The parameter can be a static or dynamic (with variables) string.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (check_uri(\"$var(uri)\")) {\n    ...\n};\n...\n```\n",
   "does_uri_exist": "### `does_uri_exist()`\n\nCheck if username in the request URI belongs to an existing user.\n\nThe checking is done against the URI table (if use_uri_table is set) or\nthe subscriber table.\n\nThis function can be used from REQUEST_ROUTE.\n\n```\n...\nif (does_uri_exist()) {\n    ...\n};\n...\n```\n"
  }
 },
 "userblocklist": {
  "overview": "The userblocklist module allows Kamailio to handle blocklists on a per\nuser basis. This information is stored in a database table, which is\nqueried to decide if the number (more exactly, the request URI user) is\nblocklisted or not.\n\nAn additional functionality that this module provides is the ability to\nhandle global blocklists. This lists are loaded on startup into memory,\nthus providing a better performance than the userblocklist case. These\nglobal blocklists are useful to allow only calls to certain\ninternational destinations, i.e. block all not allowlisted numbers. They\ncould also be used to prevent the blocklisting of important numbers, as\nallowlisting is supported too. This is useful for example to prevent the\ncustomer from blocking emergency call number or service hotlines.\n\nThe module exports four functions, `check_blocklist`, `check_allowlist`,\n`check_user_blocklist` and `check_user_allowlist` for usage in the\nconfiguration file. Furthermore it provides a RPC function to reload the\nglobal blocklist cache.\n\nPlease note that only numerical strings for matching are supported at\nthe moment (the used library supports this already, but it is not yet\nimplemented in the module). Non-digits on the beginning of the matched\nstring are skipped, any later non-digits will stop the matching on this\nposition.\n",
  "parameters": {
   "use_domain": "### `use_domain` (integer)\n\nIf set to non-zero value, the domain column in the userblocklist table\nis used.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"userblocklist\", \"use_domain\", 1)\n...\n            \n```\n",
   "match_mode": "### `match_mode` (integer)\n\nThe number of individual characters that are used for matching. Valid\nvalues are 10 or 128. When you specify 10, only digits will be used for\nmatching, this operation mode is equivalent to the old behaviour. When\nconfigured with 128, all standard ASCII chars are available for\nmatching. Please be aware that memory requirements for storing the\nrouting tree in shared memory will also increase by a factor of 12.8.\n\n*Default value is \u201c10\u201d.*\n\n```\n...\nmodparam(\"userblocklist\", \"match_mode\", 128)\n...\n            \n```\n",
   "db_url": "### `db_url` (String)\n\nURL to the database containing the data.\n\n*Default value is \u201cmysql://kamailioro:kamailioro@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"userblocklist\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "userblocklist_table": "### `userblocklist_table` (String)\n\nName of the userblocklist table for the userblocklist module.\n\n*Default value is \u201cuserblocklist\u201d.*\n\n```\n...\nmodparam(\"userblocklist\", \"userblocklist_table\", \"userblocklist\")\n...\n```\n",
   "userblocklist_id_col": "### `userblocklist_id_col` (string)\n\nunique ID\n\n```\n...\nmodparam(\"userblocklist\", \"userblocklist_id_col\", \"id\")\n...\n```\n",
   "userblocklist_username_col": "### `userblocklist_username_col` (string)\n\nThe user that is used for the blocklist lookup.\n\n```\n...\nmodparam(\"userblocklist\", \"userblocklist_username_col\", \"username\")\n...\n```\n",
   "userblocklist_domain_col": "### `userblocklist_domain_col` (string)\n\nThe domain that is used for the blocklist lookup.\n\n```\n...\nmodparam(\"userblocklist\", \"userblocklist_domain_col\", \"domain\")\n...\n```\n",
   "userblocklist_prefix_col": "### `userblocklist_prefix_col` (string)\n\nThe prefix that is matched for the blocklist.\n\n```\n...\nmodparam(\"userblocklist\", \"userblocklist_prefix_col\", \"prefix\")\n...\n```\n",
   "userblocklist_allowlist_col": "### `userblocklist_allowlist_col` (string)\n\nSpecify if this is a blocklist (0) or an allowlist (1) entry.\n\n```\n...\nmodparam(\"userblocklist\", \"userblocklist_allowlist_col\", \"allowlist\")\n...\n```\n",
   "globalblocklist_table": "### `globalblocklist_table` (String)\n\nName of the globalblocklist table for the userblocklist module. Please\nnote that this table is used when the check_blocklist function is called\nwith no parameters.\n\n*Default value is \u201cglobalblocklist\u201d.*\n\n```\n...\nmodparam(\"userblocklist\", \"globalblocklist_table\", \"globalblocklist\")\n...\n```\n",
   "globalblocklist_id_col": "### `globalblocklist_id_col` (string)\n\nunique ID\n\n```\n...\nmodparam(\"userblocklist\", \"globalblocklist_id_col\", \"id\")\n...\n```\n",
   "globalblocklist_prefix_col": "### `globalblocklist_prefix_col` (string)\n\nThe prefix that is matched for the blocklist.\n\n```\n...\nmodparam(\"userblocklist\", \"globalblocklist_prefix_col\", \"prefix\")\n...\n```\n",
   "globalblocklist_allowlist_col": "### `globalblocklist_allowlist_col` (string)\n\nSpecify if this is a blocklist (0) or an allowlist (1) entry.\n\n```\n...\nmodparam(\"userblocklist\", \"globalblocklist_allowlist_col\", \"allowlist\")\n...\n```\n",
   "globalblocklist_description_col": "### `globalblocklist_description_col` (string)\n\nA comment for the entry.\n\n```\n...\nmodparam(\"userblocklist\", \"globalblocklist_description_col\", \"description\")\n...\n```\n"
  },
  "functions": {
   "check_user_blocklist": "### `check_user_blocklist (string user, string domain, string number, string table)`\n\nFinds the longest prefix that matches the request URI user (or the\nnumber parameter) for the given user and domain name in the database. If\na match is found and it is not set to allowlist, false is returned.\nOtherwise, true is returned. Pseudo-variables or AVPs can be used for\nthe user, domain and number parameters. The number and table variables\nare optional, the defaults are used if they are omitted. The number\nparameter can be used to check for example against the from URI user.\n\n```\n...\n$avp(i:80) = $rU;\n# rewrite the R-URI\nif (!check_user_blocklist(\"$avp(i:80)\", \"$avp(i:82)\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n        \n```\n",
   "check_user_allowlist": "### `check_user_allowlist (string user, string domain, string number, string table)`\n\nFinds the longest prefix that matches the request URI user (or the\nnumber parameter) for the given user and domain name in the database. If\na match is found and it is set to allowlist, true is returned.\nOtherwise, false is returned. Pseudo-variables or AVPs can be used for\nthe user, domain and number parameters. The number and table variables\nare optional, the defaults are used if they are omitted. The number\nparameter can be used to check for example against the from URI user.\n\n```\n...\n$avp(i:80) = $rU;\n# rewrite the R-URI\nif (!check_user_allowlist(\"$avp(i:80)\", \"$avp(i:82)\")) {\n    # process request\n    exit;\n}\n...\n        \n```\n",
   "check_blocklist": "### `check_blocklist ([string table])`\n\nFinds the longest prefix that matches the request URI for the given\ntable. If a match is found and it is not set to allowlist, false is\nreturned. Otherwise, true is returned. If no table is given, then\nglobalblocklist_table is used.\n\n```\n...\nif (!check_blocklist(\"globalblocklist\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n        \n```\n",
   "check_allowlist": "### `check_allowlist (string table)`\n\nFinds the longest prefix that matches the request URI for the given\ntable. If a match is found and it is set to allowlist, true is returned.\nOtherwise, false is returned.\n\n```\n...\nif (!check_allowlist(\"globalblocklist\")) {\n    sl_send_reply(\"403\", \"Forbidden\");\n    exit;\n}\n...\n        \n```\n"
  }
 },
 "usrloc": {
  "overview": "The User location module keeps a user location table and provides access\nto the table for other modules. The module exports no functions that can\nbe used directly from routing scripts.\n",
  "parameters": {
   "nat_bflag": "### `nat_bflag` (int)\n\nThe index of the branch flag to be used as NAT marker (if the contact is\nor not natted). This is a branch flag and it will be imported and used\nby all other modules depending of usrloc module.\n\n*Default value is \u201cnot set\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"nat_bflag\", 3)\n...\n```\n",
   "user_column": "### `user_column` (string)\n\nName of database column containing usernames.\n\n*Default value is \u201cusername\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"user_column\", \"username\")\n...\n```\n",
   "domain_column": "### `domain_column` (string)\n\nName of database column containing domains.\n\n*Default value is \u201cdomain\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"domain_column\", \"domain\")\n...\n```\n",
   "contact_column": "### `contact_column` (string)\n\nName of database column containing contacts.\n\n*Default value is \u201ccontact\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"contact_column\", \"contact\")\n...\n```\n",
   "expires_column": "### `expires_column` (string)\n\nName of database column containing expires value.\n\n*Default value is \u201cexpires\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"expires_column\", \"expires\")\n...\n```\n",
   "q_column": "### `q_column` (string)\n\nName of database column containing q values.\n\n*Default value is \u201cq\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"q_column\", \"q\")\n...\n```\n",
   "callid_column": "### `callid_column` (string)\n\nName of database column containing Call-ID values.\n\n*Default value is \u201ccallid\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"callid_column\", \"callid\")\n...\n```\n",
   "cseq_column": "### `cseq_column` (string)\n\nName of database column containing Cseq.\n\n*Default value is \u201ccseq\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"cseq_column\", \"cseq\")\n...\n```\n",
   "methods_column": "### `methods_column` (string)\n\nName of database column containing supported methods.\n\n*Default value is \u201cmethods\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"methods_column\", \"methods\")\n...\n```\n",
   "flags_column": "### `flags_column` (string)\n\nName of database column to save the internal flags of the record.\n\n*Default value is \u201cflags\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"flags_column\", \"flags\")\n...\n```\n",
   "cflags_column": "### `cflags_column` (string)\n\nName of database column to save the branch/contact flags of the record.\n\n*Default value is \u201ccflags\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"cflags_column\", \"cflags\")\n...\n```\n",
   "user_agent_column": "### `user_agent_column` (string)\n\nName of database column containing user-agent values.\n\n*Default value is \u201cuser_agent\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"user_agent_column\", \"user_agent\")\n...\n```\n",
   "received_column": "### `received_column` (string)\n\nName of database column containing the source IP, port, and protocol\nfrom the REGISTER message.\n\n*Default value is \u201creceived\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"received_column\", \"received\")\n...\n```\n",
   "socket_column": "### `socket_column` (string)\n\nName of database column containing the received socket information\n(IP:port) for the REGISTER message.\n\n*Default value is \u201csocket\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"socket_column\", \"socket\")\n...\n```\n",
   "path_column": "### `path_column` (string)\n\nName of database column containing the Path header.\n\n*Default value is \u201cpath\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"path_column\", \"path\")\n...\n```\n",
   "ruid_column": "### `ruid_column` (string)\n\nName of database column containing the Kamailio record unique id.\n\n*Default value is \u201cruid\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"ruid_column\", \"myruid\")\n...\n```\n",
   "instance_column": "### `instance_column` (string)\n\nName of database column containing the SIP instance ID (GRUU - RFC5627).\nThis is a unique device identifier - UUID.\n\n*Default value is \u201cinstance\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"instance_column\", \"myinstance\")\n...\n```\n",
   "reg_id_column": "### `reg_id_column` (string)\n\nName of database table column containing the value for reg-id.\n\n*Default value is \u201creg_id\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"reg_id_column\", \"r_id\")\n...\n```\n",
   "server_id_column": "### `server_id_column` (string)\n\nName of database table column containing the value for server id.\n\n*Default value is \u201cserver_id\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"server_id_column\", \"srv_id\")\n...\n```\n",
   "connection_id_column": "### `connection_id_column` (string)\n\nName of database table column containing the value for connection id.\n\n*Default value is \u201cconnection_id\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"connection_id_column\", \"con_id\")\n...\n```\n",
   "keepalive_column": "### `keepalive_column` (string)\n\nName of database table column containing the value for keepalive status.\n\n*Default value is \u201ckeepalive\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"keepalive_column\", \"kalive\")\n...\n```\n",
   "partition_column": "### `partition_column` (string)\n\nName of database table column containing the value for partition id.\n\n*Default value is \u201cpartition\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"partition_column\", \"part\")\n...\n```\n",
   "use_domain": "### `use_domain` (int)\n\nIf the domain part of the user should be also saved and used for\nidentifying the user (along with the username part). Useful in multi\ndomain scenarios. Non 0 value means true.\n\n*Default value is \u201c0 (false)\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"use_domain\", 1)\n...\n```\n",
   "desc_time_order": "### `desc_time_order` (int)\n\nIf the user's contacts should be kept timestamp ordered; otherwise the\ncontact will be ordered based on q value. Non 0 value means true.\n\n*Default value is \u201c0 (false)\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"desc_time_order\", 1)\n...\n```\n",
   "timer_interval": "### `timer_interval` (int)\n\nNumber of seconds between two timer runs. The module uses a timer to\ndelete expired contacts, synchronize with database, send keepalives and\nother tasks, that need to be run periodically.\n\n*Default value is 60.*\n\n```\n...\nmodparam(\"usrloc\", \"timer_interval\", 120)\n...\n```\n",
   "db_url": "### `db_url` (string)\n\nURL of the database that should be used.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "db_mode": "### `db_mode` (int)\n\nThe usrloc module can utilize a database for persistent contact storage.\nIf a database is used, the location database (contacts) will survive\nmachine restarts or software crashes. The disadvantage is that accessing\na database can be very time consuming. Therefore, usrloc module\nimplements four database accessing modes:\n\n- 0 - This disables database completely. Only memory will be used.\n  Contacts will not survive restart. Use this value if you need a really\n  fast usrloc and contact persistence is not necessary or is provided by\n  other means.\n\n- 1 - Write-Through scheme. All changes to usrloc are immediately\n  reflected in database too. This is very slow, but very reliable. Use\n  this scheme if speed is not your priority but need to make sure that\n  no registered contacts will be lost during crash or reboot.\n\n- 2 - Write-Back scheme. This is a combination of previous two schemes.\n  All changes are made to memory and database synchronization is done in\n  the timer. The timer deletes all expired contacts and flushes all\n  modified or new contacts to database. Use this scheme if you encounter\n  high-load peaks and want them to process as fast as possible. The mode\n  will not help at all if the load is high all the time. Also, latency\n  of this mode is much lower than latency of mode 1, but slightly higher\n  than latency of mode 0.\n\n- 3 - DB-Only scheme. No memory cache is kept, all operations being\n  directly performed with the database. The timer deletes all expired\n  contacts from database - cleans after clients that didn't un-register\n  or re-register. The mode is useful if you configure more servers\n  sharing the same DB without any replication at SIP level. The mode may\n  be slower due the high number of DB operation. For example NAT pinging\n  is a killer since during each ping cycle all natted contact are loaded\n  from the DB; The lack of memory caching also disable the statistics\n  exports.\n\n- 4 - This uses database to load records at startup but uses only memory\n  during the runtime. Records are not written back at all, not even at\n  shutdown. Useful for scenarios when registrations are replicated to a\n  node that does the storage in a database during runtime.\n\n<div class=\"warning\">\n\n\nIn case of crash or restart contacts that are in memory only and haven't\nbeen flushed yet will get lost. If you want minimize the risk, use\nshorter timer interval.\n\n</div>\n\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"usrloc\", \"db_mode\", 2)\n...\n```\n",
   "db_load": "### `db_load` (int)\n\nDetermine if the usrloc module should load contacts from the database\nstorage during module initialization. A value of 0 disables the loading\nfrom the database, this parameter is ignored if db_mode 4 is set.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"usrloc\", \"db_load\", 0)\n...\n        \n```\n",
   "db_insert_update": "### `db_insert_update` (int)\n\nDetermine if the usrloc module should do an update when a duplicate key\nis found while inserting A value of 1 will activate update on duplicate\nkey\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"usrloc\", \"db_insert_update\", 1)\n...\n        \n```\n",
   "matching_mode": "### `matching_mode` (int)\n\nWhat contact matching algorithm to be used. Refer to section\n[???](#contact-matching-algs) for the description of the algorithms.\n\nThe parameter may take the following values:\n\n- *0* - CONTACT ONLY based matching algorithm.\n\n- *1* - CONTACT and CALLID based matching algorithm.\n\n- *2* - CONTACT and PATH based matching algorithm. This mode is like\n  mode *0* but allows for duplicate contacts from differing paths. If no\n  path is available, it defaults to mode 0.\n\n- *3* - CALLID only based matching algorithm. This mode will discard any\n  duplicate registration coming through different paths.\n\n*Default value is *0 (CONTACT_ONLY)*.*\n\n```\n...\nmodparam(\"usrloc\", \"matching_mode\", 1)\n...\n```\n",
   "cseq_delay": "### `cseq_delay` (int)\n\nDelay (in seconds) for accepting as retransmissions register requests\nwith same Call-ID and Cseq. The delay is calculated starting from the\nreceiving time of the first register with that Call-ID and Cseq.\n\nRetransmissions within this delay interval will be accepted and replied\nas the original request, but no update will be done in location. If the\ndelay is exceeded, error is reported.\n\nA value of 0 disable the retransmission detection.\n\n*Default value is \u201c20 seconds\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"cseq_delay\", 5)\n...\n```\n",
   "fetch_rows": "### `fetch_rows` (int)\n\nThe number of the rows to be fetched at once from database when loading\nthe location records. This value can be used to tune the load time at\nstartup. For 1MB of private memory (default) it should be below 4000.\nThe database driver must support fetch_result() capability.\n\n*Default value is \u201c2000\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"fetch_rows\", 3000)\n...\n```\n",
   "hash_size": "### `hash_size` (int)\n\nThe number of entries of the hash table used by usrloc to store the\nlocation records is 2^hash_size. For hash_size=4, the number of slots of\nthe hash table is 16.\n\n*Default value is \u201c10\u201d (1024 slots).*\n\n```\n...\nmodparam(\"usrloc\", \"hash_size\", 12)\n...\n```\n",
   "preload": "### `preload` (string)\n\nPreload location table given as value. A location table is loaded based\non fixup of registrar functions, therefore you need to use this\nparameter only to load tables that are not used by registrar module\ndirectly in configuration file.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"preload\", \"location\")\n...\n```\n",
   "db_update_as_insert": "### `db_update_as_insert` (int)\n\nSet this parameter if you want to do INSERT DB operations instead of\nUPDATE DB operations. It is recommended to set this parameter if you use\nCassandra as a DB backend.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"db_update_as_insert\", 1)\n...\n```\n",
   "db_check_update": "### `db_check_update` (int)\n\nSet this parameter to 1 if you want to do DB INSERT if the number of\naffected rows by contact DB UPDATE operation is 0. The database module\ndriver has to implement affected_rows() DB API function, otherwise this\nparameter is ignored - e.g., MySQL and Postgres DB connectors offer\naffected_rows().\n\n*Default value is \u201c0\u201d (no DB INSERT).*\n\n```\n...\nmodparam(\"usrloc\", \"db_check_update\", 1)\n...\n```\n",
   "timer_procs": "### `timer_procs` (int)\n\nNumber of timer processes to be started by module. Timer processes take\ncare of checking expired records and synchronization with database. If\nset to 0, no dedicated timer is started, the one from core will be used.\n\nIf the number of timer processes is greater than 1, the workload of\nsynchronization and record expiration is split up among the multiple\nprocesses. (Each process is assigned a range of slots from the internal\nhash table, and is responsible for cleanup and storage on those slots.)\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"timer_procs\", 4)\n...\n```\n",
   "xavp_contact": "### `xavp_contact` (string)\n\nThe name of XAVP storing the attributes per contact. They are saved in\nlocation record and restored at lookup. The tm module parameter\n`xavp_contact` must also be set to the same value to use the\n`t_load_contacts` and `t_next_contacts` functions.\n\n*Default value is \u201cNULL\u201d.*\n\n```\n...\nmodparam(\"tm|usrloc\", \"xavp_contact\", \"ulattrs\")\n...\n```\n",
   "db_ops_ruid": "### `db_ops_ruid` (int)\n\nIf set to 1, database queries for update or delete are done using ruid\nvalue. If it is set to 0, the old style using aor, contact and call-id\nis done.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"db_ops_ruid\", 0)\n...\n```\n",
   "handle_lost_tcp": "### `handle_lost_tcp` (int)\n\nIf set to 1, Kamailio will remove location records made via\nTCP/TLS/WS/WSS transports when it looses corresponding tcp connections.\nDoes not currently work in DB-Only scheme.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"handle_lost_tcp\", 1)\n...\n```\n",
   "close_expired_tcp": "### `close_expired_tcp` (int)\n\nIf set to 1, Kamailio will close the TCP connection when a contact has\nexpired, if the corresponding transport is TCP/TLS/WS/WSS.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"close_expired_tcp\", 1)\n...\n```\n",
   "expires_type": "### `expires_type` (int)\n\nIf set to 1, Kamailio expects to deal with BIGINT type on database\ncolumns for expires and last modified values. It allows to handle better\nthe daylight time adjustments. If set to 0, those columns are expected\nto be on default type 'DATETIME'. When it is 1, the database columns\ntypes have to be changed manually to 'BIGINT'.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"expires_type\", 1)\n...\n```\n",
   "db_raw_fetch_type": "### `db_raw_fetch_type` (int)\n\nThis affect DB-only mode and controls what kind of raw query is used to\nfetch the contacts from database for specific needs (e.g., sending NAT\nkeepalives). If it is set to 0, then the common SQL query is used\n(working for MySQL, PostgreSQL, ...). If it is set to 1, the query\nrequired by Oracle is used.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"db_raw_fetch_type\", 1)\n...\n```\n",
   "db_insert_null": "### `db_insert_null` (int)\n\nIf set to 1, the insert operation to database will add null values in\nthe statement. It has to be set to 1 for the database systems that do\nnot have table definitions that create automatically the null fields\n(e.g., db_mongodb) for each stored record.\n\nWhen set to 0, the fields that default to null are not added to the DB\ninsert statement if they don't have a different value, making the query\nsmaller.\n\n*Default value is \u201c0\u201d (don't add null fields in insert statement).*\n\n```\n...\nmodparam(\"usrloc\", \"db_insert_null\", 1)\n...\n```\n",
   "skip_remote_socket": "### `skip_remote_socket` (int)\n\nIf set to 1, Kamailio will skip location record when loading from\ndatabase, if socket value of the record does not in kamailio listening\nsocket list.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"skip_remote_socket\", 1)\n...\n```\n",
   "db_timer_clean": "### `db_timer_clean` (int)\n\nEnable (1) or disable (0) cleaning of expired db records on timer basis\nfor db_mode WRITE-BACK and WRITE-THROUGH. It uses the secondary timer\nprocess.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"db_timer_clean\", 1)\n...\n```\n",
   "rm_expired_delay": "### `rm_expired_delay` (int)\n\nSpecify the number of seconds to delay the removal of expired records.\nFor now it works for DB_ONLY mode (db_mode=3).\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"rm_expired_delay\", 30)\n...\n```\n",
   "server_id_filter": "### `server_id_filter` (int)\n\nEnable (1) or disable (0) filter records by server_id on load and during\ncleaning of expired db records. It could be useful when you want to use\nthe same location table for several kamailio instances which are\nconfigured to work in db_mode=1 or db_mode=2 (cache modes). Otherwise\none instance of proxy cleans records made by another proxy and that\nbreaks its cache.\n\n*Default value is \u201c0\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"server_id_filter\", 1)\n...\n```\n",
   "version_table": "### `version_table` (int)\n\nIf set to 0, the module will skip checking the version for location\ntable.\n\nDefault value is \u201c1 (check for table version)\u201d.\n\n```\n...\nmodparam(\"usrloc\", \"version_table\", 0)\n...\n        \n```\n",
   "ka_mode": "### `ka_mode` (int)\n\nKeepalive mode - control the internal keepalive mechanism. With this\nfeature enabled, the module sends periodically (based on timer interval)\nSIP requests to location contacts and measures the round trip in\nmicroseconds (the round trip value can be seen in the response of the\nRPC command 'ul.dump').\n\nIts value is a set of flags:\n\n- 0 - if the value is zero, no keepalive is sent\n\n- 1 (bit 1 set) - if set to 1, the keepalive is enabled for all contacts\n\n- 2 (bit 2 set) - the keepalive is sent only for natted contacts\n  (nat_bflag set)\n\n- 4 (bit 3 set) - the keepalive is sent only for UDP contacts\n\nFor example, if set to 6, then keepalive is sent only natted UDP\ncontacts.\n\nNote: the internal keepalive of usrloc module conflicts in some way with\nthe keepalive done by nathelper module. It is recommended to enable only\none.\n\nNote: the internal keepalive is for the moment implemented only for\ncontact records stored in memory.\n\nNote: it is recommended to set 'timer_procs' parameter in order to have\ndedicated timer processes for usrloc module and off-load the keepalive\nsending process from the core timers.\n\nNote: Keepalives will be sent to the IP and port using the transport\ndefined in the \u201creceived\u201d column. If not set, then keepalives will be\nsent to the AOR using UDP as a default transport. If available, the TCP\nconnection will be re-used for WS, TCP and TLS.\n\nDefault value is \u201c0 (keepalive disabled)\u201d.\n\n```\n...\nmodparam(\"usrloc\", \"ka_mode\", 1)\n...\n        \n```\n",
   "ka_method": "### `ka_method` (str)\n\nThe SIP method type for keepalive requests.\n\nDefault value is \u201cOPTIONS\u201d.\n\n```\n...\nmodparam(\"usrloc\", \"ka_method\", \"NOTIFY\")\n...\n        \n```\n",
   "ka_from": "### `ka_from` (str)\n\nThe SIP URI to be set in the From header of the keepalive requests.\n\nDefault value is \u201csip:server@kamailio.org\u201d.\n\n```\n...\nmodparam(\"usrloc\", \"ka_from\", \"sip:server@mydomain.com\")\n...\n        \n```\n",
   "ka_domain": "### `ka_domain` (str)\n\nThe domain to be set in To header URI if the multi-domain is not\nenabled. If multi-domain is enabled, then the domain from the location\nrecord is used and this parameter is ignored.\n\nDefault value is \u201ckamailio.org\u201d.\n\n```\n...\nmodparam(\"usrloc\", \"ka_domain\", \"mydomain.com\")\n...\n        \n```\n",
   "ka_filter": "### `ka_filter` (int)\n\nSet filters for keepalive processing.\n\nIts value is a set of flags:\n\n- 0 - if the value is zero, no filter is enabled for keepalives\n\n- 1 (bit 1 set) - keepalives sent only to records matching the server_id\n  global parameter.\n\nDefault value is \u201c0\u201d (no filter).\n\n```\n...\nmodparam(\"usrloc\", \"ka_filter\", 1)\n...\n        \n```\n",
   "ka_timeout": "### `ka_timeout` (int)\n\nThe parameter sets the interval in seconds after which a contact is\nremoved from location table if it does not reply to SIP keepalives\n(usually OPTIONS ping requests).\n\nThe features is available only for contacts that are stored in memory\n(not working for db only mode of the usrloc module).\n\nKeepalives are sent stateless, not using TM module. The value of this\nparameter has to be few times higher than timer interval.\n\n*Default value is \u201c0\u201d (feature disabled).*\n\n```\n...\nmodparam(\"usrloc\", \"ka_timeout\", 120)\n...\n```\n",
   "ka_interval": "### `ka_interval` (int)\n\nThe parameter sets the interval in seconds after which a new keepalive\nrequest should be sent for a location record.\n\n*Default value is \u201c40\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"ka_interval\", 30)\n...\n```\n",
   "ka_randomize": "### `ka_randomize` (int)\n\nThe parameter sets the the upper limit to the range of random seconds to\nbe added to ka_interval before checking if a new keepalive request has\nto be sent. It should help to distribute better the sending of keepalive\nrequests. The keepalive for a location record is going to be sent in a\nrandom fashion between (ka_interval + 0) and (ka_interval +\nka_randomize).\n\n*Default value is \u201c20\u201d.*\n\n```\n...\nmodparam(\"usrloc\", \"ka_interval\", 30)\n...\n```\n",
   "ka_loglevel": "### `ka_loglevel` (int)\n\nThe level to print the log message when the keepalive response is\nreceived. It should be a value between -5 (L_ALERT) and 3 (L_DBG).\n\nDefault value is \u201c255\u201d (disabled).\n\n```\n...\nmodparam(\"usrloc\", \"ka_loglevel\", 1)\n...\n        \n```\n",
   "ka_logmsg": "### `ka_logmsg` (str)\n\nThe formatted log specification to be added to the message printed when\nthe keepalive is received and roundtrip time is computed. The log\nmessage starts with \"keepalive roundtrip: %u.%06u sec - ruid [%.*s]\",\nthen concatenates the value of this parameter and the end of line.\n\nThe value of this parameter can contain script variables that are\nevaluated with the SIP response.\n\nDefault value is \u201c to-uri: [$tu] remote-addr: [$sas]\u201d.\n\n```\n...\nmodparam(\"usrloc\", \"ka_logmsg\", \" to-uri: [$tu] remote-addr: [$sas]\")\n...\n        \n```\n",
   "ka_reply_codes": "### `ka_reply_codes` (str)\n\nComma separated list of reply code values or reply code classes to be\nconsidered valid for keepalive processing. If the reply code does not\nmatch any of them, then the reply is ignored, not considered a valid\nresponse to keepalive request. It could be useful to skip replies from\nintermediary proxies that could not forward the request.\n\nDefault value is \u201c0\u201d (checking of reply code is not done, are responses\nare considered valid).\n\n```\n...\nmodparam(\"usrloc\", \"ka_reply_codes\", \"2,405,486\")\n...\n        \n```\n",
   "load_rank": "### `load_rank` (int)\n\nAllows to set the rank of the child SIP worker to load the location\nrecords.\n\nDefault value is \u201c1\u201d (PROC_SIPINIT).\n\n```\n...\nmodparam(\"usrloc\", \"load_rank\", 1)\n...\n        \n```\n",
   "db_clean_tcp": "### `db_clean_tcp` (int)\n\nIf set to 1, when Kamailio starts it removes the contacts with transport\nTCP, TLS or WSS, no longer loading them. Useful when end points do not\nlisten for incoming connections on contact address, which is quite\ncommon (end point use only tcp client connections). On restart,\nconnections are lost, therefore the corresponding contact records become\nuseless.\n\nDefault value is \u201c0\u201d (do not clean tcp contacts).\n\n```\n...\nmodparam(\"usrloc\", \"db_clean_tcp\", 1)\n...\n        \n```\n"
  },
  "functions": {}
 },
 "utils": {
  "overview": "This module implements various utility functions that are not SIP\nrelated.\n\nThe forward functionality allows Kamailio to configure forwarding at\nruntime with FIFO commands. The forwarding is executed in the pre script\ncall back and therefore handled before the routing script is executed on\nthe current message. The callback is not installed on default, thus this\nfunctionality has no runtime overhead when its deactivated.\n\nFunction xcap_auth_status can be used to check from presence server\ndatabase, if watcher is authorized to subscribe event \u201cpresence\u201d of\npresentity.\n",
  "parameters": {
   "forward_active": "### `forward_active` (int)\n\nDefines if the forwarding callback should be installed.\n\n*Default value is \u201c0\u201d - disabled.*\n\n```\n                    ...\n                    modparam(\"utils\", \"forward_active\", 1)\n                    ...\n                \n```\n",
   "pres_db_url": "### `pres_db_url` (string)\n\nDefines presence server database URL. If not given, the xcap_auth_status\nfunction is disabled.\n\n*There is no default value.*\n\n```\n...\nmodparam(\"utils\", \"pres_db_url\", \"mysql://foo:secret@localhost/pres\")\n...\n                \n```\n",
   "xcap_table": "### `xcap_table` (string)\n\nDefines the name of the xcap table in the presence server database. See\nthe xcap_server module documentation for more information.\n\n*Default value is \u201cxcap\u201d.*\n\n```\n...\nmodparam(\"utils\", \"xcap_table\", \"pres_xcap\")\n...\n                \n```\n"
  },
  "functions": {
   "xcap_auth_status": "### `xcap_auth_status(watcher_uri, presentity_uri)`\n\nFunction checks in the presence server database if a watcher is\nauthorized to subscribe to event \u201cpresence\u201d of presentity. Sphere\nchecking is not included.\n\nBoth watcher_uri and presentity_uri are pseudo variables. The function\nreturns ACTIVE_STATUS, if a subscription is allowed and PENDING_STATUS,\nTERMINATED_STATUS, or WAITING_STATUS otherwise. See presence/subscribe.h\nfor the corresponding integer codes. In case of error, function returns\n-1.\n\nFunction can be used from REQUEST_ROUTE.\n\n```\n...\nif (method==\"MESSAGE\") {\n    xcap_auth_status(\"$fu\", $ru\");\n    if ($retcode == 1) {\n        t_relay();\n    } else {\n        send_reply(\"403\", \"Forbidden\");\n    }\n}\n...\n                \n```\n"
  }
 },
 "uuid": {
  "overview": "This module exports the $uuid(type) class of variables that return\nunique values using functions from the libuuid library. UUIDs are used\nin the +sip.instance media feature tag in SIP, but can also be used for\nother purposes, like defining a unique session ID for a group of SIP\ndialogs.\n",
  "parameters": {},
  "functions": {}
 },
 "websocket": {
  "overview": "This module implements a WebSocket (RFC 6455) server and provides\nconnection establishment (handshaking), management (including connection\nkeep-alive), and framing for the SIP and MSRP WebSocket sub-protocols\n(RFC 7118 and RFC 7977).\n\nThe module supports WebSockets (ws) and secure WebSockets (wss)\ntransports\n",
  "parameters": {
   "keepalive_mechanism": "### `keepalive_mechanism` (integer)\n\nThe keep-alive mechanism to use for WebSocket connections.\n\n<div class=\"note\">\n\n\nIf *nathelper* is only being used for WebSocket connections then\n*nathelper NAT pinging* is not required. If *nathelper* is used for\nWebSocket connections and TCP/TLS aliasing/NAT-traversal then WebSocket\nkeep-alives are not required.\n\n</div>\n\n\n- 0 - no WebSocket keep-alives\n\n- 1 - Ping WebSocket keep-alives\n\n- 2 - Pong WebSocket keep-alives\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"websocket\", \"keepalive_mechanism\", 0)\n...\n```\n",
   "keepalive_timeout": "### `keepalive_timeout` (integer)\n\nThe time (in seconds) after which to send a keep-alive on idle WebSocket\nconnections.\n\n*Default value is 180.*\n\n```\n...\nmodparam(\"websocket\", \"keepalive_timeout\", 30)\n...\n```\n",
   "keepalive_processes": "### `keepalive_processes` (integer)\n\nThe number of processes to start to perform WebSocket connection\nkeep-alives.\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"websocket\", \"keepalive_processes\", 2)\n...\n```\n",
   "keepalive_interval": "### `keepalive_interval` (integer)\n\nThe number of seconds between each keep-alive process run\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"websocket\", \"keepalive_interval\", 2)\n...\n```\n",
   "ping_application_data": "### `ping_application_data` (string)\n\nThe application data to use in keep-alive Ping and Pong frames.\n\n*Default value is Kamailio Server: header content*\n\n```\n...\nmodparam(\"websocket\", \"ping_application_data\", \"WebSockets rock\")\n...\n```\n",
   "sub_protocols": "### `sub_protocols` (integer)\n\nA bitmap that allows you to control the sub-protocols supported by the\nWebSocket server.\n\n- *1* - sip (RFC 7118)\n\n- *2* - msrp (RFC 7977) - the msrp module must be loaded before the\n  websocket module\n\n*Default value is 1 when msrp module is not loaded, 3 when msrp module\nis loaded.*\n\n```\n...\nmodparam(\"websocket\", \"sub_protocols\", 2)\n...\n```\n",
   "cors_mode": "### `cors_mode` (integer)\n\nThis parameter lets you set the \"Cross-origin resource sharing\"\nbehaviour of the WebSocket server.\n\n- *0* - Do not add an \"Access-Control-Allow-Origin:\" header to the\n  response accepting the WebSocket handshake.\n\n- *1* - Add an \"Access-Control-Allow-Origin: *\" header to the response\n  accepting the WebSocket handshake.\n\n- *2* - Add an \"Access-Control-Allow-Origin:\" header containing the same\n  body as the \"Origin:\" header from the request to the response\n  accepting the WebSocket handshake. If there is no \"Origin:\" header in\n  the request no header will be added to the response.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"websocket\", \"cors_mode\", 2)\n...\n```\n",
   "verbose_list": "### `verbose_list` (int)\n\nAllows to enable/disable the printing of debug messages when getting the\nlist of websocket connections. If enabled, it prints debug messages\nevery second for ping operations.\n\n*Default value is 0 (disabled).*\n\n```\n...\nmodparam(\"websocket\", \"verbose_list\", 1)\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[...] blocks specific for websocket module.\n\nThe function has one string parameter, the value is the name of the\nevent_route block, respectively \"websocket:closed\".\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"websocket\", \"event_callback\", \"ksr_websocket_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_websocket_event(evname)\n    KSR.info(\"===== websocket module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n",
   "timer_interval": "### `timer_interval` (integer)\n\nThe number of seconds between each timer process run\n\n*Default value is 1.*\n\n```\n...\nmodparam(\"websocket\", \"timer_interval\", 5)\n...\n```\n",
   "rm_delay_interval": "### `rm_delay_interval` (integer)\n\nThe number of seconds to wait before destroying the websocket connection\nonce put in remove state.\n\n*Default value is 5.*\n\n```\n...\nmodparam(\"websocket\", \"rm_delay_interval\", 2)\n...\n```\n"
  },
  "functions": {
   "ws_handle_handshake": "### `ws_handle_handshake()`\n\nThis function checks an HTTP GET request for the required headers and\nvalues, and (if successful) upgrades the connection from HTTP to\nWebSocket.\n\nThis function can be used from ANY_ROUTE (but will only work in\n*event_route[xhttp:request]*).\n\n<div class=\"note\">\n\n\nThis function returns 0, stopping all further processing of the request,\nwhen there is a problem. Otherwise, it returns 1 (or positive number) in\ncase of success.\n\n</div>\n\n\n```\n...\nws_handle_handshake();\n...\n```\n",
   "ws_close": "### `ws_close([status, reason[, connection_id]])`\n\nThis function closes a WebSocket connection.\n\nThe function returns -1 if there is an error and 1 if it succeeds.\n\nThe meaning of the parameters is as follows:\n\n- *status* - an integer indicating the reason for closure.\n\n- *reason* - a string describing the reason for closure.\n\n- *connection_id* - the connection to close. If not specified the\n  connection the current message arrived on will be closed.\n\n<div class=\"note\">\n\n\n*status* and *reason* values SHOULD correspond to the definitions in\nsection 7.4 of RFC 6455. If these parameters are not used the defaults\nof \"1000\" and \"Normal closure\" will be used.\n\n</div>\n\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nws_close(4000, \"Because I say so\");\n...\n```\n"
  }
 },
 "xcap_client": {
  "overview": "The module is a XCAP client for Kamailio that can be used by other\nmodules. It fetches XCAP elements, either documents or part of them, by\nsending HTTP GET requests to an XCAP server. It also offers support for\nconditional queries. It uses the *libcurl* library as a client-side HTTP\ntransfer library.\n\nThe module offers a XCAP client interface with general functions that\nallow requesting for a specific element from a XCAP server. In addition\nto that it also offers the service of storing and updating the documents\nit receives. In this case only an initial request to the module is\nrequired - xcapGetNewDoc - which is like a request to the module to\nhandle from that point on the referenced document so as to promise that\nthe newest version will always be present in database.\n\nThe update method is also configurable, either through periodical\nqueries, applicable to any kind of XCAP server or with a management\ncommand that should be sent by the server upon an update.\n\nThe module is currently used by the \u201cpresence_xml\u201d module, if the\n'integrated_xcap_server' parameter is not set.\n",
  "parameters": {
   "db_url": "### `db_url`(str)\n\nThe database url.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"xcap_client\", \"db_url\", \"dbdriver://username:password@dbhost/dbname\")\n...\n```\n",
   "xcap_table": "### `xcap_table`(str)\n\nThe name of the db table where XCAP documents are stored.\n\n*Default value is \u201cxcap\u201d.*\n\n```\n...\nmodparam(\"xcap_client\", \"xcap_table\", \"xcaps\")\n...\n```\n",
   "periodical_query": "### `periodical_query`(int)\n\nA flag to disable periodical query as an update method for the documents\nthe module is responsible for. It could be disabled when the XCAP server\nis capable to send the exported management command when a change occurs\nor when another module in Kamailio handles updates.\n\nTo disable it set this parameter to 0.\n\n*Default value is \u201c1\u201d.*\n\n```\n...\nmodparam(\"xcap_client\", \"periodical_query\", 0)\n...\n```\n",
   "query_period": "### `query_period`(int)\n\nShould be set if periodical query is not disabled. Represents the time\ninterval the XCAP servers should be queried for an update.\n\nTo disable it set this parameter to 0.\n\n*Default value is \u201c100\u201d.*\n\n```\n...\nmodparam(\"xcap_client\", \"query_period\", 50)\n...\n```\n"
  },
  "functions": {}
 },
 "xcap_server": {
  "overview": "This module provides an XCAP server functionally inside Kamailio and SER\nSIP servers.\n\nBenefits brought by this integrated XCAP server:\n\n- reuse of SIP router transport layer - XCAP documents can be sent via\n  SIP (UDP, TCP, TLS and SCTP) and via HTTP (TCP or TLS (HTTPS)). For\n  HTTP/S, you need to load XHTTP module to handle HTTP/S requests.\n\n- the Presence server has access immediately to the latest version of\n  XCAP documents. No more need to trigger refresh of XCAP documents via\n  RPC command.\n\n- can be used stand-alone, with a different Presence server. It is not\n  specific for Kamailio or SER. Documents can be fetched via GET\n\n- no exotic dependencies, it is written in C. It depends on libxml2, sl\n  module and a database module (required to store the xcap documents).\n\n- you can do digest authentication using database, radius, ldap, etc.\n  Can reuse authorization mechanisms provided by SIP server.\n\n- flexibility - the XCAP server is controlled from config file of SIP\n  server, therefore you can blend the XCAP logic with features provided\n  by core or other modules.\n\nImportant: be sure you have global parameter: 'tcp_accept_no_cl=yes'.\n",
  "parameters": {
   "db_url": "### `db_url` (string)\n\nDatabase URL.\n\n*Default value is \u201cmysql://kamailio:kamailiorw@localhost/kamailio\u201d.*\n\n```\n...\nmodparam(\"xcap_server\", \"db_url\", \"mysql://user:passwd@host.com/dbname\")\n...\n```\n",
   "xcap_table": "### `xcap_table` (string)\n\nThe name of table where to store the xcap documents.\n\n*Default value is \u201cxcap\u201d.*\n\n```\n...\nmodparam(\"xcap_server\", \"xcap_table\", \"xcapdocs\")\n...\n```\n",
   "xcap_root": "### `xcap_root` (str)\n\nXCAP root URL.\n\n*Default value is '/xcap-root/'.*\n\n```\n...\nmodparam(\"xcap_server\", \"xcap_root\", \"/xcap-root/\")\n...\n```\n",
   "buf_size": "### `buf_size` (int)\n\nSize of local buffer for handling XCAP documents.\n\n*Default value is \u201c1024\u201d.*\n\n```\n...\nmodparam(\"xcap_server\", \"buf_size\", 2048)\n...\n```\n",
   "xml_ns": "### `xml_ns` (str)\n\nRegister extra XML namespaces to be used with XPath. You can set the\nparameter many times to add more namespaces. The format is\n'prefix=href'.\n\n*Default value is 'null'.*\n\n```\n...\nmodparam(\"xcap_server\", \"xml_ns\",\n    \"rl=urn:ietf:params:xml:ns:resource-lists\")\nmodparam(\"xcap_server\", \"xml_ns\",\n    \"my=urn:my:prefix\")\n...\n```\n",
   "directory_scheme": "### `directory_scheme` (int)\n\nAllows the scheme used in org.openmobilealliance.xcap-directory listings\nto be set to a specific value.\n\nThe URLs in an org.oma.xcap-directory listing must be be paths a client\ncan use to download the listed XCAP documents. In some cases (for\nexample, when the XCAP server is accessed using HTTP from an HTTP proxy\nthe client connected to using HTTPS) the XCAP server may not be able to\nautomatically determine the correct scheme to use based on the HTTP\nconnection.\n\n- *-1 (default)* - determine scheme automatically. HTTP for TCP\n  connections and HTTPS for TLS connections.\n\n- *0* - use the HTTP scheme.\n\n- *1* - use the HTTPS scheme.\n\n<!-- -->\n\n\n```\n...\nmodparam(\"xcap_server\", \"directory_scheme\", 0)\n...\n```\n",
   "directory_hostname": "### `directory_hostname` (string)\n\nAllows the hostname (and port) used in\norg.openmobilealliance.xcap-directory listings to be set to a specific\nvalue.\n\nThe URLs in an org.oma.xcap-directory listing must be be paths a client\ncan use to download the listed XCAP documents. In some cases (for\nexample, when the XCAP server is accessed through a proxy that re-writes\nheaders, or a client is non-conforming and does not include a Host:\nheader) the XCAP server may not be able to automatically determine the\ncorrect hostname to use.\n\nWhen this parameter is not set the XCAP server will attempt to use the\ncontents of the (mandatory) Host: header. If the Host: header is not\npresent the XCAP server will use the IP address and port the XCAP\nrequest was received on.\n\n```\n...\nmodparam(\"xcap_server\", \"directory_hostname\", \"xcap.example.com\")\n...\n```\n"
  },
  "functions": {
   "xcaps_put": "### `xcaps_put(uri, path, doc)`\n\nHandle XCAP PUT command.\n\n```\n...\nevent_route[xhttp:request] {\n    if($hu=~\"^/xcap-root/\")\n    {\n        # xcap ops\n        switch($rm) {\n            case \"PUT\":\n                xcaps_put(\"sip:101@$Ri\", \"$hu\", \"$rb\");\n                exit;\n                break;\n        }\n    }\n}\n...\n```\n",
   "xcaps_get": "### `xcaps_get(uri, path)`\n\nHandle XCAP GET command.\n\n```\n...\nevent_route[xhttp:request] {\n    if($hu=~\"^/xcap-root/\")\n    {\n        # xcap ops\n        switch($rm) {\n            case \"GETT\":\n                xcaps_get(\"sip:101@$Ri\", \"$hu\");\n                exit;\n                break;\n        }\n    }\n}\n...\n```\n",
   "xcaps_del": "### `xcaps_del(uri, path)`\n\nHandle XCAP DELETE command.\n\n```\n...\nevent_route[xhttp:request] {\n    if($hu=~\"^/xcap-root/\")\n    {\n        # xcap ops\n        switch($rm) {\n            case \"DELETE\":\n                xcaps_del(\"sip:101@$Ri\", \"$hu\");\n                exit;\n                break;\n        }\n    }\n}\n...\n```\n"
  }
 },
 "xhttp": {
  "overview": "This module provides basic HTTP/1.0 server functionality inside\nKamailio. SIP and HTTP are very similar protocols, so, practically, the\nSIP parser can easily handle HTTP requests just by adding a fake Via\nheader.\n\nThe xmlrpc module uses the same concept. The xHTTP module offers a\ngeneric way of handling the HTTP protocol, by calling\n*event_route[xhttp:request]* in your config. You can check the HTTP\nURL via the config variable $hu. Note that use of $ru will raise\nerrors since the structure of an HTTP URL is not compatible with that of\na SIP URI.\n",
  "parameters": {
   "url_skip": "### `url_skip` (str)\n\nRegular expression to match the HTTP URL. If there is a match, the event\nroute is not executed.\n\n*Default value is null (don't skip).*\n\n```\n...\nmodparam(\"xhttp\", \"url_skip\", \"^/RPC2\")\n...\n```\n",
   "url_match": "### `url_match` (str)\n\nRegular expression to match the HTTP URL. If there is no match, the\nevent route is not executed. This check is done after url_skip, so if\nboth url_skip and url_match would match then the event route is not\nexecuted (url_skip has higher priority).\n\n*Default value is null (match everything).*\n\n```\n...\nmodparam(\"xhttp\", \"url_match\", \"^/sip/\")\n...\n```\n",
   "event_callback": "### `event_callback` (str)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nevent_route[xhttp:request] block.\n\nThe function has one string parameter with the value \"xhttp:request\".\n\n*Default value is 'empty' (no function is executed for events).*\n\n```\n...\nmodparam(\"xhttp\", \"event_callback\", \"ksr_xhttp_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_xhttp_event(evname)\n    KSR.info(\"===== xhttp module triggered event: \" .. evname .. \"\\n\");\n    return 1;\nend\n...\n```\n"
  },
  "functions": {
   "xhttp_reply": "### `xhttp_reply(code, reason, ctype, body)`\n\nSend back a reply with content-type and body.\n\n```\n...\nevent_route[xhttp:request] {\n    xhttp_reply(\"200\", \"OK\", \"text/html\",\n        \"<html><body>OK - [$si:$sp]</body></html>\");\n}\n...\n```\n"
  }
 },
 "xhttp_pi": {
  "overview": "This module provides a web provisioning interface for Kamailio. It is\nusing the Kamailio's internal database API to provide a simple way of\nmanipulating records inside Kamailio's tables.\n\nThe module offers:\n\n- ability to connect to multiple/different databases through Kamailio's\n  db API; (all Kamailio's databases are supported);\n\n- ability to perform data input validation through Kamailio API;\n\n- ability to reconfigure the interface layout on the fly by reloading\n  the config from the xml framework via the rpc command interface.\n\nNote: when provisioning tables using *db_text*, any change made to a\n*db_text* table will not be reflected on the actual text file. In order\nto force a write out to the disk of the cached tables, the db_text rpc\ncommand *db_text.dump* must be used.\n",
  "parameters": {
   "xhttp_pi_root": "### `xhttp_pi_root` (str)\n\nIt specifies the root path for provisioning http requests. The link to\nthe provisioning web interface must be constructed using the following\npattern: http://[server_IP]:[tcp_port]/[xhttp_pi_root]\n\n*Default value is \"pi\".*\n\n```\n...\nmodparam(\"xhttp_pi\", \"xhttp_pi_root\", \"pi\")\n...\n```\n",
   "xhttp_pi_buf_size": "### `xhttp_pi_buf_size` (int)\n\nIt specifies the maximum length of the buffer (in bytes) used to write\nin the HTML reply information in order to build the HTML response.\n\n*Default value is 0 (auto set to 1/3 of the size of the configured pkg\nmem).*\n\n```\n...\nmodparam(\"xhttp_pi\", \"xhttp_pi_buf_size\", 1024)\n...\n```\n",
   "framework": "### `framework` (string)\n\nIt specifies the full path for xml framework descriptor.\n\n*There's no default value. This parameter is mandatory.*\n\n```\n...\nmodparam(\"xhttp_pi\", \"framework\", \"/usr/local/etc/kamailio/pi_framework.xml\")\n...\n```\n"
  },
  "functions": {
   "dispatch_xhttp_pi": "### `dispatch_xhttp_pi()`\n\nHandle the HTTP request and generate a response.\n\n```\n...\ntcp_accept_no_cl=yes\n...\nloadmodule \"sl.so\"\nloadmodule \"xhttp.so\"\nloadmodule \"xhttp_pi.so\"\n...\nmodparam(\"xhttp_pi\", \"framework\", \"/usr/local/etc/kamailio/pi_framework.xml\")\n...\nevent_route[xhttp:request] {\n    $var(xhttp_root) = $(hu{s.substr,0,3});\n    if ($var(xhttp_root) == \"/pi\")\n        dispatch_xhttp_pi();\n    else\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n                \"<html><body>Wrong URL $hu</body></html>\");\n}\n...\n```\n"
  }
 },
 "xhttp_prom": {
  "overview": "This module generates suitable metrics for a Prometheus monitoring\nplatform.\n\nIt answers Prometheus pull requests (HTTP requests to /metrics URL).\n\nThe module generates metrics based on Kamailio statistics, and also the\nuser can create his own metrics (currently counters, gauges and\nhistograms).\n\nThe xHTTP_PROM module uses the xHTTP module to handle HTTP requests.\nRead the documentation of the xHTTP module for more details.\n\nNOTE: This module is based on xHTTP_RPC one.\n\n*IMPORTANT*: This module uses private memory to generate HTTP responses,\nand shared memory to store all the metrics. Remember to increase size of\nprivate and shared memory if you use a huge amount of metrics.\n\nPrometheus URLs:\n\n- https://prometheus.io/\n- https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\n- https://prometheus.io/docs/instrumenting/exposition_formats/\n",
  "parameters": {
   "xhttp_prom_buf_size": "### `xhttp_prom_buf_size` (integer)\n\nSpecifies the maximum length of the buffer (in bytes) used to write the\nmetric reply information in order to build the HTML response.\n\n*Default value is 0 (auto set to 1/3 of the size of the configured pkg\nmem).*\n\n```\n...\nmodparam(\"xhttp_prom\", \"xhttp_prom_buf_size\", 1024)\n...\n        \n```\n",
   "xhttp_prom_timeout": "### `xhttp_prom_timeout` (integer)\n\nSpecifies a timeout in minutes. A metric not used during this timeout is\nautomatically deleted. Listing metrics does not count as using them.\n\n*If set to 0 timeout is disabled.* Negative values are not allowed.\n\n*Default value is 60 minutes.*\n\n```\n...\n# Set timeout to 10 hours\nmodparam(\"xhttp_prom\", \"xhttp_prom_timeout\", 600)\n...\n        \n```\n",
   "xhttp_prom_stats": "### `xhttp_prom_stats` (str)\n\nSpecifies which internal statistics from Kamailio to show. Possible\nvalues:\n\n- *all* - Show whole Kamailio statistics\n\n- *group_name:* - Show all statistics for a group\n\n- *statistic_name* - Show a specific statistic. It automatically finds\n  the group.\n\n*Default value is \"\", meaning do not display any Kamailio statistics.*\n\n*IMPORTANT: Kamailio internal statistics are parsed to convert - into\n_, so they accomplish with Prometheus guidelines for metric names.\n<https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels>*\nUser generated statistics and label names are not parsed.\n\n```\n...\n# show all kamailio statistics.\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"all\")\n\n# show statistics for sl group.\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"sl:\")\n\n# Show statistic for 200_replies in sl group.\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"200_replies\")\n\n# Do not display internal Kamailio statistics. This is the default option.\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"\")\n...\n        \n```\n",
   "xhttp_prom_beginning": "### `xhttp_prom_beginning` (str)\n\nSpecifies beginning of string the metrics are build with.\n\n*It defaults to \"kamailio_\"*, so if not specified every metric will\nstart with \"kamailio_\".\n\nVoid string \"\" is also allowed, meaning no prefix string for every\nmetric name.\n\n```\n...\n# All metrics will start with \"my_metric_\".\nmodparam(\"xhttp_prom\", \"xhttp_prom_beginning\", \"my_metric_\")\n\n# No string at the beginning.\nmodparam(\"xhttp_prom\", \"xhttp_prom_beginning\", \"\");\n...\n        \n```\n",
   "prom_counter": "### `prom_counter` (str)\n\nCreate a counter metric.\n\nThis function declares a counter but the actual counter is only created\nwhen using it (by adding to or resetting it)\n\nIt takes a list of attribute=value separated by semicolon, the\nattributes can be name and label.\n\n- *name* - name of the counter. This attribute is mandatory. It is used\n  to generate the metric name. Each name is unique, no metric shall\n  repeat a name.\n\n- *label* - names of labels in the counter. Optional. Only one label\n  parameter at most allowed in counters. Each label name is separated by\n  *:* without spaces. At most only three label names allowed in each\n  label parameter.\n\n  ```\n  # Create two labels called method and handler\n  label = method:handler\n  This would generate  {method=\"whatever\", handler=\"whatever2\"} when building\n  the metric.\n  ```\n\n<!-- -->\n\n\n```\n...\n\n# Create cnt_first counter with no labels.\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_first;\");\n\n# Create cnt_second counter with no labels.\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_second;\");\n\n\n# Create cnt_third counter with label method\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_third; label=method\");\n\nThese lines declare the counter but the actual metric will be created when\nusing it by prom_counter_inc or prom_counter_reset functions.\n\n...\n        \n```\n",
   "prom_gauge": "### `prom_gauge` (str)\n\nCreate a gauge metric.\n\nThis function declares the gauge but the actual gauge is only created\nwhen using it (by setting or resetting it)\n\nIt takes a list of attribute=value separated by semicolon, the\nattributes can be name and value.\n\n- *name* - name of the gauge. This attribute is mandatory. It is used to\n  generate the metric name. Each name is unique, no metric shall repeat\n  a name.\n\n- *label* - names of labels in the gauge. Optional. Only one label\n  parameter at most allowed in gauges. Each label name is separated by\n  *:* without spaces. At most only three label names allowed inside each\n  label parameter.\n\n  ```\n  # Create two labels called method and handler\n  label = method:handler\n  This would generate  {method=\"whatever\", handler=\"whatever2\"} when building\n  the metric.\n  ```\n\n<!-- -->\n\n\n```\n...\n\n# Create gg_first gauge with no labels\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg_first;\");\n\n# Create gg_second gauge with no labels\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg_second;\");\n\n\n# Create gg_third gauge with two labels method and handler:\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg_third; label=method:handler;\");\n\n...\n        \n```\n",
   "prom_histogram": "### `prom_histogram` (str)\n\nCreate a histogram metric.\n\nThis function declares a histogram but the actual histogram is only\ncreated when observing it.\n\nIt takes a list of attribute=value separated by semicolon, the\nattributes can be name, label and buckets.\n\n- *name* - name of the histogram. This attribute is mandatory. It is\n  used to generate the metric name. Each name is unique, no metric shall\n  repeat a name.\n\n- *label* - names of labels in the histogram. Optional. Only one label\n  parameter at most allowed in histograms. Each label name is separated\n  by *:* without spaces. At most only three label names allowed in each\n  label parameter.\n\n  ```\n  # Create two labels called method and handler\n  label = method:handler\n  This would generate  {method=\"whatever\", handler=\"whatever2\"} when building\n  the metric.\n  ```\n\n- *buckets* - specifies upper bounds for buckets in the histogram. This\n  attribute is optional.\n\n  Bucket values are separated by \":\". Each value has to be a number.\n\n  \"+Inf\" upper bucket is always automatically included.\n\n  At least one bucket value is needed (other than +Inf).\n\n  Every bucket value has to increase in the list.\n\n  If no buckets specified, default bucket list is set to these values:\n\n  [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]\n\n<!-- -->\n\n\n```\n...\n\n# Create my_histo histogram with no labels and default buckets.\nmodparam(\"xhttp_prom\", \"prom_histogram\", \"name=my_histo;\");\n\n# Create second_histo histogram with one label and default buckets.\n# modparam(\"xhttp_prom\", \"prom_histogram\", \"name=second_histo; label=my_lbl\");\n\n# Create a histogram with no labels and buckets 3.1, 5, 6.5\nmodparam(\"xhttp_prom\", \"prom_histogram\", \"name=histo_third; buckets=3.1:5:6.5\");\n\n# Create a histogram with a label and buckets 3.1, 5, 6.5\nmodparam(\"xhttp_prom\", \"prom_histogram\", \"name=histo_fourth; label=lbl; buckets=3.1:5:6.5\");\n\nThese lines declare the histogram but the actual metric will be created when\nusing it by prom_histogram_observe function.\n\n...\n        \n```\n"
  },
  "functions": {
   "prom_counter_reset": "### `prom_counter_reset(name, l0, l1, l2)`\n\nGet a counter based on its name and labels and reset its value to 0.\nName parameter is mandatory. Values of labels are optional (from none up\nto three). Name in prom_counter_reset has to match same name in\nprom_counter parameter. Number of labels in prom_counter_reset has to\nmatch number of labels in prom_counter parameter. First time a counter\nis used with this reset function the counter is created if it does not\nexist already.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *counter_reset_l0*, *counter_reset_l1*,\n*counter_reset_l2* and *counter_reset_l3*.\n\n```\n...\n# Definition of counter with prom_counter with labels method and IP\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt01; label=method:IP;\");\n...\n# Reset cnt01 counter with two values \"push\" and \"192.168.0.1\" in labels to zero.\n# First time we execute this function the counter will be created.\nprom_counter_reset(\"cnt01\", \"push\", \"192.168.0.1\");\n...\n# A metric like this will appear when listing this counter:\nkamailio_cnt01 {method=\"push\", IP=\"192.168.0.1\"} 0 1234567890\n...\n        \n```\n",
   "prom_gauge_reset": "### `prom_gauge_reset(name, l0, l1, l2)`\n\nGet a gauge based on its name and labels and reset its value to 0. Name\nparameter is mandatory. Values of labels are optional (from none up to\nthree). Name in prom_gauge_reset has to match same name in prom_gauge\nparameter. Number of labels in prom_gauge_reset has to match number of\nlabels in prom_gauge parameter. First time a gauge is used with this\nreset function the gauge is created if it does not exist already.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *gauge_reset_l0*, *gauge_reset_l1*,\n*gauge_reset_l2* and *gauge_reset_l3*.\n\n```\n...\n# Definition of gauge with prom_gauge with labels method and IP\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=cnt01; label=method:IP;\");\n...\n# Reset cnt01 gauge with two values \"push\" and \"192.168.0.1\" in labels to zero.\n# First time we execute this function the gauge will be created.\nprom_gauge_reset(\"cnt01\", \"push\", \"192.168.0.1\");\n...\n# A metric like this will appear when listing this gauge:\nkamailio_cnt01 {method=\"push\", IP=\"192.168.0.1\"} 0 1234567890\n...\n        \n```\n",
   "prom_counter_inc": "### `prom_counter_inc(name, number, l0, l1, l2)`\n\nGet a counter identified by its name and labels and increase its value\nby a number. If counter does not exist it creates the counter,\ninitializes it to zero and adds the number.\n\nName is mandatory, number is mandatory. Number has to be positive or\nzero (integer). l0, l1, l2 are values of labels and are optional.\n\nname value and number of labels have to match a previous counter\ndefinition with prom_counter.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *counter_inc_l0*, *counter_inc_l1*,\n*counter_inc_l2* and *counter_inc_l3*.\n\n```\n...\n# Definition of cnt01 counter with no labels.\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt01;\");\n...\n# Add 10 to value of cnt01 counter (with no labels) If counter does not exist it gets created.\nprom_counter_inc(\"cnt01\", \"10\");\n...\n\n# Definition of cnt02 counter with two labels method and IP\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt02; label=method:IP;\");\n...\n# Add 15 to value of cnt02 counter with labels method and IP. It creates the counter if it does not exist.\nprom_counter_inc(\"cnt02\", \"15\", \"push\", \"192.168.0.1\");\n# When listed the metric it will show a line like this:\nkamailio_cnt02 {method=\"push\", IP=\"192.168.0.1\"} 15 1234567890\n...\n        \n```\n",
   "prom_gauge_set": "### `prom_gauge_set(name, number, l0, l1, l2)`\n\nGet a gauge identified by its name and labels and set its value to a\nnumber. If gauge does not exist it creates the gauge and assigns the\nvalue to it.\n\nName is mandatory, number is mandatory. Number is a string that will be\nparsed as a float. l0, l1, l2 are values of labels and are optional.\n\nname value and number of labels have to match a previous gauge\ndefinition with prom_gauge.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *gauge_set_l0*, *gauge_set_l1*,\n*gauge_set_l2* and *gauge_set_l3*.\n\n```\n...\n# Definition of gg01 gauge with no labels.\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg01;\");\n...\n# Assign -12.5 to value of gg01 gauge (with no labels) If gauge does not exist it gets created\nprom_gauge_set(\"gg01\", \"-12.5\");\n...\n\n# Definition of gg02 gauge with two labels method and IP\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg02; label=method:IP;\");\n...\n# Assign 2.8 to value of gg02 gauge with labels method and IP. It creates the gauge if it does not exist.\nprom_gauge_set(\"gg02\", \"2.8\", \"push\", \"192.168.0.1\");\n# When listed the metric it will show a line like this:\nkamailio_gg02 {method=\"push\", IP=\"192.168.0.1\"} 2.8 1234567890\n...\n        \n```\n",
   "prom_histogram_observe": "### `prom_histogram_observe(name, number, l0, l1, l2)`\n\nGet a histogram identified by its name and labels and observe a value in\nit. If histogram does not exist it creates the histogram and accumulate\nthe value in its buckets, counter and sum.\n\nName is mandatory, number is mandatory. Number is a string that will be\nparsed as a float. l0, l1, l2 are values of labels and are optional.\n\nname value and number of labels have to match a previous histogram\ndefinition with prom_histogram.\n\nThis function accepts pseudovariables on its parameters.\n\nAvailable via KEMI framework as *histogram_observe_l0*,\n*histogram_observe_l1*, *histogram_observe_l2* and\n*histogram_observe_l3*.\n\n```\n...\n# Definition of hist01 histogram with no labels and default buckets.\nmodparam(\"xhttp_prom\", \"prom_histogram\", \"name=hist01;\");\n...\n# Observe -12.5 value in hist01 histogram (with no labels). If histogram does not exist it gets created:\nprom_histogram_observe(\"hist01\", \"-12.5\");\n...\n\n# Definition of hist02 histogram with two labels method and IP and buckets [2.3, 5.8, +Inf]:\nmodparam(\"xhttp_prom\", \"prom_histogram\", \"name=hist02; label=method:IP; buckets=2.3:5.8\");\n...\n# Observe 2.8 value in hist02 histogram with labels method and IP.\n# It creates the histogram if it does not exist.\nprom_histogram_observe(\"hist02\", \"2.8\", \"push\", \"192.168.0.1\");\n# When listed the metric it will show lines like this:\nhist02_bucket{method=\"push\", IP=\"192.168.0.1\", le=\"2.300000\"} 0 1592574659768\nhist02_bucket{method=\"push\", IP=\"192.168.0.1\", le=\"5.800000\"} 1 1592574659768\nhist02_bucket{method=\"push\", IP=\"192.168.0.1\", le=\"+Inf\"} 1 1592574659768\nhist02_sum{method=\"push\", IP=\"192.168.0.1\"} 2.800000 1592574659768\nhist02_count{method=\"push\", IP=\"192.168.0.1\"} 1 1592574659768\n\n...\n        \n```\n",
   "prom_dispatch": "### `prom_dispatch()`\n\nHandle the HTTP request and generate a response.\n\nAvailable via KEMI framework as *xhttp_prom.dispatch*\n\n```\n...\n# Needed to use SIP frames as HTTP ones.\ntcp_accept_no_cl=yes\n...\n# xhttp module depends on sl one.\nloadmodule \"sl.so\"\nloadmodule \"xhttp.so\"\nloadmodule \"xhttp_prom.so\"\n...\n# show all kamailio statistics.\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"all\")\n...\nevent_route[xhttp:request] {\n    $var(xhttp_prom_root) = $(hu{s.substr,0,8});\n    if ($var(xhttp_prom_root) == \"/metrics\")\n        prom_dispatch();\n    else\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n                \"<html><body>Wrong URL $hu</body></html>\");\n}\n...\n        \n```\n\nAnother example with counters and gauge:\n\n```\n...\n# Needed to use SIP frames as HTTP ones.\ntcp_accept_no_cl=yes\n\n# xhttp module depends on sl one.\nloadmodule \"sl.so\"\nloadmodule \"xhttp.so\"\nloadmodule \"xhttp_prom.so\"\n\n# show Kamailio statistics for sl group\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"sl:\")\n\n# Define two counters and a gauge\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_first;\");\nmodparam(\"xhttp_prom\", \"prom_counter\", \"name=cnt_second; label=method:IP\");\nmodparam(\"xhttp_prom\", \"prom_gauge\", \"name=gg_first; label=handler\");\n\nevent_route[xhttp:request] {\n    $var(xhttp_prom_root) = $(hu{s.substr,0,8});\n    if ($var(xhttp_prom_root) == \"/metrics\") {\n        prom_counter_reset(\"cnt_first\");\n        prom_counter_inc(\"cnt_second\", \"10\", \"push\", \"192.168.0.1\");\n        prom_gauge_set(\"gg_first\", \"5.2\", \"my_handler\");\n        prom_dispatch();\n    } else\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n                \"<html><body>Wrong URL $hu</body></html>\");\n}\n...\n\nWe can manually check the result with a web browser:\nWe assume Kamailio runs in localhost and port is set to default (same as SIP: 5060)\nhttp://localhost:5060\n...\n\n# User defined metrics\nkamailio_cnt_first 0 1554839325427\nkamailio_cnt_second {method=\"push\", IP=\"192.168.0.1\"} 10 1554839325427\nkamailio_gg_first{handler=\"my_handler\"} 5.2 1554839325427\n\n# Kamailio internal statistics\nkamailio_sl_1xx_replies 0 1554839325427\nkamailio_sl_200_replies 15 1554839325427\nkamailio_sl_202_replies 0 1554839325427\nkamailio_sl_2xx_replies 0 1554839325427\nkamailio_sl_300_replies 0 1554839325427\nkamailio_sl_301_replies 0 1554839325427\nkamailio_sl_302_replies 0 1554839325427\nkamailio_sl_3xx_replies 0 1554839325427\nkamailio_sl_400_replies 0 1554839325427\nkamailio_sl_401_replies 0 1554839325427\nkamailio_sl_403_replies 0 1554839325427\nkamailio_sl_404_replies 0 1554839325427\nkamailio_sl_407_replies 0 1554839325427\nkamailio_sl_408_replies 0 1554839325427\nkamailio_sl_483_replies 0 1554839325427\nkamailio_sl_4xx_replies 0 1554839325427\nkamailio_sl_500_replies 0 1554839325427\nkamailio_sl_5xx_replies 0 1554839325427\nkamailio_sl_6xx_replies 0 1554839325427\nkamailio_sl_failures 0 1554839325427\nkamailio_sl_received_ACKs 0 1554839325427\nkamailio_sl_sent_err_replies 0 1554839325427\nkamailio_sl_sent_replies 15 1554839325427\nkamailio_sl_xxx_replies 0 1554839325461\n...\n        \n```\n",
   "prom_check_uri": "### `prom_check_uri()`\n\nCheck if path of HTTP URL equals /metrics. This avoids us to check hu\nvariable from xHTTP module.\n\nNOTE: Remember not to block /metrics URL in xHTTP module\n\nAvailable via KEMI framework as *xhttp_prom.check_uri*\n\n```\n...\n# Needed to use SIP frames as HTTP ones.\ntcp_accept_no_cl=yes\n...\n# xhttp module depends on sl one.\nloadmodule \"sl.so\"\nloadmodule \"xhttp.so\"\nloadmodule \"xhttp_prom.so\"\n...\n# show all kamailio statistics.\nmodparam(\"xhttp_prom\", \"xhttp_prom_stats\", \"all\")\n...\nevent_route[xhttp:request] {\n    if (prom_check_uri())\n        prom_dispatch();\n    else\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n                \"<html><body>Wrong URL $hu</body></html>\");\n}\n...\n        \n```\n"
  }
 },
 "xhttp_rpc": {
  "overview": "This module provides an HTTP transport layer implementation for the RPC\nmanagement interface in a human-readable format.\n\nThe xHTTP_RPC module uses the xHTTP module to handle HTTP requests. Read\nthe documentation of the xHTTP module for more details.\n",
  "parameters": {
   "xhttp_rpc_root": "### `xhttp_rpc_root` (str)\n\nSpecifies the root path for RPC http requests. The link to the RPC web\ninterface must be constructed using the following pattern:\nhttp://[server_IP]:[tcp_port]/[xhttp_rpc_root]\n\n*Default value is \"rpc\".*\n\n```\n...\nmodparam(\"xhttp_rpc\", \"xhttp_rpc_root\", \"http_rpc\")\n...\n```\n",
   "xhttp_rpc_buf_size": "### `xhttp_rpc_buf_size` (str)\n\nSpecifies the maximum length of the buffer (in bytes) used to write the\nRPC reply information in order to build the HTML response.\n\n*Default value is 0 (auto set to 1/3 of the size of the configured pkg\nmem).*\n\n```\n...\nmodparam(\"xhttp_rpc\", \"xhttp_rpc_buf_size\", 1024)\n...\n```\n"
  },
  "functions": {
   "dispatch_xhttp_rpc": "### `dispatch_xhttp_rpc()`\n\nHandle the HTTP request and generate a response.\n\n```\n...\ntcp_accept_no_cl=yes\n...\nloadmodule \"sl.so\"\nloadmodule \"xhttp.so\"\nloadmodule \"xhttp_rpc.so\"\n...\nmodparam(\"xhttp_rpc\", \"xhttp_rpc_root\", \"http_rpc\")\n...\nevent_route[xhttp:request] {\n    $var(xhttp_rpc_root) = $(hu{s.substr,0,9});\n    if ($var(xhttp_rpc_root) == \"/http_rpc\")\n        dispatch_xhttp_rpc();\n    else\n        xhttp_reply(\"200\", \"OK\", \"text/html\",\n                \"<html><body>Wrong URL $hu</body></html>\");\n}\n...\n```\n"
  }
 },
 "xlog": {
  "overview": "This module provides the possibility to print user formatted log or\ndebug messages from Kamailio scripts, similar to the printf function. A\nC-style printf specifier is replaced with a part of the SIP request or\nother variables from system.\n",
  "parameters": {
   "buf_size": "### `buf_size` (integer)\n\nMaximum size of the log message.\n\n*Default value is 4096.*\n\n```\n...\nmodparam(\"xlog\", \"buf_size\", 8192)\n...\n```\n",
   "force_color": "### `force_color` (integer)\n\nWhen set to 1, forces color codes in log messages even if `log_stderror`\nis set to 0.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"xlog\", \"force_color\", 0)\n...\n```\n",
   "long_format": "### `long_format` (integer)\n\nWhen set to 1, outputs the configuration file name in xlogl() and\nxdbgl() before the line number.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"xlog\", \"long_format\", 1)\n...\n```\n",
   "prefix": "### `prefix` (str)\n\nPrefix to be output before the log message.\n\n*Default value is \"<script>: \".*\n\n```\n...\nmodparam(\"xlog\", \"prefix\", \"-xlog: \")\n...\n```\n",
   "prefix_mode": "### `prefix_mode` (str)\n\ncontrol behaviour of `prefix` value. if mode = 0 then `prefix` is\ntreated as string (current behaviour). if mode = 1 then `prefix` is\ntreated as pv_format specifier and value will be evaluated before\noutput.\n\n*Default value is 0.*\n\n```\n...\nmodparam(\"xlog\", \"prefix\", \"$cfg(name):$cfg(line)\")\nmodparam(\"xlog\", \"prefix_mode\", 1)\n...\n```\n",
   "log_facility": "### `log_facility` (string)\n\nSyslog facility to be used for the xlog output. By setting this, and\nconfiguring syslog, you can get the xlog messages in a separate syslog\nfile than the debug messages issued from the source code.\n\nDefault value is NULL (unset - use same facility as source code debug\nmessages).\n\n```\nmodparam(\"xlog\", \"log_facility\", \"LOG_DAEMON\")\n```\n",
   "log_colors": "### `log_colors` (string)\n\nUpdate terminal colors used by the Kamailio core for log levels (when\nlog_stderr=1 and log_color=1). The value has to be 'logname=colors',\nwhere colors is two characters specifying foreground and background in\nthe same format as $C(xy) variable.\n\nThe parameter can be set many times. The value can also be a\n';'-separated list of color specifications.\n\nDefault value is NULL.\n\n```\nmodparam(\"xlog\", \"log_colors\", \"L_ERR=cr\")\nmodparam(\"xlog\", \"log_colors\", \"L_ERR=cr;L_WARN=px\")\n```\n",
   "methods_filter": "### `methods_filter` (int)\n\nThe bitmask with internal SIP method ids to be ignored by xlogm()\nfunction. The value can be changed at runtime via cfg reload framework:\n\n```\n...\nkamcmd cfg.set_now_int xlog methods_filter 15\n...\n```\n\nTo see the associated internal ids for SIP requests, look in source tree\ninside parser/msg_parser.h for enum request_method.\n\n*Default value is -1 (all SIP methods are ignored).*\n\n```\n...\nmodparam(\"xlog\", \"methods_filter\", 15)\n...\n```\n"
  },
  "functions": {
   "xlog": "### `xlog([ [facility,] level,] format)`\n\nOutput a formatted log message.\n\nMeaning of the parameters are as follows:\n\n- *facility* - The syslog facility that will be used for this single log\n  message.\n\n  If this parameter is missing, the implicit facility is either the\n  facility set with the 'log_facility' module parameter or the core's\n  log facility.\n\n- *level* - The level that will be used in LOG function. It can be:\n\n  - L_ALERT - log level -5\n\n  - L_BUG - log level -4\n\n  - L_CRIT - log level -3\n\n  - L_ERR - log level -1\n\n  - L_WARN - log level 0\n\n  - L_NOTICE - log level 1\n\n  - L_INFO - log level 2\n\n  - L_DBG - log level 3\n\n  - $pv - any valid pseudo-variable, that has an integer value. See\n    above options for valid log levels.\n\n\n  If it is not a pseudo-variable, then what really matters is the third\n  letter of the value. If the log level is higher than the \u201cdebug\u201d\n  global parameter, the message is not printed to syslog.\n\n  If this parameter is missing, the implicit log level is 'L_ERR'.\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxlog(\"L_ERR\", \"time [$Tf] method ($rm) r-uri ($ru) 2nd via ($hdr(via[1]))\\n\");\n...\nxlog(\"time [$Tf] method ($rm) r-uri ($ru) 2nd via ($hdr(via[1]))\\n\");\n...\n$var(loglevel) = 2;\nxlog(\"$var(loglevel)\", \"time [$Tf] method ($rm) r-uri ($ru)\\n\");\n...\nxlog(\"LOG_LOCAL3\", \"L_ERR\", \"this message will be sent to syslog facility LOG_LOCAL3\\n\");\n...\n```\n",
   "xdbg": "### `xdbg(format)`\n\nPrint a formatted message using DBG function.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxdbg(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xinfo": "### `xinfo(format)`\n\nPrint a formatted log message at L_INFO level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxinfo(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xnotice": "### `xnotice(format)`\n\nPrint a formatted log message at L_NOTICE level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxnotice(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xwarn": "### `xwarn(format)`\n\nPrint a formatted log message at L_WARN level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxwarn(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xerr": "### `xerr(format)`\n\nPrint a formatted log message at L_ERR level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxerr(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xbug": "### `xbug(format)`\n\nPrint a formatted log message at L_BUG level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxbug(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xcrit": "### `xcrit(format)`\n\nPrint a formatted log message at L_CRIT level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxcrit(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xalert": "### `xalert(format)`\n\nPrint a formatted log message at L_ALERT level.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\nThis function can be used from ANY_ROUTE.\n\n```\n...\nxalert(\"time $Cbx[$Tf]$Cxx method ($rm) r-uri ($ru)\\n\");\n...\n```\n",
   "xlogl": "### `xlogl([ [facility,] level,] format)`\n\nSimilar to xlog(), in addition prints configuration file line number at\nthe beginning of message.\n",
   "xdbgl": "### `xdbgl(format)`\n\nSimilar to xdbg(), in addition prints configuration file line number at\nthe beginning of message.\n",
   "xlogm": "### `xlogm(level, format)`\n\nSimilar to xlog(level, format), but skips writing the log messages for\nSIP requests and responses that match the SIP method id with\nmethods_filter parameter value.\n"
  }
 },
 "xmlops": {
  "overview": "This is a module implementing functions and pseudo-variables for XML\noperations.\n",
  "parameters": {
   "buf_size": "### `buf_size` (integer)\n\nMaximum size of the XML buffer.\n\nDefault value is 4096.\n\n```\n...\nmodparam(\"xmlops\", \"buf_size\", 8192)\n...\n        \n```\n",
   "xml_ns": "### `xml_ns` (str)\n\nRegister xml namespace prefix. Parameter value must have the format:\n'prefix=uri'. It can be set many times to cope with multiple namespaces\nwithout prefix.\n\nThis is useful when it is needed to access XML documents that specify\nxmlns without prefix, which is not XML-standard compliant, but it comes\nwith SIP SIMPLE presence bodies.\n\n```\n...\nmodparam(\"xmlops\", \"xml_ns\", \"rpid=urn:ietf:params:xml:ns:pidf:rpid\")\nmodparam(\"xmlops\", \"xml_ns\", \"pidf=urn:ietf:params:xml:ns:pidf\")\n...\n$xml(x=>doc) = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <presence xmlns=\"urn:ietf:params:xml:ns:pidf\" entity=\"sip:test@mydomain.com\">\n        <tuple id=\"86ae65b7-42de-4399-b635-295caad13aac\">\n            <status><basic>none</basic></status>\n        </tuple>\n    </presence>';\n\nxinfo(\"status: $xml(x=>xpath:/pidf:presence/pidf:tuple/pidf:status/pidf:basic)\\n\");\n...\n```\n"
  },
  "functions": {}
 },
 "xmlrpc": {
  "overview": "\n",
  "parameters": {
   "route": "### `route` (string)\n\nName of the route called for XMLRPC messages.\n\nThis route will be called only for HTTP messages whose method is either\nGET or POST. The message visible inside the route will be a HTTP request\nconverted to SIP (the uri will be fixed and a fake via will be added).\n\nThe route should perform additional security checks to ensure the client\nis authorized to execute management/RPC functions and then it should\ncall the `dispatch_rpc()`.\n\nDefault: the main route is used.\n\n```\nmodparam(\"xmlrpc\", \"route\", \"route_for_xmlrpcs\")\n        \n```\n",
   "autoconversion": "### `autoconversion` (string)\n\nEnable or disable automatic parameter type conversion globally, for all\nthe methods parameters. If on, a type mismatch in a method parameter\nwill not cause a fault if it is possible to automatically convert it to\nthe type expected by the method.\n\nDefault: off.\n\nIt is recommended to leave this parameter to its default off value and\nfix instead the client application (which should use the proper types)\nor to modify the target rpc to accept any type (see the rpc scan '.'\nmodifier).\n\n```\nmodparam(\"xmlrpc\", \"autoconversion\", 1)\n        \n```\n",
   "escape_cr": "### `escape_cr` (integer)\n\nEnable CR ('\\r') escaping in replies. If enabled each '\\r' in the xmlrpc\nreply will be replaced with \"&#xD;\", according to the xml spec.\n\nIt should be turned off only if you suspect interoperability problems\nwith older clients.\n\nDefault: on.\n\n```\nmodparam(\"xmlrpc\", \"escape_cr\", 1)\n        \n```\n",
   "double_lf_to_crlf": "### `double_lf_to_crlf` (integer)\n\nWhen enabled double LFs ('\\n\\n') in the input xmlrpc strings will be\nreplaced with CR LF ('\\r\\n'). This makes LF LF behave like an escape\ncharacter for CR LF and is needed for compatibility with Kamailio tools\nand to work around buggy xmlrpc clients that don't escape the CR in CR\nLF ('\\r' should be escaped to \"&#xD;\" otherwise according to the xml\nspec \"\\r\\n\" will be transformed to '\\n'), but need to send CR LF in the\nstrings (e.g. they use `tm.t_uac_wait`).\n\nNote: when this option is turned on, there is no way to send a double LF\n('\\n\\n'), it will always be transformed in CR LF ('\\r\\n').\n\nDefault: off.\n\n```\nmodparam(\"xmlrpc\", \"double_lf_to_crlf\", 1)\n        \n```\n",
   "mode": "### `mode` (integer)\n\nWhen set to 1, the xmlrpc module does not register to core the callback\nfunctions for non-SIP messages. Useful when another module registers a\ncallback for HTTP request, letting the admin decide when to call the\nXMLRPC route (or functions).\n\nDefault: 0.\n\n```\nmodparam(\"xmlrpc\", \"mode\", 1)\n        \n```\n",
   "url_skip": "### `url_skip` (str)\n\nRegular expression to match the HTTP URL. If there is a match, then the\nxmlrpc route is not executed.\n\n*Default value is null (don't skip).*\n\n```\n...\nmodparam(\"xmlrpc\", \"url_skip\", \"^/sip\")\n...\n```\n",
   "url_match": "### `url_match` (str)\n\nRegular expression to match the HTTP URL. If there is no match, then\nxmlrpc route is not executed. This check is done after url_skip, so if\nboth url_skip and url_match would match then the xmlrpc route is not\nexecuted (url_skip has higher priority).\n\n*Default value is null (match everything).*\n\n```\n...\nmodparam(\"xmlrpc\", \"url_match\", \"^/RPC2\")\n...\n```\n",
   "event_callback": "### `event_callback` (string)\n\nThe name of the function in the kemi configuration file (embedded\nscripting language such as Lua, Python, ...) to be executed instead of\nroute blocks defined by route parameter for xmlrpc request.\n\nThis route will be called only for HTTP messages whose method is either\nGET or POST. The message visible inside the route will be a HTTP request\nconverted to SIP (the uri will be fixed and a fake via will be added).\n\nThe route should perform additional security checks to ensure the client\nis authorized to execute management/RPC functions and then it should\ncall the `dispatch_rpc()`.\n\n```\n...\nmodparam(\"xmlrpc\", \"event_callback\", \"ksr_xmlrpc_event\")\n...\n-- event callback function implemented in Lua\nfunction ksr_xmlrpc_event(evname)\n    KSR.info(\"===== xmlrpc triggered event: \" .. evname .. \"\\n\");\n    local rpc_method = KSR.pv.get(\"$rm\") or \"\"\n    if ((rpc_method == \"POST\" or rpc_method == \"GET\")) then\n        if (KSR.xmlrpc.dispatch_rpc() < 0) then\n            KSR.err(\"error while executing xmlrpc event\")\n        end\n    end\n    return 1;\nend\n...\n```\n"
  },
  "functions": {
   "dispatch_rpc": "### `dispatch_rpc()`\n\nThis function processes an XMLRPC request, found in the body of the\nrequest.\n\nIt should be used only in a route specified using the `&quot;route&quot;` module\nparameter or if the request method is GET or POST (using it for other\nrequest methods will not have adverse side-effects, but it will probably\nnot work).\n\ndispatch_rpc() extracts the XML-RPC document from the body of the\nrequest to determine the name of the RPC method to be called and then it\nsearches through the list of all the RPC functions to find a function\nwith matching name. If such a function is found then dispatch_rpc() will\npass control to the function to handle the request.\n\n```\n#...\nmodparam(\"xmlrpc\", \"route\", \"XMLRPC\");\n#...\nroute[XMLRPC]{\n    if search(\"^User-Agent:.*xmlrpclib\"))\n        set_reply_close();\n    set_reply_no_connect(); # optional\n    dispatch_rpc();\n}\n        \n```\n",
   "xmlrpc_reply": "### `xmlrpc_reply(code, reason)`\n\nThis function can be called from the config script to directly generate\nan XML-RPC reply.\n\n```\n#...\nmodparam(\"xmlrpc\", \"route\", \"XMLRPC\");\n#...\nroute[XMLRPC]{\n    # allow XMLRPC requests only on TLS and only if the client\n    # certificate is valid\n    if (proto!=TLS){\n        xmlrpc_reply(\"400\", \"xmlrpc allowed only over TLS\");\n        return;\n    }\n    if (@tls.peer.verified!=\"\"){\n        xmlrpc_reply(\"400\", \"Unauthorized\");\n        return;\n    }\n    if search(\"^User-Agent:.*xmlrpclib\"))\n        set_reply_close();\n    set_reply_no_connect(); # optional\n    dispatch_rpc();\n}\n        \n```\n"
  }
 },
 "xmpp": {
  "overview": "This module is a gateway between Kamailio and a XMPP/Jabber server. It\nenables the exchange of instant messages between SIP clients and\nXMPP(jabber) clients.\n\nThe module can be used in two different modes:\n\n- **XMPP Component Mode**. In this mode, Kamailio connects to an XMPP\n  server using the standardized XMPP component interface, extending your\n  XMPP services. The connection is done over TCP/IP with authorization.\n\n- **XMPP Server**. In this mode, the Kamailio XMPP module is a\n  stand-alone XMPP server connector, with no requirement for another\n  XMPP server in the system. This server uses XMPP S2S (Server to\n  Server) connections to connect to other XMPP servers or receive\n  connections from other servers. NOTE: this is limited implementation\n  of a XMPP server, it does not support SRV or TLS so far. Also, in this\n  mode it cannot get XMPP clients connected, only XMPP servers (in other\n  words, you cannot use it to replace an XMPP full server\n  implementation). This mode is in beta stage for the moment.\n\nIn the component mode, you need a local XMPP server (recommended\nJabberd2). The XMPP module will connect by using TCP/IP connection to\nthe local jabber server. The documentation and the source for Jabberd\nserver are located at the following link:\n<http://jabberd.jabberstudio.org/2/#download>\n\nAfter you have a running XMPP server, what you need to do is set the\nfollowing parameters in the Kamailio configuration file:\n\n- gateway_domain, xmpp_domain (which can be the same as gateway_domain)\n  and xmpp_host, which are explained in the Exported Parameters section;\n\n- listen = your ip;\n\n- alias=Kamailio SIP domain and alias=gateway domain;\n\n- in the following section of the configuration file, change to your\n  gateway domain:\n\n<!-- -->\n\n\n```\n     ### ---8<--- cut here ---8<--- ###\n    if ($rd ==\"sip-xmpp.kamailio.org\") {\n        if (!t_newtran()) {\n            sl_reply_error();\n    ...........  \n```\n\n- You can also define a password for the XMPP Component connection to\n  the Jabber server, which must be the same as the xmpp_password\n  parameter.\n\nA use case, for the component-mode, would look like this:\n\n- Kamailio is hosting the sip-server.kamailio.org SIP domain\n\n- The gateway SIP domain is sip-xmpp.kamailio.org\n\n- The XMPP server is hosting the XMPP domain xmpp.kamailio.org\n\n- The Component is hosting the XMPP domain xmpp-sip.kamailio.org\n\nIn the XMPP stand-alone server mode, the XMPP module is a minimal\nXMPP/Jabber server. In this mode, another Jabber server is not needed.\nThe gateway will connect to other XMPP servers based on the JID domain\nand by using the standardized XMPP S2S protocol.\n\nIf you want to change to server-mode, you have to change the \"backend\"\nparameter, as shown in the Exported Parameters section, from \"component\"\nto \"server\".\n\nA use case, for the server-mode, would look like this:\n\n- Kamailio is hosting the SIP domain sip-server.kamailio.org\n\n- The gateway is hosting the SIP domain sip-xmpp.kamailio.org;\n\n- The \"XMPP server\" is running on xmpp-sip.kamailio.org.\n\nUnless 'gwmap' parameter is set, in both modes (server or component),\nthe destination address must have the same pattern:\n\n\u201csip:username<delim>jabber_server@gateway_domain\u201d\n\nFrom a jabber client's point of view, the destination will look like:\n\n\u201csip_username<delim>sip_domain@xmpp_domain\u201d\n\n'delim' is a character that can be set via 'domain_separator' parameter.\n\nIf 'gwmap' parameter is used, then the addresses are not encoding the\ndomains in the username part. They are going to be straight\n'username@domain' always.\n",
  "parameters": {
   "backend": "### `backend` (string)\n\nThe mode you are using the module; it can be either \"component\" or\n\"server\".\n\n*Default value is \"component\".*\n\n```\n...\n modparam(\"xmpp\", \"backend\", \"server\")\n...\n```\n",
   "domain_separator": "### `domain_separator` (string)\n\nIn the destination address we need an extra character as a domain\nseparator, apart from @. The address of the XMPP(jabber) client looks\nlike this:\n\"sip:username<domain_separator>jabber_server@gateway_sip_domain\". The\naddress of a SIP client has the following pattern :\n\"sip_username<domain_separator>sip_domain@gateway_xmpp_domain\"; A\ncommon used character in XMPP transports is \"%\".\n\n*Default value is \"\\*\".*\n\n```\n...\n modparam(\"xmpp\", \"domain_separator\", \"%\")\n...\n```\n",
   "gateway_domain": "### `gateway_domain` (string)\n\nThe domain of the SIP-to-XMPP gateway - it has to be in DNS or SIP UA\nhas to use outbound proxy to SIP-to-XMPP gateway IP address. It has to\nbe used as domain in the destination address of the messages sent by SIP\nusers to XMPP users:\n\"sip:username<delim>jabber_server@gateway_domain\".\n\n*Default value is \"sip-xmpp.example.org\".*\n\n```\n...\n modparam(\"xmpp\", \"gateway_domain\", \"sip-xmpp.kamailio.org\")\n...\n```\n",
   "xmpp_domain": "### `xmpp_domain` (string)\n\nThe XMPP domain of the component or the server, depending on the mode.\nIt can be the same as the gateway_domain. For a server DNS name, you\nhave to add _xmpp-server._tcp SRV records in your DNS zone to enable\nconnections from other XMPP servers.\n\n*Default value is \"sip-xmpp.example.org\".*\n\n```\n...\n modparam(\"xmpp\", \"xmpp_domain\", \"xmpp-sip.kamailio.org\")\n...\n```\n",
   "xmpp_host": "### `xmpp_host` (string)\n\nThe IP address or the hostname for the local XMPP/Jabber server to\nconnect to when the backend is set to \"component\". For server mode, this\nis the IP address the XMPP module binds to listen for connections coming\nfrom other XMPP servers.\n\n*Default value is \"xmpp.example.org\".*\n\n```\n...\n modparam(\"xmpp\", \"xmpp_host\", \"xmpp.kamailio.org\")\n...\n```\n",
   "xmpp_port": "### `xmpp_port` (integer)\n\nIn component mode, this is the port the XMPP server component interface\nlistens to. In server mode, this is the port the module listens to.\n\n*Default value is \"5347\", if backend is set to \"component\" and \"5269\",\nif backend is set to \"server\".*\n\n```\n...\n modparam(\"xmpp\", \"xmpp_port\", 5269)\n...\n```\n",
   "xmpp_password": "### `xmpp_password` (string)\n\nThe password of the local XMPP server.\n\n*This is the password for the component interface on the XMPP server,\nwhen connecting as a component. Default password is \"secret\". When\nconnecting to jabberd2, you need to make sure this is the password\nconfigured in the file \"c2s.xml\". This is how the default configuration\nfor the jabberd2 looks like:*\n\n```\n            <router>\n    ...............\n    <!-- Username/password to authenticate as --&gt;\n    <user>jabberd</user>;          <!-- default: jabberd -->;\n    <pass>secret</pass>;           <!-- default: secret -->;  \n            \n\n...\n modparam(\"xmpp\", \"xmpp_password\", \"secret\")\n...\n```\n",
   "outbound_proxy": "### `outbound_proxy` (string)\n\nThe SIP address used as next hop when sending the message. Very useful\nwhen using Kamailio with a domain name not in DNS, or when using a\nseparate Kamailio instance for XMPP processing. If not set, the message\nwill be sent to the address in destination URI.\n\n*Default value is NULL.*\n\n```\n...\n modparam(\"xmpp\", \"outbound_proxy\", \"sip:kamailio.org;transport=tcp\")\n...\n```\n",
   "gwmap": "### `gwmap` (string)\n\nSet the mappings between SIP and XMPP domains. This parameter can be set\nmany times, adding more SIP-XMPP domain mappings. Its value has to be a\nlist of tokens like 'sipdomain=xmppdomain', separated by ';' (e.g.,\n'sipdomain1=xmppdomain1;sipdomain2=xmppdomain2'.\n\nWhen this parameter is set, the URI encoding based on 'domain_separator'\nis no longer enabled. The module will use only addresses in the format\n'username@domain'. If the source or destination address does not match a\ndomain in gwmap, then the domain value is preserved when sending to the\nother protocol.\n\n*Default value is NULL.*\n\n```\n...\n modparam(\"xmpp\", \"gwmap\", \"sip.kamailio.org=xmpp.kamailio.org;abc.com=xyz.com\")\n modparam(\"xmpp\", \"gwmap\", \"kamailio.net\")\n...\n```\n\nBased on the above parameter values, if there is a SIP message from\n'sip:alice@sip.kamailio.org' going to 'sip:bob@abc.com', the XMPP\nmessage to be sent is from 'alice@xmpp.kamailio.org' to 'bob@xyz.com'.\n"
  },
  "functions": {
   "xmpp_send_message": "### `xmpp_send_message()`\n\nConverts SIP messages to XMPP(jabber) messages, in order to be relayed\nto a XMPP(jabber) client.\n\n```\n...\nxmpp_send_message();\n...\n```\n"
  }
 },
 "xprint": {
  "overview": "IMPORTANT: this is former xlog module from SIP Express Router (SER) kept\nbecause it is used by other modules via API to get the value for strings\nwith specifiers. If you want to print log messages from configuration\nfile, use the real module named 'xlog'.\n\nThis module provides the possibility to print user formatted log or\ndebug messages from SER scripts, similar to printf function but now a\nspecifier is replaced with a part of the SIP request. [Implemented\nSpecifiers](#implemented_specifiers) shows what can be printed out.\n",
  "parameters": {
   "buf_size": "### `buf_size` (integer)\n\nMaximum size of the log message.\n\nDefault value is 4096.\n\n```\n...\nmodparam(\"xprint\", \"buf_size\", 8192)\n...\n        \n```\n"
  },
  "functions": {
   "xplog": "### `xplog(level, format)`\n\nPrint a formatted message using LOG function.\n\nMeaning of the parameters is as follows:\n\n- *level* - The level that will be used in LOG function. It can be:\n\n  - L_ALERT\n\n  - L_CRIT\n\n  - L_ERR\n\n  - L_WARN\n\n  - L_NOTICE\n\n  - L_INFO\n\n  - L_DBG\n\n\n  What really matters is the third letter of the value.\n\n- *format* - The formatted string to be printed.\n\n<!-- -->\n\n\n```\n...\nxplog(\"L_ERR\", \"time [%Tf] method <%rm> r-uri <%ru> 2nd via <%{via[1]}>\\n\");\n...\n\n        \n```\n",
   "xpdbg": "### `xpdbg(format)`\n\nPrint a formatted message using DBG function.\n\nMeaning of the parameters is as follows:\n\n- *format* - The formatted string to be printed.\n\n<!-- -->\n\n\n```\n...\nxpdbg(\"time [%Tf] method <%rm> r-uri <%ru>\\n\");\n...\n\n        \n```\n"
  }
 }
}