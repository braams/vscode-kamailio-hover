{
 "{s.len": "### {s.len}\n\nReturn strlen of PV value\n\n    $var(x) = \"abc\";\n    if($(var(x){s.len}) == 3)\n    {\n       ...\n    }\n\n",
 "{s.int": "### {s.int}\n\nReturn integer value of a string-represented number\n\n    $var(x) = \"1234\";\n    if($(var(x){s.int})==1234) {\n      ...\n    }\n\n",
 "{s.md5": "### {s.md5}\n\nReturn md5 over PV value\n\n    xlog(\"md5 over From username: $(fU{s.md5})\");\n\n",
 "{s.sha256": "### {s.sha256}\n\nReturn sha 256 over PV value\n\n    xlog(\"sha 256 over From username: $(fU{s.sha256})\");\n\n",
 "{s.sha384": "### {s.sha384}\n\nReturn sha 384 over PV value\n\n    xlog(\"sha 384 over From username: $(fU{s.sha384})\");\n\n",
 "{s.sha512": "### {s.sha512}\n\nReturn sha 512 over PV value\n\n    xlog(\"sha 512 over From username: $(fU{s.sha512})\");\n\n",
 "{s.substr": "### {s.substr,offset,length}\n\nReturn substring starting at offset having size of 'length'. If offset\nis negative, then it is counted from the end of PV value, -1 being the\nlast char. In case of positive value, 0 is first char. Length must be\npositive, in case of 0, substring to the end of PV value is returned.\noffset and length can be PV as well.\n\nExample:\n\n    $var(x) = \"abcd\";\n    $(var(x){s.substr,1,0}); => \"bcd\"\n\n",
 "{s.select": "### {s.select,index,separator}\n\nReturn a field from PV value. The field is selected based on separator\nand index. The separator must be a character used to identify the\nfields. Index must be an integer value or a PV. If index is negative, the\ncount of fields starts from end of PV value, -1 being last field. If\nindex is positive, 0 is the first field.\n\nExample:\n\n    $var(x) = \"12,34,56\";\n    $(var(x){s.select,1,,}) => \"34\" ;\n\n    $var(x) = \"12,34,56\";\n    $(var(x){s.select,-2,,}) => \"34\"\n\n",
 "{s.encode.7bit": "### {s.encode.7bit}\n\nReturn encoding in 7Bit of PV value\n\n",
 "{s.decode.7bit": "### {s.decode.7bit}\n\nReturn decoding of PV value in 7Bit\n\n",
 "{s.encode.hexa": "### {s.encode.hexa}\n\nReturn encoding in hexa of PV value\n\n",
 "{s.decode.hexa": "### {s.decode.hexa}\n\nReturn decoding from hexa of PV value\n\n",
 "{s.encode.base58": "### {s.encode.base58}\n\nReturn base58 encoding of PV value.\n\nThe set of base58 digits is:\n\n    123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n\n",
 "{s.decode.base58": "### {s.decode.base58}\n\nReturn base58 decoding of PV value.\n\n",
 "{s.encode.base64": "### {s.encode.base64}\n\nReturn base64 encoding of PV value\n\n",
 "{s.decode.base64": "### {s.decode.base64}\n\nDecode base64 encoded PV and return value\n\n",
 "{s.encode.base64t": "### {s.encode.base64t}\n\nReturn base64 encoding of PV value without trailing padding\ncharacters('=').\n\n",
 "{s.decode.base64t": "### {s.decode.base64t}\n\nDecode base64 encoded PV, handling missing trailing padding characters,\nand return value.\n\n",
 "{s.encode.base64url": "### {s.encode.base64url}\n\nReturn base64-url encoding of PV value\n\n",
 "{s.decode.base64url": "### {s.decode.base64url}\n\nDecode base64-url encoded PV and return value\n\n",
 "{s.encode.base64urlt": "### {s.encode.base64urlt}\n\nReturn base64-url encoding of PV value without trailing padding\ncharacters('=').\n\n",
 "{s.decode.base64urlt": "### {s.decode.base64urlt}\n\nDecode base64-url encoded PV, handling missing trailing padding\ncharacters, and return value.\n\n",
 "{s.escape.common": "### {s.escape.common}\n\nReturn escaped string of PV value. Characters escaped are ', \", \\\\ and\n0. Useful when doing DB queries (care should be taken for non Latin\ncharacter set).\n\n",
 "{s.unescape.common": "### {s.unescape.common}\n\nReturn unescaped string of PV value. Reverse of above transformation.\n\n",
 "{s.escape.user": "### {s.escape.user}\n\nReturn escaped string of PV value, changing to '%hexa' the characters\nthat are not allowed in user part of SIP URI following RFC requirements.\n\n",
 "{s.unescape.user": "### {s.unescape.user}\n\nReturn unescaped string of PV value, changing '%hexa' to character code.\nReverse of above transformation.\n\n",
 "{s.escape.param": "### {s.escape.param}\n\nReturn escaped string of PV value, changing to '%hexa' the characters\nthat are not allowed in the param part of SIP URI following RFC\nrequirements.\n\n",
 "{s.unescape.param": "### {s.unescape.param}\n\nReturn unescaped string of PV value, changing '%hexa' to character code.\nReverse of above transformation.\n\n",
 "{s.escape.csv": "### {s.escape.csv}\n\nEscapes a string to use as a CSV field, as specified in RFC4180:\n\n     * enclose string in double quotes\n     * escape double quotes with a second double quote\n\nExample:\n\n``` c\n$var(x) = 'foo,bar\"baz';\n$(var(x){s.escape.csv}); # contains '\"foo,bar\"\"baz\"'\n```\n\n",
 "{s.numeric": "### {s.numeric}\n\nRemoves all non-numeric parts of string.\n\nExample:\n\n    $var(x) = \"(040)1234/567-89\";\n    $(var(x){s.numeric}) => \"040123456789\" ;\n\n",
 "{s.tolower": "### {s.tolower}\n\nReturn string with lower case ASCII letters.\n\n",
 "{s.toupper": "### {s.toupper}\n\nReturn string with upper case ASCII letters.\n\n",
 "{s.strip": "### {s.strip,len}\n\nReturn string after removing starting 'len' characters. Parameter 'len'\ncan be positive integer or pseudo-variable holding a positive integer.\n\nExample:\n\n``` c\n$var(x) = \"1234\";\n$var(y) = $(var(x){s.strip,2}); # resulted value is \"34\"\n```\n\n",
 "{s.striptail": "### {s.striptail,len}\n\nReturn string after removing ending 'len' characters. Parameter 'len'\ncan be positive integer or pseudo-variable holding a positive integer.\n\n",
 "{s.prefixes": "### {s.prefixes\\[,len\\]}\n\nReturn series of comma separated prefixes of the pv. Parameter 'len' is\noptional and will limit the maximum prefix length.\n\nExample:\n\n``` c\n$var(x) = \"123456\";\n$(var(x){s.prefixes}) => 1,12,123,1234,12345,123456\n$(var(x){s.prefixes,4} => 1,12,123,1234\n```\n\n",
 "{s.prefixes.quoted": "### {s.prefixes.quoted\\[,len\\]}\n\nReturn series of comma separated quoted prefixes of the pv. Parameter\n'len' is optional and will limit the maximum prefix length.\n\nExample:\n\n``` c\n$var(x) = \"123456\";\n$(var(x){s.prefixes.quoted} => '1','12','123','1234','12345','123456'\n$(var(x){s.prefixes.quoted,4} => '1','12','123','1234'\n```\n\n",
 "{s.replace": "### {s.replace,match,repl}\n\nReplace all occurrences of **match** with **repl**. The parameters can\nbe pseudo-variables.\n\nExample:\n\n``` c\n$var(x) = \"abababa\";\n$(var(x){s.replace,a,c} => \"cbcbcbc\"\n```\n\n",
 "{s.ftime": "### {s.ftime,format}\n\nFormat the epoch in the pv according to the parameter. The parameter has\nto be strftime formatting string.\n\n``` c\n$(TS{s.ftime,%Y-%m-%d %H:%M:%S})\n```\n\n",
 "{s.trim": "### {s.trim}\n\nRemove left and right whitespaces (' ', '\\\\t', '\\\\r', '\\\\n') around PV\nvalue.\n\n``` c\n$(var(x){s.trim})\n```\n\n",
 "{s.rtrim": "### {s.rtrim}\n\nRemove right whitespaces (' ', '\\\\t', '\\\\r', '\\\\n') around PV value.\n\n``` c\n$(var(x){s.rtrim})\n```\n\n",
 "{s.ltrim": "### {s.ltrim}\n\nRemove left whitespaces (' ', '\\\\t', '\\\\r', '\\\\n') around PV value.\n\n``` c\n$(var(x){s.ltrim})\n```\n\n",
 "{s.rm": "### {s.rm,match}\n\nRemove occurrences of 'match' from PV. 'match' can be static string or\nvariable.\n\n``` c\n$(var(x){s.rm,test})\n```\n\n",
 "{s.rmws": "### {s.rmws}\n\nRemove occurrences of whitespace characters (' ', '\\\\t, '\\\\r', '\\\\n').\n\n``` c\n$(var(x){s.rmws})\n```\n\n",
 "{s.corehash": "### {s.corehash,n}\n\nReturn the hash id computed with Kamailio's core hashing function. The\nparameter n is optional, it has to be a number of a pv holding a number.\nIf n is provided, the value returned is **(hashid)&(n-1)**. If n is\npower of two, the result is the modulo operation between hashid and n\n(hash id % n).\n\nNote: the value is returned as string.\n\n``` c\n$(var(x){s.corehash})\n```\n\n",
 "{s.unquote": "### {s.unquote}\n\nReturn the value without surrounding single (') or double quotes (\").\n\n``` c\n$var(x) = \"\\\"alice\\\"\";\n$var(alice) = $(var(x){s.unquote});\n```\n\n",
 "{s.unbracket": "### {s.unbracket}\n\nReturn the value without surrounding (), \\[\\], {} or \\<\\>.\n\n``` c\n$var(x) = \"<sip:alice@test.sip>\";\n$var(uri) = $(var(x){s.unbracket});\n```\n\n",
 "{s.count": "### {s.count,c}\n\nCount how many times c appears in the pv value.\n\n``` c\n\"abababa\"{s.count,a}\n",
 "{s.after": "### {s.after,x}\n\nReturn the part of the string after the character **x** searched from\nthe start of the value. If the character **x** is not found, it returns\nempty string.\n\n``` c\n\"abcdef\"{s.after,c}\n",
 "{s.rafter": "### {s.rafter,x}\n\nReturn the part of the string after the character **x** searched from\nthe end of the value. If the character **x** is not found, it returns\nempty string.\n\n``` c\n\"abcdefcgh\"{s.rafter,c}\n",
 "{s.before": "### {s.before,x}\n\nReturn the part of the string before the character **x** searched from\nthe start of the value. If the character **x** is not found, it returns\nthe entire input string.\n\n``` c\n\"abcdef\"{s.before,c}\n",
 "{s.rbefore": "### {s.rbefore,x}\n\nReturn the part of the string before the character **x** searched from\nthe end of the value. If the character **x** is not found, it returns\nthe entire input string.\n\n``` c\n\"abcdefcgh\"{s.rbefore,c}\n",
 "{s.fmtlines": "### {s.fmtlines,n,m}\n\nFormat the value in lines of n characters, adding m spaces to the start\nof each new line (not to first line). Each line is ended with \"\\\\r\\\\n\"\napart of last line.\n\n``` c\n\"abcdefgh\"{s.fmtlines,4,2}\n```\n\n",
 "{s.fmtlinet": "### {s.fmtlinet,n,m}\n\nFormat the value in lines of n characters, adding m tabs to the start of\neach new line (not to first line). Each line is ended with \"\\\\r\\\\n\"\napart of last line.\n\n``` c\n\"abcdefgh\"{s.fmtlinet,4,2}\n```\n\n",
 "{s.urlencode.param": "### {s.urlencode.param}\n\nEncode the value for URL param format.\n\n",
 "{s.urldecode.param": "### {s.urldecode.param}\n\nDecode the value from URL param format.\n\n",
 "{uri.user": "### {uri.user}\n\nReturn the user part\n\n",
 "{uri.host": "### {uri.host}\n\n(same as **{uri.domain}**)\n\nReturn the domain part\n\n",
 "{uri.passwd": "### {uri.passwd}\n\nReturn the password\n\n",
 "{uri.port": "### {uri.port}\n\nReturn the port\n\n",
 "{uri.params": "### {uri.params}\n\nReturn the URI parameters in a string\n\n",
 "{uri.param": "### {uri.param,name}\n\nReturn the value of parameter with name 'name'\n\n",
 "{uri.headers": "### {uri.headers}\n\nReturn URI headers\n\n",
 "{uri.transport": "### {uri.transport}\n\nReturn the value of transport parameter\n\n",
 "{uri.ttl": "### {uri.ttl}\n\nReturn the value of ttl parameter\n\n",
 "{uri.uparam": "### {uri.uparam}\n\nReturn the value of user parameter\n\n",
 "{uri.maddr": "### {uri.maddr}\n\nReturn the value of maddr parameter\n\n",
 "{uri.method": "### {uri.method}\n\nReturn the value of method parameter\n\n",
 "{uri.lr": "### {uri.lr}\n\nReturn the value of lr parameter\n\n",
 "{uri.r2": "### {uri.r2}\n\nReturn the value of r2 parameter\n\n",
 "{uri.scheme": "### {uri.scheme}\n\nReturn the string value of URI scheme.\n\n",
 "{uri.tosocket": "### {uri.tosocket}\n\nReturn the string value corresponding to socket address matching proto,\naddress and port from the URI. In other words, converts from a format\nlike **<sip:address:port;transport=proto>** to **proto:address:port**.\n\nExample:\n\n    \"sip:test@127.0.0.1:5060;transport=udp\"{uri.tosocket} => \"udp:127.0.0.1:5060\"\n\n",
 "{uri.duri": "### {uri.duri}\n\nReturn the destination URI for routing, keeping only schema, host, port\nand transport parameter. If port and transport are not in the original\nvalue, they are also not in the returned value.\n\nExample:\n\n``` c\n$var(ouri) = \"sip:alice@server.com:5060;nat=yes;transport=tcp;line=xyz\";\n$var(duri) = $(var(ouri){uri.duri}); # => \"sip:server.com:5060;transport=tcp\"\n```\n\n",
 "{uri.saor": "### {uri.saor}\n\nReturn the SIP AoR, keeping only schema, user and host. If user is not\nin the original value, it is also not in the returned value.\n\nExample:\n\n``` c\n$var(ouri) = \"sip:alice@server.com:5060;nat=yes;transport=tcp;line=xyz\";\n$var(suri) = $(var(ouri){uri.saor}); # => \"sip:alice@server.com\"\n```\n\n",
 "{uri.suri": "### {uri.suri}\n\nReturn the simple URI for routing, keeping only schema, user, host, port\nand transport parameter. If user, port and transport are not in the\noriginal value, they are also not in the returned value.\n\nExample:\n\n``` c\n$var(ouri) = \"sip:alice@server.com:5060;nat=yes;transport=tcp;line=xyz\";\n$var(suri) = $(var(ouri){uri.suri}); # => \"sip:alice@server.com:5060;transport=tcp\"\n```\n\n",
 "{param.value": "### {param.value,name\\[, delimiter\\]}\n\nReturn the value of parameter 'name'\n\nExample:\n\n    \"a=1;b=2;c=3\"{param.value,c} = \"3\"\n\n'name' can be a pseudo-variable\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n\n",
 "{param.in": "### {param.in,name\\[,delimiter\\]}\n\nReturn 1 if the parameter 'name' is found in parameters list, 0 if not\nfound.\n\nExample:\n\n    \"a=1;b=2;c=3\"{param.in,c} = 1\n\n'name' can be a pseudo-variable\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n\n",
 "{param.valueat": "### {param.valueat,index\\[, delimiter\\]}\n\nReturn the value of parameter at position given by 'index' (0-based\nindex)\n\nExample:\n\n    \"a=1;b=2;c=3\"{param.valueat,1} = \"2\"\n\n'index' can be a pseudo-variable\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n\n",
 "{param.name": "### {param.name,index\\[, delimiter\\]}\n\nReturn the name of parameter at position 'index'.\n\nExample:\n\n    \"a=1;b=2;c=3\"{param.name,1} = \"b\"\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n\n",
 "{param.count": "### {param.count\\[, delimiter\\]}\n\nReturn the number of parameters in the list.\n\nExample:\n\n    \"a=1;b=2;c=3\"{param.count} = 3\n\n'delimiter' allows you to specify a single character to use as the\nparameter delimiter. For example, when parsing HTTP URL query strings\nuse '&'.\n\n",
 "{nameaddr.name": "### {nameaddr.name}\n\nReturn the value of display name\n\nExample:\n\n    '\"test\" <sip:test@kamailio.net>' {nameaddr.name} = \"test\"\n\n",
 "{nameaddr.uri": "### {nameaddr.uri}\n\nReturn the value of URI\n\nExample:\n\n    '\"test\" <sip:test@kamailio.net>' {nameaddr.uri} = sip:test@kamailio.net\n\n",
 "{nameaddr.len": "### {nameaddr.len}\n\nReturn the length of the entire name-addr part from the value.\n\n",
 "{tobody.uri": "### {tobody.uri}\n\n\\* return URI from To body\n\n",
 "{tobody.display": "### {tobody.display}\n\n\\* return Display name from To body\n\n",
 "{tobody.tag": "### {tobody.tag}\n\n\\* return Tag parameter from To body\n\n",
 "{tobody.user": "### {tobody.user}\n\n\\* return URI User from To body\n\n",
 "{tobody.host": "### {tobody.host}\n\n\\* return URI Host from To body\n\n",
 "{tobody.params": "### {tobody.params}\n\n\\* return parameters part from To body\n\n",
 "{line.count": "### {line.count}\n\nReturn the number of lines.\n\nExample:\n\n``` c\n$(var(x){line.count})\n```\n\n",
 "{line.at": "### {line.at,pos}\n\nReturn the line at position 'pos'. The index start from 0. Negative\nposition can be used to count from last line (which is -1). The pos can\nbe also a variable holding the index value.\n\nExample:\n\n``` c\n$(var(x){line.at,2})\n```\n\n",
 "{line.sw": "### {line.sw,match}\n\nReturn the line starting with **match**.\n\nExample:\n\n``` c\n$(var(x){line.sw,mytext})\n```\n\n",
 "{msrpuri.user": "### {msrpuri.user}\n\nUser part of a MSRP URI.\n\n",
 "{msrpuri.host": "### {msrpuri.host}\n\nHost part of a MSRP URI.\n\n",
 "{msrpuri.port": "### {msrpuri.port}\n\nPort part of a MSRP URI.\n\n",
 "{msrpuri.session": "### {msrpuri.session}\n\nSession ID part of a MSRP URI.\n\n",
 "{msrpuri.proto": "### {msrpuri.proto}\n\nTransport layer part of a MSRP URI.\n\n",
 "{msrpuri.params": "### {msrpuri.params}\n\nParameters part of a MSRP URI.\n\n",
 "{msrpuri.userinfo": "### {msrpuri.userinfo}\n\nUser-Info part of a MSRP URI. This is the same as user part, when there\nare no user parameters or password fields. Otherwise, it include the\nwhole part after scheme and before '@' in front of host.\n\n",
 "{re.subst": "### {re.subst,expression}\n\nPerform POSIX regex substitutions on string value pseudo-variables.\n\n``` c\n",
 "{sql.val": "### {sql.val}\n\nThis transformation outputs valid SQL values for various PV values:\n\n-   \\<null> values are output as NULL\n-   integers are output as integers\n-   everything else is output as quoted and escaped string\n\n``` c\n    $var(null) = $null;\n    $avp(null) = $null;\n    $avp(str) = \"String with \\ illegal \\\\characters\";\n    $avp(nr) = 12345;\n    $avp(strnr) = \"12345\";\n    \n    xlog(\"$$rm = $rm = $(rm{sql.val})\");\n    xlog(\"$$var(null) = $var(null) = $(var(null){sql.val})\");\n    xlog(\"$$avp(null) = $avp(null) = $(avp(null){sql.val})\");\n    xlog(\"$$avp(str) = $avp(str) = $(avp(str){sql.val})\");\n    xlog(\"$$avp(nr) = $avp(nr) = $(avp(nr){sql.val})\");\n    xlog(\"$$avp(strnr) = $avp(strnr) = $(avp(strnr){sql.val})\");\n\n  Output:\n    $rm = ACK = 'ACK'\n    $var(null) = 0 = 0\n    $avp(null) = <null> = NULL\n    $avp(str) = String with \\ illegal \\characters = 'String with \\\\ illegal \\\\characters'\n    $avp(nr) = 12345 = 12345\n    $avp(strnr) = 12345 = '12345'\n```\n\n",
 "{sql.val.int": "### {sql.val.int}\n\nLike sql.val, but output number 0 for null values.\n\n",
 "{sql.val.str": "### {sql.val.str}\n\nLike sql.val, but output string '' for null values.\n\n",
 "{url.path": "### {url.path}\n\nPath part of an HTTP URL.\n\nFor example,\n\n    # When the first line of HTTP request is\n    # \"GET /path/to/file/?this=is&the=querystring\"\n\n    $(hu{url.path}) => \"/path/to/file/\"\n\n",
 "{url.querystring": "### {url.querystring}\n\nQuery string part of an HTTP URL. For example,\n\n    # When the first line of HTTP request is\n    # \"GET /path/to/file/?this=is&the=querystring\"\n\n    $(hu{url.querystring}) => \"this=is&the=querystring\"\n\n",
 "{json.parse": "### {json.parse}\n\nYou can use the transformation to extract values from the json\nstructured pseudo-variables\n\n\n    $var(Custom-Data) = $(rb{json.parse,Custom-Data});\n\n",
 "{sock.host": "### {sock.host}\n\nReturn the host part.\n\n",
 "{sock.port": "### {sock.port}\n\nReturn the port part.\n\n",
 "{sock.proto": "### {sock.proto}\n\nReturn the proto part.\n\n",
 "{sock.touri": "### {sock.touri}\n\nReturn the socket address converted to SIP URI:\n**<sip:host:port;transport=proto>**.\n\n",
 "{urialias.encode": "### {urialias.encode}\n\nEncode SIP URI to alias value.\n\n``` c\n\"sip:127.0.0.1:5060;transport=udp\"{urialias.encode} => \"127.0.0.1~5060~1\"\n```\n\n",
 "{urialias.decode": "### {urialias.decode}\n\nDecode from alias value to SIP URI.\n\n``` c\n\"127.0.0.1~5060~1\"{urialias.decode} => \"sip:127.0.0.1:5060;transport=udp\"\n```\n\n",
 "{val.json": "### {val.json}\n\nIf value is $null, return empty string; if value is string, then it is\nescaped for use as json value (without surrounding quotes.\n\n``` c\n$var(x) = '\"name\" <sip:name@a.com>';\n$(var(x){val.json}) => \\\"name\\\" <sip:name@a.com>\n```\n\n",
 "{val.n0": "### {val.n0}\n\nReturn integer 0 for values that are $null.\n\n``` c\n$sht(a=>x) = $null;\n$(sht(a=>x){val.n0}) => 0\n```\n\n",
 "{val.ne": "### {val.ne}\n\nReturn empty string for values that are $null.\n\n``` c\n$sht(a=>x) = $null;\n",
 "{val.jsonqe": "### {val.jsonqe}\n\nIf value is $null, return quoted empty string; if value is string, then\nit is escaped for use as json value already with surrounding quotes; if\nthe value is int, then it is preserved as it is.\n\n``` c\n$var(x) = '\"name\" <sip:name@a.com>';\n$(var(x){val.jsonqe}) => \"\\\"name\\\" <sip:name@a.com>\"\n```\n"
}