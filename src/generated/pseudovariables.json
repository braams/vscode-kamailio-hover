{
    "$ai": "### $ai - URI in P-Asserted-Identity header\n\n**$ai** - reference to URI in request's P-Asserted-Identity header (see\nRFC 3325)\n\n",
    "$adu": "### $adu - Auth Digest URI\n\n**$adu** - URI from Authorization or Proxy-Authorization header. This\nURI is used when calculating the HTTP Digest Response.\n\n",
    "$aa": "### $aa - Auth algorithm\n\n**$aa** - algorithm from Authorization or Proxy-Authorization header.\n\n",
    "$ar": "### $ar - Auth realm\n\n**$ar** - realm from Authorization or Proxy-Authorization header\n\n",
    "$au": "### $au - Auth username user\n\n**$au** - user part of username from Authorization or\nProxy-Authorization header\n\n",
    "$ad": "### $ad - Auth username domain\n\n**$ad** - domain part of username from Authorization or\nProxy-Authorization header\n\n",
    "$aU": "### $aU - Auth whole username\n\n**$aU** - whole username from Authorization or Proxy-Authorization\nheader\n\n",
    "$Au": "### $Au - Acc username and realm/domain\n\n**$Au** - username for accounting purposes. It's a selective pseudo\nvariable (inherited from acc module). It returns the auth username and\nrealm ($au@$ar) if it exists or From URI ($fu) otherwise.\n\n",
    "$AU": "### $AU - Acc username\n\n**$AU** - username for accounting purposes. It's a selective pseudo\nvariable (inherited from acc module). It returns the auth username ($au)\nif it exists or From user ($fU) otherwise.\n\n",
    "$branch": "### $branch(name) - Branch attributes\n\n**$branch(name)** - reference to attribute 'name' of a branch\n\nThis pseudo variable gives you access to the \"additional branches\" only,\nnot to the \"main branch\". E.g. if there are 3 clients registered for the\nsame AoR, after lookup() you will have one contact in the \"main branch\"\nand two \"additional branches\". Using $branch() you can access the\nadditional branches, the main branch can be accessed using $ru and $du.\n(Note: In branch_routes there is no distinction between the main and the\nadditional branches - the branch_route will be called once for each one\nof them.)\n\nThe 'name' can be:\n\n-   uri - return uri of the branch\n-   dst_uri - return destination uri (next hop address)\n-   path - return the path vector for the branch\n-   q - return the q value of the branch\n-   send_socket - return the socket to be used to send the branch\n-   count - return the number of the branches\n-   flags - return the branch flags value\n-   ruid - return the ruid of the branch (Record internal Unique ID from\n    usrloc)\n\nThe PV can take an index to access a specific branch:\n$(branch(name)\\[index\\])\n\nExample:\n\n``` c\n$var(i)=0;\nwhile($var(i)<$branch(count))\n{\n   xlog(\"$(branch(uri)[$var(i)])\\n\");\n   $var(i) = $var(i) + 1;\n}\n```\n\nStarting with 3.1.0, you can assign value per attribute. Index can be\nused to update a specific branch:\n\n``` c\n$(branch(attr)[index]) = value;\n```\n\nIf index is missing, first branch is used. If index is -1 the last\nbranch is used.\n\nAssigning $null to uri attribute will drop the branch, for the rest of\nattributes will just set the value to null.\n\n``` c\n$(branch(uri)[2]) = \"sip:test@kamailio.org;transport=sctp\";\n```\n\n",
    "$br": "### $br - Request's first branch\n\n**$br** - reference to request's first branch\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file (will add a new branch).\n\n",
    "$bR": "### $bR - Request's all branches\n\n**$bR** - reference to request's all branches\n\n",
    "$bf": "### $bf - Branch flags\n\n**$bf** - reference to branch flags of branch 0 (RURI) - decimal output\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$bF": "### $bF - Branch flags\n\n**$bF** - reference to branch flags of branch 0 (RURI) - hexa output\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$bs": "### $bs - Body size\n\n**$bs** - body size\n\n",
    "$ci": "### $ci - Call-Id\n\n**$ci** - reference to the value of call-id header\n\n",
    "$cl": "### $cl - Content-Length\n\n**$cl** - reference to the value of content-length header\n\n",
    "$cnt": "### $cnt(pv) - Count number of pvs\n\n**$cnt(avp)** - return the number of avps\n\n``` c\nxlog(\"$$avp(x) found $cnt($avp(x)) times\\n\");\n```\n\n**$cnt(xavp)** - return the number of xavps\n\n     * $cnt($xavp(key[*])) : number of XAVPs \"key\".\n     * $cnt($xavp(key[n]=>sub[*])) : number of children \"sub\" in XAVP \"key[n]\".\n     * $cnt($xavp(key[*]=>sub[*])) : total number of children \"sub\" in all XAVPs \"key\".\n\n     * $cnt($xavp(key[n])) : 1 or 0 (if this index exists or not).\n     * $cnt($xavp(key[-n])) : same but with reverse indexing (-1 is the last index).\n\n     * $cnt($xavp(key[*]=>sub[n])) : number of children \"sub[n]\" that exist in all XAPVs \"key\".\n\n     * $cnt($xavp(key)) is the same as $cnt($xavp(key[*])).\n     * $cnt($xavp(key=>sub)) is the same as $cnt($xavp(key[*]=>sub[*]))\n\n",
    "$conid": "### $conid - TCP Connection ID\n\n**$conid** - The TCP connection ID of the connection the current message\narrived on for TCP, TLS, WS, and WSS. Set to $null for SCTP and UDP.\n\n",
    "$cs": "### $cs - CSeq Number\n\n**$cs** - reference to the sequence number in the CSeq header. The\nmethod in the CSeq header is identical to the request method, thus use\n$rm to get the method (works also for responses).\n\n",
    "$csb": "### $csb - CSeq Header Body\n\n**$csb** - reference to the CSeq header body (number method).\n\n",
    "$ct": "### $ct - Contact header\n\n**$ct** - reference to the value of contact header\n\n",
    "$cT": "### $cT - Content-Type\n\n**$cT** - reference to the value of content-type header\n\n",
    "$dd": "### $dd - Domain of destination URI\n\n**$dd** - reference to domain of destination uri (without port)\n\n",
    "$def": "### $def(name) - Defined Value\n\n**$def(name)** - return a defined value.\n\nExample:\n\n``` c\n",
    "$defn": "### $defn(name) - Defined Value As Number\n\n**$defn(name)** - return a defined value as a signed integer.\n\nExample:\n\n``` c\n",
    "$di": "### $di - Diversion header URI\n\n**$di** - reference to Diversion header URI\n\n",
    "$dip": "### $dip - Diversion \"privacy\" parameter\n\n**$dip** - reference to Diversion header \"privacy\" parameter value\n\n",
    "$dir": "### $dir - Diversion \"reason\" parameter\n\n**$dir** - reference to Diversion header \"reason\" parameter value\n\n",
    "$dic": "### $dic - Diversion \"counter\" parameter\n\n**$dic** - reference to Diversion header \"counter\" parameter value\n\n",
    "$dp": "### $dp - Port of destination URI\n\n**$dp** - reference to port of destination uri\n\n",
    "$dP": "### $dP - Transport protocol of destination URI\n\n**$dP** - reference to transport protocol of destination uri\n\n",
    "$ds": "### $ds - Destination set\n\n**$ds** - reference to destination set\n\n",
    "$du": "### $du - Destination URI\n\n**$du** - reference to destination uri\n\nIf loose_route() returns TRUE a destination uri is set according to the\nfirst Route header. $du is also set if lookup() function of 'registrar'\nmodule finds contact(s) behind NAT or if you use the path functionality.\nThe function handle_ruri_alias() from the nathelper module will also set\nit. You can set $du to any SIP URI.\n\n     sip:kamailio.org\n     sip:pbx123.kamailio.org;transport=udp\n     sip:[2001:DB8::33:2]:5980;transport=tls\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\nTo reset $du:\n\n    $du = $null;\n\n",
    "$fd": "### $fd - From URI domain\n\n**$fd** - reference to domain in URI of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\n",
    "$fn": "### $fn - From display name\n\n**$fn** - reference to display name of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\n",
    "$fs": "### $fs - Forced Send Socket\n\n**$fs** - reference to the forced send socket for the SIP message (if\nany) in the form \"proto:ip:port\". It is the socket from where Kamailio\nis going to send out the message.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file). Transport proto can be omitted when assigning\nvalue, in which case it is taken from destination URI of the\nmessage.\n\nExample:\n\n``` c\nlisten=udp:1.2.3.4:5060\n...\n$fs = \"udp:1.2.3.4:5060\";\n```\n\n",
    "$fsn": "### $fsn - Forced Send Socket Name\n\n**$fsn** - reference to the name of the forced send socket for the SIP\nmessage. The name can be assigned to this variable to select a send\nsocket via its name.\n\n``` c\nlisten=udp:1.2.3.4:5060 name \"s1\"\n...\n$fsn = \"s1\";\n...\n$fs = \"udp:1.2.3.4:5060\";\nxdbg(\"name for forced send socket: $fsn\\n\");\n```\n\n",
    "$ft": "### $ft - From tag\n\n**$ft** - reference to tag parameter of 'From' header\n\n",
    "$fti": "### $fti - Initial From tag\n\n**$fti** - reference to tag parameter of 'From' header as it was in the\ninitial request (e.g., initial INVITE).\n\nThe value From tag in the initial request can be in the To tag, if the\nrequest within the dialog is sent by the callee. This variable detects\nwho sent the request within the dialog and returns the proper value that\nwas in the From tag of the request initiating the dialog.\n\nIt is exported by **rr** module and has to be used after loose_route().\nThe append_fromtag parameter is required to be set to 1 in order to have\nthis variable returning the right value.\n\n",
    "$fu": "### $fu - From URI\n\n**$fu** - reference to URI of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\nNote that changing the From: header may break backwards compatibility\nwith SIP 1.0 devices.\n\n",
    "$fU": "### $fU - From URI username\n\n**$fU** - reference to username in URI of 'From' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\nNote that changing the From: header may break backwards compatibility\nwith SIP 1.0 devices.\n\n",
    "$fUl": "### $fUl - From URI Username Length\n\n**$fUl** - length of the username in the From URI\n\n",
    "$mb": "### $mb - SIP message buffer\n\n**$mb** - reference to SIP message buffer\n\n",
    "$mbu": "### $mbu - updated SIP message buffer\n\n**$mbu** - reference to updated SIP message buffer, after applying\nchanges\n\n",
    "$mf": "### $mf - Flags\n\n**$mf** - reference to message/transaction flags set for current SIP\nrequest\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$mF": "### $mF - Flags in hexadecimal\n\n**$mF** -reference to message/transaction flags set for current SIP\nrequest in hexa-decimal\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$mi": "### $mi - SIP message id\n\n**$mi** - reference to SIP message id\n\n",
    "$ml": "### $ml - SIP message length\n\n**$ml** - reference to SIP message length\n\n",
    "$mt": "### $mt - SIP Message Type\n\n**$mt** - returns 1 if the sip message is a request, returns 2 if the\nsip message is a reply\n\n",
    "$od": "### $od - Domain original R-URI\n\n**$od** - reference to domain in request's original R-URI\n\n",
    "$op": "### $op - Port in original R-URI\n\n**$op** - reference to port of original R-URI\n\n",
    "$oP": "### $oP - Protocol of original R-URI\n\n**$oP** - reference to transport protocol of original R-URI\n\n",
    "$ou": "### $ou - Original R-URI\n\n**$ou** - reference to request's original URI\n\n",
    "$oU": "### $oU - Username in original R-URI\n\n**$oU** - reference to username in request's original URI\n\n",
    "$oUl": "### $oUl - Original R-URI Username Length\n\n**$oUl** - the length of the username in the original R-URI\n\n",
    "$pd": "### $pd - Domain in P-Preferred-Identity header URI\n\n**$pd** - reference to domain in request's P-Preferred-Identity header\nURI (see RFC 3325)\n\n",
    "$pn": "### $pn - Display Name in P-Preferred-Identity header\n\n**$pn** - reference to Display Name in request's P-Preferred-Identity\nheader (see RFC 3325)\n\n",
    "$pp": "### $pp - Process id\n\n**$pp** - reference to process id (pid)\n\n",
    "$proto": "### $pr or $proto - Protocol of received message\n\n**$pr** or **$proto** - protocol of received message (udp, tcp, tls,\nsctp, ws, wss)\n\n",
    "$prid": "### $prid - protocol id\n\n**$prid** - internal protocol id\n\n-   0 - NONE\n-   1 - UDP\n-   2 - TCP\n-   3 - TLS\n-   4 - SCTP\n-   5 - WS\n-   6 - WSS\n-   7 - OTHER\n\n",
    "$pU": "### $pU - User in P-Preferred-Identity header URI\n\n**$pU** - reference to user in request's P-Preferred-Identity header URI\n(see RFC 3325)\n\n",
    "$pu": "### $pu - URI in P-Preferred-Identity header\n\n**$pu** - reference to URI in request's P-Preferred-Identity header (see\nRFC 3325)\n\n",
    "$rb": "### $rb - Body of request/reply\n\n**$rb** - reference to message body\n\n",
    "$rc": "### $rc - Returned code\n\n**$rc** - reference to returned code by last invoked function\n\n**$retcode** - same as **$rc**\n\nNote that the value of $rc is overwritten by each new function call.\n\nExample of use:\n\n``` c\n    lookup(\"location\");\n    $var(rc) = $rc;\n    if ($var(rc) < 0) {\n        t_newtran();\n        switch ($var(rc)) {\n            case -1:\n            case -3:\n                send_reply(\"404\", \"Not Found\");\n                exit;\n            case -2:\n                send_reply(\"405\", \"Method Not Allowed\");\n                exit;\n        }\n    }\n\n```\n\n",
    "$rd": "### $rd - Domain in R-URI\n\n**$rd** - reference to domain in request's URI (without port) or to the\nNamespace Specific String of a URN (see RFC 2141)\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$rdir": "### $rdir(key) - Request Direction\n\n**$rdir(key)** - get the direction of the request within dialog.\n\nThe direction is 'downstream' if sent by the caller and 'upstream' if\nsent by callee.\n\nThe key can be:\n\n-   id - the returned value is an integer: 1 - for direction downstream,\n    2 - for direction upstream\n-   name - the returned value is a string: 'downstream' or 'upstream'\n\nExample:\n\n``` c\nif($rdir(name)==\"upstream\") {\n  xlog(\"request was sent by callee\\n\");\n}\n```\n\nThe variable is exported by **rr** module and append_fromtag parameter\nmust be enabled. The variable has to be used after loose_route()\nfunction.\n\n",
    "$re": "### $re - Remote-Party-ID header URI\n\n**$re** - reference to Remote-Party-ID header URI\n\n",
    "$rm": "### $rm - SIP method\n\n**$rm** - reference to request's method. Works also for replies (by\nusing the CSeq header)\n\n",
    "$rmid": "### $rmid - SIP Method ID\n\n**$rmid** - returns internal integer representation of SIP method type\n\n",
    "$route_uri": "### $route_uri - URI in first Route header\n\n**$route_uri** - returns the string with URI field in the first Route\nheader\n\n",
    "$rp": "### $rp - Port in R-URI\n\n**$rp** - reference to port of R-URI\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$rP": "### $rP - Protocol of R-URI\n\n**$rP** - reference to transport protocol of R-URI\n\n",
    "$rr": "### $rr - SIP reply reason phrase\n\n**$rr** - reference to reply's reason phrase (the text after reply code)\n\n",
    "$rs": "### $rs - SIP reply code\n\n**$rs** - reference to reply's status (status-code, response-code,\nreply-code)\n\n",
    "$rt": "### $rt - Refer-to URI\n\n**$rt** - reference to URI of refer-to header\n\n",
    "$ru": "### $ru - Request URI\n\n**$ru** - reference to request's URI (address in the first line of a SIP\nrequest)\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$rU": "### $rU - Username in R-URI\n\n**$rU** - reference to username in request's URI or to the Namespace\nIdentifier of a URN (see RFC 2141)\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$rUl": "### $rUl - R-URI Username Length\n\n**$rUl** - the length of the username in R-URI\n\n",
    "$rv": "### $rv - SIP message version\n\n**$rv** - reference to SIP message (reply or request) version\n\n",
    "$ruid": "### $ruid - Record internal Unique ID\n\n**$ruid** - the Record internal Unique ID for the location record\nselected by calling registrar:lookup()\n\n",
    "$rz": "### $rz - URI Scheme of R-URI\n\n**$rz** - returns R-URI scheme, possible values: sip, sips, tel, tels\nand urn, R-URI scheme parsing error should be reflected by value: none\n\n",
    "$RAi": "### $RAi - Received advertised IP address\n\n**$RAi** - reference to advertised IP address of the interface where the\nrequest has been received, or $Ri if no advertised address.\n\n",
    "$RAp": "### $RAp - Received advertised port\n\n**$RAp** - reference to advertised port where the request has been\nreceived, or $Rp if no advertised port.\n\n",
    "$Ri": "### $Ri - Received IP address\n\n**$Ri** - reference to IP address of the interface where the request has\nbeen received\n\n",
    "$Rp": "### $Rp - Received port\n\n**$Rp** - reference to the port where the message was received\n\n",
    "$Rn": "### $Rn - Received socket name\n\n**$Rn** - reference to the name of the socket where the message was\nreceived\n\n",
    "$RAu": "### $RAu - Advertised socket URI\n\n**$RAu** - local socket where the SIP messages was received in URI\nformat, without transport parameter for UDP, using advertised address\nwhen available.\n\n",
    "$RAut": "### $RAut - Advertised socket URI\n\n**$RAut** - local socket where the SIP messages was received in URI\nformat, always with transport parameter, using advertised address when\navailable.\n\n",
    "$Ru": "### $Ru - Received socket URI\n\n**$Ru** - local socket where the SIP messages was received in URI\nformat, without transport parameter for UDP.\n\n",
    "$Rut": "### $Rut - Received socket URI\n\n**$Rut** - local socket where the SIP messages was received in URI\nformat, always with transport parameter.\n\n",
    "$sas": "### $sas - Source address in socket format\n\n**$sas** - get source address in socket format (proto:address:port).\n\n",
    "$sbranch": "### $sbranch(attr) - Static Branch\n\n**$sbranch(attr)** - class of variables allowing to manage the values of\nattributes for static branch. The static branch is internal structure\nthat is used by the functions sbranch_push_ruri() and sbranch_append()\nfrom **pv** module, enabling more flexibility in updating the R-URI\n(first) branch attributes as well as extra branches (e.g., for parallel\nforking).\n\nThe **attr** can be any of the supported values for **$branch(attr)**\nclass of variables -- see above for proper details.\n\nExample of usage:\n\n``` c\nsbranch_reset();\n$sbranch(uri) = \"sip:127.0.0.1:5080\";\n$sbranch(dst_uri) =  \"sip:127.0.0.1:5090\";\n$sbranch(path) =  \"sip:127.0.0.1:5090, sip:127.0.0.1:5094\";\n$sbranch(send_socket) =  \"udp:127.0.0.1:5060\";\nsbranch_set_ruri();\n```\n\n",
    "$sf": "### $sf - Script flags\n\n**$sf** - reference to script flags - decimal output\n\n",
    "$sF": "### $sF - Script flags\n\n**$sF** - reference to script flags - hexa output\n\n",
    "$si": "### $si - Source IP address\n\n**$si** - reference to IP source address of the message - see also $siz\n\n",
    "$sid": "### $sid - Server ID\n\n**$sid** - the value for server id (server_id parameter)\n\n",
    "$siz": "### $siz - Source IP address\n\n**$siz** - reference to IP source address of the message, with enclosing\nsquare brackets for IPv6\n\n",
    "$sp": "### $sp - Source port\n\n**$sp** - reference to the source port of the message\n\n",
    "$stat": "### $stat(name) - Statistics\n\n**$stat(name)** - return the value of statistic item specified by 'name'\n\n",
    "$su": "### $su - Source address as URI\n\n**$su** - returns the representation of source address (ip, port, proto)\nas SIP URI. If the proto is UDP, then it is not added (being the default\ntransport protocol).\n\nIts value looks like:\n\n    \"sip:ip:port\" -- if proto is UDP\n    \"sip:ip:port;transport=proto\"  -- if proto is not UDP\n\nNote that WS and WSS are both represented by transport=ws, conforming\nwith the IETF RFC for SIP over WebSocket.\n\n",
    "$sut": "### $sut - Source address as full URI\n\n**$sut** - returns the representation of source address (ip, port,\nproto) as full SIP URI. The proto UDP is added also as transport\nparameter.\n\nIts value looks like:\n\n    \"sip:ip:port;transport=proto\"\n\n",
    "$td": "### $td - To URI Domain\n\n**$td** - reference to domain in URI of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\n",
    "$tn": "### $tn - To display name\n\n**$tn** - reference to display name of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\n",
    "$tt": "### $tt - To tag\n\n**$tt** - reference to tag parameter of 'To' header\n\n",
    "$tti": "### $tti - Initial To tag\n\n**$tti** - reference to tag parameter of 'To' header as it was in the\nSIP response to the initial request (e.g., 200ok to the initial INVITE).\n\nThe value To tag in the initial transaction can be in the From tag, if\nthe request within the dialog is sent by the callee. This variable\ndetects who sent the request within the dialog and returns the proper\nvalue that was in the To tag of the transaction initiating the dialog.\n\nIt is exported by **rr** module and has to be used after loose_route().\nThe append_fromtag parameter is required to be set to 1 in order to have\nthis variable returning the right value.\n\n",
    "$tu": "### $tu - To URI\n\n**$tu** - reference to URI of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\n",
    "$tU": "### $tU - To URI Username\n\n**$tU** - reference to username in URI of 'To' header\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file, but its value does not change)\n\n",
    "$tUl": "### $tUl - To URI Username Length\n\n**$tUl** - the length of the username in To URI\n\n",
    "$Tb": "### $Tb - Startup timestamp\n\n**$Tb** - reference to unix timestamp of the time at which kamailio was\nstarted (boot time)\n\n",
    "$Tf": "### $Tf - String formatted time - cached\n\n**$Tf** - reference string formatted time\n\nNote: the system time is retrieved only once for each processed SIP\nmessage. Subsequent calls of $Tf for same SIP message will return same\nvalue.\n\n",
    "$TF": "### $TF - String formatted time - current\n\n**$TF** - reference string formatted time\n\nNote: the system time is computed for each call of $TF. Subsequent calls\nof $TF for same SIP message may return different values.\n\n",
    "$Ts": "### $Ts - Unix time stamp - cached\n\n**$Ts** - reference to unix time stamp\n\nNote: the system time is retrieved only once for each processed SIP\nmessage. Subsequent calls of $Ts for same SIP message will return same\nvalue.\n\n",
    "$TS": "### $TS - Unix time stamp - current\n\n**$TS** - reference to unix time stamp\n\nNote: the system time is computed for each call of $TS. Subsequent calls\nof $TS for same SIP message may return different values.\n\n",
    "$ua": "### $ua - User agent header\n\n**$ua** - reference to user agent header field\n\n",
    "$version": "### $version() - version\n\n**$version(num)** - version as number\n\n**$version(full)** - full version string \"name version\narchitecture/platform\"\n\n**$version(hash)** - TBA\n\n",
    "$env": "## $env(NAME) - environment variables\n\n**$env(NAME)** - value of the environment variable named NAME\n\nExample:\n\n``` c\nxdbg(\"PATH environment variable:  $env(PATH)\\n\");\n```\n\n",
    "$avp": "## $avp(id) - AVPs\n\n**$avp(id)** - the value of the AVP identified by 'id'.\n\n**$(avp(id)\\[N\\])** - represents the value of N-th AVP identified by\n'id'.\n\nThe 'id' can be:\n\n-   \"\\[(s\\|i):\\]name\" - name is the id of an AVP; 's' and 'i' specifies\n    if the id is string or integer. If missing, it is considered to be\n    string.\n-   \"name\" - the name is an AVP alias, or if the alias is not found, it\n    is a string name\n-   pseudo variable - if value of pv is integer, id is integer, if\n    string, id is string\n\n$(avp(id)\\[0\\]) can be written in shorter form as $avp(id) and\n$avp(s:name) as $avp(name).\n\nAVPs are special variables that are attached to SIP transactions. It is\na list of pairs (name,value). Before the transaction is created, the AVP\nlist is attached to SIP request. Note that the AVP list works like a\nstack, last added value is retrieved first, and there can be many values\nfor same AVP name, an assignment to the same AVP name does not overwrite\nold value, it will add the new value in the list.\n\nTo delete the first AVP with name 'id' you have to assign to it '$null':\n\n``` c\n$avp(id) = $null;\n```\n\nTo delete all the AVP with name 'id' you have to assign $null to the\nindex '\\*':\n\n``` c\n$(avp(id)[*]) = $null;\n```\n\nTo overwrite the value of the AVP with name 'id' you have to assign the\nnew value to the index '\\*':\n\n``` c\n$(avp(id)[*]) = newvalue;\n```\n\nThe value of an AVP can be integer or string. To assign a value as\nstring, it has to be enclosed in double quotes. To assign the value as\ninteger, it has to be a valid number given without quotes.\n\nExample of usage:\n\n``` c\n$avp(x) = 1;  # assign of integer value\n$avp(x) = 2;\n$avp(y) = \"abc\"; # assign of string value\nif($(avp(x)[1])==1) {\n  ...\n}\n$(avp(x)[1]) = $null;\n```\n\nIt is R/W variable (you can assign values to it directly in\nconfiguration file).\n\n",
    "$expires": "## $expires(key) - Expires Values\n\nReturn the min and max of expires value for current SIP message. Contact\nheaders are checked with higher priority, if no expires parameter there,\nthen Expires header is used\n\nIf none is found, $null is returned.\n\nPossible 'key' values:\n\n-   $expires(min) - the minimum value for expires\n-   $expires(max) - the maximum value for expires\n\nWhen there is only one expires value, then min and max return the same.\n\nExample of usage:\n\n``` c\nif($expires(max)!=$null) {\n    xlog(\"max expires value is: $expires(max)\\n\");\n}\n```\n\n",
    "$xavp": "## $xavp(id) - XAVPs\n\n**xavp** - eXtended AVPs - are variables that can store multiple values,\nwhich can also be grouped in a structure-like fashion. Their value can\nbe a string, an integer number or a list of named values (child values).\n\nThey work like a stack, similar to AVPs, and are attached to SIP\ntransactions and automatically destroyed when the transaction is\nfinished.\n\nEach xavp has a string name and can contain a string, an integer or a\nlist of named values. The structure name (or root list name) and the\nvalue name (or field name, or child value name) are separated by => like\n$xavp(root=>field) where \"root\" is the name of the structure and \"field\"\nis the name of the (child) value.\n\nTo assign a single value use:\n\n``` c\n$xavp(root)=\"string value\";\n$xavp(root)=intnumber;\n```\n\nTo assign a named value use:\n\n``` c\n$xavp(root=>field)=\"string value\";\n$xavp(root=>field)=intnumber;\n```\n\nLike avps, xavp act like a stack. To refer to an existing value, use an\nindex. The newest xavp has index zero \\[0\\].\n\n``` c\n$xavp(root[0]=>field)=12;\n```\n\nIf you assign a value without an index, a new xavp is allocated and the\nold one is pushed up the stack, becoming index \\[1\\]. Old index \\[1\\]\nbecomes \\[2\\] etc.\n\n``` c\n",
    "$xavu": "## $xavu(id) - XAVUs\n\nSimilar to XAVPs, but with single value items, therefore there are no\nindexes in the naming format. XAVUs are also stored in transaction\ncontext and destroyed when the transaction is terminated.\n\nExamples:\n\n``` c\n$xavu(x) = 123; # <- set the value\n$xavu(x) = 234; # <- update to the value, not adding to a list like for xavps\n$xavu(x) = $null; # <- delete the xavu\n$xavu(a=>b) = \"xyz\"; # <- two level naming supported\n```\n\n",
    "$xavi": "## $xavi(id) - XAVIs\n\nSimilar to XAVPs, but with key names are case insensitive. XAVIs are\nalso stored in transaction context and destroyed when the transaction is\nterminated.\n\nExamples:\n\n``` c\n$xavi(WhatEver=>FoO) = 123; # <- set the value\n# $xavi(whatever[0]=>foo) == 123\n```\n\n",
    "$hdr": "## $hdr(name) - Headers\n\n**$hdr(name)** - represents the body of first header field identified by\n'name'\n\n**$(hdr(name)\\[N\\])** - represents the body of the N-th header field\nidentified by 'name'.\n\nIf \\[N\\] is omitted then the body of the first header is printed. The\nbody of first header is returned when N=0, for the second N=1, a.s.o. In\ncase of a comma-separated multi-body headers, it returns all the bodies,\ncomma-separated. To print the last header of that type, use -1, or other\nnegative values to count from the end. No white spaces are allowed\ninside the specifier (before }, before or after {, \\[, \\] symbols). When\nN='\\*', all headers of that type are printed.\n\nIf name is \\*, then any header name is matched, e.g., $hdr(\\*) is body\nof first header, $(hdr(\\*)\\[-1\\]) is body of last header.\n\nThe module should identify compact header names. It is recommended to\nuse dedicated specifiers for headers (e.g., $ua for user agent header),\nif they are available -- they are faster.\n\nExample of usage:\n\n``` c\nif($hdr(From)=~\"kamailio\\.org\") {\n...\n}\n```\n\n\ud83d\udd25**IMPORTANT**: It is read-only variable. You can remove or add headers\nusing functions from textops module.\n\n",
    "$hfl": "## $hfl(name) - Header Field With List Of Bodies\n\nSimilar to **$hdr(name)**, but for some of the standard headers that can\nhave many bodies serialized in the same header field (i.e., comma\nseparated list of bodies in same header field) is able to return the\nindividual body values.\n\nImplemented for:\n\n-   Contact\n-   Record-Route\n-   Route\n-   Via\n\nFor the rest of the headers works like **$hdr(name)**.\n\n**$hfl(name)** - represents the first body of first header field\nidentified by 'name'.\n\n**$(hfl(name)\\[N\\])** - represents the body of the N-th header field\nidentified by 'name'.\n\nExample of usage:\n\n``` c\nif($(hfl(Via)[1])=~\"TLS\") {\n...\n}\n```\n\n",
    "$hdrc": "## $hdrc(name) - Number of Headers\n\n**$hdrc(name)** - get the number of headers with the respective name\n\nExample of usage:\n\n``` c\nif($hdrc(Via) == 2) {\n...\n}\n```\n\n",
    "$hflc": "## $hflc(name) - Number of Header Bodies\n\nSimilar to **$hdrc(name)**, but for some of the standard headers that\ncan have many bodies serialized in the same header field (i.e., comma\nseparated list of bodies in same header field) is able to count the\nnumber of individual bodies.\n\nImplemented for:\n\n-   Record-Route\n-   Route\n-   Via\n\nFor the rest of the headers works like **$hdrc(name)**.\n\nExample of usage:\n\n``` c\nif($hflc(Via)==3) {\n...\n}\n```\n\n",
    "$var": "## $var(name) - Private memory variables (zero)\n\n**$var(name)** - refers to variables that can be used in configuration\nscript, having integer or string value. This kind of variables are\nfaster than AVPs, being referenced directly to memory location.\n\nExample of usage:\n\n``` c\n$var(a) = 2; #-- sets the value of variable 'a' to integer '2'\n$var(a) = \"2\"; #-- sets the value of variable 'a' to string '2'\n$var(a) = \"sip:\" + $au + \"@\" + $fd; #-- compose a value from authentication username and From URI domain\n$var(a) = 3 + (7&(~2));\n\nif( $var(a) & 4 ) {\n  xlog(\"var a has third bit set\\n\");\n}\n```\n\n**Note:** Setting a variable to $null is actually initializing the value\nto integer '0'. This type of script variables doesn't have $null value.\n\n``` c\n$var(x) = $null;\n\nif($var(x)==0) { # this is true\n  ...\n}\n```\n\n**Note:** A script variable persists over the Kamailio process in which\nit was initialized, so be sure of giving it a new value before reading\nit or you'll get the value assigned in any other previous message\nprocessed by the same Kamailio process (pid).\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n**pv** module can be used to initialize the script variables.\n\n",
    "$vz": "## $vz(name) - Private memory variables (zero)\n\nSame as $var(name) -- added to pair with $vn(name).\n\n",
    "$vn": "## $vn(name) - Private memory variables (null)\n\nSimilar to $var(name) and able to hold $null (which is the default\nvalue). The value is kept in private memory (pkg) and it is persistent\nacross SIP message processing, within the space of each Kamailio\nprocess.\n\nExample of usage:\n\n``` c\n$vn(x) = 1;\n$vn(x) = \"abc\";\n$vn(x) = $null;\n\nif($vn(x) == $null) { ... }\n```\n\n",
    "$shv": "## $shv(name) - Shared memory variables\n\n**$shv(name)** - it is a class of pseudo-variables stored in shared\nmemory. The value of $shv(name) is visible across all Kamailio\nprocesses. Each \u201cshv\u201d has single value and it is initialised to integer\n0. You can use \u201cshvset\u201d parameter of **pv module** to initialize the\nshared variable. The module exports a set of RPC functions to get/set\nthe value of shared variables.\n\nExample - shv(name) pseudo-variable usage:\n\n    ...\n    modparam(\"pv\", \"shvset\", \"debug=i:1\")\n    ...\n    if ($shv(debug) == 1) {\n        xlog(\"request: $rm from $fu to $ru\\n\");\n    }\n    ...\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable (you can assign values to it directly in\nconfiguration file)\n\n",
    "$dsv": "## $dsv(key) - Dispatcher variables\n\nReturn attributes related to dispatcher module.\n\nThe key can be:\n\n-   code - the SIP response code that caused the execution of\n    event_route 'dispatcher:dst-up' or 'dispatcher:dst-down', if\n    available\n-   reason - the SIP response reason that caused the execution of\n    event_route 'dispatcher:dst-up' or 'dispatcher:dst-down', if\n    available\n-   flags - flags set internally when executing event_route\n    'dispatcher:dst-up' or 'dispatcher:dst-down'\n\n",
    "$time": "## $time(name) - Broken-down time\n\n**$time(name)** - the PV provides access to broken-down time attributes\nin the local timezone.\n\nThe 'name' can be:\n\n-   sec - return seconds (int 0-59)\n-   min - return minutes (int 0-59)\n-   hour - return hours (int 0-23)\n-   mday - return the day of month (int 0-59)\n-   mon - return the month (int 1-12)\n-   year - return the year (int, e.g., 2008)\n-   wday - return the day of week (int, 1=Sunday - 7=Saturday)\n-   yday - return the day of year (int, 1-366)\n-   isdst - return daylight saving time status (int, 0 - DST off, >0 DST\n    on)\n\nExample - time(name) pseudo-variable usage:\n\n``` c\n...\nif ($time(year) == 2008) {\n    xlog(\"request: $rm from $fu to $ru in year 2008\\n\");\n}\n...\n```\n\n",
    "$utime": "## $utime(name) - Broken-down time\n\n**$utime(name)** - the PV provides access to broken-down time attributes\nin UTC.\n\nSee **$time(name)** above for the possible attributes\n\n",
    "$timef": "## $timef(format) - Strftime Formatted Time\n\n**$timef(format)** - return current time as formatted by strftime\n'format'. See 'man strftime' to see the available time attribute\nspecifiers.\n\nExample:\n\n``` c\nxlog(\"Today is $timef(%m/%d/%y)\\n\");\n```\n\n",
    "$utimef": "## $utimef(format) - Strftime Formatted UTC Time\n\n**$utimef(format)** - return current time in UTC as formatted by\nstrftime 'format'. See 'man strftime' to see the available time\nattribute specifiers.\n\nExample:\n\n``` c\nxlog(\"The time is $utimef(%m/%d/%y %H:%M:%S)\\n\");\n```\n\n",
    "$ccp": "## $ccp(key) - Config Custom Parameters\n\nGet the value for global custom parameters:\n\n-   [Custom Global parameters](core.md#custom-global-parameters)\n\nExample:\n\n``` c\ngv.sval = \"hello\" desc \"hello var\"\ngv.ival = 10 desc \"ten var\"\n\nrequest_route {\n    xinfo(\"global vars: $ccp(gv.sval) :: $ccp(gv.ival)\\n\");\n}\n```\n\n",
    "$sel": "## $sel(name) - Selects\n\n**$sel(name)** - return the value of **select** specified by name.\n**select** refers a class of config variables introduced by SER 2.0,\nallowing to select and return parts of sip messages and not only.\n\nList of available selects:\n\n-   [Selects](selects.md)\n\nExample:\n\n``` c\nif($sel(via[1].host)==\"10.10.10.10\")\n{\n  ...\n}\n```\n\n",
    "$rcv": "### $rcv(key)\n\nAttributes of received data. The variables must be used inside\n**event_route\\[core:msg-received\\]** routing block.\n\nThe key can be:\n\n-   buf - received message\n-   len - lenght of received message\n-   srcip - source ip\n-   rcvip - local ip where it was received\n-   scrport - source port\n-   rcvport - local port where it was received\n-   proto - protocol as int id\n-   sproto - protocol as string\n-   af - address family\n\nExample of usage:\n\n``` c\nevent_route[core:msg-received] {\n  xlog(\"rcv on $rcv(af)/$rcv(proto): ($rcv(len)) [$rcv(buf)] from [$rcv(srcip):$rcv(srcport)] to [$rcv(rcvip):$rcv(rcvport)]\\n\");\n}\n```\n\n",
    "$rpl": "## $rpl(key)\n\nAttributes of the SIP reply processed at that moment. The variables must\nbe used during SIP reply processing, otherwise it returns $null.\n\nThe key can be:\n\n-   duri - SIP URI corresponding to the address where the SIP reply is\n    going to be sent based on 2nd via\n-   dhost - host part of duri\n-   dport - port part of duri\n-   dproto - proto part of duri\n-   dprotoid - proto id of duri\n-   cntvia - the number of Via header bodies\n\nExample of usage:\n\n``` c\nreply_route{\n  xinfo(\"reply to be sent to: $rpl(duri)\\n\");\n}\n```\n\n",
    "$msgbuf": "## $msgbuf(index)\n\nGet or set the character in the message buffer at the position index.\n\nThe index has to be a positive integer or a variable holding such value.\n\nNote that the variable returns a clone of the character stored in a\nstatic buffer, copy it to another variable if you want to compare with\nanother $msgbuf(index).\n\nThe update is done directly and immediately in the message buffer -- use\nit with care!\n\nExample of usage:\n\n``` c\nif ($msgbuf(20)==\"V\") {\n    $msgbuf(20) = \"v\";\n}\n```\n\n",
    "$hfitname": "### $hfitname(iname)\n\nThe header name of the header field iterator.\n\nExample:\n\n``` c\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        xlog(\"hdr[$hfitname(i1)] is: $hfitbody(i1)\\n\");\n    }\n    hf_iterator_end(\"i1\");\n```\n\n",
    "$hfitbody": "### $hfitbody(iname)\n\nThe header body of the header field iterator.\n\nExample:\n\n``` c\n    hf_iterator_start(\"i1\");\n    while(hf_iterator_next(\"i1\")) {\n        xlog(\"hdr[$hfitname(i1)] is: $hfitbody(i1)\\n\");\n    }\n    hf_iterator_end(\"i1\");\n```\n\n",
    "$blitval": "### $blitval(iname)\n\nThe value of the body line iterator.\n\nExample:\n\n``` c\n    bl_iterator_start(\"b1\");\n    while(bl_iterator_next(\"b1\")) {\n        xlog(\"body line: $blitval(b1)\");\n    }\n    bl_iterator_end(\"b1\");\n```\n\n",
    "$sndfrom": "### $sndfrom(name)\n\n**$snd(name)** - return attributes of the address from where the request\nis going to be sent (local socket).\n\n**$sndfrom(name)** - return attributes of the address from where the\nrequest is going to be sent (local socket, same as $snd(name)).\n\nThe name can have same values as for $sndto(...).\n\n",
    "$sndto": "### $sndto(name)\n\n**$sndto(name)** - return attributes of the address to where the request\nis going to be sent (remote socket).\n\nThey are available in **onsend_route**. The name can be:\n\n-   ip - IP address of destination\n-   af - address family to be used to send (numeric)\n-   port - port of destination address\n-   proto - transport protocol to be used to send (numeric - UDP=1,\n    TCP=2, TLS=3, SCTP=4, WS=5, WSS=6)\n-   sproto - transport protocol to be used to send (string)\n-   buf - entire send buffer as string\n-   len - length of outgoing packet (length of above buf)\n\nExample:\n\n``` c\nonsend_route {\n  if($snd(ip)==\"10.10.10.10\")\n  {\n    ...\n  }\n}\n```\n\n",
    "$sipdump": "### $sipdump(name)\n\n**$sipdump(name)** - return attributes of the message handled in the\nevent_route\\[sipdump:msg\\].\n\nThe name can be:\n\n-   tag - the tag of processing (rcv or snd)\n-   buf - entire message buffer as string\n-   len - length of the message (length of above buf)\n-   af - address family\n-   src_ip - source IP address\n-   dst_ip - destination IP address\n-   src_port - port of source address\n-   dst_port - port of source address\n-   proto - transport protocol\n\nExample:\n\n``` c\nevent_route[sipdump:msg] {\n  if($sipdump(len) > 1024) {\n    ...\n  }\n}\n```\n\n",
    "$siptrace": "### $siptrace(name)\n\n**$siptrace(name)** - return attributes of the message handled in the\nevent_route\\[siptrace:msg\\].\n\nThe name can be:\n\n-   src_addr - source socket address (proto:ip:port)\n-   dst_addr - destination socket address (proto:ip:port)\n-   src_host - source host, for IPv6 host contains \\`\\[\\]\\`\n-   dst_host - destination host, for IPv6 host contains \\`\\[\\]\\`\n-   src_hostip - source host, for IPv6 host do not contains \\`\\[\\]\\`\n-   dst_hostip - destination host, for IPv6 host do not contains\n    \\`\\[\\]\\`\n-   src_port - source port\n-   dst_port - destination port\n-   src_proto - source proto\n-   dst_proto - destination proto\n\nExample:\n\n``` c\nevent_route[siptrace:msg]\n{\n    if (allow_address(\"1\", \"$siptrace(src_hostip)\", \"0\")) {\n        return;\n\n    }\n    if (compare_ips($siptrace(src_host), \"[2001:DB8::1]\")) {\n        return;\n    }\n}\n```\n\n",
    "$BM_time_diff": "### $BM_time_diff\n\n$BM_time_diff - the time difference elapsed between calls of\nbm_start_timer(name) and bm_log_timer(name). The value is 0 if no\nbm_log_timer() was called.\n\n",
    "$dlg": "### $dlg(attr)\n\nReturn the attribute of the current processed dialog.\n\n\ud83d\udd25**IMPORTANT**: It is R/O variable.\n\nThe 'attr' can be:\n\n-   h_id - hash id\n-   h_entry - hash entry\n-   ref - reference count\n-   state - state of dialog\n-   to_rs - To route set\n-   from_rs - From route set\n-   dflags - dialog internal flags\n-   sflags - dialog script flags\n-   callid - sip call id\n-   to_uri - To uri\n-   to_tag - To tag\n-   from_uri - From uri\n-   from_tag - From tag\n-   toroute - timeout route\n-   lifetime - timeout inteval\n-   start_ts - start timestamp\n-   to_cseq - To CSeq\n-   from_cseq - From CSeq\n-   to_contact - To contact address\n-   from_contact - From contact address\n-   to_bindaddr - To bind address\n-   from_bindaddr - From bind address\n\n",
    "$dlg_ctx": "### $dlg_ctx(attr)\n\nReturn the attribute of the context for current processed dialog.\n\n\ud83d\udd25**IMPORTANT**: Some of the attributes are R/W variables.\n\nThe 'attr' can be:\n\n-   set - returns 1 if the dialog for current context is set, 0\n    otherwise\n-   flags - get/set dialog flags\n-   timeout_route - get/set route name to be executed on timeout\n-   timeout_route_id - get internal id for the route to be executed on\n    timeout\n-   timeout_bye - set to 1 if BYE has to be sent when dialog lifetime\n    elapses\n-   timeout - set the dialog lifetime (in seconds)\n-   on - get/set an integer value associated with the context (cfg\n    usage)\n-   dir - get direction of the request for the dialog of the current\n    context (0 - unknown, 1 - downstream, 2 - upstream)\n\n",
    "$dlg_var": "### $dlg_var(key)\n\nStore and retrieve custom variable for current processed dialog.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable.\n\nThe 'key' can be any string.\n\n",
    "$erl_atom": "### $erl_atom(name)\n\n*$erl_atom(name)* pseudo variable allows create analog to Erlang atom\ndata type. Erlang atom is a literal, a constant with name. Formatted\noutput pseudo variable atom could be enclosed in single quotes (') if it\ndoes not begin with a lower-case letter or if it contains other\ncharacters than alphanumeric characters, underscore (\\_), or @.\n\nExample:\n\n``` c\n$erl_atom(A) = \"node@host.tld\";\n\nxlogl(\"L_DEBUG\",\"$$erl_atom(A): $erl_atom(A=>format)\\n\");\n```\n\n",
    "$erl_list": "### $erl_list(name)\n\nCompound data type with a variable number of terms. Formally, a list is\neither the empty list \\[\\] or consists of one or more elements.\n\nExample:\n\n``` c\n$erl_atom(E) = \"example\";\n$erl_list(L) = \"list\";\n$erl_list(L) = \"of\";\n$erl_list(L) = $erl_atom(E);\n\nxlogl(\"L_DEBUG\",\"length(L): $erl_list(L=>length), format(L): $erl_list(L=>format)\\n\");\n\n",
    "$erl_tuple": "### $erl_tuple(name)\n\nFrom the Erlang point of view the tuple compound data type with a fixed\nnumber of terms. The module implementation of tuple has the same\nbehavior as the list.\n\nExample:\n\n``` c\n$erl_atom(e) = \"error\";\n\n$erl_tuple(T) = \"badrpc\";\n$erl_tuple(T) = $erl_atom(e);\n\nxlogl(\"L_DEBUG\",\"length(T): $erl_tuple(T=>length), format(T): $erl_tuple(T=>format)\\n\");\n```\n\n",
    "$erl_pid": "### $erl_pid(name)\n\nHolds Eralng process identifier. Provides access to Erlang PID value and\ncould be used in send message.\n\n",
    "$erl_ref": "### $erl_ref(name)\n\nHolds Erlang reference. Provides access to reference value and could be\nused in send message.\n\n",
    "$erl_xbuff": "### $erl_xbuff(name)\n\nGeneric pseudo variable to acts as other pseudo variables exported from\nErlang module.\n\n",
    "$sht": "### $sht(htable=>key)\n\nAccess hash table entries.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file. Hash table entry can be deleted by assigning value\n$null to it. Value of a non-existing hash table entry is $null.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter.\n\nThe \u201ckey\u201d can be:\n\n-   static string - set of characters without pseudo-variables\n-   dynamic string - set of characters that include pseudo-variables.\n    The pseudo-variables will be evaluated at runtime.\n\n    ...\n    modparam(\"htable\", \"htable\", \"a=>size=4;\")\n    ...\n    $sht(a=>$au) = 1;\n    $sht(a=>$ru) = $fu;\n    ...\n\n",
    "$shtex": "### $shtex(htable=>key)\n\nAccess hash table entry expire value. Value represents the seconds until\nthe htable entry will expire and be deleted from htable.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter\nand have auto-expire greater than 0.\n\nThe \u201ckey\u201d can be:\n\n-   static string - set of characters without pseudo-variables\n-   dynamic string - set of characters that include pseudo-variables.\n    The pseudo-variables will be evaluated at runtime.\n\n    ...\n    modparam(\"htable\", \"htable\", \"a=>size=4;autoexpire=120;\")\n    ...\n    $sht(a=>$au) = 1;\n    $shtex(a=>$au) = 10;\n    ...\n\n",
    "$shtcn": "### $shtcn(htable=>exp)\n\nCount items matching the name by regexp.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter.\n\nThe **exp** can be:\n\n-   reqexp - match by regular expression 'regexp'\n-   \\~\\~regexp - match by regular expression 'regexp'\n-   \\~%prefix - match by right prefix\n-   %\\~prefix - match by left prefix\n-   ==value - match by string value\n-   eqvalue - match by integer value\n-   \\* \\* - (two asterisks next to each other) - count all items\n\nThe **exp** can contain pseudo-variables.\n\n    ...\n    modparam(\"htable\", \"htable\", \"a=>size=4;\")\n    ...\n    $sht(a=>abc) = 1;\n    $shtex(a=>ade) = 10;\n    xlog(\"$shtcn(a=>a.*)\");\n    ...\n\n",
    "$shtcv": "### $shtcv(htable=>exp)\n\nCount items matching the value by regexp.\n\nThe \u201chtname\u201d must be a hash table name defined via \u201chtable\u201d parameter.\n\nThe **exp** must follow same rules as for **$shtcn(...)**.\n\n    ...\n    modparam(\"htable\", \"htable\", \"a=>size=4;\")\n    ...\n    $sht(a=>abc) = \"xyz\";\n    $shtex(a=>ade) = \"xwt\";\n    xlog(\"$shtcv(a=>x.*)\");\n    ...\n\n",
    "$shtinc": "### $shtinc(htable=>key)\n\nAtomic increment of the value for the hash table item.\n\n    ...\n    modparam(\"htable\", \"htable\", \"a=>size=4;\")\n    ...\n    $sht(a=>$au) = 1;\n    xlog(\"==== $shtinc(a=>$au)\\n\");\n    ...\n\n",
    "$shtdec": "### $shtdec(htable=>key)\n\nAtomic decrement of the value for the hash table item.\n\n    ...\n    modparam(\"htable\", \"htable\", \"a=>size=4;\")\n    ...\n    $sht(a=>$au) = 1;\n    xlog(\"==== $shtdec(a=>$au)\\n\");\n    ...\n\n",
    "$shtitkey": "### $shtitkey(iname)\n\nThe key at the current position in the iterator.\n\n",
    "$shtitval": "### $shtitval(iname)\n\nThe value at the current position in the iterator.\n\nExample:\n\n``` c\n    sht_iterator_start(\"i1\", \"h1\");\n    while(sht_iterator_next(\"i1\")) {\n        xlog(\"h1[$shtitkey(i1)] is: $shtitval(i1)\\n\");\n    }\n    sht_iterator_end(\"i1\");\n```\n\n",
    "$shtrecord": "### $shtrecord(id)\n\nGet the key or the value of expired item inside the\nevent_route\\[htable:expired:\\_table_name\\_\\].\n\nThe id can be:\n\n-   key\n-   value\n\nExample:\n\n``` c\nevent_route[htable:expired:h1] {\n  xlog(\"expired item ($shtrecord(key),$shtrecord(value))\\n\");\n}\n```\n\n",
    "$mct": "### $mct(key)\n\nAccess hash table entries stored in the memcached server.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201ckey\u201d can be:\n\n-   static string - set of characters without pseudo-variables\n-   dynamic string - set of characters that include pseudo-variables.\n    The pseudo-variables will be evaluated at runtime.\n\nWhen assigning values, the default expiry will be used.\n\n    ...\n    $mct($au) = 1;\n    $mct($ru) = $fu;\n    $mct(test) = 1;\n    xlog(\"stored value is $mct(test)\");\n    $mct(test) = null; # delete it\n    xlog(\"stored value is $mct(test)\"); # will return <null>\n    ...\n\n### $mct(key=>expiry)\n\nUsing this alternative format, the default expiry may be overidden by\nincluding a custom value at time of assignment.\n\n    ...\n    $mct(test=>30) = 1; # set expire time to 30 seconds\n    xlog(\"stored value is $mct(test)\");\n    # sleep 30 seconds\n    xlog(\"stored value is $mct(test)\"); # will return <null>\n    ...\n\n",
    "$mcinc": "### $mcinc(key)\n\nDo an atomic increment operation on the value stored in memcached. You\nneed to add a value previously.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201ckey\u201d can be:\n\n-   static string - set of characters without pseudo-variables\n-   dynamic string - set of characters that include pseudo-variables.\n    The pseudo-variables will be evaluated at runtime.\n\n    ...\n    $mct(cnt) = 1;\n    $mcinc(cnt) = 2; # increment by 2\n    xlog(\"counter is now $mct(cnt)\");\n    ...\n\n",
    "$mcdec": "### $mcdec(key)\n\nDo an atomic decrement operation on the value stored in memcached. You\nneed to add a value previously.\n\n\ud83d\udd25**IMPORTANT**: It is R/W variable, you can assign values to it directly in\nconfiguration file.\n\nThe \u201ckey\u201d can be:\n\n-   static string - set of characters without pseudo-variables\n-   dynamic string - set of characters that include pseudo-variables.\n    The pseudo-variables will be evaluated at runtime.\n\n    ...\n    $mct(cnt) = 10;\n    $mcdec(cnt) = 2; # decrement by 2\n    xlog(\"counter is now $mct(cnt)\");\n    ...\n\n",
    "$http_req_id": "### $http_req_id\n\nThe $http_req_id read-only variable can be used in REQUEST_ROUTE to\nretrive the unique identifier for a query after sending it or in the\nHTTP callback route to retrive the id of the query the reply belongs to.\nUseful mainly in non-transactional context.\n\n",
    "$http_req": "### $http_req(key)\n\nThe $http_req(key) write-only variable can be used to set custom\nparameters before sending a HTTP query.\n\n**key** can be one of:\n\n-   all: if set to $null, resets all the parameters to their default\n    value (the ones defined in modparam)\n-   hdr: sets/modifies/removes a HTTP header. N.B.: setting this\n    variable multiple times will add several headers to the query.\n-   body: sets/modifies/removes the request body\n-   method: sets the HTTP method: either \"GET\", \"POST\", \"PUT\" or\n    \"DELETE\" (these are the supported methods). (Note: if the method is\n    not set, curl will use GET, or POST if a body is specified)\n-   timeout: sets the HTTP timeout. (Note, this timeout should be\n    normally less than tm.fr_timer timeout, because transaction timeout\n    has a higher priority over HTTP timeout)\n-   tls_client_cert: sets the client certificate to use\n-   tls_client_key: sets the client certificate key to use\n-   tls_ca_path: sets the CA certificate path to use\n-   authmethod: Sets the preferred authentication mode for HTTP/HTTPS\n    requests. The value is a bitmap and multiple methods can be used.\n    Note that in this case, the CURL library will make an extra request\n    to discover server-supported authentication methods. You may want to\n    use a specific value. Valid values are:\n\n    * 1 - BASIC authentication\n    * 2 - HTTP Digest authentication\n    * 4 - GSS-Negotiate authentication\n    * 8 - NTLM authentication\n    * 16 - HTTP Digest with IE flavour.\n    * (Default value is 3 - BASIC and Digest authentication.)\n- username: sets the username to use for authenticated requests\n- password: sets the password to use for authenticated requests\n- suspend: if set to 0 it doesn't suspend the current transaction before performing the query\n- tcp_keepalive: enable TCP keepalive\n- tcp_ka_idle: set TCP keepalive idle time wait\n- tcp_ka_interval: set TCP keepalive interval\n\n",
    "$http_ok": "#### $http_ok\n\n1 if cURL executed the request successfully, 0 otherwise (check\n$http_err for details).\n\n",
    "$http_err": "#### $http_err\n\ncURL error string if an error occurred, $null otherwise.\n\n",
    "$http_rs": "#### $http_rs\n\nHTTP status.\n\n",
    "$http_rr": "#### $http_rr\n\nHTTP reason phrase.\n\n",
    "$http_hdr": "#### $http_hdr(Name)\n\nValue of the Name header (the $(http_hdr(Name)\\[N\\]) syntax can also be\nused, check the SIP $hdr() PV documentation for details).\n\n",
    "$http_ml": "#### $http_mb and $http_ml\n\nHTTP response buffer (including headers) and length.\n\n",
    "$http_bs": "#### $http_rb and $http_bs\n\nHTTP response body and body length,\n\n",
    "$xml": "### $xml(name=>spec)\n\n-   name - id to refer the documet\n-   spec - specifier:\n    -   doc - set/get the document as text\n    -   xpath:xpath-expression - evaluate xpath expression\n\nExample:\n\n    $xml(x=>doc) = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><a><b>test</b></a>';\n    xlog(\"content of node b: $xml(x=>xpath:/a/b/text())\\n\");\n    $xml(x=>xpath:/a/b) = \"1234\";\n\n",
    "$T_branch_idx": "### $T_branch_idx\n\n-   the index (starting with 0 for the first branch) of the branch for\n    which is executed the branch_route\\[\\].\n-   in failure_route\\[\\] block, the value is the number of completed\n    branches added to the number of new new branches\n-   in request_route block, the value is number of created branches\n-   in onreply_route\\[\\], the value is the index of the branch receiving\n    the reply\n-   if used outside of transaction processing, the value is '-1'\n\n",
    "$T_reply_ruid": "### $T_reply_ruid\n\n-   the ruid stored in the current branch of the transaction. The ruid\n    is stored in a branch from the details in a contact binding. In an\n    event_route\\[tm:branch-failure\\] block, this is the ruid of the\n    branch that sent a failure reply. In a failure_route\\[\\] block, this\n    is the ruid of the winning failure response.\n\n",
    "$T_reply_code": "### $T_reply_code\n\n-   the code of the reply, as follows: in request_route will be the last\n    stateful sent reply; in reply_route will be the current processed\n    reply; in failure_route will be the negative winning reply. In case\n    of no-reply or error, '0' value is returned\n\n",
    "$T_req": "### $T_req(pv)\n\n-   can be used in reply routes or inside the modules to get access to\n    attributes of the request belonging to same transaction as the reply\n\n    route {\n      t_on_reply(\"1\");\n      t_relay();\n    }\n\n    onreply_route[1] {\n      xlog(\"Request SRCIP:PORT = $T_req($si):$T_req($sp)\\n\");\n    }\n\n",
    "$T_rpl": "### $T_rpl(pv)\n\n-   can be used in failure routes or inside the modules to get access to\n    attributes of the winning reply belonging to same transaction as the\n    request\n\n    route {\n      t_on_failure(\"1\");\n      t_relay();\n    }\n\n    failure_route[1] {\n      xlog(\"Reply SRCIP:PORT = $T_rpl($si):$T_rpl($sp)\\n\");\n    }\n\n",
    "$T_inv": "### $T_inv(pv)\n\n-   can be used in request routes or inside the modules to get access to\n    attributes of the INVITE request while processing a CANCEL.\n\n    route {\n      if(is_method(\"CANCEL\"))\n      {\n         if($T_inv($mf) & 1 )\n         {\n            # first flag is set in the INVITE transaction\n         }\n      }\n    }\n\n",
    "$T": "### $T(name)\n\n-   pseudo-variable class to access TM attributes\n\nThe **name** can be:\n\n-   id_index - return the internal index of current transaction or $null\n    if no transaction is found\n-   id_label - return the internal label of current transaction or $null\n    if no transaction is found\n-   id_index_n - return the internal index of current transaction, if no\n    transaction exists yet, create it\n-   id_label_n - return the internal label of current transaction, if no\n    transaction exists yet, create it\n-   reply_code - reply code (alias to $T_reply_code)\n-   reply_reason - reply reason\n-   reply_last - last received reply code\n-   branch_index - branch index (alias to $T_branch_idx)\n-   ruid - return the internal location ruid field for current branch\n-   reply_type - 1 if it is a local generated reply, 0 - if no reply for\n    transaction or it is a received reply\n\nNote: the pair (id_index,id_label) uniquely identifies a transaction.\n\n",
    "$T_branch": "### $T_branch(name)\n\n-   pseudo-variable class to access TM branch attributes\n\nThe **name** can be:\n\n-   flags - Flags of the branch. In an event_route\\[tm:branch-failure\\]\n    block, this is the flags of the branch that sent a failure reply. In\n    a failure_route\\[\\] block, this is the flags of the winning failure\n    response.\n-   uri - the R-URI of the branch. Can be used in onreply_route\\[id\\] -\n    reply route blocks executed by tm module. For other routing blocks\n    handling requests, the R-URI is returned by $ru\n\n",
    "$uac_req": "### $uac_req(key)\n\n-   used to build the input for uac_send_req() function of UAC module\n\nThe key can be:\n\n-   method - SIP method\n-   ruri - request URI\n-   furi - From URI\n-   turi - To URI\n-   ouri - Outbound proxy URI\n-   hdrs - SIP Headers\n-   body - Body\n-   flags - flags for processing\n    -   1 - the password is provided in HA1 format\n-   auser - authentication username\n-   apasswd - authentication password\n-   sock - local socket to be used for sending (proto:address:port)\n-   callid - SIP-Call-ID of the generated request (by default, a call-id\n    is generated)\n-   all - alias useful to reset all fields - $uac_req(all) = $null;\n-   evroute - it has to be set to 1 in order to execute\n    event_route\\[uac:reply\\] when reply is received\n-   evcode - reply code for the request sent with uac_req_send(),\n    available inside event_route\\[uac:reply\\]\n-   evtype - is 1 if the reply was received via network, 2 if the reply\n    was locally generated (e.g., retransmission timeout), available\n    inside event_route\\[uac:reply\\]\n-   evparam - generic data buffer associated with the request that can\n    be set before sending it and retrieved when executing the event\n    route. It has a size of 128 characters.\n\n``` c\n$uac_req(method)=\"OPTIONS\";\n$uac_req(ruri)=\"sip:kamailio.org\";\n$uac_req(furi)=\"sip:kamailio.org\";\n$uac_req(turi)=\"sip:kamailio.org\";\n$uac_req(evroute) = 1;\nuac_req_send();\n...\nevent_route[uac:reply] {\n  xlog(\"request sent to $uac_req(ruri) completed with code: $uac_req(evcode)\\n\");\n}\n```\n\n",
    "$rr_count": "### $rr_count\n\n-   Number of Record Routes in received SIP request or reply.\n\n",
    "$rr_top_count": "### $rr_top_count\n\n-   If topmost Record Route in received SIP request or reply is a double\n    Record Route, value of $rr_top_count is 2. If it a single Record\n    Route, value of $rr_top_count is 1. If there is no Record Route(s),\n    value of $rr_top_count is 0.\n\n",
    "$mqk": "### $mqk(q)\n\n-   return the key of fetched item from queue q\n\n",
    "$mqv": "### $mqv(q)\n\n-   return the value of fetched item from queue q\n\n``` c\n...\nmq_add(\"myq\", \"$rU\", \"call from $fU at $Tf\");\n...\nwhile(mq_fetch(\"myq\"))\n{\n   xlog(\"$mqk(myq) - $mqv(myq)\\n\");\n}\n...\n```\n\n",
    "$TV": "### $TV(name)\n\nSeconds and microseconds taken from struct timeval. The time at that\nmoment is represented by **seconds.microseconds**.\n\n-   $TV(s) - seconds (cached at first call per sip message)\n-   $TV(u) - microseconds (cached at first call per sip message)\n-   $TV(sn) - seconds (not cached, taken at that moment)\n-   $TV(un) - microseconds (corresponding to the moment $TV(sn) is\n    retrieved)\n-   $TV(Sn) - string representation seconds.microseconds (not cached,\n    taken at that moment)\n-   $TV(Sm) - string representation of an always increasing monotonic\n    counter. Note that even if is based on clock, it starts from an\n    unspecified point in time, so should really be treated as an\n    opaque counter.\n\n",
    "$nh": "### $nh(key)\n\nReturn attributes of next hop for the SIP messages. For SIP requests,\nthe address is taken from dst_uri, if set, if not from new r-uri or\noriginal r-uri. For SIP replies, the attributes are taken from 2nd Via\nheader (username is always $null for SIP replies).\n\n-   $nh(u) - uri (lower case u)\n-   $nh(U) - username (upper case u)\n-   $nh(d) - domain\n-   $nh(p) - port (lower case p)\n-   $nh(P) - transport protocol (upper case p)\n\n",
    "$redis": "### $redis(res=>key)\n\nAccess the attributes of the Redis response.\n\nThe key can be:\n\n-   type - type of the reply (as in hiredis.h)\n-   value - the value returned by REDIS server;\n-   info - in case of error from REDIS, it will contain an info message.\n\nIf reply type is an array (as in hiredis.h), there are other keys\navailable:\n\n-   size - returns number of elements in the array.\n\n-   type\\[n\\] - returns the type of the nth element in the array. type -\n    returns array type.\n\n-   value\\[n\\] - returns value of the nth element. value - returns null\n    for an array. You need to get each element by index.\n\nIn case one of the members of the array is also an array (for example\ncalling SMEMBERS in a MULTI/EXEC transaction), the members of the array\ncan be accessed by adding any of the above keys, after a value\\[n\\] key.\nThe first value\\[n\\] references the element in the first array, while\nthe next key references an element of the referenced array.\n\nExample:\n\n    redis_cmd(\"srvN\", \"GET foo\", \"r\");\n    xlog(\"===== result type: $redis(r=>type) * value: $redis(r=>value)\\n\");\n\n",
    "$redisd": "### $redisd(key)\n\nReturn the corresponding value for various defines from hiredis library.\n\nThe key can be:\n\n-   rpl_str - return REDIS_REPLY_STRING\n-   rpl_arr - return REDIS_REPLY_ARRAY\n-   rpl_int - return REDIS_REPLY_INTEGER\n-   rpl_nil - return REDIS_REPLY_NIL\n-   rpl_sts - return REDIS_REPLY_STATUS\n-   rpl_err - return REDIS_REPLY_ERROR\n\n$redisd(rpl_XYZ) can be compared with $redis(r=>type).\n\nExample:\n\n    redis_cmd(\"srvN\", \"GET foo\", \"r\");\n    if ($redis(r=>type) == $redisd(rpl_int)) {\n    }\n\n",
    "$gip": "### $gip(pvc=>key)\n\nVariables exported by GeoIP module, returning geo-location attributes.\nThe attributes are populated upon calling function **geoip_match(ipaddr,\npvc)**.\n\n**pvc** (container id) is second parameter of geoip_match(..) and\n**key** can be:\n\n-   cc - country code\n-   tz - time zone\n-   zip - postal code\n-   lat - latitude\n-   lon - longitude\n-   dma - dma code\n-   ips - ip start\n-   ipe - ip end\n-   city - city\n-   area - area code\n-   regc - region\n-   regn - region name\n-   metro - metro code\n-   contc - continent code\n\nYou can call several time **geoip_match(ipaddr, pvc)** with different ip\naddress and containers in your config, to compare, for example,\nattributes of source and destination of a call.\n\n``` c\ngeoip_match(\"$si\", \"src\");\ngeoip_match(\"$nh(d)\", \"dst\");\n\nif($gip(src=>cc)==$gip(dst=>cc))\n{\n    # source and destination from same country\n}\n\n```\n\n",
    "$gip2": "### $gip2(pvc=>key)\n\nVariables exported by GeoIP2 module, returning geo-location attributes.\nThe attributes are populated upon calling function\n**geoip_match2(ipaddr, pvc)**.\n\n**pvc** (container id) is second parameter of geoip_match2(..) and\n**key** can be:\n\n-   cc - country code\n-   tz - time zone\n-   zip - postal code\n-   lat - latitude\n-   lon - longitude\n-   dma - dma code\n-   ips - ip start\n-   ipe - ip end\n-   city - city\n-   area - area code\n-   regc - region\n-   regn - region name\n-   metro - metro code\n-   contc - continent code\n\nYou can call several time **geoip_match(ipaddr, pvc)** with different ip\naddress and containers in your config, to compare, for example,\nattributes of source and destination of a call.\n\n``` c\ngeoip_match2(\"$si\", \"src\");\ngeoip_match2(\"$nh(d)\", \"dst\");\n\nif($gip2(src=>cc)==$gip2(dst=>cc))\n{\n    # source and destination from same country\n}\n\n```\n\n",
    "$tls": "### $tls(key)\n\nVariables related to TLS communication and certificates.\n\nThe **key** can be:\n\n-   **m_issuer_line** - return local (my) certificate issuer line\n-   **p_issuer_line** - return remote (peer) certificate issuer line\n-   **m_subject_line** - return local (my) certificate subject line\n-   **p_subject_line** - return remote (peer) certificate subject line\n\nExample:\n\n``` c\nif(proto==TLS) {\n    xinfo(\"local certificate subject: $tls(m_subject_line)\\n\");\n}\n```\n\n",
    "$tls_version": "### $tls_version\n\nThe TLS/SSL version which is used on the TLS connection from which the\nmessage was received. String type.\n\n",
    "$tls_description": "### $tls_description\n\nThe TLS/SSL description of the TLS connection from which the message was\nreceived. String type.\n\n",
    "$tls_cipher_info": "### $tls_cipher_info\n\nThe TLS/SSL cipher which is used on the TLS connection from which the\nmessage was received. String type.\n\n",
    "$tls_cipher_bits": "### $tls_cipher_bits\n\nThe number of cipher bits which are used on the TLS connection from\nwhich the message was received. String and Integer type.\n\n",
    "$tls_peer_version": "### $tls_peer_version\n\nThe version of the certificate. String type.\n\n",
    "$tls_my_version": "### $tls_my_version\n\nThe version of the certificate. String type.\n\n",
    "$tls_peer_serial": "### $tls_peer_serial\n\nThe serial number of the certificate. String and Integer type.\n\n",
    "$tls_my_serial": "### $tls_my_serial\n\nThe serial number of the certificate. String and Integer type.\n\n",
    "$tls_peer_subject": "### $tls_peer_subject\n\nASCII dump of the fields in the subject section of the certificate.\nString type. Example:\n\n      /C=AT/ST=Vienna/L=Vienna/O=enum.at/CN=enum.at\n\n",
    "$tls_peer_issuer": "### $tls_peer_issuer\n\nASCII dump of the fields in the issuer section of the certificate.\nString type.\n\n",
    "$tls_my_subject": "### $tls_my_subject\n\nASCII dump of the fields in the subject section of the certificate.\nString type.\n\n",
    "$tls_my_issuer": "### $tls_my_issuer\n\nASCII dump of the fields in the issuer section of the certificate.\nString type.\n\n",
    "$tls_peer_subject_cn": "### $tls_peer_subject_cn\n\ncommonName in the subject section of the certificate. String type.\n\n",
    "$tls_peer_issuer_cn": "### $tls_peer_issuer_cn\n\ncommonName in the issuer section of the certificate. String type.\n\n",
    "$tls_my_subject_cn": "### $tls_my_subject_cn\n\ncommonName in the subject section of the certificate. String type.\n\n",
    "$tls_my_issuer_cn": "### $tls_my_issuer_cn\n\ncommonName in the issuer section of the certificate. String type.\n\n",
    "$tls_peer_subject_locality": "### $tls_peer_subject_locality\n\nlocalityName in the subject section of the certificate. String type.\n\n",
    "$tls_peer_issuer_locality": "### $tls_peer_issuer_locality\n\nlocalityName in the issuer section of the certificate. String type.\n\n",
    "$tls_my_subject_locality": "### $tls_my_subject_locality\n\nlocalityName in the subject section of the certificate. String type.\n\n",
    "$tls_my_issuer_locality": "### $tls_my_issuer_locality\n\nlocalityName in the issuer section of the certificate. String type.\n\n",
    "$tls_peer_subject_country": "### $tls_peer_subject_country\n\ncountryName in the subject section of the certificate. String type.\n\n",
    "$tls_peer_issuer_country": "### $tls_peer_issuer_country\n\ncountryName in the issuer section of the certificate. String type.\n\n",
    "$tls_my_subject_country": "### $tls_my_subject_country\n\ncountryName in the subject section of the certificate. String type.\n\n",
    "$tls_my_issuer_country": "### $tls_my_issuer_country\n\ncountryName in the issuer section of the certificate. String type.\n\n",
    "$tls_peer_subject_state": "### $tls_peer_subject_state\n\nstateOrProvinceName in the subject section of the certificate. String\ntype.\n\n",
    "$tls_peer_issuer_state": "### $tls_peer_issuer_state\n\nstateOrProvinceName in the issuer section of the certificate. String\ntype.\n\n",
    "$tls_my_subject_state": "### $tls_my_subject_state\n\nstateOrProvinceName in the subject section of the certificate. String\ntype.\n\n",
    "$tls_my_issuer_state": "### $tls_my_issuer_state\n\nstateOrProvinceName in the issuer section of the certificate. String\ntype.\n\n",
    "$tls_peer_subject_organization": "### $tls_peer_subject_organization\n\norganizationName in the subject section of the certificate. String type.\n\n",
    "$tls_peer_issuer_organization": "### $tls_peer_issuer_organization\n\norganizationName in the issuer section of the certificate. String type.\n\n",
    "$tls_my_subject_organization": "### $tls_my_subject_organization\n\norganizationName in the subject section of the certificate. String type.\n\n",
    "$tls_my_issuer_organization": "### $tls_my_issuer_organization\n\norganizationName in the issuer section of the certificate. String type.\n\n",
    "$tls_peer_subject_unit": "### $tls_peer_subject_unit\n\norganizationalUnitName in the subject section of the certificate. String\ntype.\n\n",
    "$tls_peer_subject_uid": "### $tls_peer_subject_uid\n\nUID in the subject section of the certificate. String type.\n\n",
    "$tls_peer_issuer_unit": "### $tls_peer_issuer_unit\n\norganizationalUnitName in the issuer section of the certificate. String\ntype.\n\n",
    "$tls_my_subject_unit": "### $tls_my_subject_unit\n\norganizationalUnitName in the subject section of the certificate. String\ntype.\n\n",
    "$tls_my_subject_uid": "### $tls_my_subject_uid\n\nUID in the subject section of the certificate. String type.\n\n",
    "$tls_my_issuer_unit": "### $tls_my_issuer_unit\n\norganizationalUnitName in the issuer section of the certificate. String\ntype.\n\n",
    "$tls_peer_san_email": "### $tls_peer_san_email\n\nemail address in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_my_san_email": "### $tls_my_san_email\n\nemail address in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_peer_san_hostname": "### $tls_peer_san_hostname\n\nhostname (DNS) in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_my_san_hostname": "### $tls_my_san_hostname\n\nhostname (DNS) in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_peer_san_uri": "### $tls_peer_san_uri\n\nURI in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_my_san_uri": "### $tls_my_san_uri\n\nURI in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_peer_san_ip": "### $tls_peer_san_ip\n\nip address in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_my_san_ip": "### $tls_my_san_ip\n\nip address in the \"subject alternative name\" extension. String type.\n\n",
    "$tls_peer_verified": "### $tls_peer_verified\n\nReturns 1 if the peer's certificate was successfully verified. Otherwise\nit returns 0. String and Integer type.\n\n",
    "$tls_peer_revoked": "### $tls_peer_revoked\n\nReturns 1 if the peer's certificate was revoked. Otherwise it returns 0.\nString and Integer type.\n\n",
    "$tls_peer_expired": "### $tls_peer_expired\n\nReturns 1 if the peer's certificate is expired. Otherwise it returns 0.\nString and Integer type.\n\n",
    "$tls_peer_selfsigned": "### $tls_peer_selfsigned\n\nReturns 1 if the peer's certificate is selfsigned. Otherwise it returns\n0. String and Integer type.\n\n",
    "$tls_peer_notBefore": "### $tls_peer_notBefore\n\nReturns the notBefore validity date of the peer's certificate. String\ntype.\n\n",
    "$tls_peer_notAfter": "### $tls_peer_notAfter\n\nReturns the notAfter validity date of the peer's certificate. String\ntype.\n\n",
    "$tls_peer_server_name": "### $tls_peer_server_name\n\nThe SNI server name of the peer\n\n",
    "$tls_peer_raw_cert": "### $tls_peer_raw_cert\n\nThe raw PEM-encoded client certificate. String type.\n\n",
    "$tls_my_raw_cert": "### $tls_my_raw_cert\n\nThe raw PEM-encoded client certificate. String type.\n\n",
    "$tls_peer_urlencoded_cert": "### $tls_peer_urlencoded_cert\n\nThe PEM-encoded client certificate, urlencoded. String type.\n\n",
    "$tls_my_urlencoded_cert": "### $tls_my_urlencoded_cert\n\nThe PEM-encoded client certificate, urlencoded. String type.\n\n",
    "$msg": "### $msg(attr)\n\nReturn attributes of SIP message:\n\n-   $msg(len) - sip message length\n-   $msg(buf) - sip message buffer\n-   $msg(body) - sip message body\n-   $msg(body_len) - sip message body length\n-   $msg(hdrs) - sip message headers (surrounding white space and EoL\n    chars trimmed)\n-   $msg(fline) - sip message first line (surrounding white space and\n    EoL chars trimmed)\n-   $msg(fpart) - sip message first line and the headers\n-   $msg(lpart) - sip message headers and the body\n\n",
    "$pos": "### $pos(key)\n\nGet attributes after a function of the module is executed.\n\nThe key can be:\n\n-   ret - the return code on success or -1\n-   idx - position inside message buffer, for find/search it is the\n    start of matching\n-   len - the length of matching string for search functions\n\n",
    "$hu": "### $hu\n\n-   URL of http request.\n\n",
    "$msrp": "### $msrp(buf)\n\nThe entire content of MSRP frame - first line, headers, body and\nend-line.\n\n### $msrp(body)\n\nThe body of MSRP frame.\n\n### $msrp(code)\n\nThe code of MSRP replies.\n\n### $msrp(hdrs)\n\nThe headers in a MSRP frame.\n\n### $msrp(msgid)\n\nThe body of Message-Id header.\n\n### $msrp(method)\n\nThe method of a MSRP request.\n\n### $msrp(buflen)\n\nThe length of entire MSRP frame.\n\n### $msrp(sessid)\n\nThe session id for MSRP frame. It is taken from the first MSRP URI in\nTo-Path header.\n\n### $msrp(reason)\n\nThe reason text in a MSRP reply.\n\n### $msrp(crthop)\n\nThe URI for current hop - it is the first URI in To-Path header.\n\n### $msrp(bodylen)\n\nThe length of the body in MSRP frame.\n\n### $msrp(transid)\n\nThe transaction ID from the first line of MSRP frame.\n\n### $msrp(prevhop)\n\nThe MSRP URI of the previous hop - the first address in From-Path\nheader.\n\n### $msrp(nexthop)\n\nThe URI of the next hop - the second address in To-Path header.\n\n### $msrp(lasthop)\n\nThe last hop URI - the last address in To-Path header.\n\n### $msrp(srcaddr)\n\nThe address of the previous hop set as MSRP URI using received source IP\nand port.\n\n### $msrp(srcsock)\n\nThe local socket where the MSRP frame was received, set as\n**proto:ipaddr:port**.\n\n### $msrp(firsthop)\n\nThe URI of the first hop - the last address in From-Path header.\n\n### $msrp(prevhops)\n\nThe number of previous hops - it is the number of addresses in From-Path\nheader.\n\n### $msrp(nexthops)\n\nThe number of next hops - it is the number of addresses in To-Path\nheader minus 1 (the first address in To-Path is current hop).\n\n### $msrp(conid)\n\nThe internal integer id for TCP/TLS connection.\n\n",
    "$sipt_presentation": "### $sipt(calling_party_number.presentation) / $sipt_presentation\n\nReturns the value of the Address presentation restricted indicator\ncontained in the Calling Party Number header of the IAM message if it\nexists. Returns -1 if there isn't a Calling Party Number header.\n\nThe following values can be returned:\n\n-   0 presentation allowed\n-   1 resentation restricted\n-   2 address not avail (national use)\n-   3 spare\n\nExample:\n\n``` c\nif($sipt(calling_party_number.presentation) == 1)\n{\n        append_hf(\"Privacy: id\\r\\n\");\n        $fn = \"Anonymous\";\n}\n```\n\n",
    "$sipt_screening": "### $sipt(calling_party_number.screening) / $sipt_screening\n\nReturns the value of the Screening Indicator contained in the Calling\nParty Number header of the IAM message if it exists. Returns -1 if there\nisn't a Calling Party Number header.\n\nCan return the following values:\n\n-   0 Reserved (user provided, not verified)\n-   1 User Provided, Verified and Passed\n-   2 Reserved (user provided, verified and failed)\n-   3 Network provided\n\nExample:\n\n``` c\n",
    "$sipt_hop_counter": "### $sipt(hop_counter) / $sipt_hop_counter\n\nReturns the value of the Hop Counter for the IAM message if it exists.\nReturns -1 if there isn't a hop counter.\n\nExample:\n\n``` c\n",
    "$sipt_cpc": "### $sipt(calling_party_category) / $sipt(cpc) / $sipt_cpc\n\nReturns the value of the Calling Party Category for the IAM message.\nReturns -1 if there is a parsing error.\n\n",
    "$sipt_calling_party_nai": "### $sipt(calling_party_number.nature_of_address) / $sipt.(calling_party_number.nai) / $sipt_calling_party_nai\n\nReturns the value of the Nature of Address Indicator of the Calling\nParty for the IAM message. Returns -1 if there is a parsing error or if\nthe Calling Party Number is not present.\n\nCan return the following values:\n\n-   0 Spare\n-   1 Subscriber Number (national use)\n-   2 Unknown (national use)\n-   3 National (significant) number (national use)\n-   4 International use\n\nExample:\n\n``` c\n",
    "$sipt_called_party_nai": "### $sipt(called_party_number.nature_of_address) / $sipt(called_party_number.nai) / $sipt_called_party_nai\n\nReturns the value of the Nature of Address Indicator of the Called Party\nfor the IAM message. Returns -1 if there is a parsing error.\n\nCan return the following values:\n\n-   0 Spare\n-   1 Subscriber Number (national use)\n-   2 Unknown (national use)\n-   3 National (significant) number\n-   4 International use\n-   5 Network-specific number (national use)\n\nExample:\n\n``` c\n",
    "$sipt": "### $sipt(event_info)\n\nReturns the value of the Event Info header of the CPG message. Returns\n-1 if there is a parsing error.\n\nCan return the following values:\n\n-   0 Spare\n-   1 ALERTING\n-   2 PROGRESS\n-   3 In-band information or an appropriate pattern is now available\n-   4 Call forward on busy\n-   5 Call forward on no reply\n-   6 Call forward unconditional\n\n### $sipt(backward_call_indicator.charge_indicator)\n\nReturns the value of the charge indication of the backward call\nindicator header in the ACM or COT message. Returns -1 if there is a\nparsing error\n\nCan return the following values:\n\n-   0 no indication\n-   1 no charge\n-   2 charge\n-   3 spare\n\n### $sipt(calling_party_number)\n\nReturns the value (Address signal) of the Calling Party for the IAM\nmessage. Returns -1 if there is a parsing error or if the Calling Party\nNumber is not present.\n\n### $sipt(called_party_number)\n\nReturns the value (Address signal) of the Called Party for the IAM\nmessage. Returns -1 if there is a parsing error or if the Called Party\nNumber is not present.\n\n### $sipt(sipt_redirection_information_reason)\n\nReturns the value of the Redirection reason of the Redirection\ninformation header from ISUP. Returns -1 if there is a parsing error or\nif the Redirection information is not present.\n\n### $sipt(sipt_redirection_information_original_reason)\n\nReturns the value of the Original Redirection reason of the Redirection\ninformation header from ISUP. Returns -1 if there is a parsing error or\nif the Redirection information is not present.\n\n### $sipt(redirecting_number.nai)\n\nReturns the value of the Nature of Address Indicator of the Redirecting\nNumber. Returns -1 if there is a parsing error or if the Redirecting\nNumber is not present.\n\nCan return the following values:\n\n-   0 Spare\n-   1 Subscriber Number (national use)\n-   2 Unknown (national use)\n-   3 National (significant) number\n-   4 International use\n\n### $sipt(redirecting_number)\n\nReturns the value (Address signal) of the Redirecting Number for the IAM\nmessage. Returns -1 if there is a parsing error or if the Redirecting\nNumber is not present.\n\n### $sipt(original_called_number.nai)\n\nReturns the value of the Nature of Address Indicator of the Original\nCalled Number. Returns -1 if there is a parsing error or if the Original\nCalled Number is not present.\n\nCan return the following values:\n\n-   0 Spare\n-   1 Subscriber Number (national use)\n-   2 Unknown (national use)\n-   3 National (significant) number\n-   4 International use\n\n### $sipt(original_called_number)\n\nReturns the value (Address signal) of the Original Called Number for the\nIAM message. Returns -1 if there is a parsing error or if the Original\nCalled Number is not present.\n\n### $sipt(generic_number.nai)\n\nReturns the value of the Nature of Address Indicator of the Generic\nNumber. Returns -1 if there is a parsing error or if the Generic Number\nis not present.\n\nCan return the following values:\n\n-   0 Spare\n-   1 Subscriber Number (national use)\n-   2 Unknown (national use)\n-   3 National (significant) number\n-   4 International use\n\n### $sipt(generic_number)\n\nReturns the value (Address signal) of the Generic Number for the IAM\nmessage. Returns -1 if there is a parsing error or if the Generic Number\nis not present.\n\n",
    "$sipt_redirection_info": "### $sipt(redirection_info) / $sipt_redirection_info\n\nReturns the value of the Redirecting reason of the Call Diversion\nInformation header from ISUP. Returns -1 if there is a parsing error or\nif the Call Diversion Information is not present.\n\nCan return the following values:\n\n-   0 Unknown\n-   1 User busy\n-   2 no reply\n-   3 unconditional\n-   4 deflection during alerting\n-   5 deflection immediate response\n-   6 mobile subscriber not reachable\n\n",
    "$sipt_redirection_number": "### $sipt(redirection_number) / $sipt_redirection_number\n\nReturns the value (Address signal) of the Redirection Number. Returns -1\nif there is a parsing error or if the Redirection Number is not present.\n\nExample:\n\n``` c\n",
    "$sipt_redirection_number_nai": "### $sipt(redirection_number.nai) / $sipt_redirection_number_nai\n\nReturns the value of the Nature of Address Indicator of the Redirection\nNumber. Returns -1 if there is a parsing error or if the Redirection\nNumber is not present.\n\nCan return the following values:\n\n-   0 Spare\n-   1 Subscriber Number (national use)\n-   2 Unknown (national use)\n-   3 National (significant) number\n-   4 International use\n\n",
    "$cfg": "## $cfg(key) - Config File Attributes\n\nAttributes related to configuration file.\n\nThe key can be:\n\n-   line - return the current line in config\n-   name - return the name of current config file\n-   file - return the name of current config file\n-   route - return the name of routing block\n\nExample:\n\n``` c\nsend_reply(\"404\", \"Not found at line $cfg(line)\");\n```\n\n",
    "$dns": "## $dns(pvid=>key) - DNS Query Result\n\nThis variable stores the DNS result details after a call of\ndns_query(hostname, pvid) function from ipops module.\n\n-   pvid can be any string\n-   key can be:\n    -   count - number of addresses\n    -   ipv4 - set to 1 if at least one ipv4 address (otherwise 0)\n    -   ipv6 - set to 1 if at least one ipv6 address (otherwise 0)\n    -   addr\\[index\\] - the address as string from position index in the\n        list (0 based indexing)\n    -   type\\[index\\] - the type of address from position index in the\n        list (0 based indexing), the value is 4 for ipv4 and 6 for ipv6\n\nThe index can be an integer or a variable with integer value. First\naddress has the index 0. If negative value, the returned address is\ncounted from the end of the list, -1 being the last address. If no index\nis provided, then the first address is returned.\n\n``` c\nif(dns_query(\"test.com\", \"xyz\"))\n{\n    xlog(\" number of addresses: $dns(xyz=>count)\\n\");\n    xlog(\" ipv4 address found: $dns(xyz=>ipv4)\\n\");\n    xlog(\" ipv6 address found: $dns(xyz=>ipv6)\\n\");\n    $var(i) = 0;\n    while($var(i)&lt;$dns(xyz=>count)) {\n        xlog(\" #[$var(i)] type ($dns(xyz=>type[$var(i)]))\"\n             \" addr [$dns(xyz=>addr[$var(i)])]\\n\");\n        $var(i) = $var(i) + 1;\n    }\n}\n```\n\n",
    "$HN": "## $HN(key) - Hostname details\n\nGive local hostname details (implemented by ipops module).\n\nThe key can be:\n\n-   n - the hostname\n-   f - the fullname\n-   d - the domain\n-   i - the ip address\n\n``` c\nxlog(\"local hostanme is $HN(n)\\n\");\n```\n\n",
    "$RANDOM": "## $RANDOM - Random number\n\nReturns a random value from the \\[0 - 2^31) range.\n(Part of the cfgutils module)\n\n``` c\nif (rand_event()) {\n  $avp(i:10) = ($RANDOM / 16777216); # 2^24\n  if ($avp(i:10) < 10) {\n     $avp(i:10) = 10;\n  }\n  append_to_reply(\"Retry-After: $avp(i:10)\\n\");\n  sl_send_reply(\"503\", \"Try later\");\n  exit;\n};\n",
    "$jsonrpl": "### $jsonrpl(key) - JSONRPC Reply\n\nThis variable gives access to JSONRPC reply after executing\njsonrpc_exec(...) in kamailio.cfg.\n\nThe key can be:\n\n-   code - code for the JSONRPC response\n-   text - text of the code for the JSONRPC response\n-   body - the body of the JSONRPC response\n\n",
    "$lsock": "## $lsock(expr)\n\nGet attributes for listen sockets (from corex module).\n\nThe **expr** is an expression specifying what to match and return, the\nformat is:\n\n    matchid/value/field\n\nThe **expr** can contain variables that are evaluated before parsing the\nexpression.\n\nThe **matchid** can be:\n\n-   n - match on name\n-   l - match on listen address\n\nThe **value** specifies what to match with.\n\nThe **field** can be (only first character matches):\n\n-   name - return name\n-   listen - return the listen address\n-   advertise - return the advertise address\n-   index - return the index in the list of all sockets\n\nExample:\n\n    listen=udp:127.0.0.1:5060 advertise 127.0.0.1:5090 name \"s0\"\n    ...\n    xinfo(\"$lsock(n/s0/listen)\\n\");\n    xinfo(\"$lsock(l/udp:127.0.0.1:5060/name)\\n\");\n    $var(s0) = \"n/s0/listen\";\n    xinfo(\"$lsock($var(s0))\\n\");\n\n",
    "$evr": "### $evr(key)\n\nevrexec attributes:\n\n-   $evr(data) - processing data\n-   $evr(srcip) - source ip\n-   $evr(srcport) - sourceport as string\n-   $evr(srcportno) - source port as number\n\n",
    "$subs": "### $subs(key) - Subscription Attributes\n\nThis variable gives access to attributes of the current subscription.\nThe variable has to be used after executing *handle_subscription()* in\norder to provide accurate values.\n\nThe key can be:\n\n-   uri - subscription URI. Useful in particular for subscriptions\n    within the dialog, when the request URI in SUBSCRIBE is the Contact\n    address from the initial subscription.\n\n",
    "$ulc": "### $ulc(profile=>attr) - Registered Contact Attributes\n\nAccess the attributes of contact addresses stored in 'profile'.\n\nIt must be used after a call of \u201creg_fetch_contacts()\u201d.\n\n",
    "$hep": "### $hep(key) - HEP Packet Attributes\n\nThe key refers to HEP packet header values:\n\n-   version - HEP version\n-   src_ip - source IP address\n-   dst_ip - destination IP address\n-   0x000 - HEP attribute 0x000\n-   0x999 - HEP attribute 0x999\n\n",
    "$sruid": "## $sruid - Unique ID\n\n-   $sruid - return unique ID generated internally Kamailio\n\n",
    "$ltt": "## $ltt(key) - Local To-Tag\n\n$ltt(key) - return local generated To-tag when Kamailio sends a reply\n\n-   $ltt(s) - the to-tag used in stateless replies\n-   $ltt(t) - the to-tag used in transaction stateful replies\n    (transaction has to be created at that time, eg., by t_newtran() or\n    in a branch/failure route, otherwise it returns $null)\n-   $ltt(x) - $ltt(t) if the transaction was created already, otherwise\n    $ltt(s)\n\n",
    "$via0": "## $via0(attr) - Via\\[0\\] Attributes\n\n$via0(attr) - attributes of first Via header.\n\nThe attr can be:\n\n-   host - host part (string)\n-   port - port (number)\n-   proto - protocol - transport part (string)\n-   protoid - protocol id (integer id)\n-   branch - branch parameter\n-   rport - rport parameter value (string)\n-   received - received parameter value (string)\n-   i - i parameter value (string)\n\n",
    "$via1": "## $via1(attr) - Second Via Attributes\n\n$via1(attr) - attributes of second Via header. The attr can be the same\nas for $via0(attr).\n\n",
    "$viaZ": "## $viaZ(attr) - Last Via Attributes\n\n$viaZ(attr) - attributes of last Via header. The attr can be the same as\nfor $via0(attr).\n\n",
    "$C": "## $C(xy) - Foreground and background colors\n\n$C(xy) - reference to an escape sequence. \u201cx\u201d represents the foreground\ncolor and \u201cy\u201d represents the background color.\n\nColors could be:\n\n-   x : default color of the terminal\n-   s : Black\n-   r : Red\n-   g : Green\n-   y : Yellow\n-   b : Blue\n-   p : Purple\n-   c : Cyan\n-   w : White\n\n",
    "$K": "## $K(key) - Kamailio Constants\n\n$K(key) - return the numeric values corresponding to Kamailio\nconfiguration constants.\n\nThe key can be:\n\n-   IPv4 - return AF_INET\n-   IPv6 - return AF_INET6\n-   UDP - return PROTO_UDP\n-   TCP - return PROTO_TCP\n-   TLS - return PROTO_TLS\n-   SCTP - return PROTO_SCTP\n-   WS - return PROTO_WS\n-   WSS - return PROTO_WSS\n\n``` c\nxinfo(\"proto UDP numeric id: $K(UDP)\\n\");\n```\n\n"
   }